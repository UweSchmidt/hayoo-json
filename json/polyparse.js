[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#",
      "description": {
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-Parse-ByteString.html",
        "fct-type": "module",
        "title": "ByteString"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "ByteString",
        "normalized": "",
        "package": "polyparse",
        "partial": "Byte String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#t:Parse",
      "description": {
        "fct-descr": "\u003cp\u003eThe class \u003ccode\u003eParse\u003c/code\u003e is a replacement for \u003ccode\u003eRead\u003c/code\u003e, operating over String input.\n   Essentially, it permits better error messages for why something failed to\n   parse.  It is rather important that \u003ccode\u003eparse\u003c/code\u003e can read back exactly what\n   is generated by the corresponding instance of \u003ccode\u003eshow\u003c/code\u003e.  To apply a parser\n   to some text, use \u003ccode\u003erunParser\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "class",
        "fct-source": "src/Text-Parse-ByteString.html#Parse",
        "fct-type": "class",
        "title": "Parse"
      },
      "index": {
        "description": "The class Parse is replacement for Read operating over String input Essentially it permits better error messages for why something failed to parse It is rather important that parse can read back exactly what is generated by the corresponding instance of show To apply parser to some text use runParser",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "Parse",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parse",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#t:TextParser",
      "description": {
        "fct-descr": "\u003cp\u003eA synonym for a ByteString Parser, i.e. bytestring input (no state)\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "type",
        "fct-source": "src/Text-Parse-ByteString.html#TextParser",
        "fct-type": "type",
        "title": "TextParser"
      },
      "index": {
        "description": "synonym for ByteString Parser i.e bytestring input no state",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "TextParser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Text Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:allAsByteString",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the remaining input ByteString.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser ByteString",
        "fct-source": "src/Text-Parse-ByteString.html#allAsByteString",
        "fct-type": "function",
        "title": "allAsByteString"
      },
      "index": {
        "description": "Simply return the remaining input ByteString",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "allAsByteString",
        "normalized": "",
        "package": "polyparse",
        "partial": "As Byte String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:allAsString",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the remaining input as a String.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser String",
        "fct-source": "src/Text-Parse-ByteString.html#allAsString",
        "fct-type": "function",
        "title": "allAsString"
      },
      "index": {
        "description": "Simply return the remaining input as String",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "allAsString",
        "normalized": "",
        "package": "polyparse",
        "partial": "As String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:constructors",
      "description": {
        "fct-descr": "\u003cp\u003eParse one of a bunch of alternative constructors.  In the list argument,\n   the first element of the pair is the constructor name, and\n   the second is the parser for the rest of the value.  The first matching\n   parse is returned.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "[(String, TextParser a)] -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#constructors",
        "fct-type": "function",
        "title": "constructors"
      },
      "index": {
        "description": "Parse one of bunch of alternative constructors In the list argument the first element of the pair is the constructor name and the second is the parser for the rest of the value The first matching parse is returned",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "constructors",
        "normalized": "[(String,TextParser a)]-\u003eTextParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "[(String,TextParser a)]-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:enumeration",
      "description": {
        "fct-descr": "\u003cp\u003eParse one of the given nullary constructors (an enumeration).\n   The string argument is the name of the type, and the list argument\n   should contain all of the possible enumeration values.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e [a] -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#enumeration",
        "fct-type": "function",
        "title": "enumeration"
      },
      "index": {
        "description": "Parse one of the given nullary constructors an enumeration The string argument is the name of the type and the list argument should contain all of the possible enumeration values",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "enumeration",
        "normalized": "String-\u003e[a]-\u003eTextParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "String-\u003e[a]-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:field",
      "description": {
        "fct-descr": "\u003cp\u003eDeal with named field syntax.  The string argument is the field name,\n   and the parser returns the value of the field.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#field",
        "fct-type": "function",
        "title": "field"
      },
      "index": {
        "description": "Deal with named field syntax The string argument is the field name and the parser returns the value of the field",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "field",
        "normalized": "String-\u003eTextParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "String-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:isWord",
      "description": {
        "fct-descr": "\u003cp\u003eEnsure that the next input word is the given string.  (Note the input\n   is lexed as haskell, so wordbreaks at spaces, symbols, etc.)\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e TextParser String",
        "fct-source": "src/Text-Parse-ByteString.html#isWord",
        "fct-type": "function",
        "title": "isWord"
      },
      "index": {
        "description": "Ensure that the next input word is the given string Note the input is lexed as haskell so wordbreaks at spaces symbols etc",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "isWord",
        "normalized": "String-\u003eTextParser String",
        "package": "polyparse",
        "partial": "Word",
        "signature": "String-\u003eTextParser String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:optionalParens",
      "description": {
        "fct-descr": "\u003cp\u003eAllow optional nested string parens around an item.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#optionalParens",
        "fct-type": "function",
        "title": "optionalParens"
      },
      "index": {
        "description": "Allow optional nested string parens around an item",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "optionalParens",
        "normalized": "TextParser a-\u003eTextParser a",
        "package": "polyparse",
        "partial": "Parens",
        "signature": "TextParser a-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parens",
      "description": {
        "fct-descr": "\u003cp\u003eAllow nested parens around an item (one set required when Bool is True).\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Bool -\u003e TextParser a -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parens",
        "fct-type": "function",
        "title": "parens"
      },
      "index": {
        "description": "Allow nested parens around an item one set required when Bool is True",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parens",
        "normalized": "Bool-\u003eTextParser a-\u003eTextParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Bool-\u003eTextParser a-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parse",
      "description": {
        "fct-descr": "\u003cp\u003eA straightforward parser for an item.  (A minimal definition of\n   a class instance requires either |parse| or |parsePrec|.  In general,\n   for a type that never needs parens, you should define |parse|, but\n   for a type that _may_ need parens, you should define |parsePrec|.)\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parse",
        "fct-type": "method",
        "title": "parse"
      },
      "index": {
        "description": "straightforward parser for an item minimal definition of class instance requires either parse or parsePrec In general for type that never needs parens you should define parse but for type that may need parens you should define parsePrec",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parse",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseByRead",
      "description": {
        "fct-descr": "\u003cp\u003eIf there already exists a Read instance for a type, then we can make\n   a Parser for it, but with only poor error-reporting.  The string argument\n   is the expected type or value (for error-reporting only).  Use of this\n   wrapper function is NOT recommended with ByteString, because there\n   is a lot of inefficiency in repeated conversions to/from String.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parseByRead",
        "fct-type": "function",
        "title": "parseByRead"
      },
      "index": {
        "description": "If there already exists Read instance for type then we can make Parser for it but with only poor error-reporting The string argument is the expected type or value for error-reporting only Use of this wrapper function is NOT recommended with ByteString because there is lot of inefficiency in repeated conversions to from String",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseByRead",
        "normalized": "String-\u003eTextParser a",
        "package": "polyparse",
        "partial": "By Read",
        "signature": "String-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseDec",
      "description": {
        "fct-descr": "\u003cp\u003eParse a decimal, octal, or hexadecimal (unsigned) Integral numeric literal.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parseDec",
        "fct-type": "function",
        "title": "parseDec"
      },
      "index": {
        "description": "Parse decimal octal or hexadecimal unsigned Integral numeric literal",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseDec",
        "normalized": "",
        "package": "polyparse",
        "partial": "Dec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseFloat",
      "description": {
        "fct-descr": "\u003cp\u003eParse any (unsigned) Floating numeric literal, e.g. Float or Double.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parseFloat",
        "fct-type": "function",
        "title": "parseFloat"
      },
      "index": {
        "description": "Parse any unsigned Floating numeric literal e.g Float or Double",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseFloat",
        "normalized": "",
        "package": "polyparse",
        "partial": "Float",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseHex",
      "description": {
        "fct-descr": "\u003cp\u003eParse a decimal, octal, or hexadecimal (unsigned) Integral numeric literal.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parseHex",
        "fct-type": "function",
        "title": "parseHex"
      },
      "index": {
        "description": "Parse decimal octal or hexadecimal unsigned Integral numeric literal",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseHex",
        "normalized": "",
        "package": "polyparse",
        "partial": "Hex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseInt",
      "description": {
        "fct-descr": "\u003cp\u003eParse any (unsigned) Integral numeric literal.\n   Needs a base, radix, isDigit predicate,\n   and digitToInt converter, appropriate to the result type.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e a -\u003e (Char -\u003e Bool) -\u003e (Char -\u003e Int) -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parseInt",
        "fct-type": "function",
        "title": "parseInt"
      },
      "index": {
        "description": "Parse any unsigned Integral numeric literal Needs base radix isDigit predicate and digitToInt converter appropriate to the result type",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseInt",
        "normalized": "String-\u003ea-\u003e(Char-\u003eBool)-\u003e(Char-\u003eInt)-\u003eTextParser a",
        "package": "polyparse",
        "partial": "Int",
        "signature": "String-\u003ea-\u003e(Char-\u003eBool)-\u003e(Char-\u003eInt)-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseList",
      "description": {
        "fct-descr": "\u003cp\u003eParsing a list of items by default accepts the [] and comma syntax,\n   except when the list is really a character string using \"\".\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser [a]",
        "fct-source": "src/Text-Parse-ByteString.html#parseList",
        "fct-type": "method",
        "title": "parseList"
      },
      "index": {
        "description": "Parsing list of items by default accepts the and comma syntax except when the list is really character string using",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseList",
        "normalized": "TextParser[a]",
        "package": "polyparse",
        "partial": "List",
        "signature": "TextParser[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseLitChar",
      "description": {
        "fct-descr": "\u003cp\u003eParse a Haskell character literal.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser Char",
        "fct-source": "src/Text-Parse-ByteString.html#parseLitChar",
        "fct-type": "function",
        "title": "parseLitChar"
      },
      "index": {
        "description": "Parse Haskell character literal",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseLitChar",
        "normalized": "",
        "package": "polyparse",
        "partial": "Lit Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseOct",
      "description": {
        "fct-descr": "\u003cp\u003eParse a decimal, octal, or hexadecimal (unsigned) Integral numeric literal.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parseOct",
        "fct-type": "function",
        "title": "parseOct"
      },
      "index": {
        "description": "Parse decimal octal or hexadecimal unsigned Integral numeric literal",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseOct",
        "normalized": "",
        "package": "polyparse",
        "partial": "Oct",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parsePrec",
      "description": {
        "fct-descr": "\u003cp\u003eA straightforward parser for an item, given the precedence of\n   any surrounding expression.  (Precedence determines whether\n   parentheses are mandatory or optional.)\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Int -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parsePrec",
        "fct-type": "method",
        "title": "parsePrec"
      },
      "index": {
        "description": "straightforward parser for an item given the precedence of any surrounding expression Precedence determines whether parentheses are mandatory or optional",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parsePrec",
        "normalized": "Int-\u003eTextParser a",
        "package": "polyparse",
        "partial": "Prec",
        "signature": "Int-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseSigned",
      "description": {
        "fct-descr": "\u003cp\u003eFor any numeric parser, permit a negation sign in front of it.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a -\u003e TextParser a",
        "fct-source": "src/Text-Parse-ByteString.html#parseSigned",
        "fct-type": "function",
        "title": "parseSigned"
      },
      "index": {
        "description": "For any numeric parser permit negation sign in front of it",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseSigned",
        "normalized": "TextParser a-\u003eTextParser a",
        "package": "polyparse",
        "partial": "Signed",
        "signature": "TextParser a-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:parseUnsignedInteger",
      "description": {
        "fct-descr": "\u003cp\u003eparseUnsignedInteger uses the underlying ByteString readInteger, so\n   will be a lot faster than the generic character-by-character parseInt.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser Integer",
        "fct-source": "src/Text-Parse-ByteString.html#parseUnsignedInteger",
        "fct-type": "function",
        "title": "parseUnsignedInteger"
      },
      "index": {
        "description": "parseUnsignedInteger uses the underlying ByteString readInteger so will be lot faster than the generic character-by-character parseInt",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "parseUnsignedInteger",
        "normalized": "",
        "package": "polyparse",
        "partial": "Unsigned Integer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:readByParse",
      "description": {
        "fct-descr": "\u003cp\u003eIf you have a TextParser for a type, you can easily make it into\n   a Read instance, by throwing away any error messages.  Use of this\n   wrapper function is NOT recommended with ByteString, because there\n   is a lot of inefficiency in conversions to/from String.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a -\u003e ReadS a",
        "fct-source": "src/Text-Parse-ByteString.html#readByParse",
        "fct-type": "function",
        "title": "readByParse"
      },
      "index": {
        "description": "If you have TextParser for type you can easily make it into Read instance by throwing away any error messages Use of this wrapper function is NOT recommended with ByteString because there is lot of inefficiency in conversions to from String",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "readByParse",
        "normalized": "TextParser a-\u003eReadS a",
        "package": "polyparse",
        "partial": "By Parse",
        "signature": "TextParser a-\u003eReadS a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:readsPrecByParsePrec",
      "description": {
        "fct-descr": "\u003cp\u003eIf you have a TextParser for a type, you can easily make it into\n   a Read instance, by throwing away any error messages.  Use of this\n   wrapper function is NOT recommended with ByteString, because there\n   is a lot of inefficiency in conversions to/from String.\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "(Int -\u003e TextParser a) -\u003e Int -\u003e ReadS a",
        "fct-source": "src/Text-Parse-ByteString.html#readsPrecByParsePrec",
        "fct-type": "function",
        "title": "readsPrecByParsePrec"
      },
      "index": {
        "description": "If you have TextParser for type you can easily make it into Read instance by throwing away any error messages Use of this wrapper function is NOT recommended with ByteString because there is lot of inefficiency in conversions to from String",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "readsPrecByParsePrec",
        "normalized": "(Int-\u003eTextParser a)-\u003eInt-\u003eReadS a",
        "package": "polyparse",
        "partial": "Prec By Parse Prec",
        "signature": "(Int-\u003eTextParser a)-\u003eInt-\u003eReadS a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse-ByteString.html#v:word",
      "description": {
        "fct-descr": "\u003cp\u003eOne lexical chunk (Haskell-style lexing).\n\u003c/p\u003e",
        "fct-module": "Text.Parse.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "TextParser String",
        "fct-source": "src/Text-Parse-ByteString.html#word",
        "fct-type": "function",
        "title": "word"
      },
      "index": {
        "description": "One lexical chunk Haskell-style lexing",
        "hierarchy": "Text Parse ByteString",
        "module": "Text.Parse.ByteString",
        "name": "word",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#",
      "description": {
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-Parse.html",
        "fct-type": "module",
        "title": "Parse"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "Parse",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parse",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#t:Parse",
      "description": {
        "fct-descr": "\u003cp\u003eThe class \u003ccode\u003eParse\u003c/code\u003e is a replacement for \u003ccode\u003eRead\u003c/code\u003e, operating over String input.\n   Essentially, it permits better error messages for why something failed to\n   parse.  It is rather important that \u003ccode\u003eparse\u003c/code\u003e can read back exactly what\n   is generated by the corresponding instance of \u003ccode\u003eshow\u003c/code\u003e.  To apply a parser\n   to some text, use \u003ccode\u003erunParser\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "class",
        "fct-source": "src/Text-Parse.html#Parse",
        "fct-type": "class",
        "title": "Parse"
      },
      "index": {
        "description": "The class Parse is replacement for Read operating over String input Essentially it permits better error messages for why something failed to parse It is rather important that parse can read back exactly what is generated by the corresponding instance of show To apply parser to some text use runParser",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "Parse",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parse",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#t:TextParser",
      "description": {
        "fct-descr": "\u003cp\u003eA synonym for Parser Char, i.e. string input (no state)\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "type",
        "fct-source": "src/Text-Parse.html#TextParser",
        "fct-type": "type",
        "title": "TextParser"
      },
      "index": {
        "description": "synonym for Parser Char i.e string input no state",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "TextParser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Text Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:allAsString",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the entire remaining input String.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser String",
        "fct-source": "src/Text-Parse.html#allAsString",
        "fct-type": "function",
        "title": "allAsString"
      },
      "index": {
        "description": "Simply return the entire remaining input String",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "allAsString",
        "normalized": "",
        "package": "polyparse",
        "partial": "As String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:constructors",
      "description": {
        "fct-descr": "\u003cp\u003eParse one of a bunch of alternative constructors.  In the list argument,\n   the first element of the pair is the constructor name, and\n   the second is the parser for the rest of the value.  The first matching\n   parse is returned.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "[(String, TextParser a)] -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#constructors",
        "fct-type": "function",
        "title": "constructors"
      },
      "index": {
        "description": "Parse one of bunch of alternative constructors In the list argument the first element of the pair is the constructor name and the second is the parser for the rest of the value The first matching parse is returned",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "constructors",
        "normalized": "[(String,TextParser a)]-\u003eTextParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "[(String,TextParser a)]-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:enumeration",
      "description": {
        "fct-descr": "\u003cp\u003eParse one of the given nullary constructors (an enumeration).\n   The string argument is the name of the type, and the list argument\n   should contain all of the possible enumeration values.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e [a] -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#enumeration",
        "fct-type": "function",
        "title": "enumeration"
      },
      "index": {
        "description": "Parse one of the given nullary constructors an enumeration The string argument is the name of the type and the list argument should contain all of the possible enumeration values",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "enumeration",
        "normalized": "String-\u003e[a]-\u003eTextParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "String-\u003e[a]-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:field",
      "description": {
        "fct-descr": "\u003cp\u003eDeal with named field syntax.  The string argument is the field name,\n   and the parser returns the value of the field.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#field",
        "fct-type": "function",
        "title": "field"
      },
      "index": {
        "description": "Deal with named field syntax The string argument is the field name and the parser returns the value of the field",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "field",
        "normalized": "String-\u003eTextParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "String-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:isWord",
      "description": {
        "fct-descr": "\u003cp\u003eEnsure that the next input word is the given string.  (Note the input\n   is lexed as haskell, so wordbreaks at spaces, symbols, etc.)\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e TextParser String",
        "fct-source": "src/Text-Parse.html#isWord",
        "fct-type": "function",
        "title": "isWord"
      },
      "index": {
        "description": "Ensure that the next input word is the given string Note the input is lexed as haskell so wordbreaks at spaces symbols etc",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "isWord",
        "normalized": "String-\u003eTextParser String",
        "package": "polyparse",
        "partial": "Word",
        "signature": "String-\u003eTextParser String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:optionalParens",
      "description": {
        "fct-descr": "\u003cp\u003eAllow nested parens around an item.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#optionalParens",
        "fct-type": "function",
        "title": "optionalParens"
      },
      "index": {
        "description": "Allow nested parens around an item",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "optionalParens",
        "normalized": "TextParser a-\u003eTextParser a",
        "package": "polyparse",
        "partial": "Parens",
        "signature": "TextParser a-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parens",
      "description": {
        "fct-descr": "\u003cp\u003eAllow nested parens around an item (one set required when Bool is True).\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "Bool -\u003e TextParser a -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#parens",
        "fct-type": "function",
        "title": "parens"
      },
      "index": {
        "description": "Allow nested parens around an item one set required when Bool is True",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parens",
        "normalized": "Bool-\u003eTextParser a-\u003eTextParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Bool-\u003eTextParser a-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parse",
      "description": {
        "fct-descr": "\u003cp\u003eA straightforward parser for an item.  (A minimal definition of\n   a class instance requires either |parse| or |parsePrec|.)\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse.html#parse",
        "fct-type": "method",
        "title": "parse"
      },
      "index": {
        "description": "straightforward parser for an item minimal definition of class instance requires either parse or parsePrec",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parse",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseByRead",
      "description": {
        "fct-descr": "\u003cp\u003eIf there already exists a Read instance for a type, then we can make\n   a Parser for it, but with only poor error-reporting.  The string argument\n   is the expected type or value (for error-reporting only).\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#parseByRead",
        "fct-type": "function",
        "title": "parseByRead"
      },
      "index": {
        "description": "If there already exists Read instance for type then we can make Parser for it but with only poor error-reporting The string argument is the expected type or value for error-reporting only",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseByRead",
        "normalized": "String-\u003eTextParser a",
        "package": "polyparse",
        "partial": "By Read",
        "signature": "String-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseDec",
      "description": {
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse.html#parseDec",
        "fct-type": "function",
        "title": "parseDec"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseDec",
        "normalized": "",
        "package": "polyparse",
        "partial": "Dec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseFloat",
      "description": {
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse.html#parseFloat",
        "fct-type": "function",
        "title": "parseFloat"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseFloat",
        "normalized": "",
        "package": "polyparse",
        "partial": "Float",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseHex",
      "description": {
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse.html#parseHex",
        "fct-type": "function",
        "title": "parseHex"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseHex",
        "normalized": "",
        "package": "polyparse",
        "partial": "Hex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseInt",
      "description": {
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e a -\u003e (Char -\u003e Bool) -\u003e (Char -\u003e Int) -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#parseInt",
        "fct-type": "function",
        "title": "parseInt"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseInt",
        "normalized": "String-\u003ea-\u003e(Char-\u003eBool)-\u003e(Char-\u003eInt)-\u003eTextParser a",
        "package": "polyparse",
        "partial": "Int",
        "signature": "String-\u003ea-\u003e(Char-\u003eBool)-\u003e(Char-\u003eInt)-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseList",
      "description": {
        "fct-descr": "\u003cp\u003eParsing a list of items by default accepts the [] and comma syntax,\n   except when the list is really a character string using \"\".\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser [a]",
        "fct-source": "src/Text-Parse.html#parseList",
        "fct-type": "method",
        "title": "parseList"
      },
      "index": {
        "description": "Parsing list of items by default accepts the and comma syntax except when the list is really character string using",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseList",
        "normalized": "TextParser[a]",
        "package": "polyparse",
        "partial": "List",
        "signature": "TextParser[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseLitChar",
      "description": {
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser Char",
        "fct-source": "src/Text-Parse.html#parseLitChar",
        "fct-type": "function",
        "title": "parseLitChar"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseLitChar",
        "normalized": "",
        "package": "polyparse",
        "partial": "Lit Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseOct",
      "description": {
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a",
        "fct-source": "src/Text-Parse.html#parseOct",
        "fct-type": "function",
        "title": "parseOct"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseOct",
        "normalized": "",
        "package": "polyparse",
        "partial": "Oct",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parsePrec",
      "description": {
        "fct-descr": "\u003cp\u003eA straightforward parser for an item, given the precedence of\n   any surrounding expression.  (Precedence determines whether\n   parentheses are mandatory or optional.)\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "Int -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#parsePrec",
        "fct-type": "method",
        "title": "parsePrec"
      },
      "index": {
        "description": "straightforward parser for an item given the precedence of any surrounding expression Precedence determines whether parentheses are mandatory or optional",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parsePrec",
        "normalized": "Int-\u003eTextParser a",
        "package": "polyparse",
        "partial": "Prec",
        "signature": "Int-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:parseSigned",
      "description": {
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a -\u003e TextParser a",
        "fct-source": "src/Text-Parse.html#parseSigned",
        "fct-type": "function",
        "title": "parseSigned"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "parseSigned",
        "normalized": "TextParser a-\u003eTextParser a",
        "package": "polyparse",
        "partial": "Signed",
        "signature": "TextParser a-\u003eTextParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:readByParse",
      "description": {
        "fct-descr": "\u003cp\u003eIf you have a TextParser for a type, you can easily make it into\n   a Read instance, by throwing away any error messages.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser a -\u003e ReadS a",
        "fct-source": "src/Text-Parse.html#readByParse",
        "fct-type": "function",
        "title": "readByParse"
      },
      "index": {
        "description": "If you have TextParser for type you can easily make it into Read instance by throwing away any error messages",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "readByParse",
        "normalized": "TextParser a-\u003eReadS a",
        "package": "polyparse",
        "partial": "By Parse",
        "signature": "TextParser a-\u003eReadS a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:readsPrecByParsePrec",
      "description": {
        "fct-descr": "\u003cp\u003eIf you have a TextParser for a type, you can easily make it into\n   a Read instance, by throwing away any error messages.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "(Int -\u003e TextParser a) -\u003e Int -\u003e ReadS a",
        "fct-source": "src/Text-Parse.html#readsPrecByParsePrec",
        "fct-type": "function",
        "title": "readsPrecByParsePrec"
      },
      "index": {
        "description": "If you have TextParser for type you can easily make it into Read instance by throwing away any error messages",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "readsPrecByParsePrec",
        "normalized": "(Int-\u003eTextParser a)-\u003eInt-\u003eReadS a",
        "package": "polyparse",
        "partial": "Prec By Parse Prec",
        "signature": "(Int-\u003eTextParser a)-\u003eInt-\u003eReadS a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-Parse.html#v:word",
      "description": {
        "fct-descr": "\u003cp\u003eOne lexical chunk.  This is Haskell'98-style lexing - the result\n   should match Prelude.lex apart from better error-reporting.\n\u003c/p\u003e",
        "fct-module": "Text.Parse",
        "fct-package": "polyparse",
        "fct-signature": "TextParser String",
        "fct-source": "src/Text-Parse.html#word",
        "fct-type": "function",
        "title": "word"
      },
      "index": {
        "description": "One lexical chunk This is Haskell style lexing the result should match Prelude.lex apart from better error-reporting",
        "hierarchy": "Text Parse",
        "module": "Text.Parse",
        "name": "word",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis Haskell script defines a library of parser combinators, and is\n taken from sections 1-6 of our article \u003ca\u003eMonadic Parser Combinators\u003c/a\u003e.\n Some changes to the library have been made in the move from Gofer\n to Haskell:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Do notation is used in place of monad comprehension notation;\n\u003c/li\u003e\u003cli\u003e The parser datatype is defined using \u003ca\u003enewtype\u003c/a\u003e, to avoid the overhead\n      of tagging and untagging parsers with the P constructor.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html",
        "fct-type": "module",
        "title": "HuttonMeijer"
      },
      "index": {
        "description": "This Haskell script defines library of parser combinators and is taken from sections of our article Monadic Parser Combinators Some changes to the library have been made in the move from Gofer to Haskell Do notation is used in place of monad comprehension notation The parser datatype is defined using newtype to avoid the overhead of tagging and untagging parsers with the constructor",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "HuttonMeijer",
        "normalized": "",
        "package": "polyparse",
        "partial": "Hutton Meijer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThe parser monad\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "The parser monad",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:-43--43--43-",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#%2B%2B%2B",
        "fct-type": "function",
        "title": "(+++)"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "(+++) +++",
        "normalized": "Parser a-\u003eParser a-\u003eParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser a-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "P ([Token] -\u003e [(a, [Token])])",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "P",
        "normalized": "P([Token]-\u003e[(a,[Token])])",
        "package": "polyparse",
        "partial": "",
        "signature": "P([Token]-\u003e[(a,[Token])])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:alphanum",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Char",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#alphanum",
        "fct-type": "function",
        "title": "alphanum"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "alphanum",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:bracket",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser b -\u003e Parser c -\u003e Parser b",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#bracket",
        "fct-type": "function",
        "title": "bracket"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "bracket",
        "normalized": "Parser a-\u003eParser b-\u003eParser c-\u003eParser b",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser b-\u003eParser c-\u003eParser b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:chainl",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser (a -\u003e a -\u003e a) -\u003e a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#chainl",
        "fct-type": "function",
        "title": "chainl"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "chainl",
        "normalized": "Parser a-\u003eParser(a-\u003ea-\u003ea)-\u003ea-\u003eParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser(a-\u003ea-\u003ea)-\u003ea-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:chainl1",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser (a -\u003e a -\u003e a) -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#chainl1",
        "fct-type": "function",
        "title": "chainl1"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "chainl1",
        "normalized": "Parser a-\u003eParser(a-\u003ea-\u003ea)-\u003eParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser(a-\u003ea-\u003ea)-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:chainr",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser (a -\u003e a -\u003e a) -\u003e a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#chainr",
        "fct-type": "function",
        "title": "chainr"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "chainr",
        "normalized": "Parser a-\u003eParser(a-\u003ea-\u003ea)-\u003ea-\u003eParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser(a-\u003ea-\u003ea)-\u003ea-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:chainr1",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser (a -\u003e a -\u003e a) -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#chainr1",
        "fct-type": "function",
        "title": "chainr1"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "chainr1",
        "normalized": "Parser a-\u003eParser(a-\u003ea-\u003ea)-\u003eParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser(a-\u003ea-\u003ea)-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:char",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Char -\u003e Parser Char",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#char",
        "fct-type": "function",
        "title": "char"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "char",
        "normalized": "Char-\u003eParser Char",
        "package": "polyparse",
        "partial": "",
        "signature": "Char-\u003eParser Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:comment",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser ()",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#comment",
        "fct-type": "function",
        "title": "comment"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "comment",
        "normalized": "Parser()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:digit",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Char",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#digit",
        "fct-type": "function",
        "title": "digit"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "digit",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:first",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#first",
        "fct-type": "function",
        "title": "first"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "first",
        "normalized": "Parser a-\u003eParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:ident",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser String",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#ident",
        "fct-type": "function",
        "title": "ident"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "ident",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:identifier",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "[String] -\u003e Parser String",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#identifier",
        "fct-type": "function",
        "title": "identifier"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "identifier",
        "normalized": "[String]-\u003eParser String",
        "package": "polyparse",
        "partial": "",
        "signature": "[String]-\u003eParser String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:int",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Int",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#int",
        "fct-type": "function",
        "title": "int"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "int",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:integer",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Int",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#integer",
        "fct-type": "function",
        "title": "integer"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "integer",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:item",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Token",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#item",
        "fct-type": "function",
        "title": "item"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "item",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:junk",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser ()",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#junk",
        "fct-type": "function",
        "title": "junk"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "junk",
        "normalized": "Parser()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:letter",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Char",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#letter",
        "fct-type": "function",
        "title": "letter"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "letter",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:lower",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Char",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#lower",
        "fct-type": "function",
        "title": "lower"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "lower",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:many",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser [a]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#many",
        "fct-type": "function",
        "title": "many"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "many",
        "normalized": "Parser a-\u003eParser[a]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:many1",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser [a]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#many1",
        "fct-type": "function",
        "title": "many1"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "many1",
        "normalized": "Parser a-\u003eParser[a]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:nat",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Int",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#nat",
        "fct-type": "function",
        "title": "nat"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "nat",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:natural",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Int",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#natural",
        "fct-type": "function",
        "title": "natural"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "natural",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:ops",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "[(Parser a, b)] -\u003e Parser b",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#ops",
        "fct-type": "function",
        "title": "ops"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "ops",
        "normalized": "[(Parser a,b)]-\u003eParser b",
        "package": "polyparse",
        "partial": "",
        "signature": "[(Parser a,b)]-\u003eParser b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:papply",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e [Token] -\u003e [(a, [Token])]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#papply",
        "fct-type": "function",
        "title": "papply"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "papply",
        "normalized": "Parser a-\u003e[Token]-\u003e[(a,[Token])]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003e[Token]-\u003e[(a,[Token])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:sat",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "(Token -\u003e Bool) -\u003e Parser Token",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#sat",
        "fct-type": "function",
        "title": "sat"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "sat",
        "normalized": "(Token-\u003eBool)-\u003eParser Token",
        "package": "polyparse",
        "partial": "",
        "signature": "(Token-\u003eBool)-\u003eParser Token"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:sepby",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser b -\u003e Parser [a]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#sepby",
        "fct-type": "function",
        "title": "sepby"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "sepby",
        "normalized": "Parser a-\u003eParser b-\u003eParser[a]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser b-\u003eParser[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:sepby1",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser b -\u003e Parser [a]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#sepby1",
        "fct-type": "function",
        "title": "sepby1"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "sepby1",
        "normalized": "Parser a-\u003eParser b-\u003eParser[a]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser b-\u003eParser[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:skip",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#skip",
        "fct-type": "function",
        "title": "skip"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "skip",
        "normalized": "Parser a-\u003eParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:spaces",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser ()",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#spaces",
        "fct-type": "function",
        "title": "spaces"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "spaces",
        "normalized": "Parser()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:string",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e Parser String",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#string",
        "fct-type": "function",
        "title": "string"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "string",
        "normalized": "String-\u003eParser String",
        "package": "polyparse",
        "partial": "",
        "signature": "String-\u003eParser String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:symbol",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e Parser String",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#symbol",
        "fct-type": "function",
        "title": "symbol"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "symbol",
        "normalized": "String-\u003eParser String",
        "package": "polyparse",
        "partial": "",
        "signature": "String-\u003eParser String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:token",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#token",
        "fct-type": "function",
        "title": "token"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "token",
        "normalized": "Parser a-\u003eParser a",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser a-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijer.html#v:upper",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijer",
        "fct-package": "polyparse",
        "fct-signature": "Parser Char",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijer.html#upper",
        "fct-type": "function",
        "title": "upper"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijer",
        "module": "Text.ParserCombinators.HuttonMeijer",
        "name": "upper",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library of monadic parser combinators is based on the ones\n   defined by Graham Hutton and Erik Meijer.  It has been extended by\n   Malcolm Wallace to use an abstract token type (no longer just a\n   string) as input, and to incorporate state in the monad, useful\n   for symbol tables, macros, and so on.  Basic facilities for error\n   reporting have also been added, and later extended by Graham Klyne\n   to return the errors through an \u003ccode\u003eEither\u003c/code\u003e type, rather than just\n   calling \u003ccode\u003eerror\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html",
        "fct-type": "module",
        "title": "HuttonMeijerWallace"
      },
      "index": {
        "description": "This library of monadic parser combinators is based on the ones defined by Graham Hutton and Erik Meijer It has been extended by Malcolm Wallace to use an abstract token type no longer just string as input and to incorporate state in the monad useful for symbol tables macros and so on Basic facilities for error reporting have also been added and later extended by Graham Klyne to return the errors through an Either type rather than just calling error",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "HuttonMeijerWallace",
        "normalized": "",
        "package": "polyparse",
        "partial": "Hutton Meijer Wallace",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#t:Parser",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:-43--43--43-",
      "description": {
        "fct-descr": "\u003cp\u003eA choice between parsers.  Keep only the first success.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e a -\u003e Parser s t e a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#%2B%2B%2B",
        "fct-type": "function",
        "title": "(+++)"
      },
      "index": {
        "description": "choice between parsers Keep only the first success",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "(+++) +++",
        "normalized": "Parser a b c d-\u003eParser a b c d-\u003eParser a b c d",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e a-\u003eParser s t e a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:P",
      "description": {
        "fct-descr": "\u003cp\u003eThe parser type is parametrised on the types of the state \u003ccode\u003es\u003c/code\u003e,\n   the input tokens \u003ccode\u003et\u003c/code\u003e, error-type \u003ccode\u003ee\u003c/code\u003e, and the result value \u003ccode\u003ea\u003c/code\u003e.\n   The state and remaining input are threaded through the monad.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "P (s -\u003e [Either e t] -\u003e ParseResult s t e a)",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "The parser type is parametrised on the types of the state the input tokens error-type and the result value The state and remaining input are threaded through the monad",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "P",
        "normalized": "P(a-\u003e[Either b c]-\u003eParseResult a c b d)",
        "package": "polyparse",
        "partial": "",
        "signature": "P(s-\u003e[Either e t]-\u003eParseResult s t e a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:bracket",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s (p, t) e a -\u003e Parser s (p, t) e b -\u003e Parser s (p, t) e c -\u003e Parser s (p, t) e b",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#bracket",
        "fct-type": "function",
        "title": "bracket"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "bracket",
        "normalized": "Parser a(b,c)d e-\u003eParser a(b,c)d f-\u003eParser a(b,c)d g-\u003eParser a(b,c)d f",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s(p,t)e a-\u003eParser s(p,t)e b-\u003eParser s(p,t)e c-\u003eParser s(p,t)e b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:chainl",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e (a -\u003e a -\u003e a) -\u003e a -\u003e Parser s t e a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#chainl",
        "fct-type": "function",
        "title": "chainl"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "chainl",
        "normalized": "Parser a b c d-\u003eParser a b c(d-\u003ed-\u003ed)-\u003ed-\u003eParser a b c d",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e(a-\u003ea-\u003ea)-\u003ea-\u003eParser s t e a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:chainl1",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e (a -\u003e a -\u003e a) -\u003e Parser s t e a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#chainl1",
        "fct-type": "function",
        "title": "chainl1"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "chainl1",
        "normalized": "Parser a b c d-\u003eParser a b c(d-\u003ed-\u003ed)-\u003eParser a b c d",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e(a-\u003ea-\u003ea)-\u003eParser s t e a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:chainr",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e (a -\u003e a -\u003e a) -\u003e a -\u003e Parser s t e a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#chainr",
        "fct-type": "function",
        "title": "chainr"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "chainr",
        "normalized": "Parser a b c d-\u003eParser a b c(d-\u003ed-\u003ed)-\u003ed-\u003eParser a b c d",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e(a-\u003ea-\u003ea)-\u003ea-\u003eParser s t e a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:chainr1",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e (a -\u003e a -\u003e a) -\u003e Parser s t e a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#chainr1",
        "fct-type": "function",
        "title": "chainr1"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "chainr1",
        "normalized": "Parser a b c d-\u003eParser a b c(d-\u003ed-\u003ed)-\u003eParser a b c d",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e(a-\u003ea-\u003ea)-\u003eParser s t e a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:elserror",
      "description": {
        "fct-descr": "\u003cp\u003eIf the parser fails, generate an error message.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s (p, t) String a -\u003e String -\u003e Parser s (p, t) String a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#elserror",
        "fct-type": "function",
        "title": "elserror"
      },
      "index": {
        "description": "If the parser fails generate an error message",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "elserror",
        "normalized": "Parser a(b,c)String d-\u003eString-\u003eParser a(b,c)String d",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s(p,t)String a-\u003eString-\u003eParser s(p,t)String a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eFail if end of input is not reached\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s (p, t) String ()",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Fail if end of input is not reached",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "eof",
        "normalized": "Parser a(b,c)String()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s(p,t)String()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:item",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver the first remaining token.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e t",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#item",
        "fct-type": "function",
        "title": "item"
      },
      "index": {
        "description": "Deliver the first remaining token",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "item",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:many",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver zero or more values of \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e [a]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#many",
        "fct-type": "function",
        "title": "many"
      },
      "index": {
        "description": "Deliver zero or more values of",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "many",
        "normalized": "Parser a b c d-\u003eParser a b c[d]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:many1",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver one or more values of \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e [a]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#many1",
        "fct-type": "function",
        "title": "many1"
      },
      "index": {
        "description": "Deliver one or more values of",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "many1",
        "normalized": "Parser a b c d-\u003eParser a b c[d]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:nottok",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver the first token if it does not equal the argument.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "[t] -\u003e Parser s (p, t) e t",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#nottok",
        "fct-type": "function",
        "title": "nottok"
      },
      "index": {
        "description": "Deliver the first token if it does not equal the argument",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "nottok",
        "normalized": "[a]-\u003eParser b(c,a)d a",
        "package": "polyparse",
        "partial": "",
        "signature": "[t]-\u003eParser s(p,t)e t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:ops",
      "description": {
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "[(Parser s t e a, b)] -\u003e Parser s t e b",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#ops",
        "fct-type": "function",
        "title": "ops"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "ops",
        "normalized": "[(Parser a b c d,e)]-\u003eParser a b c e",
        "package": "polyparse",
        "partial": "",
        "signature": "[(Parser s t e a,b)]-\u003eParser s t e b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:papply",
      "description": {
        "fct-descr": "\u003cp\u003eApply the parser to some real input, given an initial state value.\n   If the parser fails, raise \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e to halt the program.\n   (This is the original exported behaviour - to allow the caller to\n   deal with the error differently, see \u003ccode\u003epapply'\u003c/code\u003e.)\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t String a -\u003e s -\u003e [Either String t] -\u003e [(a, s, [Either String t])]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#papply",
        "fct-type": "function",
        "title": "papply"
      },
      "index": {
        "description": "Apply the parser to some real input given an initial state value If the parser fails raise error to halt the program This is the original exported behaviour to allow the caller to deal with the error differently see papply",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "papply",
        "normalized": "Parser a b String c-\u003ea-\u003e[Either String b]-\u003e[(c,a,[Either String b])]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t String a-\u003es-\u003e[Either String t]-\u003e[(a,s,[Either String t])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:papply-39-",
      "description": {
        "fct-descr": "\u003cp\u003eApply the parser to some real input, given an initial state value.\n   If the parser fails, return a diagnostic message to the caller.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e s -\u003e [Either e t] -\u003e Either e [(a, s, [Either e t])]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#papply%27",
        "fct-type": "function",
        "title": "papply'"
      },
      "index": {
        "description": "Apply the parser to some real input given an initial state value If the parser fails return diagnostic message to the caller",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "papply'",
        "normalized": "Parser a b c d-\u003ea-\u003e[Either c b]-\u003eEither c[(d,a,[Either c b])]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003es-\u003e[Either e t]-\u003eEither e[(a,s,[Either e t])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003eThis is useful for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "[Either e t] -\u003e Parser s t e ()",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "This is useful for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "reparse",
        "normalized": "[Either a b]-\u003eParser c b a()",
        "package": "polyparse",
        "partial": "",
        "signature": "[Either e t]-\u003eParser s t e()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:sepby",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver zero or more values of \u003ccode\u003ea\u003c/code\u003e separated by \u003ccode\u003eb\u003c/code\u003e's.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e b -\u003e Parser s t e [a]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#sepby",
        "fct-type": "function",
        "title": "sepby"
      },
      "index": {
        "description": "Deliver zero or more values of separated by",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "sepby",
        "normalized": "Parser a b c d-\u003eParser a b c e-\u003eParser a b c[d]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e b-\u003eParser s t e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:sepby1",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver one or more values of \u003ccode\u003ea\u003c/code\u003e separated by \u003ccode\u003eb\u003c/code\u003e's.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e a -\u003e Parser s t e b -\u003e Parser s t e [a]",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#sepby1",
        "fct-type": "function",
        "title": "sepby1"
      },
      "index": {
        "description": "Deliver one or more values of separated by",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "sepby1",
        "normalized": "Parser a b c d-\u003eParser a b c e-\u003eParser a b c[d]",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t e a-\u003eParser s t e b-\u003eParser s t e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:stget",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver the entire internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t e s",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#stget",
        "fct-type": "function",
        "title": "stget"
      },
      "index": {
        "description": "Deliver the entire internal state",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "stget",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:stquery",
      "description": {
        "fct-descr": "\u003cp\u003eQuery the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e a) -\u003e Parser s t e a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#stquery",
        "fct-type": "function",
        "title": "stquery"
      },
      "index": {
        "description": "Query the internal state",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "stquery",
        "normalized": "(a-\u003eb)-\u003eParser a c d b",
        "package": "polyparse",
        "partial": "",
        "signature": "(s-\u003ea)-\u003eParser s t e a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:stupd",
      "description": {
        "fct-descr": "\u003cp\u003eUpdate the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e s) -\u003e Parser s t e ()",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#stupd",
        "fct-type": "function",
        "title": "stupd"
      },
      "index": {
        "description": "Update the internal state",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "stupd",
        "normalized": "(a-\u003ea)-\u003eParser a b c()",
        "package": "polyparse",
        "partial": "",
        "signature": "(s-\u003es)-\u003eParser s t e()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:toEOF",
      "description": {
        "fct-descr": "\u003cp\u003eAccept a complete parse of the input only, no partial parses.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "Parser s (p, t) String a -\u003e Parser s (p, t) String a",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#toEOF",
        "fct-type": "function",
        "title": "toEOF"
      },
      "index": {
        "description": "Accept complete parse of the input only no partial parses",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "toEOF",
        "normalized": "Parser a(b,c)String d-\u003eParser a(b,c)String d",
        "package": "polyparse",
        "partial": "EOF",
        "signature": "Parser s(p,t)String a-\u003eParser s(p,t)String a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:tok",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver the first token if it equals the argument.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.HuttonMeijerWallace",
        "fct-package": "polyparse",
        "fct-signature": "t -\u003e Parser s (p, t) e t",
        "fct-source": "src/Text-ParserCombinators-HuttonMeijerWallace.html#tok",
        "fct-type": "function",
        "title": "tok"
      },
      "index": {
        "description": "Deliver the first token if it equals the argument",
        "hierarchy": "Text ParserCombinators HuttonMeijerWallace",
        "module": "Text.ParserCombinators.HuttonMeijerWallace",
        "name": "tok",
        "normalized": "a-\u003eParser b(c,a)d a",
        "package": "polyparse",
        "partial": "",
        "signature": "t-\u003eParser s(p,t)e t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html",
        "fct-type": "module",
        "title": "Base"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "Base",
        "normalized": "",
        "package": "polyparse",
        "partial": "Base",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#t:Commitment",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003eCommitment\u003c/code\u003e class is an abstraction over all the current\n   concrete representations of monadic/applicative parser combinators in this\n   package.  The common feature is two-level error-handling.\n   Some primitives must be implemented specific to each parser type\n   (e.g. depending on whether the parser has a running state, or\n   whether it is lazy).  But given those primitives, large numbers of\n   combinators do not depend any further on the internal structure of\n   the particular parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "class",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#Commitment",
        "fct-type": "class",
        "title": "Commitment"
      },
      "index": {
        "description": "The Commitment class is an abstraction over all the current concrete representations of monadic applicative parser combinators in this package The common feature is two-level error-handling Some primitives must be implemented specific to each parser type e.g depending on whether the parser has running state or whether it is lazy But given those primitives large numbers of combinators do not depend any further on the internal structure of the particular parser",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "Commitment",
        "normalized": "",
        "package": "polyparse",
        "partial": "Commitment",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#t:PolyParse",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003ePolyParse\u003c/code\u003e class is an abstraction gathering all of the common\n   features that a two-level error-handling parser requires:\n   the applicative parsing interface, the monadic interface, and commitment.\n\u003c/p\u003e\u003cp\u003eThere are two additional basic combinators that we expect to be implemented\n   afresh for every concrete type, but which (for technical reasons)\n   cannot be class methods.  They are \u003ccode\u003enext\u003c/code\u003e and \u003ccode\u003esatisfy\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "class",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#PolyParse",
        "fct-type": "class",
        "title": "PolyParse"
      },
      "index": {
        "description": "The PolyParse class is an abstraction gathering all of the common features that two-level error-handling parser requires the applicative parsing interface the monadic interface and commitment There are two additional basic combinators that we expect to be implemented afresh for every concrete type but which for technical reasons cannot be class methods They are next and satisfy",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "PolyParse",
        "normalized": "",
        "package": "polyparse",
        "partial": "Poly Parse",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:adjustErr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eadjustErr\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e applies the transformation \u003ccode\u003ef\u003c/code\u003e to any error message\n   generated in \u003ccode\u003ep\u003c/code\u003e, having no effect if \u003ccode\u003ep\u003c/code\u003e succeeds.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e (String -\u003e String) -\u003e p a",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#adjustErr",
        "fct-type": "method",
        "title": "adjustErr"
      },
      "index": {
        "description": "adjustErr applies the transformation to any error message generated in having no effect if succeeds",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "adjustErr",
        "normalized": "a b-\u003e(String-\u003eString)-\u003ea b",
        "package": "polyparse",
        "partial": "Err",
        "signature": "p a-\u003e(String-\u003eString)-\u003ep a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:adjustErrBad",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eadjustErrBad\u003c/code\u003e is just like \u003ccode\u003eadjustErr\u003c/code\u003e except it also raises the\n   severity of the error.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e (String -\u003e String) -\u003e p a",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#adjustErrBad",
        "fct-type": "function",
        "title": "adjustErrBad"
      },
      "index": {
        "description": "adjustErrBad is just like adjustErr except it also raises the severity of the error",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "adjustErrBad",
        "normalized": "a b-\u003e(String-\u003eString)-\u003ea b",
        "package": "polyparse",
        "partial": "Err Bad",
        "signature": "p a-\u003e(String-\u003eString)-\u003ep a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:apply",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parsed function to a parsed value.\n   Rather like ordinary function application lifted into parsers.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p (a -\u003e b) -\u003e p a -\u003e p b",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#apply",
        "fct-type": "function",
        "title": "apply"
      },
      "index": {
        "description": "Apply parsed function to parsed value Rather like ordinary function application lifted into parsers",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "apply",
        "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
        "package": "polyparse",
        "partial": "",
        "signature": "p(a-\u003eb)-\u003ep a-\u003ep b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:bracket",
      "description": {
        "fct-descr": "\u003cp\u003eParse a bracketed item, discarding the brackets.\n   If everything matches \u003cem\u003eexcept\u003c/em\u003e the closing bracket, the whole\n   parse fails soft, which can give less-than-satisfying error messages.\n   If you want better error messages, try calling with e.g.\n     \u003ccode\u003ebracket open (commit close) item\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p bra -\u003e p ket -\u003e p a -\u003e p a",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#bracket",
        "fct-type": "function",
        "title": "bracket"
      },
      "index": {
        "description": "Parse bracketed item discarding the brackets If everything matches except the closing bracket the whole parse fails soft which can give less-than-satisfying error messages If you want better error messages try calling with e.g bracket open commit close item",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "bracket",
        "normalized": "a b-\u003ea c-\u003ea d-\u003ea d",
        "package": "polyparse",
        "partial": "",
        "signature": "p bra-\u003ep ket-\u003ep a-\u003ep a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:bracketSep",
      "description": {
        "fct-descr": "\u003cp\u003eParse a list of items, discarding the start, end, and separator\n   items.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p bra -\u003e p sep -\u003e p ket -\u003e p a -\u003e p [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#bracketSep",
        "fct-type": "function",
        "title": "bracketSep"
      },
      "index": {
        "description": "Parse list of items discarding the start end and separator items",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "bracketSep",
        "normalized": "a b-\u003ea c-\u003ea d-\u003ea e-\u003ea[e]",
        "package": "polyparse",
        "partial": "Sep",
        "signature": "p bra-\u003ep sep-\u003ep ket-\u003ep a-\u003ep[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:commit",
      "description": {
        "fct-descr": "\u003cp\u003eCommit is a way of raising the severity of any errors found within\n   its argument.  Used in the middle of a parser definition, it means that\n   any operations prior to commitment fail softly, but after commitment,\n   they fail hard.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e p a",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#commit",
        "fct-type": "method",
        "title": "commit"
      },
      "index": {
        "description": "Commit is way of raising the severity of any errors found within its argument Used in the middle of parser definition it means that any operations prior to commitment fail softly but after commitment they fail hard",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "commit",
        "normalized": "a b-\u003ea b",
        "package": "polyparse",
        "partial": "",
        "signature": "p a-\u003ep a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:discard",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ex \u003ccode\u003e\u003ca\u003ediscard\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e parses both x and y, but discards the result of y.\n   Rather like \u003ccode\u003econst\u003c/code\u003e lifted into parsers.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e p b -\u003e p a",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#discard",
        "fct-type": "function",
        "title": "discard"
      },
      "index": {
        "description": "discard parses both and but discards the result of Rather like const lifted into parsers",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "discard",
        "normalized": "a b-\u003ea c-\u003ea b",
        "package": "polyparse",
        "partial": "",
        "signature": "p a-\u003ep b-\u003ep a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:exactly",
      "description": {
        "fct-descr": "\u003cp\u003e'exactly n p' parses precisely n items, using the parser p, in sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "Int -\u003e p a -\u003e p [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#exactly",
        "fct-type": "function",
        "title": "exactly"
      },
      "index": {
        "description": "exactly parses precisely items using the parser in sequence",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "exactly",
        "normalized": "Int-\u003ea b-\u003ea[b]",
        "package": "polyparse",
        "partial": "",
        "signature": "Int-\u003ep a-\u003ep[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:failBad",
      "description": {
        "fct-descr": "\u003cp\u003eWhen a simple fail is not strong enough, use failBad for emphasis.\n   An emphasised (severe) error cannot be overridden by choice\n   operators.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "String -\u003e p a",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#failBad",
        "fct-type": "function",
        "title": "failBad"
      },
      "index": {
        "description": "When simple fail is not strong enough use failBad for emphasis An emphasised severe error cannot be overridden by choice operators",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "failBad",
        "normalized": "String-\u003ea b",
        "package": "polyparse",
        "partial": "Bad",
        "signature": "String-\u003ep a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:indent",
      "description": {
        "fct-descr": "\u003cp\u003eHelper for formatting error messages: indents all lines by a fixed amount.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "Int -\u003e String -\u003e String",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#indent",
        "fct-type": "function",
        "title": "indent"
      },
      "index": {
        "description": "Helper for formatting error messages indents all lines by fixed amount",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "indent",
        "normalized": "Int-\u003eString-\u003eString",
        "package": "polyparse",
        "partial": "",
        "signature": "Int-\u003eString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:many1",
      "description": {
        "fct-descr": "\u003cp\u003eParse a non-empty list of items.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e p [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#many1",
        "fct-type": "function",
        "title": "many1"
      },
      "index": {
        "description": "Parse non-empty list of items",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "many1",
        "normalized": "a b-\u003ea[b]",
        "package": "polyparse",
        "partial": "",
        "signature": "p a-\u003ep[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:manyFinally",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emanyFinally e t\u003c/code\u003e parses a possibly-empty sequence of \u003ccode\u003ee\u003c/code\u003e's,\n   terminated by a \u003ccode\u003et\u003c/code\u003e.  The final \u003ccode\u003et\u003c/code\u003e is discarded.  Any parse failures\n   could be due either to a badly-formed terminator or a badly-formed\n   element, so it raises both possible errors.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e p z -\u003e p [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#manyFinally",
        "fct-type": "function",
        "title": "manyFinally"
      },
      "index": {
        "description": "manyFinally parses possibly-empty sequence of terminated by The final is discarded Any parse failures could be due either to badly-formed terminator or badly-formed element so it raises both possible errors",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "manyFinally",
        "normalized": "a b-\u003ea c-\u003ea[b]",
        "package": "polyparse",
        "partial": "Finally",
        "signature": "p a-\u003ep z-\u003ep[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:manyFinally-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emanyFinally'\u003c/code\u003e is like \u003ccode\u003emanyFinally\u003c/code\u003e, except when the terminator\n   parser overlaps with the element parser.  In \u003ccode\u003emanyFinally e t\u003c/code\u003e,\n   the parser \u003ccode\u003et\u003c/code\u003e is tried only when parser \u003ccode\u003ee\u003c/code\u003e fails, whereas in\n   \u003ccode\u003emanyFinally' e t\u003c/code\u003e, the parser \u003ccode\u003et\u003c/code\u003e is always tried first, then\n   parser \u003ccode\u003ee\u003c/code\u003e only if the terminator is not found.  For instance,\n   \u003ccode\u003emanyFinally (accept \u003ca\u003e01\u003c/a\u003e) (accept \u003ca\u003e0\u003c/a\u003e)\u003c/code\u003e on input \u003ccode\u003e\u003ca\u003e0101010\u003c/a\u003e\u003c/code\u003e returns\n   \u003ccode\u003e[\u003ca\u003e01\u003c/a\u003e,\u003ca\u003e01\u003c/a\u003e,\u003ca\u003e01\u003c/a\u003e]\u003c/code\u003e, whereas \u003ccode\u003emanyFinally'\u003c/code\u003e with the same arguments\n   and input returns \u003ccode\u003e[]\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e p z -\u003e p [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#manyFinally%27",
        "fct-type": "function",
        "title": "manyFinally'"
      },
      "index": {
        "description": "manyFinally is like manyFinally except when the terminator parser overlaps with the element parser In manyFinally the parser is tried only when parser fails whereas in manyFinally the parser is always tried first then parser only if the terminator is not found For instance manyFinally accept accept on input returns whereas manyFinally with the same arguments and input returns",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "manyFinally'",
        "normalized": "a b-\u003ea c-\u003ea[b]",
        "package": "polyparse",
        "partial": "Finally'",
        "signature": "p a-\u003ep z-\u003ep[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:oneOf",
      "description": {
        "fct-descr": "\u003cp\u003eParse the first alternative in the list that succeeds.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "[p a] -\u003e p a",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#oneOf",
        "fct-type": "function",
        "title": "oneOf"
      },
      "index": {
        "description": "Parse the first alternative in the list that succeeds",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "oneOf",
        "normalized": "[a b]-\u003ea b",
        "package": "polyparse",
        "partial": "Of",
        "signature": "[p a]-\u003ep a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:oneOf-39-",
      "description": {
        "fct-descr": "\u003cp\u003eParse the first alternative that succeeds, but if none succeed,\n   report only the severe errors, and if none of those, then report\n   all the soft errors.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "[(String, p a)] -\u003e p a",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#oneOf%27",
        "fct-type": "method",
        "title": "oneOf'"
      },
      "index": {
        "description": "Parse the first alternative that succeeds but if none succeed report only the severe errors and if none of those then report all the soft errors",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "oneOf'",
        "normalized": "[(String,a b)]-\u003ea b",
        "package": "polyparse",
        "partial": "Of'",
        "signature": "[(String,p a)]-\u003ep a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:sepBy",
      "description": {
        "fct-descr": "\u003cp\u003eParse a list of items separated by discarded junk.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e p sep -\u003e p [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#sepBy",
        "fct-type": "function",
        "title": "sepBy"
      },
      "index": {
        "description": "Parse list of items separated by discarded junk",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "sepBy",
        "normalized": "a b-\u003ea c-\u003ea[b]",
        "package": "polyparse",
        "partial": "By",
        "signature": "p a-\u003ep sep-\u003ep[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:sepBy1",
      "description": {
        "fct-descr": "\u003cp\u003eParse a non-empty list of items separated by discarded junk.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "p a -\u003e p sep -\u003e p [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#sepBy1",
        "fct-type": "function",
        "title": "sepBy1"
      },
      "index": {
        "description": "Parse non-empty list of items separated by discarded junk",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "sepBy1",
        "normalized": "a b-\u003ea c-\u003ea[b]",
        "package": "polyparse",
        "partial": "By",
        "signature": "p a-\u003ep sep-\u003ep[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Base.html#v:upto",
      "description": {
        "fct-descr": "\u003cp\u003e'upto n p' parses n or fewer items, using the parser p, in sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Base",
        "fct-package": "polyparse",
        "fct-signature": "Int -\u003e p a -\u003e p [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-Base.html#upto",
        "fct-type": "function",
        "title": "upto"
      },
      "index": {
        "description": "upto parses or fewer items using the parser in sequence",
        "hierarchy": "Text ParserCombinators Poly Base",
        "module": "Text.ParserCombinators.Poly.Base",
        "name": "upto",
        "normalized": "Int-\u003ea b-\u003ea[b]",
        "package": "polyparse",
        "partial": "",
        "signature": "Int-\u003ep a-\u003ep[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html",
        "fct-type": "module",
        "title": "ByteString"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "ByteString",
        "normalized": "",
        "package": "polyparse",
        "partial": "Byte String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a specialised parsing monad with error\n   reporting.  Whereas the standard version can be used for arbitrary\n   token types, this version is specialised to ByteString input only.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is specialised parsing monad with error reporting Whereas the standard version can be used for arbitrary token types this version is specialised to ByteString input only",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "P (ByteString -\u003e Result ByteString a)",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "P",
        "normalized": "P(ByteString-\u003eResult ByteString a)",
        "package": "polyparse",
        "partial": "",
        "signature": "P(ByteString-\u003eResult ByteString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Parser ()",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "eof",
        "normalized": "Parser()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:many1Satisfy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emany1Satisfy p\u003c/code\u003e is a more efficient fused version of \u003ccode\u003emany1 (satisfy p)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "(Word8 -\u003e Bool) -\u003e Parser ByteString",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#many1Satisfy",
        "fct-type": "function",
        "title": "many1Satisfy"
      },
      "index": {
        "description": "many1Satisfy is more efficient fused version of many1 satisfy",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "many1Satisfy",
        "normalized": "(Word-\u003eBool)-\u003eParser ByteString",
        "package": "polyparse",
        "partial": "Satisfy",
        "signature": "(Word-\u003eBool)-\u003eParser ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:manySatisfy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emanySatisfy p\u003c/code\u003e is a more efficient fused version of \u003ccode\u003emany (satisfy p)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "(Word8 -\u003e Bool) -\u003e Parser ByteString",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#manySatisfy",
        "fct-type": "function",
        "title": "manySatisfy"
      },
      "index": {
        "description": "manySatisfy is more efficient fused version of many satisfy",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "manySatisfy",
        "normalized": "(Word-\u003eBool)-\u003eParser ByteString",
        "package": "polyparse",
        "partial": "Satisfy",
        "signature": "(Word-\u003eBool)-\u003eParser ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Parser Word8",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "onFail",
        "normalized": "Parser a-\u003eParser a-\u003eParser a",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser a-\u003eParser a-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "ByteString -\u003e Parser ()",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "reparse",
        "normalized": "ByteString-\u003eParser()",
        "package": "polyparse",
        "partial": "",
        "signature": "ByteString-\u003eParser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e ByteString -\u003e (Either String a, ByteString)",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "runParser",
        "normalized": "Parser a-\u003eByteString-\u003e(Either String a,ByteString)",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser a-\u003eByteString-\u003e(Either String a,ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteString.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteString",
        "fct-package": "polyparse",
        "fct-signature": "(Word8 -\u003e Bool) -\u003e Parser Word8",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteString.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly ByteString",
        "module": "Text.ParserCombinators.Poly.ByteString",
        "name": "satisfy",
        "normalized": "(Word-\u003eBool)-\u003eParser Word",
        "package": "polyparse",
        "partial": "",
        "signature": "(Word-\u003eBool)-\u003eParser Word"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html",
        "fct-type": "module",
        "title": "ByteStringChar"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "ByteStringChar",
        "normalized": "",
        "package": "polyparse",
        "partial": "Byte String Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a specialised parsing monad with error\n   reporting.  Whereas the standard version can be used for arbitrary\n   token types, this version is specialised to ByteString input only.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is specialised parsing monad with error reporting Whereas the standard version can be used for arbitrary token types this version is specialised to ByteString input only",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "P (ByteString -\u003e Result ByteString a)",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "P",
        "normalized": "P(ByteString-\u003eResult ByteString a)",
        "package": "polyparse",
        "partial": "",
        "signature": "P(ByteString-\u003eResult ByteString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "Parser ()",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "eof",
        "normalized": "Parser()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:many1Satisfy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emany1Satisfy p\u003c/code\u003e is a more efficient fused version of \u003ccode\u003emany1 (satisfy p)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser ByteString",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#many1Satisfy",
        "fct-type": "function",
        "title": "many1Satisfy"
      },
      "index": {
        "description": "many1Satisfy is more efficient fused version of many1 satisfy",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "many1Satisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser ByteString",
        "package": "polyparse",
        "partial": "Satisfy",
        "signature": "(Char-\u003eBool)-\u003eParser ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:manySatisfy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emanySatisfy p\u003c/code\u003e is a more efficient fused version of \u003ccode\u003emany (satisfy p)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser ByteString",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#manySatisfy",
        "fct-type": "function",
        "title": "manySatisfy"
      },
      "index": {
        "description": "manySatisfy is more efficient fused version of many satisfy",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "manySatisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser ByteString",
        "package": "polyparse",
        "partial": "Satisfy",
        "signature": "(Char-\u003eBool)-\u003eParser ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "Parser Char",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "onFail",
        "normalized": "Parser a-\u003eParser a-\u003eParser a",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser a-\u003eParser a-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "ByteString -\u003e Parser ()",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "reparse",
        "normalized": "ByteString-\u003eParser()",
        "package": "polyparse",
        "partial": "",
        "signature": "ByteString-\u003eParser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e ByteString -\u003e (Either String a, ByteString)",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "runParser",
        "normalized": "Parser a-\u003eByteString-\u003e(Either String a,ByteString)",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser a-\u003eByteString-\u003e(Either String a,ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-ByteStringChar.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.ByteStringChar",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser Char",
        "fct-source": "src/Text-ParserCombinators-Poly-ByteStringChar.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly ByteStringChar",
        "module": "Text.ParserCombinators.Poly.ByteStringChar",
        "name": "satisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser Char",
        "package": "polyparse",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eParser Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html",
        "fct-type": "module",
        "title": "Lazy"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "Lazy",
        "normalized": "",
        "package": "polyparse",
        "partial": "Lazy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThe only differences between a Plain and a Lazy parser are the instance\n   of Applicative, and the type (and implementation) of runParser.\n   We therefore need to \u003cem\u003enewtype\u003c/em\u003e the original Parser type, to allow it\n   to have a different instance.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "The only differences between Plain and Lazy parser are the instance of Applicative and the type and implementation of runParser We therefore need to newtype the original Parser type to allow it to have different instance",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "P (Parser t a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "P",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "eof",
        "normalized": "Parser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser t t",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser t a -\u003e Parser t a -\u003e Parser t a",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "onFail",
        "normalized": "Parser a b-\u003eParser a b-\u003eParser a b",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser t a-\u003eParser t a-\u003eParser t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "[t] -\u003e Parser t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "reparse",
        "normalized": "[a]-\u003eParser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "[t]-\u003eParser t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser t a -\u003e [t] -\u003e (a, [t])",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "runParser",
        "normalized": "Parser a b-\u003e[a]-\u003e(b,[a])",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser t a-\u003e[t]-\u003e(a,[t])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lazy.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lazy",
        "fct-package": "polyparse",
        "fct-signature": "(t -\u003e Bool) -\u003e Parser t t",
        "fct-source": "src/Text-ParserCombinators-Poly-Lazy.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly Lazy",
        "module": "Text.ParserCombinators.Poly.Lazy",
        "name": "satisfy",
        "normalized": "(a-\u003eBool)-\u003eParser a a",
        "package": "polyparse",
        "partial": "",
        "signature": "(t-\u003eBool)-\u003eParser t t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIn a strict language, where creating the entire input list of tokens\n   in one shot may be infeasible, we can use a lazy \u003ca\u003ecallback\u003c/a\u003e kind of\n   architecture instead.  The lexer returns a single token at a time,\n   together with a continuation.\n\u003c/p\u003e\u003cp\u003eThis module defines a Parser type (capable of use with the Poly\n   combinators), specialised to the callback-lexer style of input stream.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html",
        "fct-type": "module",
        "title": "Lex"
      },
      "index": {
        "description": "In strict language where creating the entire input list of tokens in one shot may be infeasible we can use lazy callback kind of architecture instead The lexer returns single token at time together with continuation This module defines Parser type capable of use with the Poly combinators specialised to the callback-lexer style of input stream",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "Lex",
        "normalized": "",
        "package": "polyparse",
        "partial": "Lex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#t:LexReturn",
      "description": {
        "fct-descr": "\u003cp\u003eIn a strict language, where creating the entire input list of tokens\n   in one shot may be infeasible, we can use a lazy \u003ca\u003ecallback\u003c/a\u003e kind of\n   architecture instead.  The lexer returns a single token at a time,\n   together with a continuation.  The \u003ccode\u003enext\u003c/code\u003e parser is responsible for \n   pulling on the token stream, applying the continuation where necessary.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#LexReturn",
        "fct-type": "data",
        "title": "LexReturn"
      },
      "index": {
        "description": "In strict language where creating the entire input list of tokens in one shot may be infeasible we can use lazy callback kind of architecture instead The lexer returns single token at time together with continuation The next parser is responsible for pulling on the token stream applying the continuation where necessary",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "LexReturn",
        "normalized": "",
        "package": "polyparse",
        "partial": "Lex Return",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a specialised parsing monad with error\n   reporting.  This version is specialised to pre-lexed String input,\n   where the lexer has been written to yield a \u003ccode\u003eLexReturn\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is specialised parsing monad with error reporting This version is specialised to pre-lexed String input where the lexer has been written to yield LexReturn",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:LexFinish",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "LexFinish",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#LexReturn",
        "fct-type": "function",
        "title": "LexFinish"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "LexFinish",
        "normalized": "",
        "package": "polyparse",
        "partial": "Lex Finish",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:LexReturn",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "LexReturn t String (String -\u003e LexReturn t)",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#LexReturn",
        "fct-type": "function",
        "title": "LexReturn"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "LexReturn",
        "normalized": "LexReturn a String(String-\u003eLexReturn a)",
        "package": "polyparse",
        "partial": "Lex Return",
        "signature": "LexReturn t String(String-\u003eLexReturn t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "P (LexReturn t -\u003e Result (LexReturn t) a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "P",
        "normalized": "P(LexReturn a-\u003eResult(LexReturn a)b)",
        "package": "polyparse",
        "partial": "",
        "signature": "P(LexReturn t-\u003eResult(LexReturn t)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "Parser t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "eof",
        "normalized": "Parser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "Parser t t",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "Parser t a -\u003e Parser t a -\u003e Parser t a",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "onFail",
        "normalized": "Parser a b-\u003eParser a b-\u003eParser a b",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser t a-\u003eParser t a-\u003eParser t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "[t] -\u003e Parser t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "reparse",
        "normalized": "[a]-\u003eParser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "[t]-\u003eParser t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "Parser t a -\u003e LexReturn t -\u003e (Either String a, String)",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "runParser",
        "normalized": "Parser a b-\u003eLexReturn a-\u003e(Either String b,String)",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser t a-\u003eLexReturn t-\u003e(Either String a,String)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Lex.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Lex",
        "fct-package": "polyparse",
        "fct-signature": "(t -\u003e Bool) -\u003e Parser t t",
        "fct-source": "src/Text-ParserCombinators-Poly-Lex.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly Lex",
        "module": "Text.ParserCombinators.Poly.Lex",
        "name": "satisfy",
        "normalized": "(a-\u003eBool)-\u003eParser a a",
        "package": "polyparse",
        "partial": "",
        "signature": "(t-\u003eBool)-\u003eParser t t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains the definitions for a generic parser, without\n   running state.  These are the parts that are shared between the Plain\n   and Lazy variations.  Do not import this module directly, but only\n   via T.P.Poly.Plain or T.P.Poly.Lazy.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html",
        "fct-type": "module",
        "title": "Parser"
      },
      "index": {
        "description": "This module contains the definitions for generic parser without running state These are the parts that are shared between the Plain and Lazy variations Do not import this module directly but only via T.P.Poly.Plain or T.P.Poly.Lazy",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a fairly generic parsing monad with error\n   reporting.  It can be used for arbitrary token types, not just\n   String input.  (If you require a running state, use module Poly.State\n   instead)\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is fairly generic parsing monad with error reporting It can be used for arbitrary token types not just String input If you require running state use module Poly.State instead",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "P ([t] -\u003e Result [t] a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "P",
        "normalized": "P([a]-\u003eResult[a]b)",
        "package": "polyparse",
        "partial": "",
        "signature": "P([t]-\u003eResult[t]a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "Parser t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "eof",
        "normalized": "Parser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "Parser t t",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "Parser t a -\u003e Parser t a -\u003e Parser t a",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "onFail",
        "normalized": "Parser a b-\u003eParser a b-\u003eParser a b",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser t a-\u003eParser t a-\u003eParser t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "[t] -\u003e Parser t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "reparse",
        "normalized": "[a]-\u003eParser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "[t]-\u003eParser t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Parser.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Parser",
        "fct-package": "polyparse",
        "fct-signature": "(t -\u003e Bool) -\u003e Parser t t",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly Parser",
        "module": "Text.ParserCombinators.Poly.Parser",
        "name": "satisfy",
        "normalized": "(a-\u003eBool)-\u003eParser a a",
        "package": "polyparse",
        "partial": "",
        "signature": "(t-\u003eBool)-\u003eParser t t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-Plain.html",
        "fct-type": "module",
        "title": "Plain"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "Plain",
        "normalized": "",
        "package": "polyparse",
        "partial": "Plain",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a fairly generic parsing monad with error\n   reporting.  It can be used for arbitrary token types, not just\n   String input.  (If you require a running state, use module Poly.State\n   instead)\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is fairly generic parsing monad with error reporting It can be used for arbitrary token types not just String input If you require running state use module Poly.State instead",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "P ([t] -\u003e Result [t] a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "P",
        "normalized": "P([a]-\u003eResult[a]b)",
        "package": "polyparse",
        "partial": "",
        "signature": "P([t]-\u003eResult[t]a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "Parser t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "eof",
        "normalized": "Parser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "Parser t t",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "Parser t a -\u003e Parser t a -\u003e Parser t a",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "onFail",
        "normalized": "Parser a b-\u003eParser a b-\u003eParser a b",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser t a-\u003eParser t a-\u003eParser t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "[t] -\u003e Parser t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "reparse",
        "normalized": "[a]-\u003eParser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "[t]-\u003eParser t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "Parser t a -\u003e [t] -\u003e (Either String a, [t])",
        "fct-source": "src/Text-ParserCombinators-Poly-Plain.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "runParser",
        "normalized": "Parser a b-\u003e[a]-\u003e(Either String b,[a])",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser t a-\u003e[t]-\u003e(Either String a,[t])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Plain.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Plain",
        "fct-package": "polyparse",
        "fct-signature": "(t -\u003e Bool) -\u003e Parser t t",
        "fct-source": "src/Text-ParserCombinators-Poly-Parser.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly Plain",
        "module": "Text.ParserCombinators.Poly.Plain",
        "name": "satisfy",
        "normalized": "(a-\u003eBool)-\u003eParser a a",
        "package": "polyparse",
        "partial": "",
        "signature": "(t-\u003eBool)-\u003eParser t t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Result.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Result",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html",
        "fct-type": "module",
        "title": "Result"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Result",
        "module": "Text.ParserCombinators.Poly.Result",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Result.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Result",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly Result",
        "module": "Text.ParserCombinators.Poly.Result",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Result.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Result",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Result",
        "module": "Text.ParserCombinators.Poly.Result",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Result.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Result",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Result",
        "module": "Text.ParserCombinators.Poly.Result",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Result.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Result",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Result",
        "module": "Text.ParserCombinators.Poly.Result",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Result.html#v:resultToEither",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a Result to an Either, paired with the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Result",
        "fct-package": "polyparse",
        "fct-signature": "Result z a -\u003e (Either String a, z)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#resultToEither",
        "fct-type": "function",
        "title": "resultToEither"
      },
      "index": {
        "description": "Convert Result to an Either paired with the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly Result",
        "module": "Text.ParserCombinators.Poly.Result",
        "name": "resultToEither",
        "normalized": "Result a b-\u003e(Either String b,a)",
        "package": "polyparse",
        "partial": "To Either",
        "signature": "Result z a-\u003e(Either String a,z)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-State.html",
        "fct-type": "module",
        "title": "State"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "State",
        "normalized": "",
        "package": "polyparse",
        "partial": "State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a fairly generic parsing monad with error\n   reporting, and running state.\n   It can be used for arbitrary token types, not just String input.\n   (If you do not require a running state, use module Poly.Plain instead)\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is fairly generic parsing monad with error reporting and running state It can be used for arbitrary token types not just String input If you do not require running state use module Poly.Plain instead",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "P (s -\u003e [t] -\u003e Result ([t], s) a)",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "P",
        "normalized": "P(a-\u003e[b]-\u003eResult([b],a)c)",
        "package": "polyparse",
        "partial": "",
        "signature": "P(s-\u003e[t]-\u003eResult([t],s)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "eof",
        "normalized": "Parser a b()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t t",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t a -\u003e Parser s t a -\u003e Parser s t a",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "onFail",
        "normalized": "Parser a b c-\u003eParser a b c-\u003eParser a b c",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser s t a-\u003eParser s t a-\u003eParser s t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "[t] -\u003e Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "reparse",
        "normalized": "[a]-\u003eParser b a()",
        "package": "polyparse",
        "partial": "",
        "signature": "[t]-\u003eParser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t a -\u003e s -\u003e [t] -\u003e (Either String a, s, [t])",
        "fct-source": "src/Text-ParserCombinators-Poly-State.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "runParser",
        "normalized": "Parser a b c-\u003ea-\u003e[b]-\u003e(Either String c,a,[b])",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser s t a-\u003es-\u003e[t]-\u003e(Either String a,s,[t])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "(t -\u003e Bool) -\u003e Parser s t t",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "satisfy",
        "normalized": "(a-\u003eBool)-\u003eParser b a a",
        "package": "polyparse",
        "partial": "",
        "signature": "(t-\u003eBool)-\u003eParser s t t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:stGet",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver the entire internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t s",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#stGet",
        "fct-type": "function",
        "title": "stGet"
      },
      "index": {
        "description": "Deliver the entire internal state",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "stGet",
        "normalized": "",
        "package": "polyparse",
        "partial": "Get",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:stQuery",
      "description": {
        "fct-descr": "\u003cp\u003eQuery the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e a) -\u003e Parser s t a",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#stQuery",
        "fct-type": "function",
        "title": "stQuery"
      },
      "index": {
        "description": "Query the internal state",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "stQuery",
        "normalized": "(a-\u003eb)-\u003eParser a c b",
        "package": "polyparse",
        "partial": "Query",
        "signature": "(s-\u003ea)-\u003eParser s t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-State.html#v:stUpdate",
      "description": {
        "fct-descr": "\u003cp\u003eUpdate the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.State",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e s) -\u003e Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#stUpdate",
        "fct-type": "function",
        "title": "stUpdate"
      },
      "index": {
        "description": "Update the internal state",
        "hierarchy": "Text ParserCombinators Poly State",
        "module": "Text.ParserCombinators.Poly.State",
        "name": "stUpdate",
        "normalized": "(a-\u003ea)-\u003eParser a b()",
        "package": "polyparse",
        "partial": "Update",
        "signature": "(s-\u003es)-\u003eParser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html",
        "fct-type": "module",
        "title": "StateLazy"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "StateLazy",
        "normalized": "",
        "package": "polyparse",
        "partial": "State Lazy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThe only differences between a State and a StateLazy parser are the\n   instance of Applicative, and the type (and implementation) of runParser.\n   We therefore need to \u003cem\u003enewtype\u003c/em\u003e the original Parser type, to allow it\n   to have a different instance.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "The only differences between State and StateLazy parser are the instance of Applicative and the type and implementation of runParser We therefore need to newtype the original Parser type to allow it to have different instance",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "P (Parser s t a)",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "P",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "eof",
        "normalized": "Parser a b()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:manyFinally",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t a -\u003e Parser s t z -\u003e Parser s t [a]",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#manyFinally",
        "fct-type": "function",
        "title": "manyFinally"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "manyFinally",
        "normalized": "Parser a b c-\u003eParser a b d-\u003eParser a b[c]",
        "package": "polyparse",
        "partial": "Finally",
        "signature": "Parser s t a-\u003eParser s t z-\u003eParser s t[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t t",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t a -\u003e Parser s t a -\u003e Parser s t a",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "onFail",
        "normalized": "Parser a b c-\u003eParser a b c-\u003eParser a b c",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser s t a-\u003eParser s t a-\u003eParser s t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "[t] -\u003e Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "reparse",
        "normalized": "[a]-\u003eParser b a()",
        "package": "polyparse",
        "partial": "",
        "signature": "[t]-\u003eParser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t a -\u003e s -\u003e [t] -\u003e (a, s, [t])",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "runParser",
        "normalized": "Parser a b c-\u003ea-\u003e[b]-\u003e(c,a,[b])",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser s t a-\u003es-\u003e[t]-\u003e(a,s,[t])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "(t -\u003e Bool) -\u003e Parser s t t",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "satisfy",
        "normalized": "(a-\u003eBool)-\u003eParser b a a",
        "package": "polyparse",
        "partial": "",
        "signature": "(t-\u003eBool)-\u003eParser s t t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:stGet",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver the entire internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t s",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#stGet",
        "fct-type": "function",
        "title": "stGet"
      },
      "index": {
        "description": "Deliver the entire internal state",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "stGet",
        "normalized": "",
        "package": "polyparse",
        "partial": "Get",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:stQuery",
      "description": {
        "fct-descr": "\u003cp\u003eQuery the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e a) -\u003e Parser s t a",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#stQuery",
        "fct-type": "function",
        "title": "stQuery"
      },
      "index": {
        "description": "Query the internal state",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "stQuery",
        "normalized": "(a-\u003eb)-\u003eParser a c b",
        "package": "polyparse",
        "partial": "Query",
        "signature": "(s-\u003ea)-\u003eParser s t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateLazy.html#v:stUpdate",
      "description": {
        "fct-descr": "\u003cp\u003eUpdate the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateLazy",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e s) -\u003e Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateLazy.html#stUpdate",
        "fct-type": "function",
        "title": "stUpdate"
      },
      "index": {
        "description": "Update the internal state",
        "hierarchy": "Text ParserCombinators Poly StateLazy",
        "module": "Text.ParserCombinators.Poly.StateLazy",
        "name": "stUpdate",
        "normalized": "(a-\u003ea)-\u003eParser a b()",
        "package": "polyparse",
        "partial": "Update",
        "signature": "(s-\u003es)-\u003eParser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains the definitions for a generic parser, with\n   running state.  These are the parts that are shared between the State\n   and StateLazy variations.  Do not import this module directly, but only\n   via T.P.Poly.State or T.P.Poly.StateLazy.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html",
        "fct-type": "module",
        "title": "StateParser"
      },
      "index": {
        "description": "This module contains the definitions for generic parser with running state These are the parts that are shared between the State and StateLazy variations Do not import this module directly but only via T.P.Poly.State or T.P.Poly.StateLazy",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "StateParser",
        "normalized": "",
        "package": "polyparse",
        "partial": "State Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a fairly generic parsing monad with error\n   reporting, and running state.\n   It can be used for arbitrary token types, not just String input.\n   (If you do not require a running state, use module Poly.Plain instead)\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is fairly generic parsing monad with error reporting and running state It can be used for arbitrary token types not just String input If you do not require running state use module Poly.Plain instead",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "P (s -\u003e [t] -\u003e Result ([t], s) a)",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "P",
        "normalized": "P(a-\u003e[b]-\u003eResult([b],a)c)",
        "package": "polyparse",
        "partial": "",
        "signature": "P(s-\u003e[t]-\u003eResult([t],s)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "eof",
        "normalized": "Parser a b()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t t",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t a -\u003e Parser s t a -\u003e Parser s t a",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "onFail",
        "normalized": "Parser a b c-\u003eParser a b c-\u003eParser a b c",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser s t a-\u003eParser s t a-\u003eParser s t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "[t] -\u003e Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "reparse",
        "normalized": "[a]-\u003eParser b a()",
        "package": "polyparse",
        "partial": "",
        "signature": "[t]-\u003eParser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "(t -\u003e Bool) -\u003e Parser s t t",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "satisfy",
        "normalized": "(a-\u003eBool)-\u003eParser b a a",
        "package": "polyparse",
        "partial": "",
        "signature": "(t-\u003eBool)-\u003eParser s t t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:stGet",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver the entire internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "Parser s t s",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#stGet",
        "fct-type": "function",
        "title": "stGet"
      },
      "index": {
        "description": "Deliver the entire internal state",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "stGet",
        "normalized": "",
        "package": "polyparse",
        "partial": "Get",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:stQuery",
      "description": {
        "fct-descr": "\u003cp\u003eQuery the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e a) -\u003e Parser s t a",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#stQuery",
        "fct-type": "function",
        "title": "stQuery"
      },
      "index": {
        "description": "Query the internal state",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "stQuery",
        "normalized": "(a-\u003eb)-\u003eParser a c b",
        "package": "polyparse",
        "partial": "Query",
        "signature": "(s-\u003ea)-\u003eParser s t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateParser.html#v:stUpdate",
      "description": {
        "fct-descr": "\u003cp\u003eUpdate the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateParser",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e s) -\u003e Parser s t ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateParser.html#stUpdate",
        "fct-type": "function",
        "title": "stUpdate"
      },
      "index": {
        "description": "Update the internal state",
        "hierarchy": "Text ParserCombinators Poly StateParser",
        "module": "Text.ParserCombinators.Poly.StateParser",
        "name": "stUpdate",
        "normalized": "(a-\u003ea)-\u003eParser a b()",
        "package": "polyparse",
        "partial": "Update",
        "signature": "(s-\u003es)-\u003eParser s t()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html",
        "fct-type": "module",
        "title": "StateText"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "StateText",
        "normalized": "",
        "package": "polyparse",
        "partial": "State Text",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a specialised parsing monad with error\n   reporting.  Whereas the standard version can be used for arbitrary\n   token types, this version is specialised to Text input only.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is specialised parsing monad with error reporting Whereas the standard version can be used for arbitrary token types this version is specialised to Text input only",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "P (s -\u003e Text -\u003e Result (Text, s) a)",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "P",
        "normalized": "P(a-\u003eText-\u003eResult(Text,a)b)",
        "package": "polyparse",
        "partial": "",
        "signature": "P(s-\u003eText-\u003eResult(Text,s)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Parser s ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "eof",
        "normalized": "Parser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser s()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:many1Satisfy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emany1Satisfy p\u003c/code\u003e is a more efficient fused version of \u003ccode\u003emany1 (satisfy p)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser s Text",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#many1Satisfy",
        "fct-type": "function",
        "title": "many1Satisfy"
      },
      "index": {
        "description": "many1Satisfy is more efficient fused version of many1 satisfy",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "many1Satisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser a Text",
        "package": "polyparse",
        "partial": "Satisfy",
        "signature": "(Char-\u003eBool)-\u003eParser s Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:manySatisfy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emanySatisfy p\u003c/code\u003e is a more efficient fused version of \u003ccode\u003emany (satisfy p)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser s Text",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#manySatisfy",
        "fct-type": "function",
        "title": "manySatisfy"
      },
      "index": {
        "description": "manySatisfy is more efficient fused version of many satisfy",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "manySatisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser a Text",
        "package": "polyparse",
        "partial": "Satisfy",
        "signature": "(Char-\u003eBool)-\u003eParser s Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Parser s Char",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Parser s a -\u003e Parser s a -\u003e Parser s a",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "onFail",
        "normalized": "Parser a b-\u003eParser a b-\u003eParser a b",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser s a-\u003eParser s a-\u003eParser s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Text -\u003e Parser s ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "reparse",
        "normalized": "Text-\u003eParser a()",
        "package": "polyparse",
        "partial": "",
        "signature": "Text-\u003eParser s()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Parser s a -\u003e s -\u003e Text -\u003e (Either String a, s, Text)",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "runParser",
        "normalized": "Parser a b-\u003ea-\u003eText-\u003e(Either String b,a,Text)",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser s a-\u003es-\u003eText-\u003e(Either String a,s,Text)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser s Char",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "satisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser a Char",
        "package": "polyparse",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eParser s Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:stGet",
      "description": {
        "fct-descr": "\u003cp\u003eDeliver the entire internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "Parser s s",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#stGet",
        "fct-type": "function",
        "title": "stGet"
      },
      "index": {
        "description": "Deliver the entire internal state",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "stGet",
        "normalized": "",
        "package": "polyparse",
        "partial": "Get",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:stQuery",
      "description": {
        "fct-descr": "\u003cp\u003eQuery the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e a) -\u003e Parser s a",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#stQuery",
        "fct-type": "function",
        "title": "stQuery"
      },
      "index": {
        "description": "Query the internal state",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "stQuery",
        "normalized": "(a-\u003eb)-\u003eParser a b",
        "package": "polyparse",
        "partial": "Query",
        "signature": "(s-\u003ea)-\u003eParser s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-StateText.html#v:stUpdate",
      "description": {
        "fct-descr": "\u003cp\u003eUpdate the internal state.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.StateText",
        "fct-package": "polyparse",
        "fct-signature": "(s -\u003e s) -\u003e Parser s ()",
        "fct-source": "src/Text-ParserCombinators-Poly-StateText.html#stUpdate",
        "fct-type": "function",
        "title": "stUpdate"
      },
      "index": {
        "description": "Update the internal state",
        "hierarchy": "Text ParserCombinators Poly StateText",
        "module": "Text.ParserCombinators.Poly.StateText",
        "name": "stUpdate",
        "normalized": "(a-\u003ea)-\u003eParser a()",
        "package": "polyparse",
        "partial": "Update",
        "signature": "(s-\u003es)-\u003eParser s()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html",
        "fct-type": "module",
        "title": "Text"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "Text",
        "normalized": "",
        "package": "polyparse",
        "partial": "Text",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003eParser\u003c/code\u003e datatype is a specialised parsing monad with error\n   reporting.  Whereas the standard version can be used for arbitrary\n   token types, this version is specialised to Text input only.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "newtype",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#Parser",
        "fct-type": "newtype",
        "title": "Parser"
      },
      "index": {
        "description": "This Parser datatype is specialised parsing monad with error reporting Whereas the standard version can be used for arbitrary token types this version is specialised to Text input only",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "Parser",
        "normalized": "",
        "package": "polyparse",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eA return type like Either, that distinguishes not only between\n   right and wrong answers, but also has commitment, so that a failure\n   cannot be undone.  This should only be used for writing very primitive\n   parsers - really it is an internal detail of the library.\n   The z type is the remaining unconsumed input.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "data",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "return type like Either that distinguishes not only between right and wrong answers but also has commitment so that failure cannot be undone This should only be used for writing very primitive parsers really it is an internal detail of the library The type is the remaining unconsumed input",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "Result",
        "normalized": "",
        "package": "polyparse",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:Committed",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "Committed (Result z a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Committed"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "Committed",
        "normalized": "",
        "package": "polyparse",
        "partial": "Committed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:Failure",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "Failure z String",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Failure"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "Failure",
        "normalized": "",
        "package": "polyparse",
        "partial": "Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:P",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "P (Text -\u003e Result Text a)",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#Parser",
        "fct-type": "function",
        "title": "P"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "P",
        "normalized": "P(Text-\u003eResult Text a)",
        "package": "polyparse",
        "partial": "",
        "signature": "P(Text-\u003eResult Text a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:Success",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "Success z a",
        "fct-source": "src/Text-ParserCombinators-Poly-Result.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "Success",
        "normalized": "",
        "package": "polyparse",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:eof",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed if the end of file/input has been reached, fail otherwise.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "Parser ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#eof",
        "fct-type": "function",
        "title": "eof"
      },
      "index": {
        "description": "Succeed if the end of file input has been reached fail otherwise",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "eof",
        "normalized": "Parser()",
        "package": "polyparse",
        "partial": "",
        "signature": "Parser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:many1Satisfy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emany1Satisfy p\u003c/code\u003e is a more efficient fused version of \u003ccode\u003emany1 (satisfy p)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser Text",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#many1Satisfy",
        "fct-type": "function",
        "title": "many1Satisfy"
      },
      "index": {
        "description": "many1Satisfy is more efficient fused version of many1 satisfy",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "many1Satisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser Text",
        "package": "polyparse",
        "partial": "Satisfy",
        "signature": "(Char-\u003eBool)-\u003eParser Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:manySatisfy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003emanySatisfy p\u003c/code\u003e is a more efficient fused version of \u003ccode\u003emany (satisfy p)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser Text",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#manySatisfy",
        "fct-type": "function",
        "title": "manySatisfy"
      },
      "index": {
        "description": "manySatisfy is more efficient fused version of many satisfy",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "manySatisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser Text",
        "package": "polyparse",
        "partial": "Satisfy",
        "signature": "(Char-\u003eBool)-\u003eParser Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:next",
      "description": {
        "fct-descr": "\u003cp\u003eSimply return the next token in the input tokenstream.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "Parser Char",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#next",
        "fct-type": "function",
        "title": "next"
      },
      "index": {
        "description": "Simply return the next token in the input tokenstream",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "next",
        "normalized": "",
        "package": "polyparse",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:onFail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ep \u003ccode\u003e\u003ca\u003eonFail\u003c/a\u003e\u003c/code\u003e q\u003c/code\u003e means parse p, unless p fails, in which case\n   parse q instead.\n   Can be chained together to give multiple attempts to parse something.\n   (Note that q could itself be a failing parser, e.g. to change the error\n   message from that defined in p to something different.)\n   However, a severe failure in p cannot be ignored.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Parser a -\u003e Parser a",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#onFail",
        "fct-type": "function",
        "title": "onFail"
      },
      "index": {
        "description": "onFail means parse unless fails in which case parse instead Can be chained together to give multiple attempts to parse something Note that could itself be failing parser e.g to change the error message from that defined in to something different However severe failure in cannot be ignored",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "onFail",
        "normalized": "Parser a-\u003eParser a-\u003eParser a",
        "package": "polyparse",
        "partial": "Fail",
        "signature": "Parser a-\u003eParser a-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:reparse",
      "description": {
        "fct-descr": "\u003cp\u003ePush some tokens back onto the front of the input stream and reparse.\n   This is useful e.g. for recursively expanding macros.  When the\n   user-parser recognises a macro use, it can lookup the macro\n   expansion from the parse state, lex it, and then stuff the\n   lexed expansion back down into the parser.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "Text -\u003e Parser ()",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#reparse",
        "fct-type": "function",
        "title": "reparse"
      },
      "index": {
        "description": "Push some tokens back onto the front of the input stream and reparse This is useful e.g for recursively expanding macros When the user-parser recognises macro use it can lookup the macro expansion from the parse state lex it and then stuff the lexed expansion back down into the parser",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "reparse",
        "normalized": "Text-\u003eParser()",
        "package": "polyparse",
        "partial": "",
        "signature": "Text-\u003eParser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:runParser",
      "description": {
        "fct-descr": "\u003cp\u003eApply a parser to an input token sequence.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "Parser a -\u003e Text -\u003e (Either String a, Text)",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#runParser",
        "fct-type": "function",
        "title": "runParser"
      },
      "index": {
        "description": "Apply parser to an input token sequence",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "runParser",
        "normalized": "Parser a-\u003eText-\u003e(Either String a,Text)",
        "package": "polyparse",
        "partial": "Parser",
        "signature": "Parser a-\u003eText-\u003e(Either String a,Text)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly-Text.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the next token if it satisfies the given predicate.\n\u003c/p\u003e",
        "fct-module": "Text.ParserCombinators.Poly.Text",
        "fct-package": "polyparse",
        "fct-signature": "(Char -\u003e Bool) -\u003e Parser Char",
        "fct-source": "src/Text-ParserCombinators-Poly-Text.html#satisfy",
        "fct-type": "function",
        "title": "satisfy"
      },
      "index": {
        "description": "Return the next token if it satisfies the given predicate",
        "hierarchy": "Text ParserCombinators Poly Text",
        "module": "Text.ParserCombinators.Poly.Text",
        "name": "satisfy",
        "normalized": "(Char-\u003eBool)-\u003eParser Char",
        "package": "polyparse",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eParser Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/polyparse/docs/Text-ParserCombinators-Poly.html#",
      "description": {
        "fct-module": "Text.ParserCombinators.Poly",
        "fct-package": "polyparse",
        "fct-signature": "module",
        "fct-source": "src/Text-ParserCombinators-Poly.html",
        "fct-type": "module",
        "title": "Poly"
      },
      "index": {
        "description": "",
        "hierarchy": "Text ParserCombinators Poly",
        "module": "Text.ParserCombinators.Poly",
        "name": "Poly",
        "normalized": "",
        "package": "polyparse",
        "partial": "Poly",
        "signature": ""
      }
    }
  }
]
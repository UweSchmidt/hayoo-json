[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGroups: zero, addition, and negation (additive inverse)\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "module",
        "fct-source": "src/Data-AdditiveGroup.html",
        "fct-type": "module",
        "title": "AdditiveGroup"
      },
      "index": {
        "description": "Groups zero addition and negation additive inverse",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "AdditiveGroup",
        "normalized": "",
        "package": "vector-space",
        "partial": "Additive Group",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#t:AdditiveGroup",
      "description": {
        "fct-descr": "\u003cp\u003eAdditive group \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "class",
        "fct-source": "src/Data-AdditiveGroup.html#AdditiveGroup",
        "fct-type": "class",
        "title": "AdditiveGroup"
      },
      "index": {
        "description": "Additive group",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "AdditiveGroup",
        "normalized": "",
        "package": "vector-space",
        "partial": "Additive Group",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#t:Sum",
      "description": {
        "fct-descr": "\u003cp\u003eMonoid under group addition.  Alternative to the \u003ccode\u003eSum\u003c/code\u003e in\n \u003ca\u003eData.Monoid\u003c/a\u003e, which uses \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003eAdditiveGroup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "newtype",
        "fct-source": "src/Data-AdditiveGroup.html#Sum",
        "fct-type": "newtype",
        "title": "Sum"
      },
      "index": {
        "description": "Monoid under group addition Alternative to the Sum in Data.Monoid which uses Num instead of AdditiveGroup",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "Sum",
        "normalized": "",
        "package": "vector-space",
        "partial": "Sum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:-94--43--94-",
      "description": {
        "fct-descr": "\u003cp\u003eAdd vectors\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v -\u003e v",
        "fct-source": "src/Data-AdditiveGroup.html#%5E%2B%5E",
        "fct-type": "method",
        "title": "(^+^)"
      },
      "index": {
        "description": "Add vectors",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "(^+^) ^+^",
        "normalized": "a-\u003ea-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:-94--45--94-",
      "description": {
        "fct-descr": "\u003cp\u003eGroup subtraction\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v -\u003e v",
        "fct-source": "src/Data-AdditiveGroup.html#%5E-%5E",
        "fct-type": "function",
        "title": "(^-^)"
      },
      "index": {
        "description": "Group subtraction",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "(^-^) ^-^",
        "normalized": "a-\u003ea-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:Sum",
      "description": {
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "Sum",
        "fct-source": "src/Data-AdditiveGroup.html#Sum",
        "fct-type": "function",
        "title": "Sum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "Sum",
        "normalized": "",
        "package": "vector-space",
        "partial": "Sum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:getSum",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "a",
        "fct-source": "src/Data-AdditiveGroup.html#Sum",
        "fct-type": "function",
        "title": "getSum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "getSum",
        "normalized": "",
        "package": "vector-space",
        "partial": "Sum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:inSum",
      "description": {
        "fct-descr": "\u003cp\u003eApplication a unary function inside a \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "(a -\u003e b) -\u003e Sum a -\u003e Sum b",
        "fct-source": "src/Data-AdditiveGroup.html#inSum",
        "fct-type": "function",
        "title": "inSum"
      },
      "index": {
        "description": "Application unary function inside Sum",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "inSum",
        "normalized": "(a-\u003eb)-\u003eSum a-\u003eSum b",
        "package": "vector-space",
        "partial": "Sum",
        "signature": "(a-\u003eb)-\u003eSum a-\u003eSum b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:inSum2",
      "description": {
        "fct-descr": "\u003cp\u003eApplication a binary function inside a \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e Sum a -\u003e Sum b -\u003e Sum c",
        "fct-source": "src/Data-AdditiveGroup.html#inSum2",
        "fct-type": "function",
        "title": "inSum2"
      },
      "index": {
        "description": "Application binary function inside Sum",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "inSum2",
        "normalized": "(a-\u003eb-\u003ec)-\u003eSum a-\u003eSum b-\u003eSum c",
        "package": "vector-space",
        "partial": "Sum",
        "signature": "(a-\u003eb-\u003ec)-\u003eSum a-\u003eSum b-\u003eSum c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:negateV",
      "description": {
        "fct-descr": "\u003cp\u003eAdditive inverse\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v",
        "fct-source": "src/Data-AdditiveGroup.html#negateV",
        "fct-type": "method",
        "title": "negateV"
      },
      "index": {
        "description": "Additive inverse",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "negateV",
        "normalized": "a-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:sumV",
      "description": {
        "fct-descr": "\u003cp\u003eSum over several vectors\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "f v -\u003e v",
        "fct-source": "src/Data-AdditiveGroup.html#sumV",
        "fct-type": "function",
        "title": "sumV"
      },
      "index": {
        "description": "Sum over several vectors",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "sumV",
        "normalized": "a b-\u003eb",
        "package": "vector-space",
        "partial": "",
        "signature": "f v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AdditiveGroup.html#v:zeroV",
      "description": {
        "fct-descr": "\u003cp\u003eThe zero element: identity for '(^+^)'\n\u003c/p\u003e",
        "fct-module": "Data.AdditiveGroup",
        "fct-package": "vector-space",
        "fct-signature": "v",
        "fct-source": "src/Data-AdditiveGroup.html#zeroV",
        "fct-type": "method",
        "title": "zeroV"
      },
      "index": {
        "description": "The zero element identity for",
        "hierarchy": "Data AdditiveGroup",
        "module": "Data.AdditiveGroup",
        "name": "zeroV",
        "normalized": "",
        "package": "vector-space",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAffine spaces.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.AffineSpace",
        "fct-package": "vector-space",
        "fct-signature": "module",
        "fct-source": "src/Data-AffineSpace.html",
        "fct-type": "module",
        "title": "AffineSpace"
      },
      "index": {
        "description": "Affine spaces",
        "hierarchy": "Data AffineSpace",
        "module": "Data.AffineSpace",
        "name": "AffineSpace",
        "normalized": "",
        "package": "vector-space",
        "partial": "Affine Space",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#t:AffineSpace",
      "description": {
        "fct-module": "Data.AffineSpace",
        "fct-package": "vector-space",
        "fct-signature": "class",
        "fct-source": "src/Data-AffineSpace.html#AffineSpace",
        "fct-type": "class",
        "title": "AffineSpace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AffineSpace",
        "module": "Data.AffineSpace",
        "name": "AffineSpace",
        "normalized": "",
        "package": "vector-space",
        "partial": "Affine Space",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:.-43--94-",
      "description": {
        "fct-descr": "\u003cp\u003ePoint plus vector\n\u003c/p\u003e",
        "fct-module": "Data.AffineSpace",
        "fct-package": "vector-space",
        "fct-signature": "p -\u003e Diff p -\u003e p",
        "fct-source": "src/Data-AffineSpace.html#.%2B%5E",
        "fct-type": "method",
        "title": "(.+^)"
      },
      "index": {
        "description": "Point plus vector",
        "hierarchy": "Data AffineSpace",
        "module": "Data.AffineSpace",
        "name": "(.+^) .+^",
        "normalized": "a-\u003eDiff a-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "p-\u003eDiff p-\u003ep"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:.-45--94-",
      "description": {
        "fct-descr": "\u003cp\u003ePoint minus vector\n\u003c/p\u003e",
        "fct-module": "Data.AffineSpace",
        "fct-package": "vector-space",
        "fct-signature": "p -\u003e Diff p -\u003e p",
        "fct-source": "src/Data-AffineSpace.html#.-%5E",
        "fct-type": "function",
        "title": "(.-^)"
      },
      "index": {
        "description": "Point minus vector",
        "hierarchy": "Data AffineSpace",
        "module": "Data.AffineSpace",
        "name": "(.-^) .-^",
        "normalized": "a-\u003eDiff a-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "p-\u003eDiff p-\u003ep"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:.-45-.",
      "description": {
        "fct-descr": "\u003cp\u003eSubtract points\n\u003c/p\u003e",
        "fct-module": "Data.AffineSpace",
        "fct-package": "vector-space",
        "fct-signature": "p -\u003e p -\u003e Diff p",
        "fct-source": "src/Data-AffineSpace.html#.-.",
        "fct-type": "method",
        "title": "(.-.)"
      },
      "index": {
        "description": "Subtract points",
        "hierarchy": "Data AffineSpace",
        "module": "Data.AffineSpace",
        "name": "(.-.) .-.",
        "normalized": "a-\u003ea-\u003eDiff a",
        "package": "vector-space",
        "partial": "",
        "signature": "p-\u003ep-\u003eDiff p"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:alerp",
      "description": {
        "fct-descr": "\u003cp\u003eAffine linear interpolation.  Varies from \u003ccode\u003ep\u003c/code\u003e to \u003ccode\u003ep'\u003c/code\u003e as \u003ccode\u003es\u003c/code\u003e varies\n from 0 to 1.  See also \u003ccode\u003e\u003ca\u003elerp\u003c/a\u003e\u003c/code\u003e (on vector spaces).\n\u003c/p\u003e",
        "fct-module": "Data.AffineSpace",
        "fct-package": "vector-space",
        "fct-signature": "p -\u003e p -\u003e Scalar (Diff p) -\u003e p",
        "fct-source": "src/Data-AffineSpace.html#alerp",
        "fct-type": "function",
        "title": "alerp"
      },
      "index": {
        "description": "Affine linear interpolation Varies from to as varies from to See also lerp on vector spaces",
        "hierarchy": "Data AffineSpace",
        "module": "Data.AffineSpace",
        "name": "alerp",
        "normalized": "a-\u003ea-\u003eScalar(Diff a)-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "p-\u003ep-\u003eScalar(Diff p)-\u003ep"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:distance",
      "description": {
        "fct-descr": "\u003cp\u003eDistance between two points.  See also \u003ccode\u003e\u003ca\u003edistanceSq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.AffineSpace",
        "fct-package": "vector-space",
        "fct-signature": "p -\u003e p -\u003e s",
        "fct-source": "src/Data-AffineSpace.html#distance",
        "fct-type": "function",
        "title": "distance"
      },
      "index": {
        "description": "Distance between two points See also distanceSq",
        "hierarchy": "Data AffineSpace",
        "module": "Data.AffineSpace",
        "name": "distance",
        "normalized": "a-\u003ea-\u003eb",
        "package": "vector-space",
        "partial": "",
        "signature": "p-\u003ep-\u003es"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-AffineSpace.html#v:distanceSq",
      "description": {
        "fct-descr": "\u003cp\u003eSquare of the distance between two points.  Sometimes useful for\n efficiency.  See also \u003ccode\u003e\u003ca\u003edistance\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.AffineSpace",
        "fct-package": "vector-space",
        "fct-signature": "p -\u003e p -\u003e Scalar v",
        "fct-source": "src/Data-AffineSpace.html#distanceSq",
        "fct-type": "function",
        "title": "distanceSq"
      },
      "index": {
        "description": "Square of the distance between two points Sometimes useful for efficiency See also distance",
        "hierarchy": "Data AffineSpace",
        "module": "Data.AffineSpace",
        "name": "distanceSq",
        "normalized": "a-\u003ea-\u003eScalar b",
        "package": "vector-space",
        "partial": "Sq",
        "signature": "p-\u003ep-\u003eScalar v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasis of a vector space, as an associated type\n This module requires ghc-6.10 or later\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Basis",
        "fct-package": "vector-space",
        "fct-signature": "module",
        "fct-source": "src/Data-Basis.html",
        "fct-type": "module",
        "title": "Basis"
      },
      "index": {
        "description": "Basis of vector space as an associated type This module requires ghc-6.10 or later",
        "hierarchy": "Data Basis",
        "module": "Data.Basis",
        "name": "Basis",
        "normalized": "",
        "package": "vector-space",
        "partial": "Basis",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#t:HasBasis",
      "description": {
        "fct-module": "Data.Basis",
        "fct-package": "vector-space",
        "fct-signature": "class",
        "fct-source": "src/Data-Basis.html#HasBasis",
        "fct-type": "class",
        "title": "HasBasis"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Basis",
        "module": "Data.Basis",
        "name": "HasBasis",
        "normalized": "",
        "package": "vector-space",
        "partial": "Has Basis",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:basisValue",
      "description": {
        "fct-descr": "\u003cp\u003eInterpret basis rep as a vector\n\u003c/p\u003e",
        "fct-module": "Data.Basis",
        "fct-package": "vector-space",
        "fct-signature": "Basis v -\u003e v",
        "fct-source": "src/Data-Basis.html#basisValue",
        "fct-type": "method",
        "title": "basisValue"
      },
      "index": {
        "description": "Interpret basis rep as vector",
        "hierarchy": "Data Basis",
        "module": "Data.Basis",
        "name": "basisValue",
        "normalized": "Basis a-\u003ea",
        "package": "vector-space",
        "partial": "Value",
        "signature": "Basis v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:decompose",
      "description": {
        "fct-descr": "\u003cp\u003eExtract coordinates\n\u003c/p\u003e",
        "fct-module": "Data.Basis",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e [(Basis v, Scalar v)]",
        "fct-source": "src/Data-Basis.html#decompose",
        "fct-type": "method",
        "title": "decompose"
      },
      "index": {
        "description": "Extract coordinates",
        "hierarchy": "Data Basis",
        "module": "Data.Basis",
        "name": "decompose",
        "normalized": "a-\u003e[(Basis a,Scalar a)]",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003e[(Basis v,Scalar v)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:decompose-39-",
      "description": {
        "fct-descr": "\u003cp\u003eExperimental version.  More elegant definitions, and friendly to\n infinite-dimensional vector spaces.\n\u003c/p\u003e",
        "fct-module": "Data.Basis",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e Basis v -\u003e Scalar v",
        "fct-source": "src/Data-Basis.html#decompose%27",
        "fct-type": "method",
        "title": "decompose'"
      },
      "index": {
        "description": "Experimental version More elegant definitions and friendly to infinite-dimensional vector spaces",
        "hierarchy": "Data Basis",
        "module": "Data.Basis",
        "name": "decompose'",
        "normalized": "a-\u003eBasis a-\u003eScalar a",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003eBasis v-\u003eScalar v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:linearCombo",
      "description": {
        "fct-descr": "\u003cp\u003eLinear combination\n\u003c/p\u003e",
        "fct-module": "Data.Basis",
        "fct-package": "vector-space",
        "fct-signature": "[(v, Scalar v)] -\u003e v",
        "fct-source": "src/Data-Basis.html#linearCombo",
        "fct-type": "function",
        "title": "linearCombo"
      },
      "index": {
        "description": "Linear combination",
        "hierarchy": "Data Basis",
        "module": "Data.Basis",
        "name": "linearCombo",
        "normalized": "[(a,Scalar a)]-\u003ea",
        "package": "vector-space",
        "partial": "Combo",
        "signature": "[(v,Scalar v)]-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Basis.html#v:recompose",
      "description": {
        "fct-module": "Data.Basis",
        "fct-package": "vector-space",
        "fct-signature": "[(Basis v, Scalar v)] -\u003e v",
        "fct-source": "src/Data-Basis.html#recompose",
        "fct-type": "function",
        "title": "recompose"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Basis",
        "module": "Data.Basis",
        "name": "recompose",
        "normalized": "[(Basis a,Scalar a)]-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "[(Basis v,Scalar v)]-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCross products and normals\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "module",
        "fct-source": "src/Data-Cross.html",
        "fct-type": "module",
        "title": "Cross"
      },
      "index": {
        "description": "Cross products and normals",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "Cross",
        "normalized": "",
        "package": "vector-space",
        "partial": "Cross",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:HasCross2",
      "description": {
        "fct-descr": "\u003cp\u003eCross product of various forms of 2D vectors\n\u003c/p\u003e",
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "class",
        "fct-source": "src/Data-Cross.html#HasCross2",
        "fct-type": "class",
        "title": "HasCross2"
      },
      "index": {
        "description": "Cross product of various forms of vectors",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "HasCross2",
        "normalized": "",
        "package": "vector-space",
        "partial": "Has Cross",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:HasCross3",
      "description": {
        "fct-descr": "\u003cp\u003eCross product of various forms of 3D vectors\n\u003c/p\u003e",
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "class",
        "fct-source": "src/Data-Cross.html#HasCross3",
        "fct-type": "class",
        "title": "HasCross3"
      },
      "index": {
        "description": "Cross product of various forms of vectors",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "HasCross3",
        "normalized": "",
        "package": "vector-space",
        "partial": "Has Cross",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:HasNormal",
      "description": {
        "fct-descr": "\u003cp\u003eThing with a normal vector (not necessarily normalized).\n\u003c/p\u003e",
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "class",
        "fct-source": "src/Data-Cross.html#HasNormal",
        "fct-type": "class",
        "title": "HasNormal"
      },
      "index": {
        "description": "Thing with normal vector not necessarily normalized",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "HasNormal",
        "normalized": "",
        "package": "vector-space",
        "partial": "Has Normal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:One",
      "description": {
        "fct-descr": "\u003cp\u003eSingleton\n\u003c/p\u003e",
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "type",
        "fct-source": "src/Data-Cross.html#One",
        "fct-type": "type",
        "title": "One"
      },
      "index": {
        "description": "Singleton",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "One",
        "normalized": "",
        "package": "vector-space",
        "partial": "One",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:Three",
      "description": {
        "fct-descr": "\u003cp\u003eHomogeneous triple\n\u003c/p\u003e",
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "type",
        "fct-source": "src/Data-Cross.html#Three",
        "fct-type": "type",
        "title": "Three"
      },
      "index": {
        "description": "Homogeneous triple",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "Three",
        "normalized": "",
        "package": "vector-space",
        "partial": "Three",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#t:Two",
      "description": {
        "fct-descr": "\u003cp\u003eHomogeneous pair\n\u003c/p\u003e",
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "type",
        "fct-source": "src/Data-Cross.html#Two",
        "fct-type": "type",
        "title": "Two"
      },
      "index": {
        "description": "Homogeneous pair",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "Two",
        "normalized": "",
        "package": "vector-space",
        "partial": "Two",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#v:cross2",
      "description": {
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v",
        "fct-source": "src/Data-Cross.html#cross2",
        "fct-type": "method",
        "title": "cross2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "cross2",
        "normalized": "a-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#v:cross3",
      "description": {
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v -\u003e v",
        "fct-source": "src/Data-Cross.html#cross3",
        "fct-type": "method",
        "title": "cross3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "cross3",
        "normalized": "a-\u003ea-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#v:normal",
      "description": {
        "fct-descr": "\u003cp\u003eNormalized normal vector.  See also \u003ccode\u003ecross\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v",
        "fct-source": "src/Data-Cross.html#normal",
        "fct-type": "function",
        "title": "normal"
      },
      "index": {
        "description": "Normalized normal vector See also cross",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "normal",
        "normalized": "a-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Cross.html#v:normalVec",
      "description": {
        "fct-module": "Data.Cross",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v",
        "fct-source": "src/Data-Cross.html#normalVec",
        "fct-type": "method",
        "title": "normalVec"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Cross",
        "module": "Data.Cross",
        "name": "normalVec",
        "normalized": "a-\u003ea",
        "package": "vector-space",
        "partial": "Vec",
        "signature": "v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Derivative.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule indirection module.  For Maclaurin- vs Horner-based derivative\n towers.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derivative",
        "fct-package": "vector-space",
        "fct-signature": "module",
        "fct-source": "src/Data-Derivative.html",
        "fct-type": "module",
        "title": "Derivative"
      },
      "index": {
        "description": "Module indirection module For Maclaurin vs Horner-based derivative towers",
        "hierarchy": "Data Derivative",
        "module": "Data.Derivative",
        "name": "Derivative",
        "normalized": "",
        "package": "vector-space",
        "partial": "Derivative",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLinear maps\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "module",
        "fct-source": "src/Data-LinearMap.html",
        "fct-type": "module",
        "title": "LinearMap"
      },
      "index": {
        "description": "Linear maps",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "LinearMap",
        "normalized": "",
        "package": "vector-space",
        "partial": "Linear Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#t::-45--42-",
      "description": {
        "fct-descr": "\u003cp\u003eLinear map, represented as an optional memo-trie from basis to\n values, where \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e means the zero map (an optimization).\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "data",
        "fct-source": "src/Data-LinearMap.html#%3A-%2A",
        "fct-type": "data",
        "title": ":-*"
      },
      "index": {
        "description": "Linear map represented as an optional memo-trie from basis to values where Nothing means the zero map an optimization",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": ":-*",
        "normalized": "",
        "package": "vector-space",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:-42-.-42-",
      "description": {
        "fct-descr": "\u003cp\u003eCompose linear maps\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(v :-* w) -\u003e (u :-* v) -\u003e u :-* w",
        "fct-source": "src/Data-LinearMap.html#%2A.%2A",
        "fct-type": "function",
        "title": "(*.*)"
      },
      "index": {
        "description": "Compose linear maps",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "(*.*) *.*",
        "normalized": "(a*b)-\u003e(c*a)-\u003ec*b",
        "package": "vector-space",
        "partial": "",
        "signature": "(v*w)-\u003e(u*v)-\u003eu*w"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:atBasis",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a linear map on a basis element.\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(u :-* v) -\u003e Basis u -\u003e v",
        "fct-source": "src/Data-LinearMap.html#atBasis",
        "fct-type": "function",
        "title": "atBasis"
      },
      "index": {
        "description": "Evaluate linear map on basis element",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "atBasis",
        "normalized": "(a*b)-\u003eBasis a-\u003eb",
        "package": "vector-space",
        "partial": "Basis",
        "signature": "(u*v)-\u003eBasis u-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:firstL",
      "description": {
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(u :-* u') -\u003e (u, v) :-* (u', v)",
        "fct-source": "src/Data-LinearMap.html#firstL",
        "fct-type": "function",
        "title": "firstL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "firstL",
        "normalized": "(a*b)-\u003e(a,c)*(b,c)",
        "package": "vector-space",
        "partial": "",
        "signature": "(u*u')-\u003e(u,v)*(u',v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:idL",
      "description": {
        "fct-descr": "\u003cp\u003eIdentity linear map\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "u :-* u",
        "fct-source": "src/Data-LinearMap.html#idL",
        "fct-type": "function",
        "title": "idL"
      },
      "index": {
        "description": "Identity linear map",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "idL",
        "normalized": "",
        "package": "vector-space",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:inLMap",
      "description": {
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(LMap' r s -\u003e LMap' t u) -\u003e (r :-* s) -\u003e t :-* u",
        "fct-source": "src/Data-LinearMap.html#inLMap",
        "fct-type": "function",
        "title": "inLMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "inLMap",
        "normalized": "(LMap' a b-\u003eLMap' c d)-\u003e(a*b)-\u003ec*d",
        "package": "vector-space",
        "partial": "LMap",
        "signature": "(LMap' r s-\u003eLMap' t u)-\u003e(r*s)-\u003et*u"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:inLMap2",
      "description": {
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(LMap' r s -\u003e LMap' t u -\u003e LMap' v w) -\u003e (r :-* s) -\u003e (t :-* u) -\u003e v :-* w",
        "fct-source": "src/Data-LinearMap.html#inLMap2",
        "fct-type": "function",
        "title": "inLMap2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "inLMap2",
        "normalized": "(LMap' a b-\u003eLMap' c d-\u003eLMap' e f)-\u003e(a*b)-\u003e(c*d)-\u003ee*f",
        "package": "vector-space",
        "partial": "LMap",
        "signature": "(LMap' r s-\u003eLMap' t u-\u003eLMap' v w)-\u003e(r*s)-\u003e(t*u)-\u003ev*w"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:inLMap3",
      "description": {
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(LMap' r s -\u003e LMap' t u -\u003e LMap' v w -\u003e LMap' x y) -\u003e (r :-* s) -\u003e (t :-* u) -\u003e (v :-* w) -\u003e x :-* y",
        "fct-source": "src/Data-LinearMap.html#inLMap3",
        "fct-type": "function",
        "title": "inLMap3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "inLMap3",
        "normalized": "(LMap' a b-\u003eLMap' c d-\u003eLMap' e f-\u003eLMap' g h)-\u003e(a*b)-\u003e(c*d)-\u003e(e*f)-\u003eg*h",
        "package": "vector-space",
        "partial": "LMap",
        "signature": "(LMap' r s-\u003eLMap' t u-\u003eLMap' v w-\u003eLMap' x y)-\u003e(r*s)-\u003e(t*u)-\u003e(v*w)-\u003ex*y"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:lapply",
      "description": {
        "fct-descr": "\u003cp\u003eApply a linear map to a vector.\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(u :-* v) -\u003e u -\u003e v",
        "fct-source": "src/Data-LinearMap.html#lapply",
        "fct-type": "function",
        "title": "lapply"
      },
      "index": {
        "description": "Apply linear map to vector",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "lapply",
        "normalized": "(a*b)-\u003ea-\u003eb",
        "package": "vector-space",
        "partial": "",
        "signature": "(u*v)-\u003eu-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftL",
      "description": {
        "fct-descr": "\u003cp\u003eApply a linear function to each element of a linear map.\n \u003ccode\u003eliftL f l == linear f *.* l\u003c/code\u003e, but works more efficiently.\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(a -\u003e b) -\u003e MSum (f a) -\u003e MSum (f b)",
        "fct-source": "src/Data-LinearMap.html#liftL",
        "fct-type": "function",
        "title": "liftL"
      },
      "index": {
        "description": "Apply linear function to each element of linear map liftL linear but works more efficiently",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "liftL",
        "normalized": "(a-\u003eb)-\u003eMSum(c a)-\u003eMSum(c b)",
        "package": "vector-space",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eMSum(f a)-\u003eMSum(f b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftL2",
      "description": {
        "fct-descr": "\u003cp\u003eApply a linear binary function (not to be confused with a bilinear\n function) to each element of a linear map.\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e MSum (f a) -\u003e MSum (f b) -\u003e MSum (f c)",
        "fct-source": "src/Data-LinearMap.html#liftL2",
        "fct-type": "function",
        "title": "liftL2"
      },
      "index": {
        "description": "Apply linear binary function not to be confused with bilinear function to each element of linear map",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "liftL2",
        "normalized": "(a-\u003eb-\u003ec)-\u003eMSum(d a)-\u003eMSum(d b)-\u003eMSum(d c)",
        "package": "vector-space",
        "partial": "",
        "signature": "(a-\u003eb-\u003ec)-\u003eMSum(f a)-\u003eMSum(f b)-\u003eMSum(f c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftL3",
      "description": {
        "fct-descr": "\u003cp\u003eApply a linear ternary function (not to be confused with a trilinear\n function) to each element of a linear map.\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e MSum (f a) -\u003e MSum (f b) -\u003e MSum (f c) -\u003e MSum (f d)",
        "fct-source": "src/Data-LinearMap.html#liftL3",
        "fct-type": "function",
        "title": "liftL3"
      },
      "index": {
        "description": "Apply linear ternary function not to be confused with trilinear function to each element of linear map",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "liftL3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eMSum(e a)-\u003eMSum(e b)-\u003eMSum(e c)-\u003eMSum(e d)",
        "package": "vector-space",
        "partial": "",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eMSum(f a)-\u003eMSum(f b)-\u003eMSum(f c)-\u003eMSum(f d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftMS",
      "description": {
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(a -\u003e b) -\u003e MSum a -\u003e MSum b",
        "fct-source": "src/Data-LinearMap.html#liftMS",
        "fct-type": "function",
        "title": "liftMS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "liftMS",
        "normalized": "(a-\u003eb)-\u003eMSum a-\u003eMSum b",
        "package": "vector-space",
        "partial": "MS",
        "signature": "(a-\u003eb)-\u003eMSum a-\u003eMSum b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftMS2",
      "description": {
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e MSum a -\u003e MSum b -\u003e MSum c",
        "fct-source": "src/Data-LinearMap.html#liftMS2",
        "fct-type": "function",
        "title": "liftMS2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "liftMS2",
        "normalized": "(a-\u003eb-\u003ec)-\u003eMSum a-\u003eMSum b-\u003eMSum c",
        "package": "vector-space",
        "partial": "MS",
        "signature": "(a-\u003eb-\u003ec)-\u003eMSum a-\u003eMSum b-\u003eMSum c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:liftMS3",
      "description": {
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e MSum a -\u003e MSum b -\u003e MSum c -\u003e MSum d",
        "fct-source": "src/Data-LinearMap.html#liftMS3",
        "fct-type": "function",
        "title": "liftMS3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "liftMS3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eMSum a-\u003eMSum b-\u003eMSum c-\u003eMSum d",
        "package": "vector-space",
        "partial": "MS",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eMSum a-\u003eMSum b-\u003eMSum c-\u003eMSum d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-LinearMap.html#v:linear",
      "description": {
        "fct-descr": "\u003cp\u003eFunction (assumed linear) as linear map.\n\u003c/p\u003e",
        "fct-module": "Data.LinearMap",
        "fct-package": "vector-space",
        "fct-signature": "(u -\u003e v) -\u003e u :-* v",
        "fct-source": "src/Data-LinearMap.html#linear",
        "fct-type": "function",
        "title": "linear"
      },
      "index": {
        "description": "Function assumed linear as linear map",
        "hierarchy": "Data LinearMap",
        "module": "Data.LinearMap",
        "name": "linear",
        "normalized": "(a-\u003eb)-\u003ea*b",
        "package": "vector-space",
        "partial": "",
        "signature": "(u-\u003ev)-\u003eu*v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInfinite derivative towers via linear maps, using the Maclaurin\n representation.  See blog posts \u003ca\u003ehttp://conal.net/blog/tag/derivatives/\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "module",
        "fct-source": "src/Data-Maclaurin.html",
        "fct-type": "module",
        "title": "Maclaurin"
      },
      "index": {
        "description": "Infinite derivative towers via linear maps using the Maclaurin representation See blog posts http conal.net blog tag derivatives",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "Maclaurin",
        "normalized": "",
        "package": "vector-space",
        "partial": "Maclaurin",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#t::-126--62-",
      "description": {
        "fct-descr": "\u003cp\u003eInfinitely differentiable functions\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "type",
        "fct-source": "src/Data-Maclaurin.html#%3A~%3E",
        "fct-type": "type",
        "title": ":~\u003e"
      },
      "index": {
        "description": "Infinitely differentiable functions",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": ":~\u003e",
        "normalized": "",
        "package": "vector-space",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#t::-62-",
      "description": {
        "fct-descr": "\u003cp\u003eTower of derivatives.\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "data",
        "fct-source": "src/Data-Maclaurin.html#%3A%3E",
        "fct-type": "data",
        "title": ":\u003e"
      },
      "index": {
        "description": "Tower of derivatives",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": ":\u003e",
        "normalized": "",
        "package": "vector-space",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:-60--36--62--62-",
      "description": {
        "fct-descr": "\u003cp\u003eMap a \u003cem\u003elinear\u003c/em\u003e function over a derivative tower.\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(b -\u003e c) -\u003e (a :\u003e b) -\u003e a :\u003e c",
        "fct-source": "src/Data-Maclaurin.html#%3C%24%3E%3E",
        "fct-type": "function",
        "title": "(\u003c$\u003e\u003e)"
      },
      "index": {
        "description": "Map linear function over derivative tower",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "(\u003c$\u003e\u003e) \u003c$\u003e\u003e",
        "normalized": "(a-\u003eb)-\u003e(c a)-\u003ec b",
        "package": "vector-space",
        "partial": "",
        "signature": "(b-\u003ec)-\u003e(a b)-\u003ea c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:-62--45--60-",
      "description": {
        "fct-descr": "\u003cp\u003eSpecialized chain rule.  See also '(@.)'\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(u -\u003e u) -\u003e ((a :\u003e u) -\u003e a :\u003e Scalar u) -\u003e (a :\u003e u) -\u003e a :\u003e u",
        "fct-source": "src/Data-Maclaurin.html#%3E-%3C",
        "fct-type": "function",
        "title": "(\u003e-\u003c)"
      },
      "index": {
        "description": "Specialized chain rule See also",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "(\u003e-\u003c) \u003e-\u003c",
        "normalized": "(a-\u003ea)-\u003e((b a)-\u003eb Scalar a)-\u003e(b a)-\u003eb a",
        "package": "vector-space",
        "partial": "",
        "signature": "(u-\u003eu)-\u003e((a u)-\u003ea Scalar u)-\u003e(a u)-\u003ea u"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:D",
      "description": {
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "D",
        "fct-source": "src/Data-Maclaurin.html#%3A%3E",
        "fct-type": "function",
        "title": "D"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "D",
        "normalized": "",
        "package": "vector-space",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:derivAtBasis",
      "description": {
        "fct-descr": "\u003cp\u003eSample the derivative at a basis element.  Optimized for partial\n application to save work for non-scalar derivatives.\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(a :\u003e b) -\u003e Basis a -\u003e a :\u003e b",
        "fct-source": "src/Data-Maclaurin.html#derivAtBasis",
        "fct-type": "function",
        "title": "derivAtBasis"
      },
      "index": {
        "description": "Sample the derivative at basis element Optimized for partial application to save work for non-scalar derivatives",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "derivAtBasis",
        "normalized": "(a b)-\u003eBasis a-\u003ea b",
        "package": "vector-space",
        "partial": "At Basis",
        "signature": "(a b)-\u003eBasis a-\u003ea b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:derivative",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "a :-* (a :\u003e b)",
        "fct-source": "src/Data-Maclaurin.html#%3A%3E",
        "fct-type": "function",
        "title": "derivative"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "derivative",
        "normalized": "",
        "package": "vector-space",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:distrib",
      "description": {
        "fct-descr": "\u003cp\u003eDerivative tower for applying a binary function that distributes over\n addition, such as multiplication.  A bit weaker assumption than\n bilinearity.  Is bilinearity necessary for correctness here?\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(b -\u003e c -\u003e u) -\u003e (a :\u003e b) -\u003e (a :\u003e c) -\u003e a :\u003e u",
        "fct-source": "src/Data-Maclaurin.html#distrib",
        "fct-type": "function",
        "title": "distrib"
      },
      "index": {
        "description": "Derivative tower for applying binary function that distributes over addition such as multiplication bit weaker assumption than bilinearity Is bilinearity necessary for correctness here",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "distrib",
        "normalized": "(a-\u003eb-\u003ec)-\u003e(d a)-\u003e(d b)-\u003ed c",
        "package": "vector-space",
        "partial": "",
        "signature": "(b-\u003ec-\u003eu)-\u003e(a b)-\u003e(a c)-\u003ea u"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:fmapD",
      "description": {
        "fct-descr": "\u003cp\u003eMap a \u003cem\u003elinear\u003c/em\u003e function over a derivative tower.\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(b -\u003e c) -\u003e (a :\u003e b) -\u003e a :\u003e c",
        "fct-source": "src/Data-Maclaurin.html#fmapD",
        "fct-type": "function",
        "title": "fmapD"
      },
      "index": {
        "description": "Map linear function over derivative tower",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "fmapD",
        "normalized": "(a-\u003eb)-\u003e(c a)-\u003ec b",
        "package": "vector-space",
        "partial": "",
        "signature": "(b-\u003ec)-\u003e(a b)-\u003ea c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:fstD",
      "description": {
        "fct-descr": "\u003cp\u003eDifferentiable version of \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(a, b) :~\u003e a",
        "fct-source": "src/Data-Maclaurin.html#fstD",
        "fct-type": "function",
        "title": "fstD"
      },
      "index": {
        "description": "Differentiable version of fst",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "fstD",
        "normalized": "(a,b)a",
        "package": "vector-space",
        "partial": "",
        "signature": "(a,b)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:idD",
      "description": {
        "fct-descr": "\u003cp\u003eDifferentiable identity function.  Sometimes called \u003ca\u003ethe\n derivation variable\u003c/a\u003e or similar, but it's not really a variable.\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "u :~\u003e u",
        "fct-source": "src/Data-Maclaurin.html#idD",
        "fct-type": "function",
        "title": "idD"
      },
      "index": {
        "description": "Differentiable identity function Sometimes called the derivation variable or similar but it not really variable",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "idD",
        "normalized": "",
        "package": "vector-space",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:liftD2",
      "description": {
        "fct-descr": "\u003cp\u003eApply a \u003cem\u003elinear\u003c/em\u003e binary function over derivative towers.\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(b -\u003e c -\u003e d) -\u003e (a :\u003e b) -\u003e (a :\u003e c) -\u003e a :\u003e d",
        "fct-source": "src/Data-Maclaurin.html#liftD2",
        "fct-type": "function",
        "title": "liftD2"
      },
      "index": {
        "description": "Apply linear binary function over derivative towers",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "liftD2",
        "normalized": "(a-\u003eb-\u003ec)-\u003e(d a)-\u003e(d b)-\u003ed c",
        "package": "vector-space",
        "partial": "",
        "signature": "(b-\u003ec-\u003ed)-\u003e(a b)-\u003e(a c)-\u003ea d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:liftD3",
      "description": {
        "fct-descr": "\u003cp\u003eApply a \u003cem\u003elinear\u003c/em\u003e ternary function over derivative towers.\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(b -\u003e c -\u003e d -\u003e e) -\u003e (a :\u003e b) -\u003e (a :\u003e c) -\u003e (a :\u003e d) -\u003e a :\u003e e",
        "fct-source": "src/Data-Maclaurin.html#liftD3",
        "fct-type": "function",
        "title": "liftD3"
      },
      "index": {
        "description": "Apply linear ternary function over derivative towers",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "liftD3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003e(e a)-\u003e(e b)-\u003e(e c)-\u003ee d",
        "package": "vector-space",
        "partial": "",
        "signature": "(b-\u003ec-\u003ed-\u003ee)-\u003e(a b)-\u003e(a c)-\u003e(a d)-\u003ea e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:linearD",
      "description": {
        "fct-descr": "\u003cp\u003eEvery linear function has a constant derivative equal to the function\n itself (as a linear map).\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(u -\u003e v) -\u003e u :~\u003e v",
        "fct-source": "src/Data-Maclaurin.html#linearD",
        "fct-type": "function",
        "title": "linearD"
      },
      "index": {
        "description": "Every linear function has constant derivative equal to the function itself as linear map",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "linearD",
        "normalized": "(a-\u003eb)-\u003ea b",
        "package": "vector-space",
        "partial": "",
        "signature": "(u-\u003ev)-\u003eu v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:pairD",
      "description": {
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(a :\u003e b, a :\u003e c) -\u003e a :\u003e (b, c)",
        "fct-source": "src/Data-Maclaurin.html#pairD",
        "fct-type": "function",
        "title": "pairD"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "pairD",
        "normalized": "(a b,a c)-\u003ea(b,c)",
        "package": "vector-space",
        "partial": "",
        "signature": "(a b,a c)-\u003ea(b,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:powVal",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "b",
        "fct-source": "src/Data-Maclaurin.html#%3A%3E",
        "fct-type": "function",
        "title": "powVal"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "powVal",
        "normalized": "",
        "package": "vector-space",
        "partial": "Val",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:pureD",
      "description": {
        "fct-descr": "\u003cp\u003eConstant derivative tower.\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "b -\u003e a :\u003e b",
        "fct-source": "src/Data-Maclaurin.html#pureD",
        "fct-type": "function",
        "title": "pureD"
      },
      "index": {
        "description": "Constant derivative tower",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "pureD",
        "normalized": "a-\u003eb a",
        "package": "vector-space",
        "partial": "",
        "signature": "b-\u003ea b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:sndD",
      "description": {
        "fct-descr": "\u003cp\u003eDifferentiable version of \u003ccode\u003e\u003ca\u003esnd\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(a, b) :~\u003e b",
        "fct-source": "src/Data-Maclaurin.html#sndD",
        "fct-type": "function",
        "title": "sndD"
      },
      "index": {
        "description": "Differentiable version of snd",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "sndD",
        "normalized": "(a,b)b",
        "package": "vector-space",
        "partial": "",
        "signature": "(a,b)b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:tripleD",
      "description": {
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(a :\u003e b, a :\u003e c, a :\u003e d) -\u003e a :\u003e (b, c, d)",
        "fct-source": "src/Data-Maclaurin.html#tripleD",
        "fct-type": "function",
        "title": "tripleD"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "tripleD",
        "normalized": "(a b,a c,a d)-\u003ea(b,c,d)",
        "package": "vector-space",
        "partial": "",
        "signature": "(a b,a c,a d)-\u003ea(b,c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:unpairD",
      "description": {
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(a :\u003e (b, c)) -\u003e (a :\u003e b, a :\u003e c)",
        "fct-source": "src/Data-Maclaurin.html#unpairD",
        "fct-type": "function",
        "title": "unpairD"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "unpairD",
        "normalized": "(a(b,c))-\u003e(a b,a c)",
        "package": "vector-space",
        "partial": "",
        "signature": "(a(b,c))-\u003e(a b,a c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-Maclaurin.html#v:untripleD",
      "description": {
        "fct-module": "Data.Maclaurin",
        "fct-package": "vector-space",
        "fct-signature": "(a :\u003e (b, c, d)) -\u003e (a :\u003e b, a :\u003e c, a :\u003e d)",
        "fct-source": "src/Data-Maclaurin.html#untripleD",
        "fct-type": "function",
        "title": "untripleD"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Maclaurin",
        "module": "Data.Maclaurin",
        "name": "untripleD",
        "normalized": "(a(b,c,d))-\u003e(a b,a c,a d)",
        "package": "vector-space",
        "partial": "",
        "signature": "(a(b,c,d))-\u003e(a b,a c,a d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVector spaces\n\u003c/p\u003e\u003cp\u003eThis version uses associated types instead of fundeps and\n requires ghc-6.10 or later\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "module",
        "fct-source": "src/Data-VectorSpace.html",
        "fct-type": "module",
        "title": "VectorSpace"
      },
      "index": {
        "description": "Vector spaces This version uses associated types instead of fundeps and requires ghc-6.10 or later",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "VectorSpace",
        "normalized": "",
        "package": "vector-space",
        "partial": "Vector Space",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#t:InnerSpace",
      "description": {
        "fct-descr": "\u003cp\u003eAdds inner (dot) products.\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "class",
        "fct-source": "src/Data-VectorSpace.html#InnerSpace",
        "fct-type": "class",
        "title": "InnerSpace"
      },
      "index": {
        "description": "Adds inner dot products",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "InnerSpace",
        "normalized": "",
        "package": "vector-space",
        "partial": "Inner Space",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#t:VectorSpace",
      "description": {
        "fct-descr": "\u003cp\u003eVector space \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "class",
        "fct-source": "src/Data-VectorSpace.html#VectorSpace",
        "fct-type": "class",
        "title": "VectorSpace"
      },
      "index": {
        "description": "Vector space",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "VectorSpace",
        "normalized": "",
        "package": "vector-space",
        "partial": "Vector Space",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:-42--94-",
      "description": {
        "fct-descr": "\u003cp\u003eScale a vector\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "Scalar v -\u003e v -\u003e v",
        "fct-source": "src/Data-VectorSpace.html#%2A%5E",
        "fct-type": "method",
        "title": "(*^)"
      },
      "index": {
        "description": "Scale vector",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "(*^) *^",
        "normalized": "Scalar a-\u003ea-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "Scalar v-\u003ev-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:-60-.-62-",
      "description": {
        "fct-descr": "\u003cp\u003eInner/dot product\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v -\u003e Scalar v",
        "fct-source": "src/Data-VectorSpace.html#%3C.%3E",
        "fct-type": "method",
        "title": "(\u003c.\u003e)"
      },
      "index": {
        "description": "Inner dot product",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "(\u003c.\u003e) \u003c.\u003e",
        "normalized": "a-\u003ea-\u003eScalar a",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev-\u003eScalar v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:-94--42-",
      "description": {
        "fct-descr": "\u003cp\u003eVector multiplied by scalar\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e s -\u003e v",
        "fct-source": "src/Data-VectorSpace.html#%5E%2A",
        "fct-type": "function",
        "title": "(^*)"
      },
      "index": {
        "description": "Vector multiplied by scalar",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "(^*) ^*",
        "normalized": "a-\u003eb-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003es-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:-94--47-",
      "description": {
        "fct-descr": "\u003cp\u003eVector divided by scalar\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e s -\u003e v",
        "fct-source": "src/Data-VectorSpace.html#%5E%2F",
        "fct-type": "function",
        "title": "(^/)"
      },
      "index": {
        "description": "Vector divided by scalar",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "(^/) ^/",
        "normalized": "a-\u003eb-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003es-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:lerp",
      "description": {
        "fct-descr": "\u003cp\u003eLinear interpolation between \u003ccode\u003ea\u003c/code\u003e (when \u003ccode\u003et==0\u003c/code\u003e) and \u003ccode\u003eb\u003c/code\u003e (when \u003ccode\u003et==1\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v -\u003e Scalar v -\u003e v",
        "fct-source": "src/Data-VectorSpace.html#lerp",
        "fct-type": "function",
        "title": "lerp"
      },
      "index": {
        "description": "Linear interpolation between when and when",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "lerp",
        "normalized": "a-\u003ea-\u003eScalar a-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev-\u003eScalar v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:magnitude",
      "description": {
        "fct-descr": "\u003cp\u003eLength of a vector.   See also \u003ccode\u003e\u003ca\u003emagnitudeSq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e s",
        "fct-source": "src/Data-VectorSpace.html#magnitude",
        "fct-type": "function",
        "title": "magnitude"
      },
      "index": {
        "description": "Length of vector See also magnitudeSq",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "magnitude",
        "normalized": "a-\u003eb",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003es"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:magnitudeSq",
      "description": {
        "fct-descr": "\u003cp\u003eSquare of the length of a vector.  Sometimes useful for efficiency.\n See also \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e s",
        "fct-source": "src/Data-VectorSpace.html#magnitudeSq",
        "fct-type": "function",
        "title": "magnitudeSq"
      },
      "index": {
        "description": "Square of the length of vector Sometimes useful for efficiency See also magnitude",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "magnitudeSq",
        "normalized": "a-\u003eb",
        "package": "vector-space",
        "partial": "Sq",
        "signature": "v-\u003es"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:normalized",
      "description": {
        "fct-descr": "\u003cp\u003eVector in same direction as given one but with length of one.  If\n given the zero vector, then return it.\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v",
        "fct-source": "src/Data-VectorSpace.html#normalized",
        "fct-type": "function",
        "title": "normalized"
      },
      "index": {
        "description": "Vector in same direction as given one but with length of one If given the zero vector then return it",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "normalized",
        "normalized": "a-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-space/docs/Data-VectorSpace.html#v:project",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eproject u v\u003c/code\u003e computes the projection of \u003ccode\u003ev\u003c/code\u003e onto \u003ccode\u003eu\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.VectorSpace",
        "fct-package": "vector-space",
        "fct-signature": "v -\u003e v -\u003e v",
        "fct-source": "src/Data-VectorSpace.html#project",
        "fct-type": "function",
        "title": "project"
      },
      "index": {
        "description": "project computes the projection of onto",
        "hierarchy": "Data VectorSpace",
        "module": "Data.VectorSpace",
        "name": "project",
        "normalized": "a-\u003ea-\u003ea",
        "package": "vector-space",
        "partial": "",
        "signature": "v-\u003ev-\u003ev"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Lazy.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports \u003ccode\u003erematch\u003c/code\u003e matchers for strict Data.Text\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Rematch.Text.Lazy",
        "fct-package": "rematch-text",
        "fct-signature": "module",
        "fct-source": "src/Control-Rematch-Text-Lazy.html",
        "fct-type": "module",
        "title": "Lazy"
      },
      "index": {
        "description": "This module exports rematch matchers for strict Data.Text",
        "hierarchy": "Control Rematch Text Lazy",
        "module": "Control.Rematch.Text.Lazy",
        "name": "Lazy",
        "normalized": "",
        "package": "rematch-text",
        "partial": "Lazy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Lazy.html#v:containsText",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input contains some Text\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Lazy",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Lazy.html#containsText",
        "fct-type": "function",
        "title": "containsText"
      },
      "index": {
        "description": "matchers if the input contains some Text",
        "hierarchy": "Control Rematch Text Lazy",
        "module": "Control.Rematch.Text.Lazy",
        "name": "containsText",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "Text",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Lazy.html#v:endsWith",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input ends with some Text\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Lazy",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Lazy.html#endsWith",
        "fct-type": "function",
        "title": "endsWith"
      },
      "index": {
        "description": "matchers if the input ends with some Text",
        "hierarchy": "Control Rematch Text Lazy",
        "module": "Control.Rematch.Text.Lazy",
        "name": "endsWith",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "With",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Lazy.html#v:equalToIgnoringCase",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input is equal ignoring case\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Lazy",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Lazy.html#equalToIgnoringCase",
        "fct-type": "function",
        "title": "equalToIgnoringCase"
      },
      "index": {
        "description": "matchers if the input is equal ignoring case",
        "hierarchy": "Control Rematch Text Lazy",
        "module": "Control.Rematch.Text.Lazy",
        "name": "equalToIgnoringCase",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "To Ignoring Case",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Lazy.html#v:equalToIgnoringWhitespace",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input is equal ignoring whitespace\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Lazy",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Lazy.html#equalToIgnoringWhitespace",
        "fct-type": "function",
        "title": "equalToIgnoringWhitespace"
      },
      "index": {
        "description": "matchers if the input is equal ignoring whitespace",
        "hierarchy": "Control Rematch Text Lazy",
        "module": "Control.Rematch.Text.Lazy",
        "name": "equalToIgnoringWhitespace",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "To Ignoring Whitespace",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Lazy.html#v:isEmptyText",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input is empty Text\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Lazy",
        "fct-package": "rematch-text",
        "fct-signature": "Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Lazy.html#isEmptyText",
        "fct-type": "function",
        "title": "isEmptyText"
      },
      "index": {
        "description": "matchers if the input is empty Text",
        "hierarchy": "Control Rematch Text Lazy",
        "module": "Control.Rematch.Text.Lazy",
        "name": "isEmptyText",
        "normalized": "",
        "package": "rematch-text",
        "partial": "Empty Text",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Lazy.html#v:startsWith",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input begins with some Text\n becomes success\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Lazy",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Lazy.html#startsWith",
        "fct-type": "function",
        "title": "startsWith"
      },
      "index": {
        "description": "matchers if the input begins with some Text becomes success",
        "hierarchy": "Control Rematch Text Lazy",
        "module": "Control.Rematch.Text.Lazy",
        "name": "startsWith",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "With",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Strict.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports \u003ccode\u003erematch\u003c/code\u003e matchers for strict Data.Text\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Rematch.Text.Strict",
        "fct-package": "rematch-text",
        "fct-signature": "module",
        "fct-source": "src/Control-Rematch-Text-Strict.html",
        "fct-type": "module",
        "title": "Strict"
      },
      "index": {
        "description": "This module exports rematch matchers for strict Data.Text",
        "hierarchy": "Control Rematch Text Strict",
        "module": "Control.Rematch.Text.Strict",
        "name": "Strict",
        "normalized": "",
        "package": "rematch-text",
        "partial": "Strict",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Strict.html#v:containsText",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input contains some Text\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Strict",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Strict.html#containsText",
        "fct-type": "function",
        "title": "containsText"
      },
      "index": {
        "description": "matchers if the input contains some Text",
        "hierarchy": "Control Rematch Text Strict",
        "module": "Control.Rematch.Text.Strict",
        "name": "containsText",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "Text",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Strict.html#v:endsWith",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input ends with some Text\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Strict",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Strict.html#endsWith",
        "fct-type": "function",
        "title": "endsWith"
      },
      "index": {
        "description": "matchers if the input ends with some Text",
        "hierarchy": "Control Rematch Text Strict",
        "module": "Control.Rematch.Text.Strict",
        "name": "endsWith",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "With",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Strict.html#v:equalToIgnoringCase",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input is equal ignoring case\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Strict",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Strict.html#equalToIgnoringCase",
        "fct-type": "function",
        "title": "equalToIgnoringCase"
      },
      "index": {
        "description": "matchers if the input is equal ignoring case",
        "hierarchy": "Control Rematch Text Strict",
        "module": "Control.Rematch.Text.Strict",
        "name": "equalToIgnoringCase",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "To Ignoring Case",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Strict.html#v:equalToIgnoringWhitespace",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input is equal ignoring whitespace\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Strict",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Strict.html#equalToIgnoringWhitespace",
        "fct-type": "function",
        "title": "equalToIgnoringWhitespace"
      },
      "index": {
        "description": "matchers if the input is equal ignoring whitespace",
        "hierarchy": "Control Rematch Text Strict",
        "module": "Control.Rematch.Text.Strict",
        "name": "equalToIgnoringWhitespace",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "To Ignoring Whitespace",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Strict.html#v:isEmptyText",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input is empty Text\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Strict",
        "fct-package": "rematch-text",
        "fct-signature": "Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Strict.html#isEmptyText",
        "fct-type": "function",
        "title": "isEmptyText"
      },
      "index": {
        "description": "matchers if the input is empty Text",
        "hierarchy": "Control Rematch Text Strict",
        "module": "Control.Rematch.Text.Strict",
        "name": "isEmptyText",
        "normalized": "",
        "package": "rematch-text",
        "partial": "Empty Text",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch-text/docs/Control-Rematch-Text-Strict.html#v:startsWith",
      "description": {
        "fct-descr": "\u003cp\u003ematchers if the input begins with some Text\n becomes success\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Text.Strict",
        "fct-package": "rematch-text",
        "fct-signature": "Text -\u003e Matcher Text",
        "fct-source": "src/Control-Rematch-Text-Strict.html#startsWith",
        "fct-type": "function",
        "title": "startsWith"
      },
      "index": {
        "description": "matchers if the input begins with some Text becomes success",
        "hierarchy": "Control Rematch Text Strict",
        "module": "Control.Rematch.Text.Strict",
        "name": "startsWith",
        "normalized": "Text-\u003eMatcher Text",
        "package": "rematch-text",
        "partial": "With",
        "signature": "Text-\u003eMatcher Text"
      }
    }
  }
]
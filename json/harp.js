[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions that simulate the behavior of regular patterns\n using a Match monad for parsing lists.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "module",
        "fct-source": "src/Harp-Match.html",
        "fct-type": "module",
        "title": "Match"
      },
      "index": {
        "description": "Functions that simulate the behavior of regular patterns using Match monad for parsing lists",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "Match",
        "normalized": "",
        "package": "harp",
        "partial": "Match",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#t:Match",
      "description": {
        "fct-descr": "\u003cp\u003eThe Match monad\n\u003c/p\u003e",
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "data",
        "fct-source": "src/Harp-Match.html#Match",
        "fct-type": "data",
        "title": "Match"
      },
      "index": {
        "description": "The Match monad",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "Match",
        "normalized": "",
        "package": "harp",
        "partial": "Match",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:-43--43--43-",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "Match e a -\u003e Match e a -\u003e Match e a",
        "fct-source": "src/Harp-Match.html#%2B%2B%2B",
        "fct-type": "function",
        "title": "(+++)"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "(+++) +++",
        "normalized": "Match a b-\u003eMatch a b-\u003eMatch a b",
        "package": "harp",
        "partial": "",
        "signature": "Match e a-\u003eMatch e a-\u003eMatch e a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:baseMatch",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "(a -\u003e Maybe b) -\u003e Match a (a, b)",
        "fct-source": "src/Harp-Match.html#baseMatch",
        "fct-type": "function",
        "title": "baseMatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "baseMatch",
        "normalized": "(a-\u003eMaybe b)-\u003eMatch a(a,b)",
        "package": "harp",
        "partial": "Match",
        "signature": "(a-\u003eMaybe b)-\u003eMatch a(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:foldComp",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[[a] -\u003e [a]] -\u003e [a] -\u003e [a]",
        "fct-source": "src/Harp-Match.html#foldComp",
        "fct-type": "function",
        "title": "foldComp"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "foldComp",
        "normalized": "[[a]-\u003e[a]]-\u003e[a]-\u003e[a]",
        "package": "harp",
        "partial": "Comp",
        "signature": "[[a]-\u003e[a]]-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:gManyMatch",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "Match e a -\u003e Match e [a]",
        "fct-source": "src/Harp-Match.html#gManyMatch",
        "fct-type": "function",
        "title": "gManyMatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "gManyMatch",
        "normalized": "Match a b-\u003eMatch a[b]",
        "package": "harp",
        "partial": "Many Match",
        "signature": "Match e a-\u003eMatch e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:manyMatch",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "Match e a -\u003e Match e [a]",
        "fct-source": "src/Harp-Match.html#manyMatch",
        "fct-type": "function",
        "title": "manyMatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "manyMatch",
        "normalized": "Match a b-\u003eMatch a[b]",
        "package": "harp",
        "partial": "Match",
        "signature": "Match e a-\u003eMatch e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:runMatch",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "Match e a -\u003e [e] -\u003e Maybe a",
        "fct-source": "src/Harp-Match.html#runMatch",
        "fct-type": "function",
        "title": "runMatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "runMatch",
        "normalized": "Match a b-\u003e[a]-\u003eMaybe b",
        "package": "harp",
        "partial": "Match",
        "signature": "Match e a-\u003e[e]-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:unzip0",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[()] -\u003e ()",
        "fct-source": "src/Harp-Match.html#unzip0",
        "fct-type": "function",
        "title": "unzip0"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "unzip0",
        "normalized": "[()]-\u003e()",
        "package": "harp",
        "partial": "",
        "signature": "[()]-\u003e()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:unzip1",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[a] -\u003e [a]",
        "fct-source": "src/Harp-Match.html#unzip1",
        "fct-type": "function",
        "title": "unzip1"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "unzip1",
        "normalized": "[a]-\u003e[a]",
        "package": "harp",
        "partial": "",
        "signature": "[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:unzip2",
      "description": {
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[(a, b)] -\u003e ([a], [b])",
        "fct-source": "src/Harp-Match.html#unzip2",
        "fct-type": "function",
        "title": "unzip2"
      },
      "index": {
        "description": "",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "unzip2",
        "normalized": "[(a,b)]-\u003e([a],[b])",
        "package": "harp",
        "partial": "",
        "signature": "[(a,b)]-\u003e([a],[b])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:unzip3",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip3\u003c/a\u003e\u003c/code\u003e function takes a list of triples and returns three\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[(a, b, c)] -\u003e ([a], [b], [c])",
        "fct-type": "function",
        "title": "unzip3"
      },
      "index": {
        "description": "The unzip3 function takes list of triples and returns three lists analogous to unzip",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "unzip3",
        "normalized": "[(a,b,c)]-\u003e([a],[b],[c])",
        "package": "harp",
        "partial": "",
        "signature": "[(a,b,c)]-\u003e([a],[b],[c])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:unzip4",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip4\u003c/a\u003e\u003c/code\u003e function takes a list of quadruples and returns four\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[(a, b, c, d)] -\u003e ([a], [b], [c], [d])",
        "fct-type": "function",
        "title": "unzip4"
      },
      "index": {
        "description": "The unzip4 function takes list of quadruples and returns four lists analogous to unzip",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "unzip4",
        "normalized": "[(a,b,c,d)]-\u003e([a],[b],[c],[d])",
        "package": "harp",
        "partial": "",
        "signature": "[(a,b,c,d)]-\u003e([a],[b],[c],[d])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:unzip5",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip5\u003c/a\u003e\u003c/code\u003e function takes a list of five-tuples and returns five\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[(a, b, c, d, e)] -\u003e ([a], [b], [c], [d], [e])",
        "fct-type": "function",
        "title": "unzip5"
      },
      "index": {
        "description": "The unzip5 function takes list of five-tuples and returns five lists analogous to unzip",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "unzip5",
        "normalized": "[(a,b,c,d,e)]-\u003e([a],[b],[c],[d],[e])",
        "package": "harp",
        "partial": "",
        "signature": "[(a,b,c,d,e)]-\u003e([a],[b],[c],[d],[e])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:unzip6",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip6\u003c/a\u003e\u003c/code\u003e function takes a list of six-tuples and returns six\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[(a, b, c, d, e, f)] -\u003e ([a], [b], [c], [d], [e], [f])",
        "fct-type": "function",
        "title": "unzip6"
      },
      "index": {
        "description": "The unzip6 function takes list of six-tuples and returns six lists analogous to unzip",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "unzip6",
        "normalized": "[(a,b,c,d,e,f)]-\u003e([a],[b],[c],[d],[e],[f])",
        "package": "harp",
        "partial": "",
        "signature": "[(a,b,c,d,e,f)]-\u003e([a],[b],[c],[d],[e],[f])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/harp/docs/Harp-Match.html#v:unzip7",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip7\u003c/a\u003e\u003c/code\u003e function takes a list of seven-tuples and returns\n seven lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Harp.Match",
        "fct-package": "harp",
        "fct-signature": "[(a, b, c, d, e, f, g)] -\u003e ([a], [b], [c], [d], [e], [f], [g])",
        "fct-type": "function",
        "title": "unzip7"
      },
      "index": {
        "description": "The unzip7 function takes list of seven-tuples and returns seven lists analogous to unzip",
        "hierarchy": "Harp Match",
        "module": "Harp.Match",
        "name": "unzip7",
        "normalized": "[(a,b,c,d,e,f,g)]-\u003e([a],[b],[c],[d],[e],[f],[g])",
        "package": "harp",
        "partial": "",
        "signature": "[(a,b,c,d,e,f,g)]-\u003e([a],[b],[c],[d],[e],[f],[g])"
      }
    }
  }
]
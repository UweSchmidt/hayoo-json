[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Chan.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDefines a Chan-like structure and makes it an MQueue instance.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.MQueue.Chan",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-MQueue-Chan.html",
        "fct-type": "module",
        "title": "Chan"
      },
      "index": {
        "description": "Defines Chan-like structure and makes it an MQueue instance",
        "hierarchy": "Data MQueue Chan",
        "module": "Data.MQueue.Chan",
        "name": "Chan",
        "normalized": "",
        "package": "queuelike",
        "partial": "Chan",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Chan.html#v:blockingPop",
      "description": {
        "fct-module": "Data.MQueue.Chan",
        "fct-package": "queuelike",
        "fct-signature": "Chan a -\u003e IO a",
        "fct-source": "src/Data-MQueue-Chan.html#blockingPop",
        "fct-type": "function",
        "title": "blockingPop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Chan",
        "module": "Data.MQueue.Chan",
        "name": "blockingPop",
        "normalized": "Chan a-\u003eIO a",
        "package": "queuelike",
        "partial": "Pop",
        "signature": "Chan a-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-MQueue-Class.html",
        "fct-type": "module",
        "title": "Class"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "Class",
        "normalized": "",
        "package": "queuelike",
        "partial": "Class",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#t:MQueue",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "class",
        "fct-source": "src/Data-MQueue-Class.html#MQueue",
        "fct-type": "class",
        "title": "MQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "MQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "MQueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#v:isEmpty",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e m Bool",
        "fct-source": "src/Data-MQueue-Class.html#isEmpty",
        "fct-type": "method",
        "title": "isEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "isEmpty",
        "normalized": "a-\u003eb Bool",
        "package": "queuelike",
        "partial": "Empty",
        "signature": "q-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#v:newQueue",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "m q",
        "fct-source": "src/Data-MQueue-Class.html#newQueue",
        "fct-type": "method",
        "title": "newQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "newQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#v:peek",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e m (Maybe (MQueueKey q))",
        "fct-source": "src/Data-MQueue-Class.html#peek",
        "fct-type": "method",
        "title": "peek"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "peek",
        "normalized": "a-\u003eb(Maybe(MQueueKey a))",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003em(Maybe(MQueueKey q))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#v:pop",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e m (Maybe (MQueueKey q))",
        "fct-source": "src/Data-MQueue-Class.html#pop",
        "fct-type": "method",
        "title": "pop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "pop",
        "normalized": "a-\u003eb(Maybe(MQueueKey a))",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003em(Maybe(MQueueKey q))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#v:pop_",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e m ()",
        "fct-source": "src/Data-MQueue-Class.html#pop_",
        "fct-type": "method",
        "title": "pop_"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "pop_",
        "normalized": "a-\u003eb()",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#v:push",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e MQueueKey q -\u003e m ()",
        "fct-source": "src/Data-MQueue-Class.html#push",
        "fct-type": "method",
        "title": "push"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "push",
        "normalized": "a-\u003eMQueueKey a-\u003eb()",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003eMQueueKey q-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Class.html#v:pushAll",
      "description": {
        "fct-module": "Data.MQueue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e [MQueueKey q] -\u003e m ()",
        "fct-source": "src/Data-MQueue-Class.html#pushAll",
        "fct-type": "method",
        "title": "pushAll"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Class",
        "module": "Data.MQueue.Class",
        "name": "pushAll",
        "normalized": "a-\u003e[MQueueKey a]-\u003eb()",
        "package": "queuelike",
        "partial": "All",
        "signature": "q-\u003e[MQueueKey q]-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Heap.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eArray-based implementation of an entirely traditional binary heap.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.MQueue.Heap",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-MQueue-Heap.html",
        "fct-type": "module",
        "title": "Heap"
      },
      "index": {
        "description": "Array-based implementation of an entirely traditional binary heap",
        "hierarchy": "Data MQueue Heap",
        "module": "Data.MQueue.Heap",
        "name": "Heap",
        "normalized": "",
        "package": "queuelike",
        "partial": "Heap",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Heap.html#t:Heap",
      "description": {
        "fct-module": "Data.MQueue.Heap",
        "fct-package": "queuelike",
        "fct-signature": "data",
        "fct-source": "src/Data-MQueue-Heap.html#Heap",
        "fct-type": "data",
        "title": "Heap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Heap",
        "module": "Data.MQueue.Heap",
        "name": "Heap",
        "normalized": "",
        "package": "queuelike",
        "partial": "Heap",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-Heap.html#v:getSize",
      "description": {
        "fct-module": "Data.MQueue.Heap",
        "fct-package": "queuelike",
        "fct-signature": "Heap s e -\u003e m Int",
        "fct-source": "src/Data-MQueue-Heap.html#getSize",
        "fct-type": "function",
        "title": "getSize"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue Heap",
        "module": "Data.MQueue.Heap",
        "name": "getSize",
        "normalized": "Heap a b-\u003ec Int",
        "package": "queuelike",
        "partial": "Size",
        "signature": "Heap s e-\u003em Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-SyncQueue.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIn the IO monad, provides thread-safe \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e-based wrappers for \u003ccode\u003eQueuelike\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eMQueue\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.MQueue.SyncQueue",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-MQueue-SyncQueue.html",
        "fct-type": "module",
        "title": "SyncQueue"
      },
      "index": {
        "description": "In the IO monad provides thread-safe MVar based wrappers for Queuelike and MQueue instances",
        "hierarchy": "Data MQueue SyncQueue",
        "module": "Data.MQueue.SyncQueue",
        "name": "SyncQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "Sync Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-SyncQueue.html#t:SyncMQ",
      "description": {
        "fct-module": "Data.MQueue.SyncQueue",
        "fct-package": "queuelike",
        "fct-signature": "data",
        "fct-source": "src/Data-MQueue-SyncQueue.html#SyncMQ",
        "fct-type": "data",
        "title": "SyncMQ"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue SyncQueue",
        "module": "Data.MQueue.SyncQueue",
        "name": "SyncMQ",
        "normalized": "",
        "package": "queuelike",
        "partial": "Sync MQ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue-SyncQueue.html#t:SyncQ",
      "description": {
        "fct-module": "Data.MQueue.SyncQueue",
        "fct-package": "queuelike",
        "fct-signature": "data",
        "fct-source": "src/Data-MQueue-SyncQueue.html#SyncQ",
        "fct-type": "data",
        "title": "SyncQ"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue SyncQueue",
        "module": "Data.MQueue.SyncQueue",
        "name": "SyncQ",
        "normalized": "",
        "package": "queuelike",
        "partial": "Sync",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-MQueue.html#",
      "description": {
        "fct-module": "Data.MQueue",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-MQueue.html",
        "fct-type": "module",
        "title": "MQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MQueue",
        "module": "Data.MQueue",
        "name": "MQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "MQueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstracts the implementation details of a single-insertion, single-extraction queuelike structure.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue-Class.html",
        "fct-type": "module",
        "title": "Class"
      },
      "index": {
        "description": "Abstracts the implementation details of single-insertion single-extraction queuelike structure",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "Class",
        "normalized": "",
        "package": "queuelike",
        "partial": "Class",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#t::-45--62-",
      "description": {
        "fct-descr": "\u003cp\u003eType that only orders on the key, ignoring the value completely; frequently useful in priority queues, so made available here.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "data",
        "fct-source": "src/Data-Queue-Class.html#%3A-%3E",
        "fct-type": "data",
        "title": ":-\u003e"
      },
      "index": {
        "description": "Type that only orders on the key ignoring the value completely frequently useful in priority queues so made available here",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": ":-\u003e",
        "normalized": "",
        "package": "queuelike",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#t:IQueue",
      "description": {
        "fct-descr": "\u003cp\u003eA generic type class encapsulating a generic queuelike structure, that supports single-insertion and single-extraction; this abstraction includes priority queues, stacks, and FIFO queues.  There are many minimal implementations, so each method lists the prerequisites for its default implementation.  Most implementations will implement \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e, (\u003ccode\u003e\u003ca\u003esingleton\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/code\u003e) or \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e, (\u003ccode\u003epeek\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e) or \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e.  (The absolute minimal implementation is \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e.)\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Class.html#IQueue",
        "fct-type": "class",
        "title": "IQueue"
      },
      "index": {
        "description": "generic type class encapsulating generic queuelike structure that supports single-insertion and single-extraction this abstraction includes priority queues stacks and FIFO queues There are many minimal implementations so each method lists the prerequisites for its default implementation Most implementations will implement empty singleton and merge or insert peek and delete or extract and size The absolute minimal implementation is empty insert extract and size",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "IQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "IQueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v::-45--62-",
      "description": {
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "e :-\u003e f",
        "fct-source": "src/Data-Queue-Class.html#%3A-%3E",
        "fct-type": "function",
        "title": ":-\u003e"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": ":-\u003e",
        "normalized": "a-\u003eb",
        "package": "queuelike",
        "partial": "",
        "signature": "e-\u003ef"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:delete",
      "description": {
        "fct-descr": "\u003cp\u003eDeletes an element from the queue, if the queue is nonempty.  The default implementation uses \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e Maybe q",
        "fct-source": "src/Data-Queue-Class.html#delete",
        "fct-type": "method",
        "title": "delete"
      },
      "index": {
        "description": "Deletes an element from the queue if the queue is nonempty The default implementation uses extract",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "delete",
        "normalized": "a-\u003eMaybe a",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003eMaybe q"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003eConstructs an empty queue.  The default implementation uses \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q",
        "fct-source": "src/Data-Queue-Class.html#empty",
        "fct-type": "method",
        "title": "empty"
      },
      "index": {
        "description": "Constructs an empty queue The default implementation uses fromList",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "empty",
        "normalized": "",
        "package": "queuelike",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:extract",
      "description": {
        "fct-descr": "\u003cp\u003eAttempts to extract an element from the queue; if the queue is empty, returns Nothing.  The default implementation uses \u003ccode\u003epeek\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e Maybe (QueueKey q, q)",
        "fct-source": "src/Data-Queue-Class.html#extract",
        "fct-type": "method",
        "title": "extract"
      },
      "index": {
        "description": "Attempts to extract an element from the queue if the queue is empty returns Nothing The default implementation uses peek and delete",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "extract",
        "normalized": "a-\u003eMaybe(QueueKey a,a)",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003eMaybe(QueueKey q,q)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003eConstructs a queue with all of the elements in the list.  The default implementation uses \u003ccode\u003e\u003ca\u003einsertAll\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "[QueueKey q] -\u003e q",
        "fct-source": "src/Data-Queue-Class.html#fromList",
        "fct-type": "method",
        "title": "fromList"
      },
      "index": {
        "description": "Constructs queue with all of the elements in the list The default implementation uses insertAll and empty",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "fromList",
        "normalized": "[QueueKey a]-\u003ea",
        "package": "queuelike",
        "partial": "List",
        "signature": "[QueueKey q]-\u003eq"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:insert",
      "description": {
        "fct-descr": "\u003cp\u003eInserts a single element into the queue.  The default implementation uses \u003ccode\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esingleton\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "QueueKey q -\u003e q -\u003e q",
        "fct-source": "src/Data-Queue-Class.html#insert",
        "fct-type": "method",
        "title": "insert"
      },
      "index": {
        "description": "Inserts single element into the queue The default implementation uses merge and singleton",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "insert",
        "normalized": "QueueKey a-\u003ea-\u003ea",
        "package": "queuelike",
        "partial": "",
        "signature": "QueueKey q-\u003eq-\u003eq"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:insertAll",
      "description": {
        "fct-descr": "\u003cp\u003eInserts several elements into the queue.  The default implementation uses \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e.  (In some cases, it may be advantageous to override this implementation with \u003ccode\u003exs `\u003ccode\u003e\u003ca\u003einsertAll\u003c/a\u003e\u003c/code\u003e` q = q `\u003ccode\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/code\u003e` \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.)\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "[QueueKey q] -\u003e q -\u003e q",
        "fct-source": "src/Data-Queue-Class.html#insertAll",
        "fct-type": "method",
        "title": "insertAll"
      },
      "index": {
        "description": "Inserts several elements into the queue The default implementation uses insert In some cases it may be advantageous to override this implementation with xs insertAll merge fromList xs",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "insertAll",
        "normalized": "[QueueKey a]-\u003ea-\u003ea",
        "package": "queuelike",
        "partial": "All",
        "signature": "[QueueKey q]-\u003eq-\u003eq"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:merge",
      "description": {
        "fct-descr": "\u003cp\u003eMerges two queues so that the contents of the second queue are inserted into the first queue in extraction order.  The default implementation uses \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003einsertAll\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e q -\u003e q",
        "fct-source": "src/Data-Queue-Class.html#merge",
        "fct-type": "method",
        "title": "merge"
      },
      "index": {
        "description": "Merges two queues so that the contents of the second queue are inserted into the first queue in extraction order The default implementation uses toList and insertAll",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "merge",
        "normalized": "a-\u003ea-\u003ea",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003eq-\u003eq"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:mergeAll",
      "description": {
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "[q] -\u003e q",
        "fct-source": "src/Data-Queue-Class.html#mergeAll",
        "fct-type": "method",
        "title": "mergeAll"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "mergeAll",
        "normalized": "[a]-\u003ea",
        "package": "queuelike",
        "partial": "All",
        "signature": "[q]-\u003eq"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eChecks if the queue is empty.  The default implementation uses \u003ccode\u003epeek\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e Bool",
        "fct-source": "src/Data-Queue-Class.html#null",
        "fct-type": "method",
        "title": "null"
      },
      "index": {
        "description": "Checks if the queue is empty The default implementation uses peek",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "null",
        "normalized": "a-\u003eBool",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003eConstructs a queue with a single element.  The default implementation uses \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "QueueKey q -\u003e q",
        "fct-source": "src/Data-Queue-Class.html#singleton",
        "fct-type": "method",
        "title": "singleton"
      },
      "index": {
        "description": "Constructs queue with single element The default implementation uses insert and empty",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "singleton",
        "normalized": "QueueKey a-\u003ea",
        "package": "queuelike",
        "partial": "",
        "signature": "QueueKey q-\u003eq"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:size",
      "description": {
        "fct-descr": "\u003cp\u003eGets the size of the queue.  The default implementation uses \u003ccode\u003e\u003ca\u003etoList_\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e Int",
        "fct-source": "src/Data-Queue-Class.html#size",
        "fct-type": "method",
        "title": "size"
      },
      "index": {
        "description": "Gets the size of the queue The default implementation uses toList",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "size",
        "normalized": "a-\u003eInt",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003eExtracts every element from the queue.  The default implementation uses \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e [QueueKey q]",
        "fct-source": "src/Data-Queue-Class.html#toList",
        "fct-type": "method",
        "title": "toList"
      },
      "index": {
        "description": "Extracts every element from the queue The default implementation uses extract",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "toList",
        "normalized": "a-\u003e[QueueKey a]",
        "package": "queuelike",
        "partial": "List",
        "signature": "q-\u003e[QueueKey q]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:toList_",
      "description": {
        "fct-descr": "\u003cp\u003eExtracts every element from the queue, with no guarantees upon order.  The default implementation uses \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e [QueueKey q]",
        "fct-source": "src/Data-Queue-Class.html#toList_",
        "fct-type": "method",
        "title": "toList_"
      },
      "index": {
        "description": "Extracts every element from the queue with no guarantees upon order The default implementation uses toList",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "toList_",
        "normalized": "a-\u003e[QueueKey a]",
        "package": "queuelike",
        "partial": "List",
        "signature": "q-\u003e[QueueKey q]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Class.html#v:top",
      "description": {
        "fct-descr": "\u003cp\u003eGets the element that will next be extracted from the queue, if there is an element available.  The default implementation uses \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Class",
        "fct-package": "queuelike",
        "fct-signature": "q -\u003e Maybe (QueueKey q)",
        "fct-source": "src/Data-Queue-Class.html#top",
        "fct-type": "method",
        "title": "top"
      },
      "index": {
        "description": "Gets the element that will next be extracted from the queue if there is an element available The default implementation uses extract",
        "hierarchy": "Data Queue Class",
        "module": "Data.Queue.Class",
        "name": "top",
        "normalized": "a-\u003eMaybe(QueueKey a)",
        "package": "queuelike",
        "partial": "",
        "signature": "q-\u003eMaybe(QueueKey q)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Instances.html#",
      "description": {
        "fct-module": "Data.Queue.Instances",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue-Instances.html",
        "fct-type": "module",
        "title": "Instances"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Instances",
        "module": "Data.Queue.Instances",
        "name": "Instances",
        "normalized": "",
        "package": "queuelike",
        "partial": "Instances",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-PQueue.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn efficient implementation of a priority queue.\n\u003c/p\u003e\u003cp\u003eThe implementation of \u003ccode\u003e\u003ca\u003ePQueue\u003c/a\u003e\u003c/code\u003e is based on a \u003cem\u003epairing heap\u003c/em\u003e, a simple and efficient implementation of a general-purpose priority queue.  \u003ccode\u003e\u003ca\u003ePQueue\u003c/a\u003e\u003c/code\u003e supports \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003epeek\u003c/code\u003e in constant time, and \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e in logarithmic time.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Queue.PQueue",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue-PQueue.html",
        "fct-type": "module",
        "title": "PQueue"
      },
      "index": {
        "description": "An efficient implementation of priority queue The implementation of PQueue is based on pairing heap simple and efficient implementation of general-purpose priority queue PQueue supports insert merge and peek in constant time and extract and delete in logarithmic time",
        "hierarchy": "Data Queue PQueue",
        "module": "Data.Queue.PQueue",
        "name": "PQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "PQueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-PQueue.html#t:PQueue",
      "description": {
        "fct-module": "Data.Queue.PQueue",
        "fct-package": "queuelike",
        "fct-signature": "data",
        "fct-source": "src/Data-Queue-PQueue.html#PQueue",
        "fct-type": "data",
        "title": "PQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue PQueue",
        "module": "Data.Queue.PQueue",
        "name": "PQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "PQueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-PQueue.html#v:drawQueue",
      "description": {
        "fct-module": "Data.Queue.PQueue",
        "fct-package": "queuelike",
        "fct-signature": "PQueue e -\u003e String",
        "fct-source": "src/Data-Queue-PQueue.html#drawQueue",
        "fct-type": "function",
        "title": "drawQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue PQueue",
        "module": "Data.Queue.PQueue",
        "name": "drawQueue",
        "normalized": "PQueue a-\u003eString",
        "package": "queuelike",
        "partial": "Queue",
        "signature": "PQueue e-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Queue.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA basic first-in, first-out queue implementation implementing the \u003ccode\u003eQueuelike\u003c/code\u003e abstraction.  Bootstrapped from \u003ca\u003eData.Sequence\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Queue.Queue",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue-Queue.html",
        "fct-type": "module",
        "title": "Queue"
      },
      "index": {
        "description": "basic first-in first-out queue implementation implementing the Queuelike abstraction Bootstrapped from Data.Sequence",
        "hierarchy": "Data Queue Queue",
        "module": "Data.Queue.Queue",
        "name": "Queue",
        "normalized": "",
        "package": "queuelike",
        "partial": "Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Queue.html#t:Queue",
      "description": {
        "fct-module": "Data.Queue.Queue",
        "fct-package": "queuelike",
        "fct-signature": "data",
        "fct-source": "src/Data-Queue-Queue.html#Queue",
        "fct-type": "data",
        "title": "Queue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Queue",
        "module": "Data.Queue.Queue",
        "name": "Queue",
        "normalized": "",
        "package": "queuelike",
        "partial": "Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Queue.html#v:cons",
      "description": {
        "fct-module": "Data.Queue.Queue",
        "fct-package": "queuelike",
        "fct-signature": "e -\u003e Queue e -\u003e Queue e",
        "fct-source": "src/Data-Queue-Queue.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Queue",
        "module": "Data.Queue.Queue",
        "name": "cons",
        "normalized": "a-\u003eQueue a-\u003eQueue a",
        "package": "queuelike",
        "partial": "",
        "signature": "e-\u003eQueue e-\u003eQueue e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Stack.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA basic implementation of a stack implementing the \u003ccode\u003eQueue\u003c/code\u003e abstraction.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Queue.Stack",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue-Stack.html",
        "fct-type": "module",
        "title": "Stack"
      },
      "index": {
        "description": "basic implementation of stack implementing the Queue abstraction",
        "hierarchy": "Data Queue Stack",
        "module": "Data.Queue.Stack",
        "name": "Stack",
        "normalized": "",
        "package": "queuelike",
        "partial": "Stack",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-Stack.html#t:Stack",
      "description": {
        "fct-module": "Data.Queue.Stack",
        "fct-package": "queuelike",
        "fct-signature": "data",
        "fct-source": "src/Data-Queue-Stack.html#Stack",
        "fct-type": "data",
        "title": "Stack"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Stack",
        "module": "Data.Queue.Stack",
        "name": "Stack",
        "normalized": "",
        "package": "queuelike",
        "partial": "Stack",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-TrieQueue.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003eTrieQueue e\u003c/code\u003e is a priority queue \u003ccode\u003eIQueue\u003c/code\u003e instance satisfying \u003ccode\u003eQueueKey (TrieQueue e) ~ [e]\u003c/code\u003e, with the property that this queue frequently performs better than any other queue\n implementation in this package for keys of type \u003ccode\u003e[e]\u003c/code\u003e.  \n\u003c/p\u003e\u003cp\u003eThis particular implementation is highly experimental and possibly a genuinely new data structure.  See the source code for details.\n However, for many cases this priority queue may be used for a heap sort that runs faster than the \u003ca\u003eData.List\u003c/a\u003e implementation,\n or the vanilla \u003ca\u003eData.Queue.PQueue\u003c/a\u003e implementation.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Queue.TrieQueue",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue-TrieQueue.html",
        "fct-type": "module",
        "title": "TrieQueue"
      },
      "index": {
        "description": "TrieQueue is priority queue IQueue instance satisfying QueueKey TrieQueue with the property that this queue frequently performs better than any other queue implementation in this package for keys of type This particular implementation is highly experimental and possibly genuinely new data structure See the source code for details However for many cases this priority queue may be used for heap sort that runs faster than the Data.List implementation or the vanilla Data.Queue.PQueue implementation",
        "hierarchy": "Data Queue TrieQueue",
        "module": "Data.Queue.TrieQueue",
        "name": "TrieQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "Trie Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue-TrieQueue.html#t:TrieQueue",
      "description": {
        "fct-module": "Data.Queue.TrieQueue",
        "fct-package": "queuelike",
        "fct-signature": "data",
        "fct-source": "src/Data-Queue-TrieQueue.html#TrieQueue",
        "fct-type": "data",
        "title": "TrieQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue TrieQueue",
        "module": "Data.Queue.TrieQueue",
        "name": "TrieQueue",
        "normalized": "",
        "package": "queuelike",
        "partial": "Trie Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queuelike/docs/Data-Queue.html#",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queuelike",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue.html",
        "fct-type": "module",
        "title": "Queue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "Queue",
        "normalized": "",
        "package": "queuelike",
        "partial": "Queue",
        "signature": ""
      }
    }
  }
]
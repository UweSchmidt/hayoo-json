[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation module for \u003ca\u003eData.List.Split\u003c/a\u003e, a combinator library\n for splitting lists.  See the \u003ca\u003eData.List.Split\u003c/a\u003e documentation for\n more description and examples.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "module",
        "fct-source": "src/Data-List-Split-Internals.html",
        "fct-type": "module",
        "title": "Internals"
      },
      "index": {
        "description": "Implementation module for Data.List.Split combinator library for splitting lists See the Data.List.Split documentation for more description and examples",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Internals",
        "normalized": "",
        "package": "split",
        "partial": "Internals",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#t:Chunk",
      "description": {
        "fct-descr": "\u003cp\u003eTag chunks as delimiters or text.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "data",
        "fct-source": "src/Data-List-Split-Internals.html#Chunk",
        "fct-type": "data",
        "title": "Chunk"
      },
      "index": {
        "description": "Tag chunks as delimiters or text",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Chunk",
        "normalized": "",
        "package": "split",
        "partial": "Chunk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#t:CondensePolicy",
      "description": {
        "fct-descr": "\u003cp\u003eWhat to do with multiple consecutive delimiters?\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "data",
        "fct-source": "src/Data-List-Split-Internals.html#CondensePolicy",
        "fct-type": "data",
        "title": "CondensePolicy"
      },
      "index": {
        "description": "What to do with multiple consecutive delimiters",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "CondensePolicy",
        "normalized": "",
        "package": "split",
        "partial": "Condense Policy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#t:DelimPolicy",
      "description": {
        "fct-descr": "\u003cp\u003eWhat to do with delimiters?\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "data",
        "fct-source": "src/Data-List-Split-Internals.html#DelimPolicy",
        "fct-type": "data",
        "title": "DelimPolicy"
      },
      "index": {
        "description": "What to do with delimiters",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "DelimPolicy",
        "normalized": "",
        "package": "split",
        "partial": "Delim Policy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#t:Delimiter",
      "description": {
        "fct-descr": "\u003cp\u003eA delimiter is a list of predicates on elements, matched by some\n   contiguous subsequence of a list.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "newtype",
        "fct-source": "src/Data-List-Split-Internals.html#Delimiter",
        "fct-type": "newtype",
        "title": "Delimiter"
      },
      "index": {
        "description": "delimiter is list of predicates on elements matched by some contiguous subsequence of list",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Delimiter",
        "normalized": "",
        "package": "split",
        "partial": "Delimiter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#t:EndPolicy",
      "description": {
        "fct-descr": "\u003cp\u003eWhat to do with a blank chunk at either end of the list\n   (\u003cem\u003ei.e.\u003c/em\u003e when the list begins or ends with a delimiter).\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "data",
        "fct-source": "src/Data-List-Split-Internals.html#EndPolicy",
        "fct-type": "data",
        "title": "EndPolicy"
      },
      "index": {
        "description": "What to do with blank chunk at either end of the list i.e when the list begins or ends with delimiter",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "EndPolicy",
        "normalized": "",
        "package": "split",
        "partial": "End Policy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#t:SplitList",
      "description": {
        "fct-descr": "\u003cp\u003eInternal representation of a split list that tracks which pieces\n   are delimiters and which aren't.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "type",
        "fct-source": "src/Data-List-Split-Internals.html#SplitList",
        "fct-type": "type",
        "title": "SplitList"
      },
      "index": {
        "description": "Internal representation of split list that tracks which pieces are delimiters and which aren",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "SplitList",
        "normalized": "",
        "package": "split",
        "partial": "Split List",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#t:Splitter",
      "description": {
        "fct-descr": "\u003cp\u003eA splitting strategy.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "data",
        "fct-source": "src/Data-List-Split-Internals.html#Splitter",
        "fct-type": "data",
        "title": "Splitter"
      },
      "index": {
        "description": "splitting strategy",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Splitter",
        "normalized": "",
        "package": "split",
        "partial": "Splitter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:Condense",
      "description": {
        "fct-descr": "\u003cp\u003eCondense into a single delimiter.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Condense",
        "fct-source": "src/Data-List-Split-Internals.html#CondensePolicy",
        "fct-type": "function",
        "title": "Condense"
      },
      "index": {
        "description": "Condense into single delimiter",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Condense",
        "normalized": "",
        "package": "split",
        "partial": "Condense",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:Delim",
      "description": {
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Delim [a]",
        "fct-source": "src/Data-List-Split-Internals.html#Chunk",
        "fct-type": "function",
        "title": "Delim"
      },
      "index": {
        "description": "",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Delim",
        "normalized": "Delim[a]",
        "package": "split",
        "partial": "Delim",
        "signature": "Delim[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:Delimiter",
      "description": {
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Delimiter [a -\u003e Bool]",
        "fct-source": "src/Data-List-Split-Internals.html#Delimiter",
        "fct-type": "function",
        "title": "Delimiter"
      },
      "index": {
        "description": "",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Delimiter",
        "normalized": "Delimiter[a-\u003eBool]",
        "package": "split",
        "partial": "Delimiter",
        "signature": "Delimiter[a-\u003eBool]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:Drop",
      "description": {
        "fct-descr": "\u003cp\u003eDrop delimiters from the output.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Drop",
        "fct-source": "src/Data-List-Split-Internals.html#DelimPolicy",
        "fct-type": "function",
        "title": "Drop"
      },
      "index": {
        "description": "Drop delimiters from the output",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Drop",
        "normalized": "",
        "package": "split",
        "partial": "Drop",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:DropBlank",
      "description": {
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "DropBlank",
        "fct-source": "src/Data-List-Split-Internals.html#EndPolicy",
        "fct-type": "function",
        "title": "DropBlank"
      },
      "index": {
        "description": "",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "DropBlank",
        "normalized": "",
        "package": "split",
        "partial": "Drop Blank",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:DropBlankFields",
      "description": {
        "fct-descr": "\u003cp\u003eKeep consecutive\n   delimiters separate, but\n   don't insert blank chunks in\n   between them.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "DropBlankFields",
        "fct-source": "src/Data-List-Split-Internals.html#CondensePolicy",
        "fct-type": "function",
        "title": "DropBlankFields"
      },
      "index": {
        "description": "Keep consecutive delimiters separate but don insert blank chunks in between them",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "DropBlankFields",
        "normalized": "",
        "package": "split",
        "partial": "Drop Blank Fields",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:Keep",
      "description": {
        "fct-descr": "\u003cp\u003eKeep delimiters as separate chunks\n   of the output.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Keep",
        "fct-source": "src/Data-List-Split-Internals.html#DelimPolicy",
        "fct-type": "function",
        "title": "Keep"
      },
      "index": {
        "description": "Keep delimiters as separate chunks of the output",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Keep",
        "normalized": "",
        "package": "split",
        "partial": "Keep",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:KeepBlank",
      "description": {
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "KeepBlank",
        "fct-source": "src/Data-List-Split-Internals.html#EndPolicy",
        "fct-type": "function",
        "title": "KeepBlank"
      },
      "index": {
        "description": "",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "KeepBlank",
        "normalized": "",
        "package": "split",
        "partial": "Keep Blank",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:KeepBlankFields",
      "description": {
        "fct-descr": "\u003cp\u003eInsert blank chunks\n   between consecutive\n   delimiters.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "KeepBlankFields",
        "fct-source": "src/Data-List-Split-Internals.html#CondensePolicy",
        "fct-type": "function",
        "title": "KeepBlankFields"
      },
      "index": {
        "description": "Insert blank chunks between consecutive delimiters",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "KeepBlankFields",
        "normalized": "",
        "package": "split",
        "partial": "Keep Blank Fields",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:KeepLeft",
      "description": {
        "fct-descr": "\u003cp\u003eKeep delimiters in the output,\n   prepending them to the following\n   chunk.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "KeepLeft",
        "fct-source": "src/Data-List-Split-Internals.html#DelimPolicy",
        "fct-type": "function",
        "title": "KeepLeft"
      },
      "index": {
        "description": "Keep delimiters in the output prepending them to the following chunk",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "KeepLeft",
        "normalized": "",
        "package": "split",
        "partial": "Keep Left",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:KeepRight",
      "description": {
        "fct-descr": "\u003cp\u003eKeep delimiters in the output,\n   appending them to the previous chunk.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "KeepRight",
        "fct-source": "src/Data-List-Split-Internals.html#DelimPolicy",
        "fct-type": "function",
        "title": "KeepRight"
      },
      "index": {
        "description": "Keep delimiters in the output appending them to the previous chunk",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "KeepRight",
        "normalized": "",
        "package": "split",
        "partial": "Keep Right",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:Splitter",
      "description": {
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter",
        "fct-source": "src/Data-List-Split-Internals.html#Splitter",
        "fct-type": "function",
        "title": "Splitter"
      },
      "index": {
        "description": "",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Splitter",
        "normalized": "",
        "package": "split",
        "partial": "Splitter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:Text",
      "description": {
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Text [a]",
        "fct-source": "src/Data-List-Split-Internals.html#Chunk",
        "fct-type": "function",
        "title": "Text"
      },
      "index": {
        "description": "",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "Text",
        "normalized": "Text[a]",
        "package": "split",
        "partial": "Text",
        "signature": "Text[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:build",
      "description": {
        "fct-descr": "\u003cp\u003eStandard build function, specialized to building lists.\n\u003c/p\u003e\u003cp\u003eUsually build is given the rank-2 type\n\u003c/p\u003e\u003cpre\u003e build :: (forall b. (a -\u003e b -\u003e b) -\u003e b -\u003e b) -\u003e [a]\n\u003c/pre\u003e\u003cp\u003ebut since we only use it when \u003ccode\u003e(b ~ [a])\u003c/code\u003e, we give it the more\n   restricted type signature in order to avoid needing a\n   non-Haskell2010 extension.\n\u003c/p\u003e\u003cp\u003eNote that the 0.1.4.3 release of this package did away with a\n   custom \u003ccode\u003ebuild\u003c/code\u003e implementation in favor of importing one from\n   \u003ca\u003eGHC.Exts\u003c/a\u003e, which was (reportedly) faster for some applications.\n   However, in the interest of simplicity and complete Haskell2010\n   compliance as \u003ccode\u003esplit\u003c/code\u003e is being included in the Haskel Platform,\n   version 0.2.1.0 has gone back to defining \u003ccode\u003ebuild\u003c/code\u003e manually.  This\n   is in line with \u003ccode\u003esplit\u003c/code\u003e's design philosophy of having efficiency\n   as a non-goal.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "((a -\u003e [a] -\u003e [a]) -\u003e [a] -\u003e [a]) -\u003e [a]",
        "fct-source": "src/Data-List-Split-Internals.html#build",
        "fct-type": "function",
        "title": "build"
      },
      "index": {
        "description": "Standard build function specialized to building lists Usually build is given the rank-2 type build forall but since we only use it when we give it the more restricted type signature in order to avoid needing non-Haskell2010 extension Note that the release of this package did away with custom build implementation in favor of importing one from GHC.Exts which was reportedly faster for some applications However in the interest of simplicity and complete Haskell2010 compliance as split is being included in the Haskel Platform version has gone back to defining build manually This is in line with split design philosophy of having efficiency as non-goal",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "build",
        "normalized": "((a-\u003e[a]-\u003e[a])-\u003e[a]-\u003e[a])-\u003e[a]",
        "package": "split",
        "partial": "",
        "signature": "((a-\u003e[a]-\u003e[a])-\u003e[a]-\u003e[a])-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:chop",
      "description": {
        "fct-descr": "\u003cp\u003eA useful recursion pattern for processing a list to produce a new\n   list, often used for \"chopping\" up the input list.  Typically\n   chop is called with some function that will consume an initial\n   prefix of the list and produce a value and the rest of the list.\n\u003c/p\u003e\u003cp\u003eFor example, many common Prelude functions can be implemented in\n   terms of \u003ccode\u003echop\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e group :: (Eq a) =\u003e [a] -\u003e [[a]]\n group = chop (\\ xs@(x:_) -\u003e span (==x) xs)\n\n words :: String -\u003e [String]\n words = filter (not . null) . chop (span (not . isSpace) . dropWhile isSpace)\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "([a] -\u003e (b, [a])) -\u003e [a] -\u003e [b]",
        "fct-source": "src/Data-List-Split-Internals.html#chop",
        "fct-type": "function",
        "title": "chop"
      },
      "index": {
        "description": "useful recursion pattern for processing list to produce new list often used for chopping up the input list Typically chop is called with some function that will consume an initial prefix of the list and produce value and the rest of the list For example many common Prelude functions can be implemented in terms of chop group Eq group chop xs span xs words String String words filter not null chop span not isSpace dropWhile isSpace",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "chop",
        "normalized": "([a]-\u003e(b,[a]))-\u003e[a]-\u003e[b]",
        "package": "split",
        "partial": "",
        "signature": "([a]-\u003e(b,[a]))-\u003e[a]-\u003e[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:chunksOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e splits a list into length-n pieces.  The last\n   piece will be shorter if \u003ccode\u003en\u003c/code\u003e does not evenly divide the length of\n   the list.  If \u003ccode\u003en \u003c= 0\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e n l\u003c/code\u003e returns an infinite list\n   of empty lists.  For example:\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e n []\u003c/code\u003e is \u003ccode\u003e[]\u003c/code\u003e, not \u003ccode\u003e[[]]\u003c/code\u003e.  This is\n   intentional, and is consistent with a recursive definition of\n   \u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e; it satisfies the property that\n\u003c/p\u003e\u003cpre\u003echunksOf n xs ++ chunksOf n ys == chunksOf n (xs ++ ys)\u003c/pre\u003e\u003cp\u003ewhenever \u003ccode\u003en\u003c/code\u003e evenly divides the length of \u003ccode\u003exs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Int -\u003e [e] -\u003e [[e]]",
        "fct-source": "src/Data-List-Split-Internals.html#chunksOf",
        "fct-type": "function",
        "title": "chunksOf"
      },
      "index": {
        "description": "chunksOf splits list into length-n pieces The last piece will be shorter if does not evenly divide the length of the list If chunksOf returns an infinite list of empty lists For example Note that chunksOf is not This is intentional and is consistent with recursive definition of chunksOf it satisfies the property that chunksOf xs chunksOf ys chunksOf xs ys whenever evenly divides the length of xs",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "chunksOf",
        "normalized": "Int-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "Of",
        "signature": "Int-\u003e[e]-\u003e[[e]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:condense",
      "description": {
        "fct-descr": "\u003cp\u003eCondense multiple consecutive delimiters into one.  For example:\n\u003c/p\u003e\u003cpre\u003e split (condense $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"z\",\"b\",\"xyz\",\"c\",\"x\",\"d\"]\n split (dropDelims $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"b\",\"\",\"\",\"c\",\"d\"]\n split (condense . dropDelims $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"b\",\"c\",\"d\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#condense",
        "fct-type": "function",
        "title": "condense"
      },
      "index": {
        "description": "Condense multiple consecutive delimiters into one For example split condense oneOf xyz aazbxyzcxd aa xyz split dropDelims oneOf xyz aazbxyzcxd aa split condense dropDelims oneOf xyz aazbxyzcxd aa",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "condense",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:condensePolicy",
      "description": {
        "fct-descr": "\u003cp\u003eWhat to do with multiple\n   consecutive delimiters\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "CondensePolicy",
        "fct-source": "src/Data-List-Split-Internals.html#Splitter",
        "fct-type": "function",
        "title": "condensePolicy"
      },
      "index": {
        "description": "What to do with multiple consecutive delimiters",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "condensePolicy",
        "normalized": "",
        "package": "split",
        "partial": "Policy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:defaultSplitter",
      "description": {
        "fct-descr": "\u003cp\u003eThe default splitting strategy: keep delimiters in the output\n   as separate chunks, don't condense multiple consecutive\n   delimiters into one, keep initial and final blank chunks.\n   Default delimiter is the constantly false predicate.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003edefaultSplitter\u003c/a\u003e\u003c/code\u003e should normally not be used; use\n   \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e instead, which are the same as\n   the \u003ccode\u003e\u003ca\u003edefaultSplitter\u003c/a\u003e\u003c/code\u003e with just the delimiter overridden.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003edefaultSplitter\u003c/a\u003e\u003c/code\u003e strategy with any delimiter gives a\n   maximally information-preserving splitting strategy, in the sense\n   that (a) taking the \u003ccode\u003e\u003ca\u003econcat\u003c/a\u003e\u003c/code\u003e of the output yields the original\n   list, and (b) given only the output list, we can reconstruct a\n   \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e which would produce the same output list again given\n   the original input list.  This default strategy can be overridden\n   to allow discarding various sorts of information.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#defaultSplitter",
        "fct-type": "function",
        "title": "defaultSplitter"
      },
      "index": {
        "description": "The default splitting strategy keep delimiters in the output as separate chunks don condense multiple consecutive delimiters into one keep initial and final blank chunks Default delimiter is the constantly false predicate Note that defaultSplitter should normally not be used use oneOf onSublist or whenElt instead which are the same as the defaultSplitter with just the delimiter overridden The defaultSplitter strategy with any delimiter gives maximally information-preserving splitting strategy in the sense that taking the concat of the output yields the original list and given only the output list we can reconstruct Splitter which would produce the same output list again given the original input list This default strategy can be overridden to allow discarding various sorts of information",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "defaultSplitter",
        "normalized": "",
        "package": "split",
        "partial": "Splitter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:delimPolicy",
      "description": {
        "fct-descr": "\u003cp\u003eWhat to do with delimiters (drop\n   from output, keep as separate\n   elements in output, or merge with\n   previous or following chunks)\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "DelimPolicy",
        "fct-source": "src/Data-List-Split-Internals.html#Splitter",
        "fct-type": "function",
        "title": "delimPolicy"
      },
      "index": {
        "description": "What to do with delimiters drop from output keep as separate elements in output or merge with previous or following chunks",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "delimPolicy",
        "normalized": "",
        "package": "split",
        "partial": "Policy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:delimiter",
      "description": {
        "fct-descr": "\u003cp\u003eWhat delimiter to split on\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Delimiter a",
        "fct-source": "src/Data-List-Split-Internals.html#Splitter",
        "fct-type": "function",
        "title": "delimiter"
      },
      "index": {
        "description": "What delimiter to split on",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "delimiter",
        "normalized": "",
        "package": "split",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:doCondense",
      "description": {
        "fct-descr": "\u003cp\u003eCondense multiple consecutive delimiters into one if the\n   \u003ccode\u003e\u003ca\u003eCondensePolicy\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eCondense\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "CondensePolicy -\u003e SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#doCondense",
        "fct-type": "function",
        "title": "doCondense"
      },
      "index": {
        "description": "Condense multiple consecutive delimiters into one if the CondensePolicy is Condense",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "doCondense",
        "normalized": "CondensePolicy-\u003eSplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Condense",
        "signature": "CondensePolicy-\u003eSplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:doDrop",
      "description": {
        "fct-descr": "\u003cp\u003eDrop delimiters if the \u003ccode\u003e\u003ca\u003eDelimPolicy\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eDrop\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "DelimPolicy -\u003e SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#doDrop",
        "fct-type": "function",
        "title": "doDrop"
      },
      "index": {
        "description": "Drop delimiters if the DelimPolicy is Drop",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "doDrop",
        "normalized": "DelimPolicy-\u003eSplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Drop",
        "signature": "DelimPolicy-\u003eSplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:doMerge",
      "description": {
        "fct-descr": "\u003cp\u003eMerge delimiters into adjacent chunks according to the \u003ccode\u003e\u003ca\u003eDelimPolicy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "DelimPolicy -\u003e SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#doMerge",
        "fct-type": "function",
        "title": "doMerge"
      },
      "index": {
        "description": "Merge delimiters into adjacent chunks according to the DelimPolicy",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "doMerge",
        "normalized": "DelimPolicy-\u003eSplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Merge",
        "signature": "DelimPolicy-\u003eSplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:dropBlanks",
      "description": {
        "fct-descr": "\u003cp\u003eDrop all blank chunks from the output, and condense consecutive\n   delimiters into one.  Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropInitBlank\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003econdense\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \"::b:::a\" == [\"\",\":\",\"\",\":\",\"b\",\":\",\"\",\":\",\"\",\":\",\"a\"]\n split (dropBlanks $ oneOf \":\") \"::b:::a\" == [\"::\",\"b\",\":::\",\"a\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropBlanks",
        "fct-type": "function",
        "title": "dropBlanks"
      },
      "index": {
        "description": "Drop all blank chunks from the output and condense consecutive delimiters into one Equivalent to dropInitBlank dropFinalBlank condense For example split oneOf split dropBlanks oneOf",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "dropBlanks",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Blanks",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:dropDelims",
      "description": {
        "fct-descr": "\u003cp\u003eDrop delimiters from the output (the default is to keep\n   them). For example,\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \"a:b:c\" == [\"a\", \":\", \"b\", \":\", \"c\"]\n split (dropDelims $ oneOf \":\") \"a:b:c\" == [\"a\", \"b\", \"c\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropDelims",
        "fct-type": "function",
        "title": "dropDelims"
      },
      "index": {
        "description": "Drop delimiters from the output the default is to keep them For example split oneOf split dropDelims oneOf",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "dropDelims",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Delims",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:dropFinal",
      "description": {
        "fct-descr": "\u003cp\u003eDrop a final blank chunk according to the given \u003ccode\u003e\u003ca\u003eEndPolicy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "EndPolicy -\u003e SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#dropFinal",
        "fct-type": "function",
        "title": "dropFinal"
      },
      "index": {
        "description": "Drop final blank chunk according to the given EndPolicy",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "dropFinal",
        "normalized": "EndPolicy-\u003eSplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Final",
        "signature": "EndPolicy-\u003eSplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:dropFinalBlank",
      "description": {
        "fct-descr": "\u003cp\u003eDon't generate a blank chunk if there is a delimiter at the end.\n   For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \"a:b:\" == [\"a\",\":\",\"b\",\":\",\"\"]\n split (dropFinalBlank $ oneOf \":\") \"a:b:\" == [\"a\",\":\",\"b\",\":\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropFinalBlank",
        "fct-type": "function",
        "title": "dropFinalBlank"
      },
      "index": {
        "description": "Don generate blank chunk if there is delimiter at the end For example split oneOf split dropFinalBlank oneOf",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "dropFinalBlank",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Final Blank",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:dropInitBlank",
      "description": {
        "fct-descr": "\u003cp\u003eDon't generate a blank chunk if there is a delimiter at the\n   beginning.  For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \":a:b\" == [\"\",\":\",\"a\",\":\",\"b\"]\n split (dropInitBlank $ oneOf \":\") \":a:b\" == [\":\",\"a\",\":\",\"b\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropInitBlank",
        "fct-type": "function",
        "title": "dropInitBlank"
      },
      "index": {
        "description": "Don generate blank chunk if there is delimiter at the beginning For example split oneOf split dropInitBlank oneOf",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "dropInitBlank",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Init Blank",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:dropInitial",
      "description": {
        "fct-descr": "\u003cp\u003eDrop an initial blank chunk according to the given \u003ccode\u003e\u003ca\u003eEndPolicy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "EndPolicy -\u003e SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#dropInitial",
        "fct-type": "function",
        "title": "dropInitial"
      },
      "index": {
        "description": "Drop an initial blank chunk according to the given EndPolicy",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "dropInitial",
        "normalized": "EndPolicy-\u003eSplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Initial",
        "signature": "EndPolicy-\u003eSplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:dropInnerBlanks",
      "description": {
        "fct-descr": "\u003cp\u003eDon't generate blank chunks between consecutive delimiters.\n   For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \"::b:::a\" == [\"\",\":\",\"\",\":\",\"b\",\":\",\"\",\":\",\"\",\":\",\"a\"]\n split (dropInnerBlanks $ oneOf \":\") \"::b:::a\" == [\"\", \":\",\":\",\"b\",\":\",\":\",\":\",\"a\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropInnerBlanks",
        "fct-type": "function",
        "title": "dropInnerBlanks"
      },
      "index": {
        "description": "Don generate blank chunks between consecutive delimiters For example split oneOf split dropInnerBlanks oneOf",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "dropInnerBlanks",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Inner Blanks",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:endBy",
      "description": {
        "fct-descr": "\u003cp\u003eSplit into chunks terminated by the given subsequence.\n   Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e endBy \";\" \"foo;bar;baz;\" == [\"foo\",\"bar\",\"baz\"]\n\u003c/pre\u003e\u003cp\u003eNote also that the \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e function from \u003ca\u003eData.List\u003c/a\u003e is equivalent\n   to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eendBy\u003c/a\u003e\u003c/code\u003e \"\\n\"\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#endBy",
        "fct-type": "function",
        "title": "endBy"
      },
      "index": {
        "description": "Split into chunks terminated by the given subsequence Equivalent to split dropFinalBlank dropDelims onSublist For example endBy foo bar baz foo bar baz Note also that the lines function from Data.List is equivalent to endBy",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "endBy",
        "normalized": "[a]-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "By",
        "signature": "[a]-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:endByOneOf",
      "description": {
        "fct-descr": "\u003cp\u003eSplit into chunks terminated by one of the given elements.\n   Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. For example:\n\u003c/p\u003e\u003cpre\u003e endByOneOf \";,\" \"foo;bar,baz;\" == [\"foo\",\"bar\",\"baz\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#endByOneOf",
        "fct-type": "function",
        "title": "endByOneOf"
      },
      "index": {
        "description": "Split into chunks terminated by one of the given elements Equivalent to split dropFinalBlank dropDelims oneOf For example endByOneOf foo bar baz foo bar baz",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "endByOneOf",
        "normalized": "[a]-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "By One Of",
        "signature": "[a]-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:endsWith",
      "description": {
        "fct-descr": "\u003cp\u003eMake a strategy that splits a list into chunks that all end with\n   the given subsequence, except possibly the last.  Equivalent to\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ekeepDelimsR\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e split (endsWith \"ly\") \"happilyslowlygnarlylily\" == [\"happily\",\"slowly\",\"gnarly\",\"lily\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#endsWith",
        "fct-type": "function",
        "title": "endsWith"
      },
      "index": {
        "description": "Make strategy that splits list into chunks that all end with the given subsequence except possibly the last Equivalent to dropFinalBlank keepDelimsR onSublist For example split endsWith ly happilyslowlygnarlylily happily slowly gnarly lily",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "endsWith",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "With",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:endsWithOneOf",
      "description": {
        "fct-descr": "\u003cp\u003eMake a strategy that splits a list into chunks that all end with\n   one of the given elements, except possibly the last.  Equivalent\n   to \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ekeepDelimsR\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e split (condense $ endsWithOneOf \".,?! \") \"Hi, there!  How are you?\" == [\"Hi, \",\"there!  \",\"How \",\"are \",\"you?\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#endsWithOneOf",
        "fct-type": "function",
        "title": "endsWithOneOf"
      },
      "index": {
        "description": "Make strategy that splits list into chunks that all end with one of the given elements except possibly the last Equivalent to dropFinalBlank keepDelimsR oneOf For example split condense endsWithOneOf Hi there How are you Hi there How are you",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "endsWithOneOf",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "With One Of",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:finalBlankPolicy",
      "description": {
        "fct-descr": "\u003cp\u003eDrop a final blank?\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "EndPolicy",
        "fct-source": "src/Data-List-Split-Internals.html#Splitter",
        "fct-type": "function",
        "title": "finalBlankPolicy"
      },
      "index": {
        "description": "Drop final blank",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "finalBlankPolicy",
        "normalized": "",
        "package": "split",
        "partial": "Blank Policy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:fromElem",
      "description": {
        "fct-descr": "\u003cp\u003eUntag a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Chunk a -\u003e [a]",
        "fct-source": "src/Data-List-Split-Internals.html#fromElem",
        "fct-type": "function",
        "title": "fromElem"
      },
      "index": {
        "description": "Untag Chunk",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "fromElem",
        "normalized": "Chunk a-\u003e[a]",
        "package": "split",
        "partial": "Elem",
        "signature": "Chunk a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:initBlankPolicy",
      "description": {
        "fct-descr": "\u003cp\u003eDrop an initial blank?\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "EndPolicy",
        "fct-source": "src/Data-List-Split-Internals.html#Splitter",
        "fct-type": "function",
        "title": "initBlankPolicy"
      },
      "index": {
        "description": "Drop an initial blank",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "initBlankPolicy",
        "normalized": "",
        "package": "split",
        "partial": "Blank Policy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:insertBlanks",
      "description": {
        "fct-descr": "\u003cp\u003eInsert blank chunks between any remaining consecutive delimiters\n   (unless the condense policy is \u003ccode\u003e\u003ca\u003eDropBlankFields\u003c/a\u003e\u003c/code\u003e), and at the\n   beginning or end if the first or last element is a delimiter.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "CondensePolicy -\u003e SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#insertBlanks",
        "fct-type": "function",
        "title": "insertBlanks"
      },
      "index": {
        "description": "Insert blank chunks between any remaining consecutive delimiters unless the condense policy is DropBlankFields and at the beginning or end if the first or last element is delimiter",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "insertBlanks",
        "normalized": "CondensePolicy-\u003eSplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Blanks",
        "signature": "CondensePolicy-\u003eSplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:insertBlanks-39-",
      "description": {
        "fct-descr": "\u003cp\u003eInsert blank chunks between consecutive delimiters.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "CondensePolicy -\u003e SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#insertBlanks%27",
        "fct-type": "function",
        "title": "insertBlanks'"
      },
      "index": {
        "description": "Insert blank chunks between consecutive delimiters",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "insertBlanks'",
        "normalized": "CondensePolicy-\u003eSplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Blanks'",
        "signature": "CondensePolicy-\u003eSplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:isDelim",
      "description": {
        "fct-descr": "\u003cp\u003eTest whether a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e is a delimiter.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Chunk a -\u003e Bool",
        "fct-source": "src/Data-List-Split-Internals.html#isDelim",
        "fct-type": "function",
        "title": "isDelim"
      },
      "index": {
        "description": "Test whether Chunk is delimiter",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "isDelim",
        "normalized": "Chunk a-\u003eBool",
        "package": "split",
        "partial": "Delim",
        "signature": "Chunk a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:isText",
      "description": {
        "fct-descr": "\u003cp\u003eTest whether a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e is text.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Chunk a -\u003e Bool",
        "fct-source": "src/Data-List-Split-Internals.html#isText",
        "fct-type": "function",
        "title": "isText"
      },
      "index": {
        "description": "Test whether Chunk is text",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "isText",
        "normalized": "Chunk a-\u003eBool",
        "package": "split",
        "partial": "Text",
        "signature": "Chunk a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:keepDelimsL",
      "description": {
        "fct-descr": "\u003cp\u003eKeep delimiters in the output by prepending them to adjacent\n   chunks.  For example:\n\u003c/p\u003e\u003cpre\u003e split (keepDelimsL $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"zb\",\"x\",\"y\",\"zc\",\"xd\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#keepDelimsL",
        "fct-type": "function",
        "title": "keepDelimsL"
      },
      "index": {
        "description": "Keep delimiters in the output by prepending them to adjacent chunks For example split keepDelimsL oneOf xyz aazbxyzcxd aa zb zc xd",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "keepDelimsL",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Delims",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:keepDelimsR",
      "description": {
        "fct-descr": "\u003cp\u003eKeep delimiters in the output by appending them to adjacent\n   chunks. For example:\n\u003c/p\u003e\u003cpre\u003e split (keepDelimsR $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aaz\",\"bx\",\"y\",\"z\",\"cx\",\"d\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#keepDelimsR",
        "fct-type": "function",
        "title": "keepDelimsR"
      },
      "index": {
        "description": "Keep delimiters in the output by appending them to adjacent chunks For example split keepDelimsR oneOf xyz aazbxyzcxd aaz bx cx",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "keepDelimsR",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Delims",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:linesBy",
      "description": {
        "fct-descr": "\u003cp\u003eSplit into \"lines\", with line boundaries indicated by the given\n   predicate. Satisfies \u003ccode\u003e\u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e === linesBy (=='\\n')\u003c/code\u003e; equivalent to\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e linesBy (=='x') \"dogxxxcatxbirdxx\" == [\"dog\",\"\",\"\",\"cat\",\"bird\",\"\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#linesBy",
        "fct-type": "function",
        "title": "linesBy"
      },
      "index": {
        "description": "Split into lines with line boundaries indicated by the given predicate Satisfies lines linesBy equivalent to split dropFinalBlank dropDelims whenElt For example linesBy dogxxxcatxbirdxx dog cat bird",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "linesBy",
        "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "By",
        "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:matchDelim",
      "description": {
        "fct-descr": "\u003cp\u003eTry to match a delimiter at the start of a list, either failing\n   or decomposing the list into the portion which matched the delimiter\n   and the remainder.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Delimiter a -\u003e [a] -\u003e Maybe ([a], [a])",
        "fct-source": "src/Data-List-Split-Internals.html#matchDelim",
        "fct-type": "function",
        "title": "matchDelim"
      },
      "index": {
        "description": "Try to match delimiter at the start of list either failing or decomposing the list into the portion which matched the delimiter and the remainder",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "matchDelim",
        "normalized": "Delimiter a-\u003e[a]-\u003eMaybe([a],[a])",
        "package": "split",
        "partial": "Delim",
        "signature": "Delimiter a-\u003e[a]-\u003eMaybe([a],[a])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:mergeLeft",
      "description": {
        "fct-descr": "\u003cp\u003eMerge delimiters with adjacent chunks to the right (yes, that's\n   not a typo: the delimiters should end up on the left of the\n   chunks, so they are merged with chunks to their right).\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#mergeLeft",
        "fct-type": "function",
        "title": "mergeLeft"
      },
      "index": {
        "description": "Merge delimiters with adjacent chunks to the right yes that not typo the delimiters should end up on the left of the chunks so they are merged with chunks to their right",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "mergeLeft",
        "normalized": "SplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Left",
        "signature": "SplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:mergeRight",
      "description": {
        "fct-descr": "\u003cp\u003eMerge delimiters with adjacent chunks to the left.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#mergeRight",
        "fct-type": "function",
        "title": "mergeRight"
      },
      "index": {
        "description": "Merge delimiters with adjacent chunks to the left",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "mergeRight",
        "normalized": "SplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Right",
        "signature": "SplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:onSublist",
      "description": {
        "fct-descr": "\u003cp\u003eA splitting strategy that splits on the given list, when it is\n   encountered as an exact subsequence.  For example:\n\u003c/p\u003e\u003cpre\u003e split (onSublist \"xyz\") \"aazbxyzcxd\" == [\"aazb\",\"xyz\",\"cxd\"]\n\u003c/pre\u003e\u003cp\u003eNote that splitting on the empty list is a special case, which\n   splits just before every element of the list being split.  For example:\n\u003c/p\u003e\u003cpre\u003e split (onSublist \"\") \"abc\" == [\"\",\"\",\"a\",\"\",\"b\",\"\",\"c\"]\n split (dropDelims . dropBlanks $ onSublist \"\") \"abc\" == [\"a\",\"b\",\"c\"]\n\u003c/pre\u003e\u003cp\u003eHowever, if you want to break a list into singleton elements like\n   this, you are better off using \u003ccode\u003e\u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e 1\u003c/code\u003e, or better yet,\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (:[])\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#onSublist",
        "fct-type": "function",
        "title": "onSublist"
      },
      "index": {
        "description": "splitting strategy that splits on the given list when it is encountered as an exact subsequence For example split onSublist xyz aazbxyzcxd aazb xyz cxd Note that splitting on the empty list is special case which splits just before every element of the list being split For example split onSublist abc split dropDelims dropBlanks onSublist abc However if you want to break list into singleton elements like this you are better off using chunksOf or better yet map",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "onSublist",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "Sublist",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:oneOf",
      "description": {
        "fct-descr": "\u003cp\u003eA splitting strategy that splits on any one of the given\n   elements.  For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"z\",\"b\",\"x\",\"\",\"y\",\"\",\"z\",\"c\",\"x\",\"d\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#oneOf",
        "fct-type": "function",
        "title": "oneOf"
      },
      "index": {
        "description": "splitting strategy that splits on any one of the given elements For example split oneOf xyz aazbxyzcxd aa",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "oneOf",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "Of",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:postProcess",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a split list in the internal tagged representation, produce\n   a new internal tagged representation corresponding to the final\n   output, according to the strategy defined by the given\n   \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e SplitList a -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#postProcess",
        "fct-type": "function",
        "title": "postProcess"
      },
      "index": {
        "description": "Given split list in the internal tagged representation produce new internal tagged representation corresponding to the final output according to the strategy defined by the given Splitter",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "postProcess",
        "normalized": "Splitter a-\u003eSplitList a-\u003eSplitList a",
        "package": "split",
        "partial": "Process",
        "signature": "Splitter a-\u003eSplitList a-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:split",
      "description": {
        "fct-descr": "\u003cp\u003eSplit a list according to the given splitting strategy.  This is\n   how to \"run\" a \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e that has been built using the other\n   combinators.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#split",
        "fct-type": "function",
        "title": "split"
      },
      "index": {
        "description": "Split list according to the given splitting strategy This is how to run Splitter that has been built using the other combinators",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "split",
        "normalized": "Splitter a-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "",
        "signature": "Splitter a-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:splitInternal",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a delimiter to use, split a list into an internal\n   representation with chunks tagged as delimiters or text.  This\n   transformation is lossless; in particular,\n\u003c/p\u003e\u003cpre\u003e\n   \u003ccode\u003e\u003ca\u003econcatMap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efromElem\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003esplitInternal\u003c/a\u003e\u003c/code\u003e d l) == l.\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "Delimiter a -\u003e [a] -\u003e SplitList a",
        "fct-source": "src/Data-List-Split-Internals.html#splitInternal",
        "fct-type": "function",
        "title": "splitInternal"
      },
      "index": {
        "description": "Given delimiter to use split list into an internal representation with chunks tagged as delimiters or text This transformation is lossless in particular concatMap fromElem splitInternal",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "splitInternal",
        "normalized": "Delimiter a-\u003e[a]-\u003eSplitList a",
        "package": "split",
        "partial": "Internal",
        "signature": "Delimiter a-\u003e[a]-\u003eSplitList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:splitOn",
      "description": {
        "fct-descr": "\u003cp\u003eSplit on the given sublist.  Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e splitOn \"..\" \"a..b...c....d..\" == [\"a\",\"b\",\".c\",\"\",\"d\",\"\"]\n\u003c/pre\u003e\u003cp\u003eIn some parsing combinator frameworks this is also known as\n   \u003ccode\u003esepBy\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that this is the right inverse of the \u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e function\n   from \u003ca\u003eData.List\u003c/a\u003e, that is,\n\u003c/p\u003e\u003cpre\u003e intercalate x . splitOn x === id\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitOn\u003c/a\u003e\u003c/code\u003e x . \u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e is the identity on\n   certain lists, but it is tricky to state the precise conditions\n   under which this holds.  (For example, it is not enough to say\n   that \u003ccode\u003ex\u003c/code\u003e does not occur in any elements of the input list.\n   Working out why is left as an exercise for the reader.)\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitOn",
        "fct-type": "function",
        "title": "splitOn"
      },
      "index": {
        "description": "Split on the given sublist Equivalent to split dropDelims onSublist For example splitOn a..b...c....d In some parsing combinator frameworks this is also known as sepBy Note that this is the right inverse of the intercalate function from Data.List that is intercalate splitOn id splitOn intercalate is the identity on certain lists but it is tricky to state the precise conditions under which this holds For example it is not enough to say that does not occur in any elements of the input list Working out why is left as an exercise for the reader",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "splitOn",
        "normalized": "[a]-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "On",
        "signature": "[a]-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:splitOneOf",
      "description": {
        "fct-descr": "\u003cp\u003eSplit on any of the given elements.  Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e splitOneOf \";.,\" \"foo,bar;baz.glurk\" == [\"foo\",\"bar\",\"baz\",\"glurk\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitOneOf",
        "fct-type": "function",
        "title": "splitOneOf"
      },
      "index": {
        "description": "Split on any of the given elements Equivalent to split dropDelims oneOf For example splitOneOf foo bar baz.glurk foo bar baz glurk",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "splitOneOf",
        "normalized": "[a]-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "One Of",
        "signature": "[a]-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:splitPlaces",
      "description": {
        "fct-descr": "\u003cp\u003eSplit a list into chunks of the given lengths. For example:\n\u003c/p\u003e\u003cpre\u003e splitPlaces [2,3,4] [1..20] == [[1,2],[3,4,5],[6,7,8,9]]\n splitPlaces [4,9] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]\n splitPlaces [4,9,3] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]\n\u003c/pre\u003e\u003cp\u003eIf the input list is longer than the total of the given lengths,\n   then the remaining elements are dropped. If the list is shorter\n   than the total of the given lengths, then the result may contain\n   fewer chunks than requested, and the last chunk may be shorter\n   than requested.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [e] -\u003e [[e]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitPlaces",
        "fct-type": "function",
        "title": "splitPlaces"
      },
      "index": {
        "description": "Split list into chunks of the given lengths For example splitPlaces splitPlaces splitPlaces If the input list is longer than the total of the given lengths then the remaining elements are dropped If the list is shorter than the total of the given lengths then the result may contain fewer chunks than requested and the last chunk may be shorter than requested",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "splitPlaces",
        "normalized": "[a]-\u003e[b]-\u003e[[b]]",
        "package": "split",
        "partial": "Places",
        "signature": "[a]-\u003e[e]-\u003e[[e]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:splitPlacesBlanks",
      "description": {
        "fct-descr": "\u003cp\u003eSplit a list into chunks of the given lengths. Unlike\n   \u003ccode\u003e\u003ca\u003esplitPlaces\u003c/a\u003e\u003c/code\u003e, the output list will always be the same length as\n   the first input argument. If the input list is longer than the\n   total of the given lengths, then the remaining elements are\n   dropped. If the list is shorter than the total of the given\n   lengths, then the last several chunks will be shorter than\n   requested or empty. For example:\n\u003c/p\u003e\u003cpre\u003e splitPlacesBlanks [2,3,4] [1..20] == [[1,2],[3,4,5],[6,7,8,9]]\n splitPlacesBlanks [4,9] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]\n splitPlacesBlanks [4,9,3] [1..10] == [[1,2,3,4],[5,6,7,8,9,10],[]]\n\u003c/pre\u003e\u003cp\u003eNotice the empty list in the output of the third example, which\n   differs from the behavior of \u003ccode\u003e\u003ca\u003esplitPlaces\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [e] -\u003e [[e]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitPlacesBlanks",
        "fct-type": "function",
        "title": "splitPlacesBlanks"
      },
      "index": {
        "description": "Split list into chunks of the given lengths Unlike splitPlaces the output list will always be the same length as the first input argument If the input list is longer than the total of the given lengths then the remaining elements are dropped If the list is shorter than the total of the given lengths then the last several chunks will be shorter than requested or empty For example splitPlacesBlanks splitPlacesBlanks splitPlacesBlanks Notice the empty list in the output of the third example which differs from the behavior of splitPlaces",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "splitPlacesBlanks",
        "normalized": "[a]-\u003e[b]-\u003e[[b]]",
        "package": "split",
        "partial": "Places Blanks",
        "signature": "[a]-\u003e[e]-\u003e[[e]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:splitWhen",
      "description": {
        "fct-descr": "\u003cp\u003eSplit on elements satisfying the given predicate.  Equivalent to\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e splitWhen (\u003c0) [1,3,-4,5,7,-9,0,2] == [[1,3],[5,7],[0,2]]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitWhen",
        "fct-type": "function",
        "title": "splitWhen"
      },
      "index": {
        "description": "Split on elements satisfying the given predicate Equivalent to split dropDelims whenElt For example splitWhen",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "splitWhen",
        "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "When",
        "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:startsWith",
      "description": {
        "fct-descr": "\u003cp\u003eMake a strategy that splits a list into chunks that all start\n   with the given subsequence (except possibly the first).\n   Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropInitBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ekeepDelimsL\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n   For example:\n\u003c/p\u003e\u003cpre\u003e split (startsWith \"app\") \"applyapplicativeapplaudapproachapple\" == [\"apply\",\"applicative\",\"applaud\",\"approach\",\"apple\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#startsWith",
        "fct-type": "function",
        "title": "startsWith"
      },
      "index": {
        "description": "Make strategy that splits list into chunks that all start with the given subsequence except possibly the first Equivalent to dropInitBlank keepDelimsL onSublist For example split startsWith app applyapplicativeapplaudapproachapple apply applicative applaud approach apple",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "startsWith",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "With",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:startsWithOneOf",
      "description": {
        "fct-descr": "\u003cp\u003eMake a strategy that splits a list into chunks that all start\n   with one of the given elements (except possibly the first).\n   Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropInitBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ekeepDelimsL\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For\n   example:\n\u003c/p\u003e\u003cpre\u003e split (startsWithOneOf ['A'..'Z']) \"ACamelCaseIdentifier\" == [\"A\",\"Camel\",\"Case\",\"Identifier\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#startsWithOneOf",
        "fct-type": "function",
        "title": "startsWithOneOf"
      },
      "index": {
        "description": "Make strategy that splits list into chunks that all start with one of the given elements except possibly the first Equivalent to dropInitBlank keepDelimsL oneOf For example split startsWithOneOf ACamelCaseIdentifier Camel Case Identifier",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "startsWithOneOf",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "With One Of",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:whenElt",
      "description": {
        "fct-descr": "\u003cp\u003eA splitting strategy that splits on any elements that satisfy the\n   given predicate.  For example:\n\u003c/p\u003e\u003cpre\u003e split (whenElt (\u003c0)) [2,4,-3,6,-9,1] == [[2,4],[-3],[6],[-9],[1]]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "(a -\u003e Bool) -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#whenElt",
        "fct-type": "function",
        "title": "whenElt"
      },
      "index": {
        "description": "splitting strategy that splits on any elements that satisfy the given predicate For example split whenElt",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "whenElt",
        "normalized": "(a-\u003eBool)-\u003eSplitter a",
        "package": "split",
        "partial": "Elt",
        "signature": "(a-\u003eBool)-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split-Internals.html#v:wordsBy",
      "description": {
        "fct-descr": "\u003cp\u003eSplit into \"words\", with word boundaries indicated by the given\n   predicate.  Satisfies \u003ccode\u003e\u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e === wordsBy\n   \u003ccode\u003e\u003ca\u003eisSpace\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e; equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropBlanks\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e wordsBy (=='x') \"dogxxxcatxbirdxx\" == [\"dog\",\"cat\",\"bird\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split.Internals",
        "fct-package": "split",
        "fct-signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#wordsBy",
        "fct-type": "function",
        "title": "wordsBy"
      },
      "index": {
        "description": "Split into words with word boundaries indicated by the given predicate Satisfies words wordsBy isSpace equivalent to split dropBlanks dropDelims whenElt For example wordsBy dogxxxcatxbirdxx dog cat bird",
        "hierarchy": "Data List Split Internals",
        "module": "Data.List.Split.Internals",
        "name": "wordsBy",
        "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "By",
        "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ca\u003eData.List.Split\u003c/a\u003e module contains a wide range of strategies\n for splitting lists with respect to some sort of delimiter, mostly\n implemented through a unified combinator interface.  The goal is to\n be flexible yet simple.  See below for usage, examples, and\n detailed documentation of all exported functions.  If you want to\n learn about the implementation, see \u003ca\u003eData.List.Split.Internals\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eA darcs repository containing the source (including a module with\n over 40 QuickCheck properties) can be found at\n \u003ca\u003ehttp://hub.darcs.net/byorgey/split\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "module",
        "fct-source": "src/Data-List-Split.html",
        "fct-type": "module",
        "title": "Split"
      },
      "index": {
        "description": "The Data.List.Split module contains wide range of strategies for splitting lists with respect to some sort of delimiter mostly implemented through unified combinator interface The goal is to be flexible yet simple See below for usage examples and detailed documentation of all exported functions If you want to learn about the implementation see Data.List.Split.Internals darcs repository containing the source including module with over QuickCheck properties can be found at http hub.darcs.net byorgey split",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "Split",
        "normalized": "",
        "package": "split",
        "partial": "Split",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#t:Splitter",
      "description": {
        "fct-descr": "\u003cp\u003eA splitting strategy.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "data",
        "fct-source": "src/Data-List-Split-Internals.html#Splitter",
        "fct-type": "data",
        "title": "Splitter"
      },
      "index": {
        "description": "splitting strategy",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "Splitter",
        "normalized": "",
        "package": "split",
        "partial": "Splitter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:chop",
      "description": {
        "fct-descr": "\u003cp\u003eA useful recursion pattern for processing a list to produce a new\n   list, often used for \"chopping\" up the input list.  Typically\n   chop is called with some function that will consume an initial\n   prefix of the list and produce a value and the rest of the list.\n\u003c/p\u003e\u003cp\u003eFor example, many common Prelude functions can be implemented in\n   terms of \u003ccode\u003echop\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e group :: (Eq a) =\u003e [a] -\u003e [[a]]\n group = chop (\\ xs@(x:_) -\u003e span (==x) xs)\n\n words :: String -\u003e [String]\n words = filter (not . null) . chop (span (not . isSpace) . dropWhile isSpace)\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "([a] -\u003e (b, [a])) -\u003e [a] -\u003e [b]",
        "fct-source": "src/Data-List-Split-Internals.html#chop",
        "fct-type": "function",
        "title": "chop"
      },
      "index": {
        "description": "useful recursion pattern for processing list to produce new list often used for chopping up the input list Typically chop is called with some function that will consume an initial prefix of the list and produce value and the rest of the list For example many common Prelude functions can be implemented in terms of chop group Eq group chop xs span xs words String String words filter not null chop span not isSpace dropWhile isSpace",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "chop",
        "normalized": "([a]-\u003e(b,[a]))-\u003e[a]-\u003e[b]",
        "package": "split",
        "partial": "",
        "signature": "([a]-\u003e(b,[a]))-\u003e[a]-\u003e[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:chunksOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e splits a list into length-n pieces.  The last\n   piece will be shorter if \u003ccode\u003en\u003c/code\u003e does not evenly divide the length of\n   the list.  If \u003ccode\u003en \u003c= 0\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e n l\u003c/code\u003e returns an infinite list\n   of empty lists.  For example:\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e n []\u003c/code\u003e is \u003ccode\u003e[]\u003c/code\u003e, not \u003ccode\u003e[[]]\u003c/code\u003e.  This is\n   intentional, and is consistent with a recursive definition of\n   \u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e; it satisfies the property that\n\u003c/p\u003e\u003cpre\u003echunksOf n xs ++ chunksOf n ys == chunksOf n (xs ++ ys)\u003c/pre\u003e\u003cp\u003ewhenever \u003ccode\u003en\u003c/code\u003e evenly divides the length of \u003ccode\u003exs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Int -\u003e [e] -\u003e [[e]]",
        "fct-source": "src/Data-List-Split-Internals.html#chunksOf",
        "fct-type": "function",
        "title": "chunksOf"
      },
      "index": {
        "description": "chunksOf splits list into length-n pieces The last piece will be shorter if does not evenly divide the length of the list If chunksOf returns an infinite list of empty lists For example Note that chunksOf is not This is intentional and is consistent with recursive definition of chunksOf it satisfies the property that chunksOf xs chunksOf ys chunksOf xs ys whenever evenly divides the length of xs",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "chunksOf",
        "normalized": "Int-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "Of",
        "signature": "Int-\u003e[e]-\u003e[[e]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:condense",
      "description": {
        "fct-descr": "\u003cp\u003eCondense multiple consecutive delimiters into one.  For example:\n\u003c/p\u003e\u003cpre\u003e split (condense $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"z\",\"b\",\"xyz\",\"c\",\"x\",\"d\"]\n split (dropDelims $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"b\",\"\",\"\",\"c\",\"d\"]\n split (condense . dropDelims $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"b\",\"c\",\"d\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#condense",
        "fct-type": "function",
        "title": "condense"
      },
      "index": {
        "description": "Condense multiple consecutive delimiters into one For example split condense oneOf xyz aazbxyzcxd aa xyz split dropDelims oneOf xyz aazbxyzcxd aa split condense dropDelims oneOf xyz aazbxyzcxd aa",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "condense",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:defaultSplitter",
      "description": {
        "fct-descr": "\u003cp\u003eThe default splitting strategy: keep delimiters in the output\n   as separate chunks, don't condense multiple consecutive\n   delimiters into one, keep initial and final blank chunks.\n   Default delimiter is the constantly false predicate.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003edefaultSplitter\u003c/a\u003e\u003c/code\u003e should normally not be used; use\n   \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e instead, which are the same as\n   the \u003ccode\u003e\u003ca\u003edefaultSplitter\u003c/a\u003e\u003c/code\u003e with just the delimiter overridden.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003edefaultSplitter\u003c/a\u003e\u003c/code\u003e strategy with any delimiter gives a\n   maximally information-preserving splitting strategy, in the sense\n   that (a) taking the \u003ccode\u003e\u003ca\u003econcat\u003c/a\u003e\u003c/code\u003e of the output yields the original\n   list, and (b) given only the output list, we can reconstruct a\n   \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e which would produce the same output list again given\n   the original input list.  This default strategy can be overridden\n   to allow discarding various sorts of information.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#defaultSplitter",
        "fct-type": "function",
        "title": "defaultSplitter"
      },
      "index": {
        "description": "The default splitting strategy keep delimiters in the output as separate chunks don condense multiple consecutive delimiters into one keep initial and final blank chunks Default delimiter is the constantly false predicate Note that defaultSplitter should normally not be used use oneOf onSublist or whenElt instead which are the same as the defaultSplitter with just the delimiter overridden The defaultSplitter strategy with any delimiter gives maximally information-preserving splitting strategy in the sense that taking the concat of the output yields the original list and given only the output list we can reconstruct Splitter which would produce the same output list again given the original input list This default strategy can be overridden to allow discarding various sorts of information",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "defaultSplitter",
        "normalized": "",
        "package": "split",
        "partial": "Splitter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:dropBlanks",
      "description": {
        "fct-descr": "\u003cp\u003eDrop all blank chunks from the output, and condense consecutive\n   delimiters into one.  Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropInitBlank\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003econdense\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \"::b:::a\" == [\"\",\":\",\"\",\":\",\"b\",\":\",\"\",\":\",\"\",\":\",\"a\"]\n split (dropBlanks $ oneOf \":\") \"::b:::a\" == [\"::\",\"b\",\":::\",\"a\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropBlanks",
        "fct-type": "function",
        "title": "dropBlanks"
      },
      "index": {
        "description": "Drop all blank chunks from the output and condense consecutive delimiters into one Equivalent to dropInitBlank dropFinalBlank condense For example split oneOf split dropBlanks oneOf",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "dropBlanks",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Blanks",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:dropDelims",
      "description": {
        "fct-descr": "\u003cp\u003eDrop delimiters from the output (the default is to keep\n   them). For example,\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \"a:b:c\" == [\"a\", \":\", \"b\", \":\", \"c\"]\n split (dropDelims $ oneOf \":\") \"a:b:c\" == [\"a\", \"b\", \"c\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropDelims",
        "fct-type": "function",
        "title": "dropDelims"
      },
      "index": {
        "description": "Drop delimiters from the output the default is to keep them For example split oneOf split dropDelims oneOf",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "dropDelims",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Delims",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:dropFinalBlank",
      "description": {
        "fct-descr": "\u003cp\u003eDon't generate a blank chunk if there is a delimiter at the end.\n   For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \"a:b:\" == [\"a\",\":\",\"b\",\":\",\"\"]\n split (dropFinalBlank $ oneOf \":\") \"a:b:\" == [\"a\",\":\",\"b\",\":\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropFinalBlank",
        "fct-type": "function",
        "title": "dropFinalBlank"
      },
      "index": {
        "description": "Don generate blank chunk if there is delimiter at the end For example split oneOf split dropFinalBlank oneOf",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "dropFinalBlank",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Final Blank",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:dropInitBlank",
      "description": {
        "fct-descr": "\u003cp\u003eDon't generate a blank chunk if there is a delimiter at the\n   beginning.  For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \":a:b\" == [\"\",\":\",\"a\",\":\",\"b\"]\n split (dropInitBlank $ oneOf \":\") \":a:b\" == [\":\",\"a\",\":\",\"b\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropInitBlank",
        "fct-type": "function",
        "title": "dropInitBlank"
      },
      "index": {
        "description": "Don generate blank chunk if there is delimiter at the beginning For example split oneOf split dropInitBlank oneOf",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "dropInitBlank",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Init Blank",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:dropInnerBlanks",
      "description": {
        "fct-descr": "\u003cp\u003eDon't generate blank chunks between consecutive delimiters.\n   For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \":\") \"::b:::a\" == [\"\",\":\",\"\",\":\",\"b\",\":\",\"\",\":\",\"\",\":\",\"a\"]\n split (dropInnerBlanks $ oneOf \":\") \"::b:::a\" == [\"\", \":\",\":\",\"b\",\":\",\":\",\":\",\"a\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#dropInnerBlanks",
        "fct-type": "function",
        "title": "dropInnerBlanks"
      },
      "index": {
        "description": "Don generate blank chunks between consecutive delimiters For example split oneOf split dropInnerBlanks oneOf",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "dropInnerBlanks",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Inner Blanks",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:endBy",
      "description": {
        "fct-descr": "\u003cp\u003eSplit into chunks terminated by the given subsequence.\n   Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e endBy \";\" \"foo;bar;baz;\" == [\"foo\",\"bar\",\"baz\"]\n\u003c/pre\u003e\u003cp\u003eNote also that the \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e function from \u003ca\u003eData.List\u003c/a\u003e is equivalent\n   to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eendBy\u003c/a\u003e\u003c/code\u003e \"\\n\"\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#endBy",
        "fct-type": "function",
        "title": "endBy"
      },
      "index": {
        "description": "Split into chunks terminated by the given subsequence Equivalent to split dropFinalBlank dropDelims onSublist For example endBy foo bar baz foo bar baz Note also that the lines function from Data.List is equivalent to endBy",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "endBy",
        "normalized": "[a]-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "By",
        "signature": "[a]-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:endByOneOf",
      "description": {
        "fct-descr": "\u003cp\u003eSplit into chunks terminated by one of the given elements.\n   Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. For example:\n\u003c/p\u003e\u003cpre\u003e endByOneOf \";,\" \"foo;bar,baz;\" == [\"foo\",\"bar\",\"baz\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#endByOneOf",
        "fct-type": "function",
        "title": "endByOneOf"
      },
      "index": {
        "description": "Split into chunks terminated by one of the given elements Equivalent to split dropFinalBlank dropDelims oneOf For example endByOneOf foo bar baz foo bar baz",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "endByOneOf",
        "normalized": "[a]-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "By One Of",
        "signature": "[a]-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:endsWith",
      "description": {
        "fct-descr": "\u003cp\u003eMake a strategy that splits a list into chunks that all end with\n   the given subsequence, except possibly the last.  Equivalent to\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ekeepDelimsR\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e split (endsWith \"ly\") \"happilyslowlygnarlylily\" == [\"happily\",\"slowly\",\"gnarly\",\"lily\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#endsWith",
        "fct-type": "function",
        "title": "endsWith"
      },
      "index": {
        "description": "Make strategy that splits list into chunks that all end with the given subsequence except possibly the last Equivalent to dropFinalBlank keepDelimsR onSublist For example split endsWith ly happilyslowlygnarlylily happily slowly gnarly lily",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "endsWith",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "With",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:endsWithOneOf",
      "description": {
        "fct-descr": "\u003cp\u003eMake a strategy that splits a list into chunks that all end with\n   one of the given elements, except possibly the last.  Equivalent\n   to \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ekeepDelimsR\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e split (condense $ endsWithOneOf \".,?! \") \"Hi, there!  How are you?\" == [\"Hi, \",\"there!  \",\"How \",\"are \",\"you?\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#endsWithOneOf",
        "fct-type": "function",
        "title": "endsWithOneOf"
      },
      "index": {
        "description": "Make strategy that splits list into chunks that all end with one of the given elements except possibly the last Equivalent to dropFinalBlank keepDelimsR oneOf For example split condense endsWithOneOf Hi there How are you Hi there How are you",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "endsWithOneOf",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "With One Of",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:keepDelimsL",
      "description": {
        "fct-descr": "\u003cp\u003eKeep delimiters in the output by prepending them to adjacent\n   chunks.  For example:\n\u003c/p\u003e\u003cpre\u003e split (keepDelimsL $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"zb\",\"x\",\"y\",\"zc\",\"xd\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#keepDelimsL",
        "fct-type": "function",
        "title": "keepDelimsL"
      },
      "index": {
        "description": "Keep delimiters in the output by prepending them to adjacent chunks For example split keepDelimsL oneOf xyz aazbxyzcxd aa zb zc xd",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "keepDelimsL",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Delims",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:keepDelimsR",
      "description": {
        "fct-descr": "\u003cp\u003eKeep delimiters in the output by appending them to adjacent\n   chunks. For example:\n\u003c/p\u003e\u003cpre\u003e split (keepDelimsR $ oneOf \"xyz\") \"aazbxyzcxd\" == [\"aaz\",\"bx\",\"y\",\"z\",\"cx\",\"d\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#keepDelimsR",
        "fct-type": "function",
        "title": "keepDelimsR"
      },
      "index": {
        "description": "Keep delimiters in the output by appending them to adjacent chunks For example split keepDelimsR oneOf xyz aazbxyzcxd aaz bx cx",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "keepDelimsR",
        "normalized": "Splitter a-\u003eSplitter a",
        "package": "split",
        "partial": "Delims",
        "signature": "Splitter a-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:linesBy",
      "description": {
        "fct-descr": "\u003cp\u003eSplit into \"lines\", with line boundaries indicated by the given\n   predicate. Satisfies \u003ccode\u003e\u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e === linesBy (=='\\n')\u003c/code\u003e; equivalent to\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e linesBy (=='x') \"dogxxxcatxbirdxx\" == [\"dog\",\"\",\"\",\"cat\",\"bird\",\"\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#linesBy",
        "fct-type": "function",
        "title": "linesBy"
      },
      "index": {
        "description": "Split into lines with line boundaries indicated by the given predicate Satisfies lines linesBy equivalent to split dropFinalBlank dropDelims whenElt For example linesBy dogxxxcatxbirdxx dog cat bird",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "linesBy",
        "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "By",
        "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:onSublist",
      "description": {
        "fct-descr": "\u003cp\u003eA splitting strategy that splits on the given list, when it is\n   encountered as an exact subsequence.  For example:\n\u003c/p\u003e\u003cpre\u003e split (onSublist \"xyz\") \"aazbxyzcxd\" == [\"aazb\",\"xyz\",\"cxd\"]\n\u003c/pre\u003e\u003cp\u003eNote that splitting on the empty list is a special case, which\n   splits just before every element of the list being split.  For example:\n\u003c/p\u003e\u003cpre\u003e split (onSublist \"\") \"abc\" == [\"\",\"\",\"a\",\"\",\"b\",\"\",\"c\"]\n split (dropDelims . dropBlanks $ onSublist \"\") \"abc\" == [\"a\",\"b\",\"c\"]\n\u003c/pre\u003e\u003cp\u003eHowever, if you want to break a list into singleton elements like\n   this, you are better off using \u003ccode\u003e\u003ccode\u003e\u003ca\u003echunksOf\u003c/a\u003e\u003c/code\u003e 1\u003c/code\u003e, or better yet,\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (:[])\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#onSublist",
        "fct-type": "function",
        "title": "onSublist"
      },
      "index": {
        "description": "splitting strategy that splits on the given list when it is encountered as an exact subsequence For example split onSublist xyz aazbxyzcxd aazb xyz cxd Note that splitting on the empty list is special case which splits just before every element of the list being split For example split onSublist abc split dropDelims dropBlanks onSublist abc However if you want to break list into singleton elements like this you are better off using chunksOf or better yet map",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "onSublist",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "Sublist",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:oneOf",
      "description": {
        "fct-descr": "\u003cp\u003eA splitting strategy that splits on any one of the given\n   elements.  For example:\n\u003c/p\u003e\u003cpre\u003e split (oneOf \"xyz\") \"aazbxyzcxd\" == [\"aa\",\"z\",\"b\",\"x\",\"\",\"y\",\"\",\"z\",\"c\",\"x\",\"d\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#oneOf",
        "fct-type": "function",
        "title": "oneOf"
      },
      "index": {
        "description": "splitting strategy that splits on any one of the given elements For example split oneOf xyz aazbxyzcxd aa",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "oneOf",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "Of",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:split",
      "description": {
        "fct-descr": "\u003cp\u003eSplit a list according to the given splitting strategy.  This is\n   how to \"run\" a \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e that has been built using the other\n   combinators.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "Splitter a -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#split",
        "fct-type": "function",
        "title": "split"
      },
      "index": {
        "description": "Split list according to the given splitting strategy This is how to run Splitter that has been built using the other combinators",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "split",
        "normalized": "Splitter a-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "",
        "signature": "Splitter a-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:splitOn",
      "description": {
        "fct-descr": "\u003cp\u003eSplit on the given sublist.  Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e splitOn \"..\" \"a..b...c....d..\" == [\"a\",\"b\",\".c\",\"\",\"d\",\"\"]\n\u003c/pre\u003e\u003cp\u003eIn some parsing combinator frameworks this is also known as\n   \u003ccode\u003esepBy\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that this is the right inverse of the \u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e function\n   from \u003ca\u003eData.List\u003c/a\u003e, that is,\n\u003c/p\u003e\u003cpre\u003e intercalate x . splitOn x === id\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitOn\u003c/a\u003e\u003c/code\u003e x . \u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e is the identity on\n   certain lists, but it is tricky to state the precise conditions\n   under which this holds.  (For example, it is not enough to say\n   that \u003ccode\u003ex\u003c/code\u003e does not occur in any elements of the input list.\n   Working out why is left as an exercise for the reader.)\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitOn",
        "fct-type": "function",
        "title": "splitOn"
      },
      "index": {
        "description": "Split on the given sublist Equivalent to split dropDelims onSublist For example splitOn a..b...c....d In some parsing combinator frameworks this is also known as sepBy Note that this is the right inverse of the intercalate function from Data.List that is intercalate splitOn id splitOn intercalate is the identity on certain lists but it is tricky to state the precise conditions under which this holds For example it is not enough to say that does not occur in any elements of the input list Working out why is left as an exercise for the reader",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "splitOn",
        "normalized": "[a]-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "On",
        "signature": "[a]-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:splitOneOf",
      "description": {
        "fct-descr": "\u003cp\u003eSplit on any of the given elements.  Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e splitOneOf \";.,\" \"foo,bar;baz.glurk\" == [\"foo\",\"bar\",\"baz\",\"glurk\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitOneOf",
        "fct-type": "function",
        "title": "splitOneOf"
      },
      "index": {
        "description": "Split on any of the given elements Equivalent to split dropDelims oneOf For example splitOneOf foo bar baz.glurk foo bar baz glurk",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "splitOneOf",
        "normalized": "[a]-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "One Of",
        "signature": "[a]-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:splitPlaces",
      "description": {
        "fct-descr": "\u003cp\u003eSplit a list into chunks of the given lengths. For example:\n\u003c/p\u003e\u003cpre\u003e splitPlaces [2,3,4] [1..20] == [[1,2],[3,4,5],[6,7,8,9]]\n splitPlaces [4,9] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]\n splitPlaces [4,9,3] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]\n\u003c/pre\u003e\u003cp\u003eIf the input list is longer than the total of the given lengths,\n   then the remaining elements are dropped. If the list is shorter\n   than the total of the given lengths, then the result may contain\n   fewer chunks than requested, and the last chunk may be shorter\n   than requested.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [e] -\u003e [[e]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitPlaces",
        "fct-type": "function",
        "title": "splitPlaces"
      },
      "index": {
        "description": "Split list into chunks of the given lengths For example splitPlaces splitPlaces splitPlaces If the input list is longer than the total of the given lengths then the remaining elements are dropped If the list is shorter than the total of the given lengths then the result may contain fewer chunks than requested and the last chunk may be shorter than requested",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "splitPlaces",
        "normalized": "[a]-\u003e[b]-\u003e[[b]]",
        "package": "split",
        "partial": "Places",
        "signature": "[a]-\u003e[e]-\u003e[[e]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:splitPlacesBlanks",
      "description": {
        "fct-descr": "\u003cp\u003eSplit a list into chunks of the given lengths. Unlike\n   \u003ccode\u003e\u003ca\u003esplitPlaces\u003c/a\u003e\u003c/code\u003e, the output list will always be the same length as\n   the first input argument. If the input list is longer than the\n   total of the given lengths, then the remaining elements are\n   dropped. If the list is shorter than the total of the given\n   lengths, then the last several chunks will be shorter than\n   requested or empty. For example:\n\u003c/p\u003e\u003cpre\u003e splitPlacesBlanks [2,3,4] [1..20] == [[1,2],[3,4,5],[6,7,8,9]]\n splitPlacesBlanks [4,9] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]\n splitPlacesBlanks [4,9,3] [1..10] == [[1,2,3,4],[5,6,7,8,9,10],[]]\n\u003c/pre\u003e\u003cp\u003eNotice the empty list in the output of the third example, which\n   differs from the behavior of \u003ccode\u003e\u003ca\u003esplitPlaces\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e [e] -\u003e [[e]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitPlacesBlanks",
        "fct-type": "function",
        "title": "splitPlacesBlanks"
      },
      "index": {
        "description": "Split list into chunks of the given lengths Unlike splitPlaces the output list will always be the same length as the first input argument If the input list is longer than the total of the given lengths then the remaining elements are dropped If the list is shorter than the total of the given lengths then the last several chunks will be shorter than requested or empty For example splitPlacesBlanks splitPlacesBlanks splitPlacesBlanks Notice the empty list in the output of the third example which differs from the behavior of splitPlaces",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "splitPlacesBlanks",
        "normalized": "[a]-\u003e[b]-\u003e[[b]]",
        "package": "split",
        "partial": "Places Blanks",
        "signature": "[a]-\u003e[e]-\u003e[[e]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:splitWhen",
      "description": {
        "fct-descr": "\u003cp\u003eSplit on elements satisfying the given predicate.  Equivalent to\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e splitWhen (\u003c0) [1,3,-4,5,7,-9,0,2] == [[1,3],[5,7],[0,2]]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#splitWhen",
        "fct-type": "function",
        "title": "splitWhen"
      },
      "index": {
        "description": "Split on elements satisfying the given predicate Equivalent to split dropDelims whenElt For example splitWhen",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "splitWhen",
        "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "When",
        "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:startsWith",
      "description": {
        "fct-descr": "\u003cp\u003eMake a strategy that splits a list into chunks that all start\n   with the given subsequence (except possibly the first).\n   Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropInitBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ekeepDelimsL\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n   For example:\n\u003c/p\u003e\u003cpre\u003e split (startsWith \"app\") \"applyapplicativeapplaudapproachapple\" == [\"apply\",\"applicative\",\"applaud\",\"approach\",\"apple\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#startsWith",
        "fct-type": "function",
        "title": "startsWith"
      },
      "index": {
        "description": "Make strategy that splits list into chunks that all start with the given subsequence except possibly the first Equivalent to dropInitBlank keepDelimsL onSublist For example split startsWith app applyapplicativeapplaudapproachapple apply applicative applaud approach apple",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "startsWith",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "With",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:startsWithOneOf",
      "description": {
        "fct-descr": "\u003cp\u003eMake a strategy that splits a list into chunks that all start\n   with one of the given elements (except possibly the first).\n   Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropInitBlank\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ekeepDelimsL\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For\n   example:\n\u003c/p\u003e\u003cpre\u003e split (startsWithOneOf ['A'..'Z']) \"ACamelCaseIdentifier\" == [\"A\",\"Camel\",\"Case\",\"Identifier\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "[a] -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#startsWithOneOf",
        "fct-type": "function",
        "title": "startsWithOneOf"
      },
      "index": {
        "description": "Make strategy that splits list into chunks that all start with one of the given elements except possibly the first Equivalent to dropInitBlank keepDelimsL oneOf For example split startsWithOneOf ACamelCaseIdentifier Camel Case Identifier",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "startsWithOneOf",
        "normalized": "[a]-\u003eSplitter a",
        "package": "split",
        "partial": "With One Of",
        "signature": "[a]-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:whenElt",
      "description": {
        "fct-descr": "\u003cp\u003eA splitting strategy that splits on any elements that satisfy the\n   given predicate.  For example:\n\u003c/p\u003e\u003cpre\u003e split (whenElt (\u003c0)) [2,4,-3,6,-9,1] == [[2,4],[-3],[6],[-9],[1]]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "(a -\u003e Bool) -\u003e Splitter a",
        "fct-source": "src/Data-List-Split-Internals.html#whenElt",
        "fct-type": "function",
        "title": "whenElt"
      },
      "index": {
        "description": "splitting strategy that splits on any elements that satisfy the given predicate For example split whenElt",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "whenElt",
        "normalized": "(a-\u003eBool)-\u003eSplitter a",
        "package": "split",
        "partial": "Elt",
        "signature": "(a-\u003eBool)-\u003eSplitter a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/split/docs/Data-List-Split.html#v:wordsBy",
      "description": {
        "fct-descr": "\u003cp\u003eSplit into \"words\", with word boundaries indicated by the given\n   predicate.  Satisfies \u003ccode\u003e\u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e === wordsBy\n   \u003ccode\u003e\u003ca\u003eisSpace\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e; equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edropBlanks\u003c/a\u003e\u003c/code\u003e\n   . \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  For example:\n\u003c/p\u003e\u003cpre\u003e wordsBy (=='x') \"dogxxxcatxbirdxx\" == [\"dog\",\"cat\",\"bird\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Split",
        "fct-package": "split",
        "fct-signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Split-Internals.html#wordsBy",
        "fct-type": "function",
        "title": "wordsBy"
      },
      "index": {
        "description": "Split into words with word boundaries indicated by the given predicate Satisfies words wordsBy isSpace equivalent to split dropBlanks dropDelims whenElt For example wordsBy dogxxxcatxbirdxx dog cat bird",
        "hierarchy": "Data List Split",
        "module": "Data.List.Split",
        "name": "wordsBy",
        "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
        "package": "split",
        "partial": "By",
        "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]"
      }
    }
  }
]
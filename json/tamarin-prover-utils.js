[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Basics.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRe-export basic control structures for easier imports.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Basics",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Control-Basics.html",
        "fct-type": "module",
        "title": "Basics"
      },
      "index": {
        "description": "Re-export basic control structures for easier imports",
        "hierarchy": "Control Basics",
        "module": "Control.Basics",
        "name": "Basics",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Basics",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eShallow monad transformer for dealing with bindings.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Bind.html",
        "fct-type": "module",
        "title": "Bind"
      },
      "index": {
        "description": "Shallow monad transformer for dealing with bindings",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "Bind",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#t:Bind",
      "description": {
        "fct-descr": "\u003cp\u003eManaging just bindings.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Bind.html#Bind",
        "fct-type": "type",
        "title": "Bind"
      },
      "index": {
        "description": "Managing just bindings",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "Bind",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#t:BindT",
      "description": {
        "fct-descr": "\u003cp\u003eManaging bindings on top of another monad.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Bind.html#BindT",
        "fct-type": "type",
        "title": "BindT"
      },
      "index": {
        "description": "Managing bindings on top of another monad",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "BindT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#t:Bindings",
      "description": {
        "fct-descr": "\u003cp\u003eType constructor for the state of the binding store.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Bind.html#Bindings",
        "fct-type": "type",
        "title": "Bindings"
      },
      "index": {
        "description": "Type constructor for the state of the binding store",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "Bindings",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bindings",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#t:MonadBind",
      "description": {
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "class",
        "fct-source": "src/Control-Monad-Bind.html#MonadBind",
        "fct-type": "class",
        "title": "MonadBind"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "MonadBind",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Monad Bind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:evalBind",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a binding context computation.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Bind k v a -\u003e Bindings k v -\u003e a",
        "fct-source": "src/Control-Monad-Bind.html#evalBind",
        "fct-type": "function",
        "title": "evalBind"
      },
      "index": {
        "description": "Evaluate binding context computation",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "evalBind",
        "normalized": "Bind a b c-\u003eBindings a b-\u003ec",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": "Bind k v a-\u003eBindings k v-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:evalBindT",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a binding context computation.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "BindT k v m a -\u003e Bindings k v -\u003e m a",
        "fct-source": "src/Control-Monad-Bind.html#evalBindT",
        "fct-type": "function",
        "title": "evalBindT"
      },
      "index": {
        "description": "Evaluate binding context computation",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "evalBindT",
        "normalized": "BindT a b c d-\u003eBindings a b-\u003ec d",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": "BindT k v m a-\u003eBindings k v-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:execBind",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a binding context computation.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Bind k v a -\u003e Bindings k v -\u003e Bindings k v",
        "fct-source": "src/Control-Monad-Bind.html#execBind",
        "fct-type": "function",
        "title": "execBind"
      },
      "index": {
        "description": "Execute binding context computation",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "execBind",
        "normalized": "Bind a b c-\u003eBindings a b-\u003eBindings a b",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": "Bind k v a-\u003eBindings k v-\u003eBindings k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:execBindT",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a binding context computation.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "BindT k v m a -\u003e Bindings k v -\u003e m (Bindings k v)",
        "fct-source": "src/Control-Monad-Bind.html#execBindT",
        "fct-type": "function",
        "title": "execBindT"
      },
      "index": {
        "description": "Execute binding context computation",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "execBindT",
        "normalized": "BindT a b c d-\u003eBindings a b-\u003ec(Bindings a b)",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": "BindT k v m a-\u003eBindings k v-\u003em(Bindings k v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:importBinding",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eimportBinding mkR d n\u003c/code\u003e checks if there is already a binding registered\n for the value \u003ccode\u003ed\u003c/code\u003e and if not it generates a fresh identifier using the name\n \u003ccode\u003en\u003c/code\u003e as a hint and converting name and identifier to a value using $mkR$.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(String -\u003e Integer -\u003e v) -\u003e k -\u003e String -\u003e m v",
        "fct-source": "src/Control-Monad-Bind.html#importBinding",
        "fct-type": "function",
        "title": "importBinding"
      },
      "index": {
        "description": "importBinding mkR checks if there is already binding registered for the value and if not it generates fresh identifier using the name as hint and converting name and identifier to value using mkR",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "importBinding",
        "normalized": "(String-\u003eInteger-\u003ea)-\u003eb-\u003eString-\u003ec a",
        "package": "tamarin-prover-utils",
        "partial": "Binding",
        "signature": "(String-\u003eInteger-\u003ev)-\u003ek-\u003eString-\u003em v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:insertBinding",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003einsertBinding k v\u003c/code\u003e inserts the binding of \u003ccode\u003ek\u003c/code\u003e to \u003ccode\u003ev\u003c/code\u003e, possibly\n overwriting the existing binding of \u003ccode\u003ek\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "k -\u003e v -\u003e m ()",
        "fct-source": "src/Control-Monad-Bind.html#insertBinding",
        "fct-type": "function",
        "title": "insertBinding"
      },
      "index": {
        "description": "insertBinding inserts the binding of to possibly overwriting the existing binding of",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "insertBinding",
        "normalized": "a-\u003eb-\u003ec()",
        "package": "tamarin-prover-utils",
        "partial": "Binding",
        "signature": "k-\u003ev-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:lookupBinding",
      "description": {
        "fct-descr": "\u003cp\u003eLookup a stored binding.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "k -\u003e m (Maybe v)",
        "fct-source": "src/Control-Monad-Bind.html#lookupBinding",
        "fct-type": "function",
        "title": "lookupBinding"
      },
      "index": {
        "description": "Lookup stored binding",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "lookupBinding",
        "normalized": "a-\u003eb(Maybe c)",
        "package": "tamarin-prover-utils",
        "partial": "Binding",
        "signature": "k-\u003em(Maybe v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:noBindings",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty binding store.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Bindings v k",
        "fct-source": "src/Control-Monad-Bind.html#noBindings",
        "fct-type": "function",
        "title": "noBindings"
      },
      "index": {
        "description": "The empty binding store",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "noBindings",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bindings",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:runBind",
      "description": {
        "fct-descr": "\u003cp\u003eRun a computation with bindings.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Bind k v a -\u003e Bindings k v -\u003e (a, Bindings k v)",
        "fct-source": "src/Control-Monad-Bind.html#runBind",
        "fct-type": "function",
        "title": "runBind"
      },
      "index": {
        "description": "Run computation with bindings",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "runBind",
        "normalized": "Bind a b c-\u003eBindings a b-\u003e(c,Bindings a b)",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": "Bind k v a-\u003eBindings k v-\u003e(a,Bindings k v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Bind.html#v:runBindT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a computation with bindings.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Bind",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "BindT k v m a -\u003e Bindings k v -\u003e m (a, Bindings k v)",
        "fct-source": "src/Control-Monad-Bind.html#runBindT",
        "fct-type": "function",
        "title": "runBindT"
      },
      "index": {
        "description": "Run computation with bindings",
        "hierarchy": "Control Monad Bind",
        "module": "Control.Monad.Bind",
        "name": "runBindT",
        "normalized": "BindT a b c d-\u003eBindings a b-\u003ec(d,Bindings a b)",
        "package": "tamarin-prover-utils",
        "partial": "Bind",
        "signature": "BindT k v m a-\u003eBindings k v-\u003em(a,Bindings k v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComputations that need perform case distinctions.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Disj.html",
        "fct-type": "module",
        "title": "Disj"
      },
      "index": {
        "description": "Computations that need perform case distinctions",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "Disj",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Disj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#t:DisjT",
      "description": {
        "fct-descr": "\u003cp\u003eA disjunction of atoms of type a.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Control-Monad-Trans-Disj.html#DisjT",
        "fct-type": "newtype",
        "title": "DisjT"
      },
      "index": {
        "description": "disjunction of atoms of type",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "DisjT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Disj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#t:MonadDisj",
      "description": {
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "class",
        "fct-source": "src/Control-Monad-Disj-Class.html#MonadDisj",
        "fct-type": "class",
        "title": "MonadDisj"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "MonadDisj",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Monad Disj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:DisjT",
      "description": {
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "DisjT",
        "fct-source": "src/Control-Monad-Trans-Disj.html#DisjT",
        "fct-type": "function",
        "title": "DisjT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "DisjT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Disj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:contradiction",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003econtradiction reason\u003c/code\u003e denotes the logical false, but also \n provides the \u003ccode\u003ereason\u003c/code\u003e as meta-information.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e m a",
        "fct-source": "src/Control-Monad-Disj.html#contradiction",
        "fct-type": "function",
        "title": "contradiction"
      },
      "index": {
        "description": "contradiction reason denotes the logical false but also provides the reason as meta-information",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "contradiction",
        "normalized": "String-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:contradictionIf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003econtradictionIf b reason\u003c/code\u003e is logically equivalent to \u003ccode\u003enot b\u003c/code\u003e, but also\n provides the \u003ccode\u003ereason\u003c/code\u003e as meta-information.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Bool -\u003e String -\u003e m ()",
        "fct-source": "src/Control-Monad-Disj.html#contradictionIf",
        "fct-type": "function",
        "title": "contradictionIf"
      },
      "index": {
        "description": "contradictionIf reason is logically equivalent to not but also provides the reason as meta-information",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "contradictionIf",
        "normalized": "Bool-\u003eString-\u003ea()",
        "package": "tamarin-prover-utils",
        "partial": "If",
        "signature": "Bool-\u003eString-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:contradictory",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003econtradictory\u003c/code\u003e denotes the logical false.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "m a",
        "fct-source": "src/Control-Monad-Disj.html#contradictory",
        "fct-type": "function",
        "title": "contradictory"
      },
      "index": {
        "description": "contradictory denotes the logical false",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "contradictory",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:contradictoryBecause",
      "description": {
        "fct-descr": "\u003cp\u003eMark a contradiction.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Maybe String -\u003e m a",
        "fct-source": "src/Control-Monad-Disj-Class.html#contradictoryBecause",
        "fct-type": "method",
        "title": "contradictoryBecause"
      },
      "index": {
        "description": "Mark contradiction",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "contradictoryBecause",
        "normalized": "Maybe String-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "Because",
        "signature": "Maybe String-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:contradictoryIf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003econtradictoryIf b\u003c/code\u003e is logically equivalent to \u003ccode\u003enot b\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Bool -\u003e m ()",
        "fct-source": "src/Control-Monad-Disj.html#contradictoryIf",
        "fct-type": "function",
        "title": "contradictoryIf"
      },
      "index": {
        "description": "contradictoryIf is logically equivalent to not",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "contradictoryIf",
        "normalized": "Bool-\u003ea()",
        "package": "tamarin-prover-utils",
        "partial": "If",
        "signature": "Bool-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:disjT",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003eDisjT\u003c/a\u003e\u003c/code\u003e action.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "m [a] -\u003e DisjT m a",
        "fct-source": "src/Control-Monad-Trans-Disj.html#disjT",
        "fct-type": "function",
        "title": "disjT"
      },
      "index": {
        "description": "Construct DisjT action",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "disjT",
        "normalized": "a[b]-\u003eDisjT a b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "m[a]-\u003eDisjT m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:disjunction",
      "description": {
        "fct-descr": "\u003cp\u003eDisjoin two computations.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "m a -\u003e m a -\u003e m a",
        "fct-source": "src/Control-Monad-Disj-Class.html#disjunction",
        "fct-type": "method",
        "title": "disjunction"
      },
      "index": {
        "description": "Disjoin two computations",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "disjunction",
        "normalized": "a b-\u003ea b-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "m a-\u003em a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:disjunctionOfList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003edisjunctionOfList xs\u003c/code\u003e build the disjunction of the values in list \u003ccode\u003exs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e m a",
        "fct-source": "src/Control-Monad-Disj.html#disjunctionOfList",
        "fct-type": "function",
        "title": "disjunctionOfList"
      },
      "index": {
        "description": "disjunctionOfList xs build the disjunction of the values in list xs",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "disjunctionOfList",
        "normalized": "[a]-\u003eb a",
        "package": "tamarin-prover-utils",
        "partial": "Of List",
        "signature": "[a]-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:disjunctions",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003edisjunctions ds\u003c/code\u003e builds the disjunction of all the \u003ccode\u003eds\u003c/code\u003e values.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[m a] -\u003e m a",
        "fct-source": "src/Control-Monad-Disj.html#disjunctions",
        "fct-type": "function",
        "title": "disjunctions"
      },
      "index": {
        "description": "disjunctions ds builds the disjunction of all the ds values",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "disjunctions",
        "normalized": "[a b]-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[m a]-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:runDisjT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eDisjT\u003c/a\u003e\u003c/code\u003e action.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "DisjT m a -\u003e m [a]",
        "fct-source": "src/Control-Monad-Trans-Disj.html#runDisjT",
        "fct-type": "function",
        "title": "runDisjT"
      },
      "index": {
        "description": "Run DisjT action",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "runDisjT",
        "normalized": "DisjT a b-\u003ea[b]",
        "package": "tamarin-prover-utils",
        "partial": "Disj",
        "signature": "DisjT m a-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Disj.html#v:unDisjT",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Control.Monad.Disj",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "ListT m a",
        "fct-source": "src/Control-Monad-Trans-Disj.html#DisjT",
        "fct-type": "function",
        "title": "unDisjT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Disj",
        "module": "Control.Monad.Disj",
        "name": "unDisjT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Disj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComputations that need a fresh name supply.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Fresh.html",
        "fct-type": "module",
        "title": "Fresh"
      },
      "index": {
        "description": "Computations that need fresh name supply",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "Fresh",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#t:Fresh",
      "description": {
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#Fresh",
        "fct-type": "type",
        "title": "Fresh"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "Fresh",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#t:FreshState",
      "description": {
        "fct-descr": "\u003cp\u003eThe state of the name supply: the first unused sequence number of every name.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#FreshState",
        "fct-type": "type",
        "title": "FreshState"
      },
      "index": {
        "description": "The state of the name supply the first unused sequence number of every name",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "FreshState",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#t:FreshT",
      "description": {
        "fct-descr": "\u003cp\u003eA computation that can generate fresh variables from name hints.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#FreshT",
        "fct-type": "newtype",
        "title": "FreshT"
      },
      "index": {
        "description": "computation that can generate fresh variables from name hints",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "FreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#t:MonadFresh",
      "description": {
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "class",
        "fct-source": "src/Control-Monad-Fresh-Class.html#MonadFresh",
        "fct-type": "class",
        "title": "MonadFresh"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "MonadFresh",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Monad Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:FreshT",
      "description": {
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#FreshT",
        "fct-type": "function",
        "title": "FreshT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "FreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:evalFresh",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#evalFresh",
        "fct-type": "function",
        "title": "evalFresh"
      },
      "index": {
        "description": "Evaluate computation with fresh name supply",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "evalFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:evalFreshT",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#evalFreshT",
        "fct-type": "function",
        "title": "evalFreshT"
      },
      "index": {
        "description": "Evaluate computation with fresh name supply",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "evalFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:execFresh",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e FreshState",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#execFresh",
        "fct-type": "function",
        "title": "execFresh"
      },
      "index": {
        "description": "Execute computation with fresh name supply",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "execFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003eFreshState",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003eFreshState"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:execFreshT",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m FreshState",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#execFreshT",
        "fct-type": "function",
        "title": "execFreshT"
      },
      "index": {
        "description": "Execute computation with fresh name supply",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "execFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea FreshState",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em FreshState"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:freshIdent",
      "description": {
        "fct-descr": "\u003cp\u003eGet the integer of the next fresh identifier of this name.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "freshIdent",
        "fct-source": "src/Control-Monad-Fresh-Class.html#freshIdent",
        "fct-type": "method",
        "title": "freshIdent"
      },
      "index": {
        "description": "Get the integer of the next fresh identifier of this name",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "freshIdent",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Ident",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:freshIdents",
      "description": {
        "fct-descr": "\u003cp\u003eGet a number of fresh identifiers. This reserves the required number\n of identifiers on all names.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "freshIdents",
        "fct-source": "src/Control-Monad-Fresh-Class.html#freshIdents",
        "fct-type": "method",
        "title": "freshIdents"
      },
      "index": {
        "description": "Get number of fresh identifiers This reserves the required number of identifiers on all names",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "freshIdents",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Idents",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:freshT",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003eFreshT\u003c/a\u003e\u003c/code\u003e action from a \u003ccode\u003e\u003ca\u003eFreshState\u003c/a\u003e\u003c/code\u003e modification.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(FreshState -\u003e m (a, FreshState)) -\u003e FreshT m a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#freshT",
        "fct-type": "function",
        "title": "freshT"
      },
      "index": {
        "description": "Construct FreshT action from FreshState modification",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "freshT",
        "normalized": "(FreshState-\u003ea(b,FreshState))-\u003eFreshT a b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(FreshState-\u003em(a,FreshState))-\u003eFreshT m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:nothingUsed",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty fresh state.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshState",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#nothingUsed",
        "fct-type": "function",
        "title": "nothingUsed"
      },
      "index": {
        "description": "The empty fresh state",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "nothingUsed",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Used",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:runFresh",
      "description": {
        "fct-descr": "\u003cp\u003eRun a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e (a, FreshState)",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#runFresh",
        "fct-type": "function",
        "title": "runFresh"
      },
      "index": {
        "description": "Run computation with fresh name supply",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "runFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003e(a,FreshState)",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003e(a,FreshState)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:runFreshT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m (a, FreshState)",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#runFreshT",
        "fct-type": "function",
        "title": "runFreshT"
      },
      "index": {
        "description": "Run computation with fresh name supply",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "runFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea(b,FreshState)",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em(a,FreshState)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:scopeFreshness",
      "description": {
        "fct-descr": "\u003cp\u003eScope the \u003ccode\u003e\u003ca\u003efreshIdent\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efreshIdents\u003c/a\u003e\u003c/code\u003e requests such that these\n variables are not marked as used once the scope is left.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "m a -\u003e m a",
        "fct-source": "src/Control-Monad-Fresh-Class.html#scopeFreshness",
        "fct-type": "method",
        "title": "scopeFreshness"
      },
      "index": {
        "description": "Scope the freshIdent and freshIdents requests such that these variables are not marked as used once the scope is left",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "scopeFreshness",
        "normalized": "a b-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "Freshness",
        "signature": "m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Fresh.html#v:unFreshT",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Control.Monad.Fresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "StateT FreshState m a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#FreshT",
        "fct-type": "function",
        "title": "unFreshT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Fresh",
        "module": "Control.Monad.Fresh",
        "name": "unFreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA monad transformer for passing a fast fresh name supply through a\n computation. It uses an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e counter to determine the next free name.\n\u003c/p\u003e\u003cp\u003eModeled after the mtl-2.0 library.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html",
        "fct-type": "module",
        "title": "FastFresh"
      },
      "index": {
        "description": "monad transformer for passing fast fresh name supply through computation It uses an Integer counter to determine the next free name Modeled after the mtl-2.0 library",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "FastFresh",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fast Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#t:Fresh",
      "description": {
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#Fresh",
        "fct-type": "type",
        "title": "Fresh"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "Fresh",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#t:FreshState",
      "description": {
        "fct-descr": "\u003cp\u003eThe state of the name supply: the first unused sequence number of every name.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#FreshState",
        "fct-type": "type",
        "title": "FreshState"
      },
      "index": {
        "description": "The state of the name supply the first unused sequence number of every name",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "FreshState",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#t:FreshT",
      "description": {
        "fct-descr": "\u003cp\u003eA computation that can generate fresh variables from name hints.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#FreshT",
        "fct-type": "newtype",
        "title": "FreshT"
      },
      "index": {
        "description": "computation that can generate fresh variables from name hints",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "FreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:FreshT",
      "description": {
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#FreshT",
        "fct-type": "function",
        "title": "FreshT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "FreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:evalFresh",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#evalFresh",
        "fct-type": "function",
        "title": "evalFresh"
      },
      "index": {
        "description": "Evaluate computation with fresh name supply",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "evalFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:evalFreshT",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#evalFreshT",
        "fct-type": "function",
        "title": "evalFreshT"
      },
      "index": {
        "description": "Evaluate computation with fresh name supply",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "evalFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:execFresh",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e FreshState",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#execFresh",
        "fct-type": "function",
        "title": "execFresh"
      },
      "index": {
        "description": "Execute computation with fresh name supply",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "execFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003eFreshState",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003eFreshState"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:execFreshT",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m FreshState",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#execFreshT",
        "fct-type": "function",
        "title": "execFreshT"
      },
      "index": {
        "description": "Execute computation with fresh name supply",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "execFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea FreshState",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em FreshState"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:freshIdents",
      "description": {
        "fct-descr": "\u003cp\u003eGet \u003ccode\u003ek\u003c/code\u003e fresh identifiers.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Integer-\u003e FreshT m Integer",
        "fct-type": "function",
        "title": "freshIdents"
      },
      "index": {
        "description": "Get fresh identifiers",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "freshIdents",
        "normalized": "Integer-\u003eFreshT a Integer",
        "package": "tamarin-prover-utils",
        "partial": "Idents",
        "signature": "Integer-\u003eFreshT m Integer"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:freshT",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003eFreshT\u003c/a\u003e\u003c/code\u003e action from a \u003ccode\u003e\u003ca\u003eFreshState\u003c/a\u003e\u003c/code\u003e modification.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(FreshState -\u003e m (a, FreshState)) -\u003e FreshT m a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#freshT",
        "fct-type": "function",
        "title": "freshT"
      },
      "index": {
        "description": "Construct FreshT action from FreshState modification",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "freshT",
        "normalized": "(FreshState-\u003ea(b,FreshState))-\u003eFreshT a b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(FreshState-\u003em(a,FreshState))-\u003eFreshT m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:nothingUsed",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty fresh state.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshState",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#nothingUsed",
        "fct-type": "function",
        "title": "nothingUsed"
      },
      "index": {
        "description": "The empty fresh state",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "nothingUsed",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Used",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:runFresh",
      "description": {
        "fct-descr": "\u003cp\u003eRun a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e (a, FreshState)",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#runFresh",
        "fct-type": "function",
        "title": "runFresh"
      },
      "index": {
        "description": "Run computation with fresh name supply",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "runFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003e(a,FreshState)",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003e(a,FreshState)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:runFreshT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m (a, FreshState)",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#runFreshT",
        "fct-type": "function",
        "title": "runFreshT"
      },
      "index": {
        "description": "Run computation with fresh name supply",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "runFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea(b,FreshState)",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em(a,FreshState)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:scopeFreshness",
      "description": {
        "fct-descr": "\u003cp\u003eRestrict the scope of the freshness requests.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshT m a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#scopeFreshness",
        "fct-type": "function",
        "title": "scopeFreshness"
      },
      "index": {
        "description": "Restrict the scope of the freshness requests",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "scopeFreshness",
        "normalized": "FreshT a b-\u003eFreshT a b",
        "package": "tamarin-prover-utils",
        "partial": "Freshness",
        "signature": "FreshT m a-\u003eFreshT m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-FastFresh.html#v:unFreshT",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Control.Monad.Trans.FastFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "StateT FreshState m a",
        "fct-source": "src/Control-Monad-Trans-FastFresh.html#FreshT",
        "fct-type": "function",
        "title": "unFreshT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Trans FastFresh",
        "module": "Control.Monad.Trans.FastFresh",
        "name": "unFreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA monad transformer for passing a fresh name supply through a computation.\n The name supply is precise in the sense that every \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e has its own\n supply of indices for the next fresh name.\n\u003c/p\u003e\u003cp\u003eModeled after the mtl-2.0 library.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html",
        "fct-type": "module",
        "title": "PreciseFresh"
      },
      "index": {
        "description": "monad transformer for passing fresh name supply through computation The name supply is precise in the sense that every String has its own supply of indices for the next fresh name Modeled after the mtl-2.0 library",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "PreciseFresh",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Precise Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#t:Fresh",
      "description": {
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#Fresh",
        "fct-type": "type",
        "title": "Fresh"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "Fresh",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#t:FreshState",
      "description": {
        "fct-descr": "\u003cp\u003eThe state of the name supply: the first unused sequence number of every name.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#FreshState",
        "fct-type": "type",
        "title": "FreshState"
      },
      "index": {
        "description": "The state of the name supply the first unused sequence number of every name",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "FreshState",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#t:FreshT",
      "description": {
        "fct-descr": "\u003cp\u003eA computation that can generate fresh variables from name hints.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#FreshT",
        "fct-type": "newtype",
        "title": "FreshT"
      },
      "index": {
        "description": "computation that can generate fresh variables from name hints",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "FreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:FreshT",
      "description": {
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#FreshT",
        "fct-type": "function",
        "title": "FreshT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "FreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:evalFresh",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e a",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#evalFresh",
        "fct-type": "function",
        "title": "evalFresh"
      },
      "index": {
        "description": "Evaluate computation with fresh name supply",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "evalFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:evalFreshT",
      "description": {
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m a",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#evalFreshT",
        "fct-type": "function",
        "title": "evalFreshT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "evalFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:execFresh",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e FreshState",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#execFresh",
        "fct-type": "function",
        "title": "execFresh"
      },
      "index": {
        "description": "Execute computation with fresh name supply",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "execFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003eFreshState",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003eFreshState"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:execFreshT",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m FreshState",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#execFreshT",
        "fct-type": "function",
        "title": "execFreshT"
      },
      "index": {
        "description": "Execute computation with fresh name supply",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "execFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea FreshState",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em FreshState"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:freshIdent",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(log(n))\u003c/em\u003e. Get a fresh identifier for the given name.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e FreshT m Integer",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#freshIdent",
        "fct-type": "function",
        "title": "freshIdent"
      },
      "index": {
        "description": "log Get fresh identifier for the given name",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "freshIdent",
        "normalized": "String-\u003eFreshT a Integer",
        "package": "tamarin-prover-utils",
        "partial": "Ident",
        "signature": "String-\u003eFreshT m Integer"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:freshIdents",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Get \u003ccode\u003ek\u003c/code\u003e fresh identifiers.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Integer-\u003e FreshT m Integer",
        "fct-type": "function",
        "title": "freshIdents"
      },
      "index": {
        "description": "Get fresh identifiers",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "freshIdents",
        "normalized": "Integer-\u003eFreshT a Integer",
        "package": "tamarin-prover-utils",
        "partial": "Idents",
        "signature": "Integer-\u003eFreshT m Integer"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:freshT",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003eFreshT\u003c/a\u003e\u003c/code\u003e action from a \u003ccode\u003e\u003ca\u003eFreshState\u003c/a\u003e\u003c/code\u003e modification.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(FreshState -\u003e m (a, FreshState)) -\u003e FreshT m a",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#freshT",
        "fct-type": "function",
        "title": "freshT"
      },
      "index": {
        "description": "Construct FreshT action from FreshState modification",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "freshT",
        "normalized": "(FreshState-\u003ea(b,FreshState))-\u003eFreshT a b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(FreshState-\u003em(a,FreshState))-\u003eFreshT m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:nothingUsed",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty fresh state.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshState",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#nothingUsed",
        "fct-type": "function",
        "title": "nothingUsed"
      },
      "index": {
        "description": "The empty fresh state",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "nothingUsed",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Used",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:runFresh",
      "description": {
        "fct-descr": "\u003cp\u003eRun a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Fresh a -\u003e FreshState -\u003e (a, FreshState)",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#runFresh",
        "fct-type": "function",
        "title": "runFresh"
      },
      "index": {
        "description": "Run computation with fresh name supply",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "runFresh",
        "normalized": "Fresh a-\u003eFreshState-\u003e(a,FreshState)",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "Fresh a-\u003eFreshState-\u003e(a,FreshState)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:runFreshT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a computation with a fresh name supply.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshState -\u003e m (a, FreshState)",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#runFreshT",
        "fct-type": "function",
        "title": "runFreshT"
      },
      "index": {
        "description": "Run computation with fresh name supply",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "runFreshT",
        "normalized": "FreshT a b-\u003eFreshState-\u003ea(b,FreshState)",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": "FreshT m a-\u003eFreshState-\u003em(a,FreshState)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:scopeFreshness",
      "description": {
        "fct-descr": "\u003cp\u003eRestrict the scope of the freshness requests.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "FreshT m a -\u003e FreshT m a",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#scopeFreshness",
        "fct-type": "function",
        "title": "scopeFreshness"
      },
      "index": {
        "description": "Restrict the scope of the freshness requests",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "scopeFreshness",
        "normalized": "FreshT a b-\u003eFreshT a b",
        "package": "tamarin-prover-utils",
        "partial": "Freshness",
        "signature": "FreshT m a-\u003eFreshT m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Control-Monad-Trans-PreciseFresh.html#v:unFreshT",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Control.Monad.Trans.PreciseFresh",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "StateT FreshState m a",
        "fct-source": "src/Control-Monad-Trans-PreciseFresh.html#FreshT",
        "fct-type": "function",
        "title": "unFreshT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Trans PreciseFresh",
        "module": "Control.Monad.Trans.PreciseFresh",
        "name": "unFreshT",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Fresh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple color module for handling RGB and HSV representations of colors.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Data-Color.html",
        "fct-type": "module",
        "title": "Color"
      },
      "index": {
        "description": "simple color module for handling RGB and HSV representations of colors",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "Color",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Color",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#t:HSV",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-source": "src/Data-Color.html#HSV",
        "fct-type": "data",
        "title": "HSV"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "HSV",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "HSV",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#t:RGB",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-source": "src/Data-Color.html#RGB",
        "fct-type": "data",
        "title": "RGB"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "RGB",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "RGB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:HSV",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "HSV",
        "fct-source": "src/Data-Color.html#HSV",
        "fct-type": "function",
        "title": "HSV"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "HSV",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "HSV",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:RGB",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "RGB",
        "fct-source": "src/Data-Color.html#RGB",
        "fct-type": "function",
        "title": "RGB"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "RGB",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "RGB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:blue",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "RGB t",
        "fct-source": "src/Data-Color.html#blue",
        "fct-type": "function",
        "title": "blue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "blue",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:colorGroups",
      "description": {
        "fct-descr": "\u003cp\u003eBuild color groups according to the list of group sizes using the default\n \u003ccode\u003ecolorGroupStyle\u003c/code\u003e for the function \u003ccode\u003egenColorGroups\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Double -\u003e [Int] -\u003e [((Int, Int), HSV Double)]",
        "fct-source": "src/Data-Color.html#colorGroups",
        "fct-type": "function",
        "title": "colorGroups"
      },
      "index": {
        "description": "Build color groups according to the list of group sizes using the default colorGroupStyle for the function genColorGroups",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "colorGroups",
        "normalized": "Double-\u003e[Int]-\u003e[((Int,Int),HSV Double)]",
        "package": "tamarin-prover-utils",
        "partial": "Groups",
        "signature": "Double-\u003e[Int]-\u003e[((Int,Int),HSV Double)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:green",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "RGB t",
        "fct-source": "src/Data-Color.html#green",
        "fct-type": "function",
        "title": "green"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "green",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:hsvH",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "!a",
        "fct-source": "src/Data-Color.html#HSV",
        "fct-type": "function",
        "title": "hsvH"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "hsvH",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:hsvS",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "!a",
        "fct-source": "src/Data-Color.html#HSV",
        "fct-type": "function",
        "title": "hsvS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "hsvS",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:hsvToGray",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "HSV t -\u003e HSV t",
        "fct-source": "src/Data-Color.html#hsvToGray",
        "fct-type": "function",
        "title": "hsvToGray"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "hsvToGray",
        "normalized": "HSV a-\u003eHSV a",
        "package": "tamarin-prover-utils",
        "partial": "To Gray",
        "signature": "HSV t-\u003eHSV t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:hsvToHex",
      "description": {
        "fct-descr": "\u003cp\u003eHexadecimal representation of an HSV value; i.e., of its corresponding RGB\n value.\n\u003c/p\u003e",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "HSV t -\u003e [Char]",
        "fct-source": "src/Data-Color.html#hsvToHex",
        "fct-type": "function",
        "title": "hsvToHex"
      },
      "index": {
        "description": "Hexadecimal representation of an HSV value i.e of its corresponding RGB value",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "hsvToHex",
        "normalized": "HSV a-\u003e[Char]",
        "package": "tamarin-prover-utils",
        "partial": "To Hex",
        "signature": "HSV t-\u003e[Char]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:hsvToRGB",
      "description": {
        "fct-descr": "\u003cp\u003eHSV to RGB conversion.\n Pre: 0 \u003c= h \u003c= 360 and 0 \u003c= s,v \u003c= 1\n (Source: http:\u003cem/\u003ede.wikipedia.org\u003cem\u003ewiki\u003c/em\u003eHSV-Farbraum)\n\u003c/p\u003e",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "HSV t -\u003e RGB t",
        "fct-source": "src/Data-Color.html#hsvToRGB",
        "fct-type": "function",
        "title": "hsvToRGB"
      },
      "index": {
        "description": "HSV to RGB conversion Pre and Source http de.wikipedia.org wiki HSV-Farbraum",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "hsvToRGB",
        "normalized": "HSV a-\u003eRGB a",
        "package": "tamarin-prover-utils",
        "partial": "To RGB",
        "signature": "HSV t-\u003eRGB t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:hsvV",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "!a",
        "fct-source": "src/Data-Color.html#HSV",
        "fct-type": "function",
        "title": "hsvV"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "hsvV",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:lightColorGroups",
      "description": {
        "fct-descr": "\u003cp\u003eBuild color groups according to the list of group sizes using the\n default light \u003ccode\u003elightColorGroupStyle\u003c/code\u003e for the function\n \u003ccode\u003egenColorGroups\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Double -\u003e [Int] -\u003e [((Int, Int), HSV Double)]",
        "fct-source": "src/Data-Color.html#lightColorGroups",
        "fct-type": "function",
        "title": "lightColorGroups"
      },
      "index": {
        "description": "Build color groups according to the list of group sizes using the default light lightColorGroupStyle for the function genColorGroups",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "lightColorGroups",
        "normalized": "Double-\u003e[Int]-\u003e[((Int,Int),HSV Double)]",
        "package": "tamarin-prover-utils",
        "partial": "Color Groups",
        "signature": "Double-\u003e[Int]-\u003e[((Int,Int),HSV Double)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:red",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "RGB t",
        "fct-source": "src/Data-Color.html#red",
        "fct-type": "function",
        "title": "red"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "red",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:rgbB",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "!a",
        "fct-source": "src/Data-Color.html#RGB",
        "fct-type": "function",
        "title": "rgbB"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "rgbB",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:rgbG",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "!a",
        "fct-source": "src/Data-Color.html#RGB",
        "fct-type": "function",
        "title": "rgbG"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "rgbG",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:rgbR",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "!a",
        "fct-source": "src/Data-Color.html#RGB",
        "fct-type": "function",
        "title": "rgbR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "rgbR",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:rgbToGray",
      "description": {
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "RGB t -\u003e t",
        "fct-source": "src/Data-Color.html#rgbToGray",
        "fct-type": "function",
        "title": "rgbToGray"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "rgbToGray",
        "normalized": "RGB a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "To Gray",
        "signature": "RGB t-\u003et"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:rgbToHSV",
      "description": {
        "fct-descr": "\u003cp\u003eRGB to HSV conversion.\n Pre: 0 \u003c= r,g,b \u003c= 1\n (Source: http:\u003cem/\u003ede.wikipedia.org\u003cem\u003ewiki\u003c/em\u003eHSV-Farbraum)\n\u003c/p\u003e",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "RGB t -\u003e HSV t",
        "fct-source": "src/Data-Color.html#rgbToHSV",
        "fct-type": "function",
        "title": "rgbToHSV"
      },
      "index": {
        "description": "RGB to HSV conversion Pre Source http de.wikipedia.org wiki HSV-Farbraum",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "rgbToHSV",
        "normalized": "RGB a-\u003eHSV a",
        "package": "tamarin-prover-utils",
        "partial": "To HSV",
        "signature": "RGB t-\u003eHSV t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-Color.html#v:rgbToHex",
      "description": {
        "fct-descr": "\u003cp\u003eHexadecimal representation of an RGB value\n\u003c/p\u003e",
        "fct-module": "Data.Color",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "RGB t -\u003e String",
        "fct-source": "src/Data-Color.html#rgbToHex",
        "fct-type": "function",
        "title": "rgbToHex"
      },
      "index": {
        "description": "Hexadecimal representation of an RGB value",
        "hierarchy": "Data Color",
        "module": "Data.Color",
        "name": "rgbToHex",
        "normalized": "RGB a-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "To Hex",
        "signature": "RGB t-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple  vertice list based representation of DAGs and some common operations on it.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Data-DAG-Simple.html",
        "fct-type": "module",
        "title": "Simple"
      },
      "index": {
        "description": "Simple vertice list based representation of DAGs and some common operations on it",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "Simple",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Simple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#t:Relation",
      "description": {
        "fct-descr": "\u003cp\u003eA relation represented as a list of tuples.\n\u003c/p\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Data-DAG-Simple.html#Relation",
        "fct-type": "type",
        "title": "Relation"
      },
      "index": {
        "description": "relation represented as list of tuples",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "Relation",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Relation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#v:cyclic",
      "description": {
        "fct-descr": "\u003cp\u003eIs the relation cyclic.\n\u003c/p\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(a, a)] -\u003e Bool",
        "fct-source": "src/Data-DAG-Simple.html#cyclic",
        "fct-type": "function",
        "title": "cyclic"
      },
      "index": {
        "description": "Is the relation cyclic",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "cyclic",
        "normalized": "[(a,a)]-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[(a,a)]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#v:dfsLoopBreakers",
      "description": {
        "fct-descr": "\u003cp\u003eCompute a minimal set of loop-breakers using a greedy DFS strategy. A set\n of loop-breakers is a set of nodes such that removing them ensures the\n acyclicity of the relation. It is minimal, if no node can be removed from\n the set.\n\u003c/p\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(a, a)] -\u003e [a]",
        "fct-source": "src/Data-DAG-Simple.html#dfsLoopBreakers",
        "fct-type": "function",
        "title": "dfsLoopBreakers"
      },
      "index": {
        "description": "Compute minimal set of loop-breakers using greedy DFS strategy set of loop-breakers is set of nodes such that removing them ensures the acyclicity of the relation It is minimal if no node can be removed from the set",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "dfsLoopBreakers",
        "normalized": "[(a,a)]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "Loop Breakers",
        "signature": "[(a,a)]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#v:image",
      "description": {
        "fct-descr": "\u003cp\u003eThe image of an element under a \u003ccode\u003e\u003ca\u003eRelation\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "a -\u003e Relation a -\u003e [a]",
        "fct-source": "src/Data-DAG-Simple.html#image",
        "fct-type": "function",
        "title": "image"
      },
      "index": {
        "description": "The image of an element under Relation",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "image",
        "normalized": "a-\u003eRelation a-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "a-\u003eRelation a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#v:inverse",
      "description": {
        "fct-descr": "\u003cp\u003eThe inverse of a \u003ccode\u003e\u003ca\u003eRelation\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Relation a -\u003e Relation a",
        "fct-source": "src/Data-DAG-Simple.html#inverse",
        "fct-type": "function",
        "title": "inverse"
      },
      "index": {
        "description": "The inverse of Relation",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "inverse",
        "normalized": "Relation a-\u003eRelation a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Relation a-\u003eRelation a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#v:reachableSet",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the set of nodes reachable from the given set of nodes.\n\u003c/p\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e [(a, a)] -\u003e Set a",
        "fct-source": "src/Data-DAG-Simple.html#reachableSet",
        "fct-type": "function",
        "title": "reachableSet"
      },
      "index": {
        "description": "Compute the set of nodes reachable from the given set of nodes",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "reachableSet",
        "normalized": "[a]-\u003e[(a,a)]-\u003eSet a",
        "package": "tamarin-prover-utils",
        "partial": "Set",
        "signature": "[a]-\u003e[(a,a)]-\u003eSet a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#v:restrict",
      "description": {
        "fct-descr": "\u003cp\u003eRestrict a relation to elements satisfying a predicate.\n\u003c/p\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e Bool) -\u003e Relation a -\u003e Relation a",
        "fct-source": "src/Data-DAG-Simple.html#restrict",
        "fct-type": "function",
        "title": "restrict"
      },
      "index": {
        "description": "Restrict relation to elements satisfying predicate",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "restrict",
        "normalized": "(a-\u003eBool)-\u003eRelation a-\u003eRelation a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eRelation a-\u003eRelation a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Data-DAG-Simple.html#v:toposort",
      "description": {
        "fct-descr": "\u003cp\u003eProduce a topological sorting of the given relation. If the relation is\n cyclic, then the result is at least some permutation of all elements of\n the given relation.\n\u003c/p\u003e",
        "fct-module": "Data.DAG.Simple",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(a, a)] -\u003e [a]",
        "fct-source": "src/Data-DAG-Simple.html#toposort",
        "fct-type": "function",
        "title": "toposort"
      },
      "index": {
        "description": "Produce topological sorting of the given relation If the relation is cyclic then the result is at least some permutation of all elements of the given relation",
        "hierarchy": "Data DAG Simple",
        "module": "Data.DAG.Simple",
        "name": "toposort",
        "normalized": "[(a,a)]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[(a,a)]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Debug-Trace-Ignore.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule that can be imported to ignore calls to \u003ccode\u003etrace\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Debug.Trace.Ignore",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Debug-Trace-Ignore.html",
        "fct-type": "module",
        "title": "Ignore"
      },
      "index": {
        "description": "Module that can be imported to ignore calls to trace",
        "hierarchy": "Debug Trace Ignore",
        "module": "Debug.Trace.Ignore",
        "name": "Ignore",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Ignore",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Debug-Trace-Ignore.html#v:trace",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003etrace a b\u003c/code\u003e returns the second argument.\n\u003c/p\u003e",
        "fct-module": "Debug.Trace.Ignore",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "a -\u003e b -\u003e b",
        "fct-source": "src/Debug-Trace-Ignore.html#trace",
        "fct-type": "function",
        "title": "trace"
      },
      "index": {
        "description": "trace returns the second argument",
        "hierarchy": "Debug Trace Ignore",
        "module": "Debug.Trace.Ignore",
        "name": "trace",
        "normalized": "a-\u003eb-\u003eb",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "a-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Bounded.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonoids for bounded types.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Extension.Data.Bounded",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Extension-Data-Bounded.html",
        "fct-type": "module",
        "title": "Bounded"
      },
      "index": {
        "description": "Monoids for bounded types",
        "hierarchy": "Extension Data Bounded",
        "module": "Extension.Data.Bounded",
        "name": "Bounded",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Bounded.html#t:BoundedMax",
      "description": {
        "fct-descr": "\u003cp\u003eA newtype wrapper for a monoid of the maximum of a bounded type.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Bounded",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Extension-Data-Bounded.html#BoundedMax",
        "fct-type": "newtype",
        "title": "BoundedMax"
      },
      "index": {
        "description": "newtype wrapper for monoid of the maximum of bounded type",
        "hierarchy": "Extension Data Bounded",
        "module": "Extension.Data.Bounded",
        "name": "BoundedMax",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bounded Max",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Bounded.html#t:BoundedMin",
      "description": {
        "fct-descr": "\u003cp\u003eA newtype wrapper for a monoid of the minimum of a bounded type.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Bounded",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Extension-Data-Bounded.html#BoundedMin",
        "fct-type": "newtype",
        "title": "BoundedMin"
      },
      "index": {
        "description": "newtype wrapper for monoid of the minimum of bounded type",
        "hierarchy": "Extension Data Bounded",
        "module": "Extension.Data.Bounded",
        "name": "BoundedMin",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bounded Min",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Bounded.html#v:BoundedMax",
      "description": {
        "fct-module": "Extension.Data.Bounded",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "BoundedMax",
        "fct-source": "src/Extension-Data-Bounded.html#BoundedMax",
        "fct-type": "function",
        "title": "BoundedMax"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Data Bounded",
        "module": "Extension.Data.Bounded",
        "name": "BoundedMax",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bounded Max",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Bounded.html#v:BoundedMin",
      "description": {
        "fct-module": "Extension.Data.Bounded",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "BoundedMin",
        "fct-source": "src/Extension-Data-Bounded.html#BoundedMin",
        "fct-type": "function",
        "title": "BoundedMin"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Data Bounded",
        "module": "Extension.Data.Bounded",
        "name": "BoundedMin",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bounded Min",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Bounded.html#v:getBoundedMax",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Extension.Data.Bounded",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "a",
        "fct-source": "src/Extension-Data-Bounded.html#BoundedMax",
        "fct-type": "function",
        "title": "getBoundedMax"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Data Bounded",
        "module": "Extension.Data.Bounded",
        "name": "getBoundedMax",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bounded Max",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Bounded.html#v:getBoundedMin",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Extension.Data.Bounded",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "a",
        "fct-source": "src/Extension-Data-Bounded.html#BoundedMin",
        "fct-type": "function",
        "title": "getBoundedMin"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Data Bounded",
        "module": "Extension.Data.Bounded",
        "name": "getBoundedMin",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Bounded Min",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-ByteString.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvided NFData instance for ByteString (with bytestring \u003c 0.10)\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Extension.Data.ByteString",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Extension-Data-ByteString.html",
        "fct-type": "module",
        "title": "ByteString"
      },
      "index": {
        "description": "Provided NFData instance for ByteString with bytestring",
        "hierarchy": "Extension Data ByteString",
        "module": "Extension.Data.ByteString",
        "name": "ByteString",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Byte String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtensions to the first-class labels (fclabels) package.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Extension-Data-Label.html",
        "fct-type": "module",
        "title": "Label"
      },
      "index": {
        "description": "Extensions to the first-class labels fclabels package",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "Label",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:-61-:",
      "description": {
        "fct-descr": "\u003cp\u003eAlias for \u003ccode\u003e\u003ca\u003eputs\u003c/a\u003e\u003c/code\u003e that reads like an assignment.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": ":-\u003e s a -\u003e a -\u003e m ()",
        "fct-type": "function",
        "title": "(=:)"
      },
      "index": {
        "description": "Alias for puts that reads like an assignment",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "(=:) =:",
        "normalized": "-\u003ea b-\u003eb-\u003ec()",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "-\u003es a-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:askM",
      "description": {
        "fct-descr": "\u003cp\u003eGet part of the state from a reader.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(r :-\u003e a) -\u003e m a",
        "fct-source": "src/Extension-Data-Label.html#askM",
        "fct-type": "function",
        "title": "askM"
      },
      "index": {
        "description": "Get part of the state from reader",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "askM",
        "normalized": "(a-\u003eb)-\u003ec b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(r-\u003ea)-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:fstL",
      "description": {
        "fct-descr": "\u003cp\u003eLens for the first element of a tuple.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a, b) :-\u003e a",
        "fct-source": "src/Extension-Data-Label.html#fstL",
        "fct-type": "function",
        "title": "fstL"
      },
      "index": {
        "description": "Lens for the first element of tuple",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "fstL",
        "normalized": "(a,b)-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(a,b)-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:getM",
      "description": {
        "fct-descr": "\u003cp\u003eGet some part of the state.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(s :-\u003e a) -\u003e m a",
        "fct-source": "src/Extension-Data-Label.html#getM",
        "fct-type": "function",
        "title": "getM"
      },
      "index": {
        "description": "Get some part of the state",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "getM",
        "normalized": "(a-\u003eb)-\u003ec b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(s-\u003ea)-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:imageL",
      "description": {
        "fct-descr": "\u003cp\u003eLens for the element at a given position of a map.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "k -\u003e Map k v :-\u003e v",
        "fct-source": "src/Extension-Data-Label.html#imageL",
        "fct-type": "function",
        "title": "imageL"
      },
      "index": {
        "description": "Lens for the element at given position of map",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "imageL",
        "normalized": "a-\u003eMap a b-\u003eb",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "k-\u003eMap k v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:liftLA",
      "description": {
        "fct-descr": "\u003cp\u003eLift a label into an applicative functor.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a :-\u003e b) -\u003e f a :-\u003e f b",
        "fct-source": "src/Extension-Data-Label.html#liftLA",
        "fct-type": "function",
        "title": "liftLA"
      },
      "index": {
        "description": "Lift label into an applicative functor",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "liftLA",
        "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
        "package": "tamarin-prover-utils",
        "partial": "LA",
        "signature": "(a-\u003eb)-\u003ef a-\u003ef b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:modA",
      "description": {
        "fct-descr": "\u003cp\u003eEffectful modification of a labeled value.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a :-\u003e b) -\u003e (b -\u003e f b) -\u003e a -\u003e f a",
        "fct-source": "src/Extension-Data-Label.html#modA",
        "fct-type": "function",
        "title": "modA"
      },
      "index": {
        "description": "Effectful modification of labeled value",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "modA",
        "normalized": "(a-\u003eb)-\u003e(b-\u003ec b)-\u003ea-\u003ec a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(a-\u003eb)-\u003e(b-\u003ef b)-\u003ea-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:modM",
      "description": {
        "fct-descr": "\u003cp\u003eModify some part of the state.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(s :-\u003e a) -\u003e (a -\u003e a) -\u003e m ()",
        "fct-source": "src/Extension-Data-Label.html#modM",
        "fct-type": "function",
        "title": "modM"
      },
      "index": {
        "description": "Modify some part of the state",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "modM",
        "normalized": "(a-\u003eb)-\u003e(b-\u003eb)-\u003ec()",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(s-\u003ea)-\u003e(a-\u003ea)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:nthL",
      "description": {
        "fct-descr": "\u003cp\u003eLens for the nth element of the list.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e [a] :-\u003e a",
        "fct-source": "src/Extension-Data-Label.html#nthL",
        "fct-type": "function",
        "title": "nthL"
      },
      "index": {
        "description": "Lens for the nth element of the list",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "nthL",
        "normalized": "Int-\u003e[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Int-\u003e[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:setM",
      "description": {
        "fct-descr": "\u003cp\u003eSet some part of the state.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(s :-\u003e a) -\u003e a -\u003e m ()",
        "fct-source": "src/Extension-Data-Label.html#setM",
        "fct-type": "function",
        "title": "setM"
      },
      "index": {
        "description": "Set some part of the state",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "setM",
        "normalized": "(a-\u003eb)-\u003eb-\u003ec()",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(s-\u003ea)-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Label.html#v:sndL",
      "description": {
        "fct-descr": "\u003cp\u003eLens for the second element of a tuple.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Label",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a, b) :-\u003e b",
        "fct-source": "src/Extension-Data-Label.html#sndL",
        "fct-type": "function",
        "title": "sndL"
      },
      "index": {
        "description": "Lens for the second element of tuple",
        "hierarchy": "Extension Data Label",
        "module": "Extension.Data.Label",
        "name": "sndL",
        "normalized": "(a,b)-\u003eb",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(a,b)-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Monoid.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA variant of \u003ca\u003eData.Monoid\u003c/a\u003e that also exports '(\u003ca/\u003e)' for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Extension.Data.Monoid",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Extension-Data-Monoid.html",
        "fct-type": "module",
        "title": "Monoid"
      },
      "index": {
        "description": "variant of Data.Monoid that also exports for mappend",
        "hierarchy": "Extension Data Monoid",
        "module": "Extension.Data.Monoid",
        "name": "Monoid",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Monoid",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Monoid.html#t:MinMax",
      "description": {
        "fct-descr": "\u003cp\u003eA newtype wrapper around \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e that returns a tuple of the minimum and\n maximum value encountered, if there was any.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Monoid",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Extension-Data-Monoid.html#MinMax",
        "fct-type": "newtype",
        "title": "MinMax"
      },
      "index": {
        "description": "newtype wrapper around Maybe that returns tuple of the minimum and maximum value encountered if there was any",
        "hierarchy": "Extension Data Monoid",
        "module": "Extension.Data.Monoid",
        "name": "MinMax",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Min Max",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Monoid.html#v:MinMax",
      "description": {
        "fct-module": "Extension.Data.Monoid",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "MinMax",
        "fct-source": "src/Extension-Data-Monoid.html#MinMax",
        "fct-type": "function",
        "title": "MinMax"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Data Monoid",
        "module": "Extension.Data.Monoid",
        "name": "MinMax",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Min Max",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Monoid.html#v:getMinMax",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Extension.Data.Monoid",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Maybe (a, a)",
        "fct-source": "src/Extension-Data-Monoid.html#MinMax",
        "fct-type": "function",
        "title": "getMinMax"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Data Monoid",
        "module": "Extension.Data.Monoid",
        "name": "getMinMax",
        "normalized": "Maybe(a,a)",
        "package": "tamarin-prover-utils",
        "partial": "Min Max",
        "signature": "Maybe(a,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Data-Monoid.html#v:minMaxSingleton",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003eMinMax\u003c/a\u003e\u003c/code\u003e value from a singleton value.\n\u003c/p\u003e",
        "fct-module": "Extension.Data.Monoid",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "a -\u003e MinMax a",
        "fct-source": "src/Extension-Data-Monoid.html#minMaxSingleton",
        "fct-type": "function",
        "title": "minMaxSingleton"
      },
      "index": {
        "description": "Construct MinMax value from singleton value",
        "hierarchy": "Extension Data Monoid",
        "module": "Extension.Data.Monoid",
        "name": "minMaxSingleton",
        "normalized": "a-\u003eMinMax a",
        "package": "tamarin-prover-utils",
        "partial": "Max Singleton",
        "signature": "a-\u003eMinMax a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions that could/should have made it into the Prelude or one of the\n base libraries\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Extension-Prelude.html",
        "fct-type": "module",
        "title": "Prelude"
      },
      "index": {
        "description": "Functions that could should have made it into the Prelude or one of the base libraries",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "Prelude",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Prelude",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#t:Named",
      "description": {
        "fct-descr": "\u003cp\u003eName values of a given type\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "type",
        "fct-source": "src/Extension-Prelude.html#Named",
        "fct-type": "type",
        "title": "Named"
      },
      "index": {
        "description": "Name values of given type",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "Named",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Named",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:choose",
      "description": {
        "fct-descr": "\u003cp\u003ethe list of all permutations of a given list\n permutations :: [a] -\u003e [[a]]\n permutations [] = [[]]\n permutations zs = aux zs []\n where aux [] _ = []\n aux (x:xs) ys = [x:p | p \u003c- permutations (xs++ys)] ++ aux xs (x:ys)\n\u003c/p\u003e\u003cp\u003ethe list of all combinations of n elements of a list.\n E.g. choose 2 [1,2,3] = [[1,2],[1,3],[2,3]]\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Extension-Prelude.html#choose",
        "fct-type": "function",
        "title": "choose"
      },
      "index": {
        "description": "the list of all permutations of given list permutations permutations permutations zs aux zs where aux aux xs ys permutations xs ys aux xs ys the list of all combinations of elements of list E.g choose",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "choose",
        "normalized": "Int-\u003e[a]-\u003e[[a]]",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Int-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:eqClasses",
      "description": {
        "fct-descr": "\u003cp\u003epartition the given set into equality classes with respect\n to the representative given by the projection function\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e b) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Extension-Prelude.html#eqClasses",
        "fct-type": "function",
        "title": "eqClasses"
      },
      "index": {
        "description": "partition the given set into equality classes with respect to the representative given by the projection function",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "eqClasses",
        "normalized": "(a-\u003eb)-\u003e[a]-\u003e[[a]]",
        "package": "tamarin-prover-utils",
        "partial": "Classes",
        "signature": "(a-\u003eb)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:eqClassesBy",
      "description": {
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(b -\u003e b -\u003e Ordering) -\u003e (a -\u003e b) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Extension-Prelude.html#eqClassesBy",
        "fct-type": "function",
        "title": "eqClassesBy"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "eqClassesBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003e(b-\u003ea)-\u003e[b]-\u003e[[b]]",
        "package": "tamarin-prover-utils",
        "partial": "Classes By",
        "signature": "(b-\u003eb-\u003eOrdering)-\u003e(a-\u003eb)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:errorFree",
      "description": {
        "fct-descr": "\u003cp\u003eGather all error free computations.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[m a] -\u003e m [a]",
        "fct-source": "src/Extension-Prelude.html#errorFree",
        "fct-type": "function",
        "title": "errorFree"
      },
      "index": {
        "description": "Gather all error free computations",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "errorFree",
        "normalized": "[a b]-\u003ea[b]",
        "package": "tamarin-prover-utils",
        "partial": "Free",
        "signature": "[m a]-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:errorFree1",
      "description": {
        "fct-descr": "\u003cp\u003eGather all error free computations and ensure that at least one was error\n free.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[m a] -\u003e m [a]",
        "fct-source": "src/Extension-Prelude.html#errorFree1",
        "fct-type": "function",
        "title": "errorFree1"
      },
      "index": {
        "description": "Gather all error free computations and ensure that at least one was error free",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "errorFree1",
        "normalized": "[a b]-\u003ea[b]",
        "package": "tamarin-prover-utils",
        "partial": "Free",
        "signature": "[m a]-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:flushLeft",
      "description": {
        "fct-descr": "\u003cp\u003eExtend a string with spaces to be flushed left.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e String -\u003e String",
        "fct-source": "src/Extension-Prelude.html#flushLeft",
        "fct-type": "function",
        "title": "flushLeft"
      },
      "index": {
        "description": "Extend string with spaces to be flushed left",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "flushLeft",
        "normalized": "Int-\u003eString-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "Left",
        "signature": "Int-\u003eString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:flushLeftBy",
      "description": {
        "fct-descr": "\u003cp\u003eExtend a list with the given separators to be flushed left.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e Int -\u003e [a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#flushLeftBy",
        "fct-type": "function",
        "title": "flushLeftBy"
      },
      "index": {
        "description": "Extend list with the given separators to be flushed left",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "flushLeftBy",
        "normalized": "[a]-\u003eInt-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "Left By",
        "signature": "[a]-\u003eInt-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:flushRight",
      "description": {
        "fct-descr": "\u003cp\u003eExtend a string with spaces to be flushed right.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e String -\u003e String",
        "fct-source": "src/Extension-Prelude.html#flushRight",
        "fct-type": "function",
        "title": "flushRight"
      },
      "index": {
        "description": "Extend string with spaces to be flushed right",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "flushRight",
        "normalized": "Int-\u003eString-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "Right",
        "signature": "Int-\u003eString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:flushRightBy",
      "description": {
        "fct-descr": "\u003cp\u003eExtend a list with the given separators to be flushed right.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e Int -\u003e [a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#flushRightBy",
        "fct-type": "function",
        "title": "flushRightBy"
      },
      "index": {
        "description": "Extend list with the given separators to be flushed right",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "flushRightBy",
        "normalized": "[a]-\u003eInt-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "Right By",
        "signature": "[a]-\u003eInt-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:groupOn",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem/\u003eO(n).\u003cem/\u003e Group on a projection of the data to group\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e b) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Extension-Prelude.html#groupOn",
        "fct-type": "function",
        "title": "groupOn"
      },
      "index": {
        "description": "Group on projection of the data to group",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "groupOn",
        "normalized": "(a-\u003eb)-\u003e[a]-\u003e[[a]]",
        "package": "tamarin-prover-utils",
        "partial": "On",
        "signature": "(a-\u003eb)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:groupSortOn",
      "description": {
        "fct-descr": "\u003cp\u003esort and group on a projection\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e b) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Extension-Prelude.html#groupSortOn",
        "fct-type": "function",
        "title": "groupSortOn"
      },
      "index": {
        "description": "sort and group on projection",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "groupSortOn",
        "normalized": "(a-\u003eb)-\u003e[a]-\u003e[[a]]",
        "package": "tamarin-prover-utils",
        "partial": "Sort On",
        "signature": "(a-\u003eb)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:ifM",
      "description": {
        "fct-descr": "\u003cp\u003eA monadic if statement\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "m Bool -\u003e m a -\u003e m a -\u003e m a",
        "fct-source": "src/Extension-Prelude.html#ifM",
        "fct-type": "function",
        "title": "ifM"
      },
      "index": {
        "description": "monadic if statement",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "ifM",
        "normalized": "a Bool-\u003ea b-\u003ea b-\u003ea b",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "m Bool-\u003em a-\u003em a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:implies",
      "description": {
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Bool -\u003e Bool -\u003e Bool",
        "fct-source": "src/Extension-Prelude.html#implies",
        "fct-type": "function",
        "title": "implies"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "implies",
        "normalized": "Bool-\u003eBool-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Bool-\u003eBool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:isLeft",
      "description": {
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Either a b -\u003e Bool",
        "fct-source": "src/Extension-Prelude.html#isLeft",
        "fct-type": "function",
        "title": "isLeft"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "isLeft",
        "normalized": "Either a b-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "Left",
        "signature": "Either a b-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:isRight",
      "description": {
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Either a b -\u003e Bool",
        "fct-source": "src/Extension-Prelude.html#isRight",
        "fct-type": "function",
        "title": "isRight"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "isRight",
        "normalized": "Either a b-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "Right",
        "signature": "Either a b-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:keepFirst",
      "description": {
        "fct-descr": "\u003cp\u003eAn element masks another element if the predicate is true. This function\n keeps only the elements not masked by a previous element in the list.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#keepFirst",
        "fct-type": "function",
        "title": "keepFirst"
      },
      "index": {
        "description": "An element masks another element if the predicate is true This function keeps only the elements not masked by previous element in the list",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "keepFirst",
        "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "First",
        "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:leaveOneOut",
      "description": {
        "fct-descr": "\u003cp\u003ebuild the list of lists each leaving another element out.\n (From left to right)\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e [[a]]",
        "fct-source": "src/Extension-Prelude.html#leaveOneOut",
        "fct-type": "function",
        "title": "leaveOneOut"
      },
      "index": {
        "description": "build the list of lists each leaving another element out From left to right",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "leaveOneOut",
        "normalized": "[a]-\u003e[[a]]",
        "package": "tamarin-prover-utils",
        "partial": "One Out",
        "signature": "[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:nubOn",
      "description": {
        "fct-descr": "\u003cp\u003eKeep only the first element of elements having the same projected value\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#nubOn",
        "fct-type": "function",
        "title": "nubOn"
      },
      "index": {
        "description": "Keep only the first element of elements having the same projected value",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "nubOn",
        "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "On",
        "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:oneOfList",
      "description": {
        "fct-descr": "\u003cp\u003eInject the elements of a list as alternatives.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e f a",
        "fct-source": "src/Extension-Prelude.html#oneOfList",
        "fct-type": "function",
        "title": "oneOfList"
      },
      "index": {
        "description": "Inject the elements of list as alternatives",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "oneOfList",
        "normalized": "[a]-\u003eb a",
        "package": "tamarin-prover-utils",
        "partial": "Of List",
        "signature": "[a]-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:oneOfMap",
      "description": {
        "fct-descr": "\u003cp\u003eInject the elements of a map as alternatives.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Map k v -\u003e f (k, v)",
        "fct-source": "src/Extension-Prelude.html#oneOfMap",
        "fct-type": "function",
        "title": "oneOfMap"
      },
      "index": {
        "description": "Inject the elements of map as alternatives",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "oneOfMap",
        "normalized": "Map a b-\u003ec(a,b)",
        "package": "tamarin-prover-utils",
        "partial": "Of Map",
        "signature": "Map k v-\u003ef(k,v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:oneOfSet",
      "description": {
        "fct-descr": "\u003cp\u003eInject the elements of a set as alternatives.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Set a -\u003e f a",
        "fct-source": "src/Extension-Prelude.html#oneOfSet",
        "fct-type": "function",
        "title": "oneOfSet"
      },
      "index": {
        "description": "Inject the elements of set as alternatives",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "oneOfSet",
        "normalized": "Set a-\u003eb a",
        "package": "tamarin-prover-utils",
        "partial": "Of Set",
        "signature": "Set a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:putErr",
      "description": {
        "fct-descr": "\u003cp\u003eabbreviation to print to stderr\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e IO ()",
        "fct-source": "src/Extension-Prelude.html#putErr",
        "fct-type": "function",
        "title": "putErr"
      },
      "index": {
        "description": "abbreviation to print to stderr",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "putErr",
        "normalized": "String-\u003eIO()",
        "package": "tamarin-prover-utils",
        "partial": "Err",
        "signature": "String-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:putErrLn",
      "description": {
        "fct-descr": "\u003cp\u003eabbreviation to println to stderr\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e IO ()",
        "fct-source": "src/Extension-Prelude.html#putErrLn",
        "fct-type": "function",
        "title": "putErrLn"
      },
      "index": {
        "description": "abbreviation to println to stderr",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "putErrLn",
        "normalized": "String-\u003eIO()",
        "package": "tamarin-prover-utils",
        "partial": "Err Ln",
        "signature": "String-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:singleton",
      "description": {
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "a -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "singleton",
        "normalized": "a-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:sortOn",
      "description": {
        "fct-descr": "\u003cp\u003esort on a projection of the data to sort\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#sortOn",
        "fct-type": "function",
        "title": "sortOn"
      },
      "index": {
        "description": "sort on projection of the data to sort",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "sortOn",
        "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "On",
        "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:sortOnMemo",
      "description": {
        "fct-descr": "\u003cp\u003esort on a projection of the data to sort, memorizing the results of the\n projection in order to avoid recomputation.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#sortOnMemo",
        "fct-type": "function",
        "title": "sortOnMemo"
      },
      "index": {
        "description": "sort on projection of the data to sort memorizing the results of the projection in order to avoid recomputation",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "sortOnMemo",
        "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "On Memo",
        "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:sortPair",
      "description": {
        "fct-descr": "\u003cp\u003esort the elements of a pair\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a, a) -\u003e (a, a)",
        "fct-source": "src/Extension-Prelude.html#sortPair",
        "fct-type": "function",
        "title": "sortPair"
      },
      "index": {
        "description": "sort the elements of pair",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "sortPair",
        "normalized": "(a,a)-\u003e(a,a)",
        "package": "tamarin-prover-utils",
        "partial": "Pair",
        "signature": "(a,a)-\u003e(a,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:sortednub",
      "description": {
        "fct-descr": "\u003cp\u003eSort list and remove duplicates. O(n*log n)\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#sortednub",
        "fct-type": "function",
        "title": "sortednub"
      },
      "index": {
        "description": "Sort list and remove duplicates log",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "sortednub",
        "normalized": "[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:sortednubBy",
      "description": {
        "fct-descr": "\u003cp\u003eSort a list according to a user-defined comparison function and remove\n duplicates.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#sortednubBy",
        "fct-type": "function",
        "title": "sortednubBy"
      },
      "index": {
        "description": "Sort list according to user-defined comparison function and remove duplicates",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "sortednubBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:sortednubOn",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem/\u003eO(n*log n).\u003cem/\u003e Sort list and remove duplicates with respect to a\n projection.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
        "fct-source": "src/Extension-Prelude.html#sortednubOn",
        "fct-type": "function",
        "title": "sortednubOn"
      },
      "index": {
        "description": "log Sort list and remove duplicates with respect to projection",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "sortednubOn",
        "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "On",
        "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:splitBy",
      "description": {
        "fct-descr": "\u003cp\u003esplit a list into sublists whenever the predicate identifies an element as\n a separator. Note that the separator is not retained and a separator at the\n very end is ignored.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Extension-Prelude.html#splitBy",
        "fct-type": "function",
        "title": "splitBy"
      },
      "index": {
        "description": "split list into sublists whenever the predicate identifies an element as separator Note that the separator is not retained and separator at the very end is ignored",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "splitBy",
        "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
        "package": "tamarin-prover-utils",
        "partial": "By",
        "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:swap",
      "description": {
        "fct-descr": "\u003cp\u003eThese functions were inspired by the ML library accompanying the\n   Isabelle theorem prover (\u003ca\u003ehttp://isabelle.in.tum.de/\u003c/a\u003e)\n\u003c/p\u003e\u003cp\u003eswap the elements of a pair\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a, b) -\u003e (b, a)",
        "fct-source": "src/Extension-Prelude.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "These functions were inspired by the ML library accompanying the Isabelle theorem prover http isabelle.in.tum.de swap the elements of pair",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "swap",
        "normalized": "(a,b)-\u003e(b,a)",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(a,b)-\u003e(b,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:unique",
      "description": {
        "fct-descr": "\u003cp\u003echeck whether the given list contains no duplicates\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e Bool",
        "fct-source": "src/Extension-Prelude.html#unique",
        "fct-type": "function",
        "title": "unique"
      },
      "index": {
        "description": "check whether the given list contains no duplicates",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "unique",
        "normalized": "[a]-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[a]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:unreachable",
      "description": {
        "fct-descr": "\u003cp\u003eMark a part of the code as unreachable.\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e a",
        "fct-source": "src/Extension-Prelude.html#unreachable",
        "fct-type": "function",
        "title": "unreachable"
      },
      "index": {
        "description": "Mark part of the code as unreachable",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "unreachable",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Extension-Prelude.html#v:warning",
      "description": {
        "fct-descr": "\u003cp\u003emarks a string as being a warning\n\u003c/p\u003e",
        "fct-module": "Extension.Prelude",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/Extension-Prelude.html#warning",
        "fct-type": "function",
        "title": "warning"
      },
      "index": {
        "description": "marks string as being warning",
        "hierarchy": "Extension Prelude",
        "module": "Extension.Prelude",
        "name": "warning",
        "normalized": "String-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Logic-Connectives.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes and instances to handle series of disjunctions and conjunctions.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Logic.Connectives",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Logic-Connectives.html",
        "fct-type": "module",
        "title": "Connectives"
      },
      "index": {
        "description": "Types and instances to handle series of disjunctions and conjunctions",
        "hierarchy": "Logic Connectives",
        "module": "Logic.Connectives",
        "name": "Connectives",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Connectives",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Logic-Connectives.html#t:Conj",
      "description": {
        "fct-descr": "\u003cp\u003eA conjunction of atoms of type a.\n\u003c/p\u003e",
        "fct-module": "Logic.Connectives",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Logic-Connectives.html#Conj",
        "fct-type": "newtype",
        "title": "Conj"
      },
      "index": {
        "description": "conjunction of atoms of type",
        "hierarchy": "Logic Connectives",
        "module": "Logic.Connectives",
        "name": "Conj",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Conj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Logic-Connectives.html#t:Disj",
      "description": {
        "fct-descr": "\u003cp\u003eA disjunction of atoms of type a.\n\u003c/p\u003e",
        "fct-module": "Logic.Connectives",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "newtype",
        "fct-source": "src/Logic-Connectives.html#Disj",
        "fct-type": "newtype",
        "title": "Disj"
      },
      "index": {
        "description": "disjunction of atoms of type",
        "hierarchy": "Logic Connectives",
        "module": "Logic.Connectives",
        "name": "Disj",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Disj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Logic-Connectives.html#v:Conj",
      "description": {
        "fct-module": "Logic.Connectives",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Conj",
        "fct-source": "src/Logic-Connectives.html#Conj",
        "fct-type": "function",
        "title": "Conj"
      },
      "index": {
        "description": "",
        "hierarchy": "Logic Connectives",
        "module": "Logic.Connectives",
        "name": "Conj",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Conj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Logic-Connectives.html#v:Disj",
      "description": {
        "fct-module": "Logic.Connectives",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Disj",
        "fct-source": "src/Logic-Connectives.html#Disj",
        "fct-type": "function",
        "title": "Disj"
      },
      "index": {
        "description": "",
        "hierarchy": "Logic Connectives",
        "module": "Logic.Connectives",
        "name": "Disj",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Disj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Logic-Connectives.html#v:getConj",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Logic.Connectives",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a]",
        "fct-source": "src/Logic-Connectives.html#Conj",
        "fct-type": "function",
        "title": "getConj"
      },
      "index": {
        "description": "",
        "hierarchy": "Logic Connectives",
        "module": "Logic.Connectives",
        "name": "getConj",
        "normalized": "[a]",
        "package": "tamarin-prover-utils",
        "partial": "Conj",
        "signature": "[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Logic-Connectives.html#v:getDisj",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Logic.Connectives",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a]",
        "fct-source": "src/Logic-Connectives.html#Disj",
        "fct-type": "function",
        "title": "getDisj"
      },
      "index": {
        "description": "",
        "hierarchy": "Logic Connectives",
        "module": "Logic.Connectives",
        "name": "getDisj",
        "normalized": "[a]",
        "package": "tamarin-prover-utils",
        "partial": "Disj",
        "signature": "[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/System-Timing.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple module for timing IO action.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "System.Timing",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/System-Timing.html",
        "fct-type": "module",
        "title": "Timing"
      },
      "index": {
        "description": "simple module for timing IO action",
        "hierarchy": "System Timing",
        "module": "System.Timing",
        "name": "Timing",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Timing",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/System-Timing.html#v:timed",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an IO action and return its result plus the time it took to execute it.\n\u003c/p\u003e",
        "fct-module": "System.Timing",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "IO a -\u003e IO (a, NominalDiffTime)",
        "fct-source": "src/System-Timing.html#timed",
        "fct-type": "function",
        "title": "timed"
      },
      "index": {
        "description": "Execute an IO action and return its result plus the time it took to execute it",
        "hierarchy": "System Timing",
        "module": "System.Timing",
        "name": "timed",
        "normalized": "IO a-\u003eIO(a,NominalDiffTime)",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "IO a-\u003eIO(a,NominalDiffTime)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/System-Timing.html#v:timed_",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an IO action and return the time it took to execute it.\n\u003c/p\u003e",
        "fct-module": "System.Timing",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "IO a -\u003e IO NominalDiffTime",
        "fct-source": "src/System-Timing.html#timed_",
        "fct-type": "function",
        "title": "timed_"
      },
      "index": {
        "description": "Execute an IO action and return the time it took to execute it",
        "hierarchy": "System Timing",
        "module": "System.Timing",
        "name": "timed_",
        "normalized": "IO a-\u003eIO NominalDiffTime",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "IO a-\u003eIO NominalDiffTime"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides a simple interface for building .dot graph files, for input into the dot and graphviz tools.\n It includes a monadic interface for building graphs.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Text-Dot.html",
        "fct-type": "module",
        "title": "Dot"
      },
      "index": {
        "description": "This module provides simple interface for building dot graph files for input into the dot and graphviz tools It includes monadic interface for building graphs",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "Dot",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Dot",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#t:Dot",
      "description": {
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-source": "src/Text-Dot.html#Dot",
        "fct-type": "data",
        "title": "Dot"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "Dot",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Dot",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#t:NodeId",
      "description": {
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-source": "src/Text-Dot.html#NodeId",
        "fct-type": "data",
        "title": "NodeId"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "NodeId",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Node Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#t:Record",
      "description": {
        "fct-descr": "\u003cp\u003eSpecifies the construction of a record; i.e., mentions all fields possibly\n together with ports and their horizontal and vertical nesting. (see: record\n shapes in the DOT documentation.)\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-source": "src/Text-Dot.html#Record",
        "fct-type": "data",
        "title": "Record"
      },
      "index": {
        "description": "Specifies the construction of record i.e mentions all fields possibly together with ports and their horizontal and vertical nesting see record shapes in the DOT documentation",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "Record",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Record",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:attribute",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eattribute\u003c/a\u003e\u003c/code\u003e gives a attribute to the current scope.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(String, String) -\u003e Dot ()",
        "fct-source": "src/Text-Dot.html#attribute",
        "fct-type": "function",
        "title": "attribute"
      },
      "index": {
        "description": "attribute gives attribute to the current scope",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "attribute",
        "normalized": "(String,String)-\u003eDot()",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "(String,String)-\u003eDot()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:cluster",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecluster\u003c/a\u003e\u003c/code\u003e builds an explicit, internally named subgraph (called cluster).\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Dot a -\u003e Dot (NodeId, a)",
        "fct-source": "src/Text-Dot.html#cluster",
        "fct-type": "function",
        "title": "cluster"
      },
      "index": {
        "description": "cluster builds an explicit internally named subgraph called cluster",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "cluster",
        "normalized": "Dot a-\u003eDot(NodeId,a)",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Dot a-\u003eDot(NodeId,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:edge",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eedge\u003c/a\u003e\u003c/code\u003e generates an edge between two \u003ccode\u003e\u003ca\u003eNodeId\u003c/a\u003e\u003c/code\u003es, with attributes.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "NodeId -\u003e NodeId -\u003e [(String, String)] -\u003e Dot ()",
        "fct-source": "src/Text-Dot.html#edge",
        "fct-type": "function",
        "title": "edge"
      },
      "index": {
        "description": "edge generates an edge between two NodeId with attributes",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "edge",
        "normalized": "NodeId-\u003eNodeId-\u003e[(String,String)]-\u003eDot()",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "NodeId-\u003eNodeId-\u003e[(String,String)]-\u003eDot()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:edgeAttributes",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eedgeAttributes\u003c/a\u003e\u003c/code\u003e sets attributes for all the following edges in the scope.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(String, String)] -\u003e Dot ()",
        "fct-source": "src/Text-Dot.html#edgeAttributes",
        "fct-type": "function",
        "title": "edgeAttributes"
      },
      "index": {
        "description": "edgeAttributes sets attributes for all the following edges in the scope",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "edgeAttributes",
        "normalized": "[(String,String)]-\u003eDot()",
        "package": "tamarin-prover-utils",
        "partial": "Attributes",
        "signature": "[(String,String)]-\u003eDot()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:field",
      "description": {
        "fct-descr": "\u003cp\u003eA simple field of a record.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e Record a",
        "fct-source": "src/Text-Dot.html#field",
        "fct-type": "function",
        "title": "field"
      },
      "index": {
        "description": "simple field of record",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "field",
        "normalized": "String-\u003eRecord a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003eRecord a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:graphAttributes",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egraphAttributes\u003c/a\u003e\u003c/code\u003e sets attributes for current graph.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(String, String)] -\u003e Dot ()",
        "fct-source": "src/Text-Dot.html#graphAttributes",
        "fct-type": "function",
        "title": "graphAttributes"
      },
      "index": {
        "description": "graphAttributes sets attributes for current graph",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "graphAttributes",
        "normalized": "[(String,String)]-\u003eDot()",
        "package": "tamarin-prover-utils",
        "partial": "Attributes",
        "signature": "[(String,String)]-\u003eDot()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:hcat",
      "description": {
        "fct-descr": "\u003cp\u003eConcatenate records horizontally.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[Record a] -\u003e Record a",
        "fct-source": "src/Text-Dot.html#hcat",
        "fct-type": "function",
        "title": "hcat"
      },
      "index": {
        "description": "Concatenate records horizontally",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "hcat",
        "normalized": "[Record a]-\u003eRecord a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[Record a]-\u003eRecord a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:hcat-39-",
      "description": {
        "fct-descr": "\u003cp\u003eConcatenate a list strings interpreted as simple fields horizontally.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[String] -\u003e Record a",
        "fct-source": "src/Text-Dot.html#hcat%27",
        "fct-type": "function",
        "title": "hcat'"
      },
      "index": {
        "description": "Concatenate list strings interpreted as simple fields horizontally",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "hcat'",
        "normalized": "[String]-\u003eRecord a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[String]-\u003eRecord a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:mrecord",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ca\u003erecord\u003c/a\u003e, but creates record nodes with rounded corners; i.e. uses\n the \"Mrecord\" shape instead of the \"record\" shape.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Record a -\u003e [(String, String)] -\u003e Dot (NodeId, [(a, NodeId)])",
        "fct-source": "src/Text-Dot.html#mrecord",
        "fct-type": "function",
        "title": "mrecord"
      },
      "index": {
        "description": "Like record but creates record nodes with rounded corners i.e uses the Mrecord shape instead of the record shape",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "mrecord",
        "normalized": "Record a-\u003e[(String,String)]-\u003eDot(NodeId,[(a,NodeId)])",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Record a-\u003e[(String,String)]-\u003eDot(NodeId,[(a,NodeId)])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:mrecord-39-",
      "description": {
        "fct-descr": "\u003cp\u003eA variant of \u003ca\u003emrecord\u003c/a\u003e ignoring the port identifiers.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Record a -\u003e [(String, String)] -\u003e Dot (NodeId, [NodeId])",
        "fct-source": "src/Text-Dot.html#mrecord%27",
        "fct-type": "function",
        "title": "mrecord'"
      },
      "index": {
        "description": "variant of mrecord ignoring the port identifiers",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "mrecord'",
        "normalized": "Record a-\u003e[(String,String)]-\u003eDot(NodeId,[NodeId])",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Record a-\u003e[(String,String)]-\u003eDot(NodeId,[NodeId])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:mrecord_",
      "description": {
        "fct-descr": "\u003cp\u003eA variant of \u003ca\u003emrecord\u003c/a\u003e ignoring the port to node-id association list.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Record a -\u003e [(String, String)] -\u003e Dot NodeId",
        "fct-source": "src/Text-Dot.html#mrecord_",
        "fct-type": "function",
        "title": "mrecord_"
      },
      "index": {
        "description": "variant of mrecord ignoring the port to node-id association list",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "mrecord_",
        "normalized": "Record a-\u003e[(String,String)]-\u003eDot NodeId",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Record a-\u003e[(String,String)]-\u003eDot NodeId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:node",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enode\u003c/a\u003e\u003c/code\u003e takes a list of attributes, generates a new node, and gives a\n \u003ccode\u003e\u003ca\u003eNodeId\u003c/a\u003e\u003c/code\u003e. Multi-line labels are fixed such that they use non-breaking\n spaces and are terminated with a new-line.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(String, String)] -\u003e Dot NodeId",
        "fct-source": "src/Text-Dot.html#node",
        "fct-type": "function",
        "title": "node"
      },
      "index": {
        "description": "node takes list of attributes generates new node and gives NodeId Multi-line labels are fixed such that they use non-breaking spaces and are terminated with new-line",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "node",
        "normalized": "[(String,String)]-\u003eDot NodeId",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[(String,String)]-\u003eDot NodeId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:nodeAttributes",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enodeAttributes\u003c/a\u003e\u003c/code\u003e sets attributes for all the following nodes in the scope.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(String, String)] -\u003e Dot ()",
        "fct-source": "src/Text-Dot.html#nodeAttributes",
        "fct-type": "function",
        "title": "nodeAttributes"
      },
      "index": {
        "description": "nodeAttributes sets attributes for all the following nodes in the scope",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "nodeAttributes",
        "normalized": "[(String,String)]-\u003eDot()",
        "package": "tamarin-prover-utils",
        "partial": "Attributes",
        "signature": "[(String,String)]-\u003eDot()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:portField",
      "description": {
        "fct-descr": "\u003cp\u003eA field together with a port which can be used to create direct edges to\n this field. Note that you can use any type to identify the ports. When\n creating a record node you will get back an association list between your\n record identifiers and their concrete node ids.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "a -\u003e String -\u003e Record a",
        "fct-source": "src/Text-Dot.html#portField",
        "fct-type": "function",
        "title": "portField"
      },
      "index": {
        "description": "field together with port which can be used to create direct edges to this field Note that you can use any type to identify the ports When creating record node you will get back an association list between your record identifiers and their concrete node ids",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "portField",
        "normalized": "a-\u003eString-\u003eRecord a",
        "package": "tamarin-prover-utils",
        "partial": "Field",
        "signature": "a-\u003eString-\u003eRecord a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:record",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a record node with the given attributes. It returns the node-id of\n the created node together with an association list mapping the port\n idenfiers given in the record to their corresponding node-ids. This list is\n ordered according to a left-to-rigth traversal of the record description.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Record a -\u003e [(String, String)] -\u003e Dot (NodeId, [(a, NodeId)])",
        "fct-source": "src/Text-Dot.html#record",
        "fct-type": "function",
        "title": "record"
      },
      "index": {
        "description": "Create record node with the given attributes It returns the node-id of the created node together with an association list mapping the port idenfiers given in the record to their corresponding node-ids This list is ordered according to left-to-rigth traversal of the record description",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "record",
        "normalized": "Record a-\u003e[(String,String)]-\u003eDot(NodeId,[(a,NodeId)])",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Record a-\u003e[(String,String)]-\u003eDot(NodeId,[(a,NodeId)])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:record-39-",
      "description": {
        "fct-descr": "\u003cp\u003eA variant of \u003ca\u003erecord\u003c/a\u003e ignoring the port identifiers.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Record a -\u003e [(String, String)] -\u003e Dot (NodeId, [NodeId])",
        "fct-source": "src/Text-Dot.html#record%27",
        "fct-type": "function",
        "title": "record'"
      },
      "index": {
        "description": "variant of record ignoring the port identifiers",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "record'",
        "normalized": "Record a-\u003e[(String,String)]-\u003eDot(NodeId,[NodeId])",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Record a-\u003e[(String,String)]-\u003eDot(NodeId,[NodeId])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:record_",
      "description": {
        "fct-descr": "\u003cp\u003eA variant of \u003ca\u003erecord\u003c/a\u003e ignoring the port to node-id association list.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Record a -\u003e [(String, String)] -\u003e Dot NodeId",
        "fct-source": "src/Text-Dot.html#record_",
        "fct-type": "function",
        "title": "record_"
      },
      "index": {
        "description": "variant of record ignoring the port to node-id association list",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "record_",
        "normalized": "Record a-\u003e[(String,String)]-\u003eDot NodeId",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Record a-\u003e[(String,String)]-\u003eDot NodeId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:same",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esame\u003c/a\u003e\u003c/code\u003e provides a combinator for a common pattern; a set of \u003ccode\u003e\u003ca\u003eNodeId\u003c/a\u003e\u003c/code\u003es with the same rank.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[NodeId] -\u003e Dot ()",
        "fct-source": "src/Text-Dot.html#same",
        "fct-type": "function",
        "title": "same"
      },
      "index": {
        "description": "same provides combinator for common pattern set of NodeId with the same rank",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "same",
        "normalized": "[NodeId]-\u003eDot()",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[NodeId]-\u003eDot()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:scope",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escope\u003c/a\u003e\u003c/code\u003e groups a subgraph together; in dot these are the subgraphs inside \u003ca\u003e{\u003c/a\u003e and \u003ca\u003e}\u003c/a\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Dot a -\u003e Dot a",
        "fct-source": "src/Text-Dot.html#scope",
        "fct-type": "function",
        "title": "scope"
      },
      "index": {
        "description": "scope groups subgraph together in dot these are the subgraphs inside and",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "scope",
        "normalized": "Dot a-\u003eDot a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Dot a-\u003eDot a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:share",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eshare\u003c/a\u003e\u003c/code\u003e is when a set of nodes share specific attributes. Usually used for layout tweaking.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(String, String)] -\u003e [NodeId] -\u003e Dot ()",
        "fct-source": "src/Text-Dot.html#share",
        "fct-type": "function",
        "title": "share"
      },
      "index": {
        "description": "share is when set of nodes share specific attributes Usually used for layout tweaking",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "share",
        "normalized": "[(String,String)]-\u003e[NodeId]-\u003eDot()",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[(String,String)]-\u003e[NodeId]-\u003eDot()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:showDot",
      "description": {
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Dot a -\u003e String",
        "fct-source": "src/Text-Dot.html#showDot",
        "fct-type": "function",
        "title": "showDot"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "showDot",
        "normalized": "Dot a-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "Dot",
        "signature": "Dot a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:userNode",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003euserNode\u003c/a\u003e\u003c/code\u003e takes a NodeId, and adds some attributes to that node.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "NodeId -\u003e [(String, String)] -\u003e Dot ()",
        "fct-source": "src/Text-Dot.html#userNode",
        "fct-type": "function",
        "title": "userNode"
      },
      "index": {
        "description": "userNode takes NodeId and adds some attributes to that node",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "userNode",
        "normalized": "NodeId-\u003e[(String,String)]-\u003eDot()",
        "package": "tamarin-prover-utils",
        "partial": "Node",
        "signature": "NodeId-\u003e[(String,String)]-\u003eDot()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:userNodeId",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003euserNodeId\u003c/a\u003e\u003c/code\u003e allows a user to use their own (Int-based) node id's, without needing to remap them.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e NodeId",
        "fct-source": "src/Text-Dot.html#userNodeId",
        "fct-type": "function",
        "title": "userNodeId"
      },
      "index": {
        "description": "userNodeId allows user to use their own Int-based node id without needing to remap them",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "userNodeId",
        "normalized": "Int-\u003eNodeId",
        "package": "tamarin-prover-utils",
        "partial": "Node Id",
        "signature": "Int-\u003eNodeId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:vcat",
      "description": {
        "fct-descr": "\u003cp\u003eConcatenate records vertically.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[Record a] -\u003e Record a",
        "fct-source": "src/Text-Dot.html#vcat",
        "fct-type": "function",
        "title": "vcat"
      },
      "index": {
        "description": "Concatenate records vertically",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "vcat",
        "normalized": "[Record a]-\u003eRecord a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[Record a]-\u003eRecord a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Dot.html#v:vcat-39-",
      "description": {
        "fct-descr": "\u003cp\u003eConcatenate a list strings interpreted as simple fields vertically.\n\u003c/p\u003e",
        "fct-module": "Text.Dot",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[String] -\u003e Record a",
        "fct-source": "src/Text-Dot.html#vcat%27",
        "fct-type": "function",
        "title": "vcat'"
      },
      "index": {
        "description": "Concatenate list strings interpreted as simple fields vertically",
        "hierarchy": "Text Dot",
        "module": "Text.Dot",
        "name": "vcat'",
        "normalized": "[String]-\u003eRecord a",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[String]-\u003eRecord a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eDocument\u003c/a\u003e\u003c/code\u003e class allowing to have different interpretations of the\n HughesPJ pretty-printing combinators.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Text-PrettyPrint-Class.html",
        "fct-type": "module",
        "title": "Class"
      },
      "index": {
        "description": "Document class allowing to have different interpretations of the HughesPJ pretty-printing combinators",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "Class",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Class",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#t:Doc",
      "description": {
        "fct-descr": "\u003cp\u003eThe abstract type of documents.\n A Doc represents a *set* of layouts. A Doc with\n no occurrences of Union or NoDoc represents just one layout.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "Doc"
      },
      "index": {
        "description": "The abstract type of documents Doc represents set of layouts Doc with no occurrences of Union or NoDoc represents just one layout",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "Doc",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Doc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#t:Document",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "class",
        "fct-source": "src/Text-PrettyPrint-Class.html#Document",
        "fct-type": "class",
        "title": "Document"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "Document",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Document",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#t:Mode",
      "description": {
        "fct-descr": "\u003cp\u003eRendering mode.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "Mode"
      },
      "index": {
        "description": "Rendering mode",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "Mode",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Mode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#t:Style",
      "description": {
        "fct-descr": "\u003cp\u003eA rendering style.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "Style"
      },
      "index": {
        "description": "rendering style",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "Style",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Style",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:-36--36-",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#%24%24",
        "fct-type": "method",
        "title": "($$)"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "($$) $$",
        "normalized": "a-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:-36--45--36-",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#%24-%24",
        "fct-type": "method",
        "title": "($-$)"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "($-$) $-$",
        "normalized": "a-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:-36--45--45--36-",
      "description": {
        "fct-descr": "\u003cp\u003eVertical concatentation of two documents with an empty line in between.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#%24--%24",
        "fct-type": "function",
        "title": "($--$)"
      },
      "index": {
        "description": "Vertical concatentation of two documents with an empty line in between",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "($--$) $--$",
        "normalized": "a-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:-60--45--62-",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#%3C-%3E",
        "fct-type": "method",
        "title": "(\u003c-\u003e)"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "(\u003c-\u003e) \u003c-\u003e",
        "normalized": "a-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:-60--62-",
      "description": {
        "fct-descr": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "m -\u003e m -\u003e m",
        "fct-type": "function",
        "title": "(\u003c\u003e)"
      },
      "index": {
        "description": "An infix synonym for mappend",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "(\u003c\u003e) \u003c\u003e",
        "normalized": "a-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "m-\u003em-\u003em"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:LeftMode",
      "description": {
        "fct-descr": "\u003cp\u003eNo indentation, infinitely long lines\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "LeftMode",
        "fct-type": "function",
        "title": "LeftMode"
      },
      "index": {
        "description": "No indentation infinitely long lines",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "LeftMode",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Left Mode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:OneLineMode",
      "description": {
        "fct-descr": "\u003cp\u003eAll on one line\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "OneLineMode",
        "fct-type": "function",
        "title": "OneLineMode"
      },
      "index": {
        "description": "All on one line",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "OneLineMode",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "One Line Mode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:PageMode",
      "description": {
        "fct-descr": "\u003cp\u003eNormal\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "PageMode",
        "fct-type": "function",
        "title": "PageMode"
      },
      "index": {
        "description": "Normal",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "PageMode",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Page Mode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:Style",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Style",
        "fct-type": "function",
        "title": "Style"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "Style",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Style",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:ZigZagMode",
      "description": {
        "fct-descr": "\u003cp\u003eWith zig-zag cuts\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "ZigZagMode",
        "fct-type": "function",
        "title": "ZigZagMode"
      },
      "index": {
        "description": "With zig-zag cuts",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "ZigZagMode",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Zig Zag Mode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:braces",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#braces",
        "fct-type": "function",
        "title": "braces"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "braces",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:brackets",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#brackets",
        "fct-type": "function",
        "title": "brackets"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "brackets",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:caseEmptyDoc",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#caseEmptyDoc",
        "fct-type": "method",
        "title": "caseEmptyDoc"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "caseEmptyDoc",
        "normalized": "a-\u003ea-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Empty Doc",
        "signature": "d-\u003ed-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:cat",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#cat",
        "fct-type": "method",
        "title": "cat"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "cat",
        "normalized": "[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:char",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Char -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#char",
        "fct-type": "method",
        "title": "char"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "char",
        "normalized": "Char-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Char-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:colon",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#colon",
        "fct-type": "function",
        "title": "colon"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "colon",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:comma",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#comma",
        "fct-type": "function",
        "title": "comma"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "comma",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:defaultStyle",
      "description": {
        "fct-descr": "\u003cp\u003eThe default \u003ccode\u003e\u003ca\u003eStyle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Style",
        "fct-source": "src/Text-PrettyPrint-Class.html#defaultStyle",
        "fct-type": "function",
        "title": "defaultStyle"
      },
      "index": {
        "description": "The default Style",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "defaultStyle",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Style",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:double",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Double -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#double",
        "fct-type": "function",
        "title": "double"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "double",
        "normalized": "Double-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Double-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:doubleQuotes",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#doubleQuotes",
        "fct-type": "function",
        "title": "doubleQuotes"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "doubleQuotes",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Quotes",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:emptyDoc",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty document.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#emptyDoc",
        "fct-type": "function",
        "title": "emptyDoc"
      },
      "index": {
        "description": "The empty document",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "emptyDoc",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Doc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:equals",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#equals",
        "fct-type": "function",
        "title": "equals"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "equals",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:fcat",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#fcat",
        "fct-type": "method",
        "title": "fcat"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "fcat",
        "normalized": "[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:fixedWidthText",
      "description": {
        "fct-descr": "\u003cp\u003eOutput text with a fixed width: if it is smaller then nothing happens,\n otherwise care is taken to make the text appear having the given width.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#fixedWidthText",
        "fct-type": "function",
        "title": "fixedWidthText"
      },
      "index": {
        "description": "Output text with fixed width if it is smaller then nothing happens otherwise care is taken to make the text appear having the given width",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "fixedWidthText",
        "normalized": "Int-\u003eString-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Width Text",
        "signature": "Int-\u003eString-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:float",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Float -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#float",
        "fct-type": "function",
        "title": "float"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "float",
        "normalized": "Float-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Float-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:fsep",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#fsep",
        "fct-type": "method",
        "title": "fsep"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "fsep",
        "normalized": "[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:hang",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e Int -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#hang",
        "fct-type": "function",
        "title": "hang"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "hang",
        "normalized": "a-\u003eInt-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003eInt-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:hcat",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#hcat",
        "fct-type": "method",
        "title": "hcat"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "hcat",
        "normalized": "[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:hsep",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#hsep",
        "fct-type": "method",
        "title": "hsep"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "hsep",
        "normalized": "[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:int",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#int",
        "fct-type": "function",
        "title": "int"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "int",
        "normalized": "Int-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Int-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:integer",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Integer -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#integer",
        "fct-type": "function",
        "title": "integer"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "integer",
        "normalized": "Integer-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Integer-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:isEmpty",
      "description": {
        "fct-descr": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the document is empty\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Doc -\u003e Bool",
        "fct-type": "function",
        "title": "isEmpty"
      },
      "index": {
        "description": "Returns True if the document is empty",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "isEmpty",
        "normalized": "Doc-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "Empty",
        "signature": "Doc-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:lbrace",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#lbrace",
        "fct-type": "function",
        "title": "lbrace"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "lbrace",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:lbrack",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#lbrack",
        "fct-type": "function",
        "title": "lbrack"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "lbrack",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:lineLength",
      "description": {
        "fct-descr": "\u003cp\u003eLength of line, in chars\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int",
        "fct-type": "function",
        "title": "lineLength"
      },
      "index": {
        "description": "Length of line in chars",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "lineLength",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Length",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:lparen",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#lparen",
        "fct-type": "function",
        "title": "lparen"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "lparen",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:mode",
      "description": {
        "fct-descr": "\u003cp\u003eThe rendering mode\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Mode",
        "fct-type": "function",
        "title": "mode"
      },
      "index": {
        "description": "The rendering mode",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "mode",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:nest",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#nest",
        "fct-type": "method",
        "title": "nest"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "nest",
        "normalized": "Int-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Int-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:nestBetween",
      "description": {
        "fct-descr": "\u003cp\u003eNest a document surrounded by a leading and a finishing document breaking\n lead, body, and finish onto separate lines, if they don't fit on a single\n line.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int-\u003e d-\u003e d-\u003e d-\u003e d",
        "fct-type": "function",
        "title": "nestBetween"
      },
      "index": {
        "description": "Nest document surrounded by leading and finishing document breaking lead body and finish onto separate lines if they don fit on single line",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "nestBetween",
        "normalized": "Int-\u003ea-\u003ea-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Between",
        "signature": "Int-\u003ed-\u003ed-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:nestShort",
      "description": {
        "fct-descr": "\u003cp\u003eNest a document surrounded by a leading and a finishing document with an\n non-compulsory break between lead and body.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int-\u003e d-\u003e d-\u003e d-\u003e d",
        "fct-type": "function",
        "title": "nestShort"
      },
      "index": {
        "description": "Nest document surrounded by leading and finishing document with an non-compulsory break between lead and body",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "nestShort",
        "normalized": "Int-\u003ea-\u003ea-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Short",
        "signature": "Int-\u003ed-\u003ed-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:nestShort-39-",
      "description": {
        "fct-descr": "\u003cp\u003eNest document between two strings and indent body by \u003ccode\u003elength lead + 1\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e String -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#nestShort%27",
        "fct-type": "function",
        "title": "nestShort'"
      },
      "index": {
        "description": "Nest document between two strings and indent body by length lead",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "nestShort'",
        "normalized": "String-\u003eString-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Short'",
        "signature": "String-\u003eString-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:nestShortNonEmpty",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003enestShort\u003c/a\u003e\u003c/code\u003e but doesn't print the lead and finish, if the document is\n empty.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Int -\u003e d -\u003e d -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#nestShortNonEmpty",
        "fct-type": "function",
        "title": "nestShortNonEmpty"
      },
      "index": {
        "description": "Like nestShort but doesn print the lead and finish if the document is empty",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "nestShortNonEmpty",
        "normalized": "Int-\u003ea-\u003ea-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Short Non Empty",
        "signature": "Int-\u003ed-\u003ed-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:nestShortNonEmpty-39-",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003enestShort'\u003c/a\u003e\u003c/code\u003e but doesn't print the lead and finish, if the document is\n empty.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e String -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#nestShortNonEmpty%27",
        "fct-type": "function",
        "title": "nestShortNonEmpty'"
      },
      "index": {
        "description": "Like nestShort but doesn print the lead and finish if the document is empty",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "nestShortNonEmpty'",
        "normalized": "String-\u003eString-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Short Non Empty'",
        "signature": "String-\u003eString-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:numbered",
      "description": {
        "fct-descr": "\u003cp\u003eNumber a list of documents that are vertically separated by the given\n separator.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e [d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#numbered",
        "fct-type": "function",
        "title": "numbered"
      },
      "index": {
        "description": "Number list of documents that are vertically separated by the given separator",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "numbered",
        "normalized": "a-\u003e[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003e[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:numbered-39-",
      "description": {
        "fct-descr": "\u003cp\u003eNumber a list of documents with numbers terminated by \u003ca\u003e.\u003c/a\u003e and vertically\n separate using an empty line.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#numbered%27",
        "fct-type": "function",
        "title": "numbered'"
      },
      "index": {
        "description": "Number list of documents with numbers terminated by and vertically separate using an empty line",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "numbered'",
        "normalized": "[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:parens",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#parens",
        "fct-type": "function",
        "title": "parens"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "parens",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:punctuate",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e [d] -\u003e [d]",
        "fct-source": "src/Text-PrettyPrint-Class.html#punctuate",
        "fct-type": "function",
        "title": "punctuate"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "punctuate",
        "normalized": "a-\u003e[a]-\u003e[a]",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003e[d]-\u003e[d]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:quotes",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#quotes",
        "fct-type": "function",
        "title": "quotes"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "quotes",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:rational",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Rational -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#rational",
        "fct-type": "function",
        "title": "rational"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "rational",
        "normalized": "Rational-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Rational-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:rbrace",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#rbrace",
        "fct-type": "function",
        "title": "rbrace"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "rbrace",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:rbrack",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#rbrack",
        "fct-type": "function",
        "title": "rbrack"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "rbrack",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:render",
      "description": {
        "fct-descr": "\u003cp\u003eRender the \u003ccode\u003eDoc\u003c/code\u003e to a String using the default \u003ccode\u003eStyle\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Doc -\u003e String",
        "fct-type": "function",
        "title": "render"
      },
      "index": {
        "description": "Render the Doc to String using the default Style",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "render",
        "normalized": "Doc-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "Doc-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:renderStyle",
      "description": {
        "fct-descr": "\u003cp\u003eRender the \u003ccode\u003eDoc\u003c/code\u003e to a String using the given \u003ccode\u003eStyle\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Style -\u003e Doc -\u003e String",
        "fct-type": "function",
        "title": "renderStyle"
      },
      "index": {
        "description": "Render the Doc to String using the given Style",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "renderStyle",
        "normalized": "Style-\u003eDoc-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "Style",
        "signature": "Style-\u003eDoc-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:ribbonsPerLine",
      "description": {
        "fct-descr": "\u003cp\u003eRatio of ribbon length to line length\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Float",
        "fct-type": "function",
        "title": "ribbonsPerLine"
      },
      "index": {
        "description": "Ratio of ribbon length to line length",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "ribbonsPerLine",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Per Line",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:rparen",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#rparen",
        "fct-type": "function",
        "title": "rparen"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "rparen",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:semi",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#semi",
        "fct-type": "function",
        "title": "semi"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "semi",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:sep",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#sep",
        "fct-type": "method",
        "title": "sep"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "sep",
        "normalized": "[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:space",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d",
        "fct-source": "src/Text-PrettyPrint-Class.html#space",
        "fct-type": "function",
        "title": "space"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "space",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:symbol",
      "description": {
        "fct-descr": "\u003cp\u003ePrint string as symbol having width 1.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#symbol",
        "fct-type": "function",
        "title": "symbol"
      },
      "index": {
        "description": "Print string as symbol having width",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "symbol",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:text",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#text",
        "fct-type": "method",
        "title": "text"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "text",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:vcat",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[d] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#vcat",
        "fct-type": "method",
        "title": "vcat"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "vcat",
        "normalized": "[a]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "[d]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Class.html#v:zeroWidthText",
      "description": {
        "fct-module": "Text.PrettyPrint.Class",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Class.html#zeroWidthText",
        "fct-type": "method",
        "title": "zeroWidthText"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Class",
        "module": "Text.PrettyPrint.Class",
        "name": "zeroWidthText",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Width Text",
        "signature": "String-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePretty-printing with support for highlighting keywords and comments.\n Currently this module is not functional on itself, but geared towards its\n use in Text.PrettyPrint.Html.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Text-PrettyPrint-Highlight.html",
        "fct-type": "module",
        "title": "Highlight"
      },
      "index": {
        "description": "Pretty-printing with support for highlighting keywords and comments Currently this module is not functional on itself but geared towards its use in Text.PrettyPrint.Html",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "Highlight",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Highlight",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#t:HighlightDocument",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "class",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#HighlightDocument",
        "fct-type": "class",
        "title": "HighlightDocument"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "HighlightDocument",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Highlight Document",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#t:HighlightStyle",
      "description": {
        "fct-descr": "\u003cp\u003eCurrently we support only keywords, operators, and comments.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#HighlightStyle",
        "fct-type": "data",
        "title": "HighlightStyle"
      },
      "index": {
        "description": "Currently we support only keywords operators and comments",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "HighlightStyle",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Highlight Style",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:Comment",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Comment",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#HighlightStyle",
        "fct-type": "function",
        "title": "Comment"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "Comment",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Comment",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:Keyword",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Keyword",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#HighlightStyle",
        "fct-type": "function",
        "title": "Keyword"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "Keyword",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Keyword",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:Operator",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Operator",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#HighlightStyle",
        "fct-type": "function",
        "title": "Operator"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "Operator",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Operator",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:comment",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#comment",
        "fct-type": "function",
        "title": "comment"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "comment",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:comment_",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#comment_",
        "fct-type": "function",
        "title": "comment_"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "comment_",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:highlight",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "HighlightStyle -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#highlight",
        "fct-type": "method",
        "title": "highlight"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "highlight",
        "normalized": "HighlightStyle-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "HighlightStyle-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:keyword",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#keyword",
        "fct-type": "function",
        "title": "keyword"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "keyword",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:keyword_",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#keyword_",
        "fct-type": "function",
        "title": "keyword_"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "keyword_",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:opParens",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#opParens",
        "fct-type": "function",
        "title": "opParens"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "opParens",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Parens",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:operator",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#operator",
        "fct-type": "function",
        "title": "operator"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "operator",
        "normalized": "a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Highlight.html#v:operator_",
      "description": {
        "fct-module": "Text.PrettyPrint.Highlight",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Highlight.html#operator_",
        "fct-type": "function",
        "title": "operator_"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Highlight",
        "module": "Text.PrettyPrint.Highlight",
        "name": "operator_",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePretty-printing with support for HTML markup and proper HTML escaping.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Text-PrettyPrint-Html.html",
        "fct-type": "module",
        "title": "Html"
      },
      "index": {
        "description": "Pretty-printing with support for HTML markup and proper HTML escaping",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "Html",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Html",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#t:HtmlDoc",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eDocument\u003c/a\u003e\u003c/code\u003e transformer that adds proper HTML escaping.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "data",
        "fct-source": "src/Text-PrettyPrint-Html.html#HtmlDoc",
        "fct-type": "data",
        "title": "HtmlDoc"
      },
      "index": {
        "description": "Document transformer that adds proper HTML escaping",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "HtmlDoc",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Html Doc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#t:HtmlDocument",
      "description": {
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "class",
        "fct-source": "src/Text-PrettyPrint-Html.html#HtmlDocument",
        "fct-type": "class",
        "title": "HtmlDocument"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "HtmlDocument",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Html Document",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:closedTag",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eclosedTag tag attrs\u003c/code\u003e builds the closed tag \u003ccode\u003etag\u003c/code\u003e with the attributes\n \u003ccode\u003eattrs\u003c/code\u003e; e.g.,\n\u003c/p\u003e\u003cpre\u003e closedTag \"img\" \"href\" \"here\" = HtmlDoc (text \"\u003cimg href=\\\"here\\\"/\u003e)\n\u003c/pre\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e [(String, String)] -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Html.html#closedTag",
        "fct-type": "function",
        "title": "closedTag"
      },
      "index": {
        "description": "closedTag tag attrs builds the closed tag tag with the attributes attrs e.g closedTag img href here HtmlDoc text img href here",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "closedTag",
        "normalized": "String-\u003e[(String,String)]-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Tag",
        "signature": "String-\u003e[(String,String)]-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:getHtmlDoc",
      "description": {
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "HtmlDoc d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Html.html#getHtmlDoc",
        "fct-type": "function",
        "title": "getHtmlDoc"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "getHtmlDoc",
        "normalized": "HtmlDoc a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Html Doc",
        "signature": "HtmlDoc d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:getNoHtmlDoc",
      "description": {
        "fct-descr": "\u003cp\u003eExtract the wrapped document.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "NoHtmlDoc d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Html.html#getNoHtmlDoc",
        "fct-type": "function",
        "title": "getNoHtmlDoc"
      },
      "index": {
        "description": "Extract the wrapped document",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "getNoHtmlDoc",
        "normalized": "NoHtmlDoc a-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "No Html Doc",
        "signature": "NoHtmlDoc d-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:htmlDoc",
      "description": {
        "fct-descr": "\u003cp\u003eWrap a document such that HTML markup can be added without disturbing the\n layout.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e HtmlDoc d",
        "fct-source": "src/Text-PrettyPrint-Html.html#htmlDoc",
        "fct-type": "function",
        "title": "htmlDoc"
      },
      "index": {
        "description": "Wrap document such that HTML markup can be added without disturbing the layout",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "htmlDoc",
        "normalized": "a-\u003eHtmlDoc a",
        "package": "tamarin-prover-utils",
        "partial": "Doc",
        "signature": "d-\u003eHtmlDoc d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:noHtmlDoc",
      "description": {
        "fct-descr": "\u003cp\u003eWrap a document such that all \u003ccode\u003e\u003ca\u003eHtmlDocument\u003c/a\u003e\u003c/code\u003e specific methods are ignored.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "d -\u003e NoHtmlDoc d",
        "fct-source": "src/Text-PrettyPrint-Html.html#noHtmlDoc",
        "fct-type": "function",
        "title": "noHtmlDoc"
      },
      "index": {
        "description": "Wrap document such that all HtmlDocument specific methods are ignored",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "noHtmlDoc",
        "normalized": "a-\u003eNoHtmlDoc a",
        "package": "tamarin-prover-utils",
        "partial": "Html Doc",
        "signature": "d-\u003eNoHtmlDoc d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:postprocessHtmlDoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003epostprocessHtmlDoc cs\u003c/code\u003e converts the line-breaks of \u003ccode\u003ecs\u003c/code\u003e to \u003ccode\u003e\u003ca\u003ebr\u003c/a\u003e\u003c/code\u003e tags and\n the prefixed spaces in every line of \u003ccode\u003ecs\u003c/code\u003e by non-breaing HTML spaces \u003ccode\u003e&nbsp;\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/Text-PrettyPrint-Html.html#postprocessHtmlDoc",
        "fct-type": "function",
        "title": "postprocessHtmlDoc"
      },
      "index": {
        "description": "postprocessHtmlDoc cs converts the line-breaks of cs to br tags and the prefixed spaces in every line of cs by non-breaing HTML spaces nbsp",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "postprocessHtmlDoc",
        "normalized": "String-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "Html Doc",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:renderHtmlDoc",
      "description": {
        "fct-descr": "\u003cpre\u003erenderHtmlDoc = \u003ccode\u003e\u003ca\u003epostprocessHtmlDoc\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003erender\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003egetHtmlDoc\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "HtmlDoc Doc -\u003e String",
        "fct-source": "src/Text-PrettyPrint-Html.html#renderHtmlDoc",
        "fct-type": "function",
        "title": "renderHtmlDoc"
      },
      "index": {
        "description": "renderHtmlDoc postprocessHtmlDoc render getHtmlDoc",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "renderHtmlDoc",
        "normalized": "HtmlDoc Doc-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "Html Doc",
        "signature": "HtmlDoc Doc-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:unescapedText",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eunescapedText str\u003c/code\u003e converts the \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003estr\u003c/code\u003e to a document without\n performing any escaping.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Html.html#unescapedText",
        "fct-type": "method",
        "title": "unescapedText"
      },
      "index": {
        "description": "unescapedText str converts the String str to document without performing any escaping",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "unescapedText",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Text",
        "signature": "String-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:unescapedZeroWidthText",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eunescapedZeroWidthText str\u003c/code\u003e converts the \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003estr\u003c/code\u003e to a document\n with zero width without performing any escaping.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Html.html#unescapedZeroWidthText",
        "fct-type": "method",
        "title": "unescapedZeroWidthText"
      },
      "index": {
        "description": "unescapedZeroWidthText str converts the String str to document with zero width without performing any escaping",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "unescapedZeroWidthText",
        "normalized": "String-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Zero Width Text",
        "signature": "String-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:withTag",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ewithTag tag attrs inner\u003c/code\u003e adds the tag \u003ccode\u003etag\u003c/code\u003e with the attributes\n \u003ccode\u003eattrs\u003c/code\u003e around the \u003ccode\u003einner\u003c/code\u003e document.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e [(String, String)] -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Html.html#withTag",
        "fct-type": "function",
        "title": "withTag"
      },
      "index": {
        "description": "withTag tag attrs inner adds the tag tag with the attributes attrs around the inner document",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "withTag",
        "normalized": "String-\u003e[(String,String)]-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Tag",
        "signature": "String-\u003e[(String,String)]-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-PrettyPrint-Html.html#v:withTagNonEmpty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ewithTagNonEmpty tag attrs inner\u003c/code\u003e adds the tag \u003ccode\u003etag\u003c/code\u003e with the attributes\n \u003ccode\u003eattrs\u003c/code\u003e around the \u003ccode\u003einner\u003c/code\u003e document iff \u003ccode\u003einner\u003c/code\u003e is a non-empty document.\n\u003c/p\u003e",
        "fct-module": "Text.PrettyPrint.Html",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e [(String, String)] -\u003e d -\u003e d",
        "fct-source": "src/Text-PrettyPrint-Html.html#withTagNonEmpty",
        "fct-type": "function",
        "title": "withTagNonEmpty"
      },
      "index": {
        "description": "withTagNonEmpty tag attrs inner adds the tag tag with the attributes attrs around the inner document iff inner is non-empty document",
        "hierarchy": "Text PrettyPrint Html",
        "module": "Text.PrettyPrint.Html",
        "name": "withTagNonEmpty",
        "normalized": "String-\u003e[(String,String)]-\u003ea-\u003ea",
        "package": "tamarin-prover-utils",
        "partial": "Tag Non Empty",
        "signature": "String-\u003e[(String,String)]-\u003ed-\u003ed"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Unicode.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport functions for exploiting Unicode characters.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.Unicode",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Text-Unicode.html",
        "fct-type": "module",
        "title": "Unicode"
      },
      "index": {
        "description": "Support functions for exploiting Unicode characters",
        "hierarchy": "Text Unicode",
        "module": "Text.Unicode",
        "name": "Unicode",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Unicode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Unicode.html#v:subscript",
      "description": {
        "fct-descr": "\u003cp\u003eConvert all subscriptable characters to subscripts.\n\u003c/p\u003e",
        "fct-module": "Text.Unicode",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/Text-Unicode.html#subscript",
        "fct-type": "function",
        "title": "subscript"
      },
      "index": {
        "description": "Convert all subscriptable characters to subscripts",
        "hierarchy": "Text Unicode",
        "module": "Text.Unicode",
        "name": "subscript",
        "normalized": "String-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Text-Unicode.html#v:subscriptChar",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a subscriptable character to its subsript.\n\u003c/p\u003e",
        "fct-module": "Text.Unicode",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Char -\u003e Char",
        "fct-source": "src/Text-Unicode.html#subscriptChar",
        "fct-type": "function",
        "title": "subscriptChar"
      },
      "index": {
        "description": "Convert subscriptable character to its subsript",
        "hierarchy": "Text Unicode",
        "module": "Text.Unicode",
        "name": "subscriptChar",
        "normalized": "Char-\u003eChar",
        "package": "tamarin-prover-utils",
        "partial": "Char",
        "signature": "Char-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#",
      "description": {
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "module",
        "fct-source": "src/Utils-Misc.html",
        "fct-type": "module",
        "title": "Misc"
      },
      "index": {
        "description": "",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "Misc",
        "normalized": "",
        "package": "tamarin-prover-utils",
        "partial": "Misc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:envIsSet",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eenvIsSet k\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e if there is a v such \u003ccode\u003ek=v\u003c/code\u003e is in the environment and \u003ccode\u003eFalse\u003c/code\u003e otherwise.\n\u003c/p\u003e",
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e Bool",
        "fct-source": "src/Utils-Misc.html#envIsSet",
        "fct-type": "function",
        "title": "envIsSet"
      },
      "index": {
        "description": "envIsSet returns True if there is such is in the environment and False otherwise",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "envIsSet",
        "normalized": "String-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "Is Set",
        "signature": "String-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:equivClasses",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the equality classes given wrto a partial function.\n\u003c/p\u003e",
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[(a, b)] -\u003e Map b (Set a)",
        "fct-source": "src/Utils-Misc.html#equivClasses",
        "fct-type": "function",
        "title": "equivClasses"
      },
      "index": {
        "description": "Compute the equality classes given wrto partial function",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "equivClasses",
        "normalized": "[(a,b)]-\u003eMap b(Set a)",
        "package": "tamarin-prover-utils",
        "partial": "Classes",
        "signature": "[(a,b)]-\u003eMap b(Set a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:getEnvMaybe",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003egetEnvMaybe k\u003c/code\u003e returns \u003ccode\u003eJust v\u003c/code\u003e if \u003ccode\u003ek=v\u003c/code\u003e is in the environment and \u003ccode\u003eNothing\u003c/code\u003e otherwise\n\u003c/p\u003e",
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e Maybe String",
        "fct-source": "src/Utils-Misc.html#getEnvMaybe",
        "fct-type": "function",
        "title": "getEnvMaybe"
      },
      "index": {
        "description": "getEnvMaybe returns Just if is in the environment and Nothing otherwise",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "getEnvMaybe",
        "normalized": "String-\u003eMaybe String",
        "package": "tamarin-prover-utils",
        "partial": "Env Maybe",
        "signature": "String-\u003eMaybe String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:invertMap",
      "description": {
        "fct-descr": "\u003cp\u003eInverts a bijective Map.\n\u003c/p\u003e",
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "Map k v -\u003e Map v k",
        "fct-source": "src/Utils-Misc.html#invertMap",
        "fct-type": "function",
        "title": "invertMap"
      },
      "index": {
        "description": "Inverts bijective Map",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "invertMap",
        "normalized": "Map a b-\u003eMap b a",
        "package": "tamarin-prover-utils",
        "partial": "Map",
        "signature": "Map k v-\u003eMap v k"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:noDuplicates",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003enoDuplicates xs\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e if the list \u003ccode\u003exs\u003c/code\u003e contains no duplicates\n\u003c/p\u003e",
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e Bool",
        "fct-source": "src/Utils-Misc.html#noDuplicates",
        "fct-type": "function",
        "title": "noDuplicates"
      },
      "index": {
        "description": "noDuplicates xs returns True if the list xs contains no duplicates",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "noDuplicates",
        "normalized": "[a]-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "Duplicates",
        "signature": "[a]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:setAny",
      "description": {
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "(a -\u003e Bool) -\u003e Set a -\u003e Bool",
        "fct-source": "src/Utils-Misc.html#setAny",
        "fct-type": "function",
        "title": "setAny"
      },
      "index": {
        "description": "",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "setAny",
        "normalized": "(a-\u003eBool)-\u003eSet a-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "Any",
        "signature": "(a-\u003eBool)-\u003eSet a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:stringSHA256",
      "description": {
        "fct-descr": "\u003cp\u003eThe SHA-256 hash of a string in base64 notation.\n\u003c/p\u003e",
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/Utils-Misc.html#stringSHA256",
        "fct-type": "function",
        "title": "stringSHA256"
      },
      "index": {
        "description": "The SHA-256 hash of string in base64 notation",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "stringSHA256",
        "normalized": "String-\u003eString",
        "package": "tamarin-prover-utils",
        "partial": "SHA",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:subsetOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003esubsetOf xs ys\u003c/code\u003e return \u003ccode\u003eTrue\u003c/code\u003e if \u003ccode\u003eset xs\u003c/code\u003e is a subset of \u003ccode\u003eset ys\u003c/code\u003e \n\u003c/p\u003e",
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "[a] -\u003e [a] -\u003e Bool",
        "fct-source": "src/Utils-Misc.html#subsetOf",
        "fct-type": "function",
        "title": "subsetOf"
      },
      "index": {
        "description": "subsetOf xs ys return True if set xs is subset of set ys",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "subsetOf",
        "normalized": "[a]-\u003e[a]-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "Of",
        "signature": "[a]-\u003e[a]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:unsafeEq",
      "description": {
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "a -\u003e a -\u003e Bool",
        "fct-source": "src/Utils-Misc.html#unsafeEq",
        "fct-type": "function",
        "title": "unsafeEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "unsafeEq",
        "normalized": "a-\u003ea-\u003eBool",
        "package": "tamarin-prover-utils",
        "partial": "Eq",
        "signature": "a-\u003ea-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/tamarin-prover-utils/docs/Utils-Misc.html#v:whileTrue",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ewhileTrue m\u003c/code\u003e iterates m until it returns \u003ccode\u003eFalse\u003c/code\u003e.\n   Returns the number of iterations \u003ccode\u003em\u003c/code\u003e was run. \u003ccode\u003e0\u003c/code\u003e\n   means \u003ccode\u003em\u003c/code\u003e never returned \u003ccode\u003eTrue\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Utils.Misc",
        "fct-package": "tamarin-prover-utils",
        "fct-signature": "m Bool -\u003e m Int",
        "fct-source": "src/Utils-Misc.html#whileTrue",
        "fct-type": "function",
        "title": "whileTrue"
      },
      "index": {
        "description": "whileTrue iterates until it returns False Returns the number of iterations was run means never returned True",
        "hierarchy": "Utils Misc",
        "module": "Utils.Misc",
        "name": "whileTrue",
        "normalized": "a Bool-\u003ea Int",
        "package": "tamarin-prover-utils",
        "partial": "True",
        "signature": "m Bool-\u003em Int"
      }
    }
  }
]
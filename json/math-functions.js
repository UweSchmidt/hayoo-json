[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstant values common to much numeric code.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "module",
        "fct-source": "src/Numeric-MathFunctions-Constants.html",
        "fct-type": "module",
        "title": "Constants"
      },
      "index": {
        "description": "Constant values common to much numeric code",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "Constants",
        "normalized": "",
        "package": "math-functions",
        "partial": "Constants",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_1_sqrt_2",
      "description": {
        "fct-descr": "\u003cpre\u003e1 / sqrt 2\u003c/pre\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_1_sqrt_2",
        "fct-type": "function",
        "title": "m_1_sqrt_2"
      },
      "index": {
        "description": "sqrt",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_1_sqrt_2",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_2_sqrt_pi",
      "description": {
        "fct-descr": "\u003cpre\u003e2 / sqrt pi\u003c/pre\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_2_sqrt_pi",
        "fct-type": "function",
        "title": "m_2_sqrt_pi"
      },
      "index": {
        "description": "sqrt pi",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_2_sqrt_pi",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_NaN",
      "description": {
        "fct-descr": "\u003cp\u003eNot a number.\n\u003c/p\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_NaN",
        "fct-type": "function",
        "title": "m_NaN"
      },
      "index": {
        "description": "Not number",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_NaN",
        "normalized": "",
        "package": "math-functions",
        "partial": "Na",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_epsilon",
      "description": {
        "fct-descr": "\u003cp\u003eThe smallest \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e &#949; such that 1 + &#949; &#8800; 1.\n\u003c/p\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_epsilon",
        "fct-type": "function",
        "title": "m_epsilon"
      },
      "index": {
        "description": "The smallest Double such that",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_epsilon",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_eulerMascheroni",
      "description": {
        "fct-descr": "\u003cp\u003eEuler&#8211;Mascheroni constant (&#947; = 0.57721...)\u003c/p\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_eulerMascheroni",
        "fct-type": "function",
        "title": "m_eulerMascheroni"
      },
      "index": {
        "description": "Euler Mascheroni constant",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_eulerMascheroni",
        "normalized": "",
        "package": "math-functions",
        "partial": "Mascheroni",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_huge",
      "description": {
        "fct-descr": "\u003cp\u003eA very large number.\n\u003c/p\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_huge",
        "fct-type": "function",
        "title": "m_huge"
      },
      "index": {
        "description": "very large number",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_huge",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_ln_sqrt_2_pi",
      "description": {
        "fct-descr": "\u003cpre\u003elog(sqrt((2*pi))\u003c/pre\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_ln_sqrt_2_pi",
        "fct-type": "function",
        "title": "m_ln_sqrt_2_pi"
      },
      "index": {
        "description": "log sqrt pi",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_ln_sqrt_2_pi",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_max_exp",
      "description": {
        "fct-descr": "\u003cp\u003eThe largest \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e \u003cem\u003ex\u003c/em\u003e such that 2**(\u003cem\u003ex\u003c/em\u003e-1) is approximately\n representable as a \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Int",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_max_exp",
        "fct-type": "function",
        "title": "m_max_exp"
      },
      "index": {
        "description": "The largest Int such that is approximately representable as Double",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_max_exp",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_neg_inf",
      "description": {
        "fct-descr": "\u003cp\u003eNegative infinity.\n\u003c/p\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_neg_inf",
        "fct-type": "function",
        "title": "m_neg_inf"
      },
      "index": {
        "description": "Negative infinity",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_neg_inf",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_pos_inf",
      "description": {
        "fct-descr": "\u003cp\u003ePositive infinity.\n\u003c/p\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_pos_inf",
        "fct-type": "function",
        "title": "m_pos_inf"
      },
      "index": {
        "description": "Positive infinity",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_pos_inf",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_sqrt_2",
      "description": {
        "fct-descr": "\u003cpre\u003esqrt 2\u003c/pre\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_sqrt_2",
        "fct-type": "function",
        "title": "m_sqrt_2"
      },
      "index": {
        "description": "sqrt",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_sqrt_2",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_sqrt_2_pi",
      "description": {
        "fct-descr": "\u003cpre\u003esqrt (2 * pi)\u003c/pre\u003e",
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_sqrt_2_pi",
        "fct-type": "function",
        "title": "m_sqrt_2_pi"
      },
      "index": {
        "description": "sqrt pi",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_sqrt_2_pi",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_tiny",
      "description": {
        "fct-module": "Numeric.MathFunctions.Constants",
        "fct-package": "math-functions",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-MathFunctions-Constants.html#m_tiny",
        "fct-type": "function",
        "title": "m_tiny"
      },
      "index": {
        "description": "",
        "hierarchy": "Numeric MathFunctions Constants",
        "module": "Numeric.MathFunctions.Constants",
        "name": "m_tiny",
        "normalized": "",
        "package": "math-functions",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial-Chebyshev.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChebyshev polynomials.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.Polynomial.Chebyshev",
        "fct-package": "math-functions",
        "fct-signature": "module",
        "fct-source": "src/Numeric-Polynomial-Chebyshev.html",
        "fct-type": "module",
        "title": "Chebyshev"
      },
      "index": {
        "description": "Chebyshev polynomials",
        "hierarchy": "Numeric Polynomial Chebyshev",
        "module": "Numeric.Polynomial.Chebyshev",
        "name": "Chebyshev",
        "normalized": "",
        "package": "math-functions",
        "partial": "Chebyshev",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial-Chebyshev.html#v:chebyshev",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a Chebyshev polynomial of the first kind. Uses\n Clenshaw's algorithm.\n\u003c/p\u003e",
        "fct-module": "Numeric.Polynomial.Chebyshev",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e v Double-\u003e Double",
        "fct-type": "function",
        "title": "chebyshev"
      },
      "index": {
        "description": "Evaluate Chebyshev polynomial of the first kind Uses Clenshaw algorithm",
        "hierarchy": "Numeric Polynomial Chebyshev",
        "module": "Numeric.Polynomial.Chebyshev",
        "name": "chebyshev",
        "normalized": "Double-\u003ea Double-\u003eDouble",
        "package": "math-functions",
        "partial": "",
        "signature": "Double-\u003ev Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial-Chebyshev.html#v:chebyshevBroucke",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate a Chebyshev polynomial of the first kind. Uses Broucke's\n ECHEB algorithm, and his convention for coefficient handling. It\n treat 0th coefficient different so\n\u003c/p\u003e\u003cpre\u003e chebyshev x [a0,a1,a2...] == chebyshevBroucke [2*a0,a1,a2...]\n\u003c/pre\u003e",
        "fct-module": "Numeric.Polynomial.Chebyshev",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e v Double-\u003e Double",
        "fct-type": "function",
        "title": "chebyshevBroucke"
      },
      "index": {
        "description": "Evaluate Chebyshev polynomial of the first kind Uses Broucke ECHEB algorithm and his convention for coefficient handling It treat th coefficient different so chebyshev a0 a1 a2 chebyshevBroucke a0 a1 a2",
        "hierarchy": "Numeric Polynomial Chebyshev",
        "module": "Numeric.Polynomial.Chebyshev",
        "name": "chebyshevBroucke",
        "normalized": "Double-\u003ea Double-\u003eDouble",
        "package": "math-functions",
        "partial": "Broucke",
        "signature": "Double-\u003ev Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunction for evaluating polynomials using Horher's method.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.Polynomial",
        "fct-package": "math-functions",
        "fct-signature": "module",
        "fct-source": "src/Numeric-Polynomial.html",
        "fct-type": "module",
        "title": "Polynomial"
      },
      "index": {
        "description": "Function for evaluating polynomials using Horher method",
        "hierarchy": "Numeric Polynomial",
        "module": "Numeric.Polynomial",
        "name": "Polynomial",
        "normalized": "",
        "package": "math-functions",
        "partial": "Polynomial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluateEvenPolynomial",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate polynomial with only even powers using Horner's method.\n Coefficients starts from lowest. In pseudocode:\n\u003c/p\u003e\u003cpre\u003e evaluateOddPolynomial x [1,2,3] = 1 + 2*x^2 + 3*x^4\n\u003c/pre\u003e",
        "fct-module": "Numeric.Polynomial",
        "fct-package": "math-functions",
        "fct-signature": "a-\u003e v a-\u003e a",
        "fct-type": "function",
        "title": "evaluateEvenPolynomial"
      },
      "index": {
        "description": "Evaluate polynomial with only even powers using Horner method Coefficients starts from lowest In pseudocode evaluateOddPolynomial",
        "hierarchy": "Numeric Polynomial",
        "module": "Numeric.Polynomial",
        "name": "evaluateEvenPolynomial",
        "normalized": "a-\u003eb a-\u003ea",
        "package": "math-functions",
        "partial": "Even Polynomial",
        "signature": "a-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluateEvenPolynomialL",
      "description": {
        "fct-module": "Numeric.Polynomial",
        "fct-package": "math-functions",
        "fct-signature": "a -\u003e [a] -\u003e a",
        "fct-source": "src/Numeric-Polynomial.html#evaluateEvenPolynomialL",
        "fct-type": "function",
        "title": "evaluateEvenPolynomialL"
      },
      "index": {
        "description": "",
        "hierarchy": "Numeric Polynomial",
        "module": "Numeric.Polynomial",
        "name": "evaluateEvenPolynomialL",
        "normalized": "a-\u003e[a]-\u003ea",
        "package": "math-functions",
        "partial": "Even Polynomial",
        "signature": "a-\u003e[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluateOddPolynomial",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate polynomial with only odd powers using Horner's method.\n Coefficients starts from lowest. In pseudocode:\n\u003c/p\u003e\u003cpre\u003e evaluateOddPolynomial x [1,2,3] = 1*x + 2*x^3 + 3*x^5\n\u003c/pre\u003e",
        "fct-module": "Numeric.Polynomial",
        "fct-package": "math-functions",
        "fct-signature": "a-\u003e v a-\u003e a",
        "fct-type": "function",
        "title": "evaluateOddPolynomial"
      },
      "index": {
        "description": "Evaluate polynomial with only odd powers using Horner method Coefficients starts from lowest In pseudocode evaluateOddPolynomial",
        "hierarchy": "Numeric Polynomial",
        "module": "Numeric.Polynomial",
        "name": "evaluateOddPolynomial",
        "normalized": "a-\u003eb a-\u003ea",
        "package": "math-functions",
        "partial": "Odd Polynomial",
        "signature": "a-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluateOddPolynomialL",
      "description": {
        "fct-module": "Numeric.Polynomial",
        "fct-package": "math-functions",
        "fct-signature": "a -\u003e [a] -\u003e a",
        "fct-source": "src/Numeric-Polynomial.html#evaluateOddPolynomialL",
        "fct-type": "function",
        "title": "evaluateOddPolynomialL"
      },
      "index": {
        "description": "",
        "hierarchy": "Numeric Polynomial",
        "module": "Numeric.Polynomial",
        "name": "evaluateOddPolynomialL",
        "normalized": "a-\u003e[a]-\u003ea",
        "package": "math-functions",
        "partial": "Odd Polynomial",
        "signature": "a-\u003e[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluatePolynomial",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate polynomial using Horner's method. Coefficients starts\n from lowest. In pseudocode:\n\u003c/p\u003e\u003cpre\u003e evaluateOddPolynomial x [1,2,3] = 1 + 2*x + 3*x^2\n\u003c/pre\u003e",
        "fct-module": "Numeric.Polynomial",
        "fct-package": "math-functions",
        "fct-signature": "a-\u003e v a-\u003e a",
        "fct-type": "function",
        "title": "evaluatePolynomial"
      },
      "index": {
        "description": "Evaluate polynomial using Horner method Coefficients starts from lowest In pseudocode evaluateOddPolynomial",
        "hierarchy": "Numeric Polynomial",
        "module": "Numeric.Polynomial",
        "name": "evaluatePolynomial",
        "normalized": "a-\u003eb a-\u003ea",
        "package": "math-functions",
        "partial": "Polynomial",
        "signature": "a-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluatePolynomialL",
      "description": {
        "fct-module": "Numeric.Polynomial",
        "fct-package": "math-functions",
        "fct-signature": "a -\u003e [a] -\u003e a",
        "fct-source": "src/Numeric-Polynomial.html#evaluatePolynomialL",
        "fct-type": "function",
        "title": "evaluatePolynomialL"
      },
      "index": {
        "description": "",
        "hierarchy": "Numeric Polynomial",
        "module": "Numeric.Polynomial",
        "name": "evaluatePolynomialL",
        "normalized": "a-\u003e[a]-\u003ea",
        "package": "math-functions",
        "partial": "Polynomial",
        "signature": "a-\u003e[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions-Extra.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLess common mathematical functions.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.SpecFunctions.Extra",
        "fct-package": "math-functions",
        "fct-signature": "module",
        "fct-source": "src/Numeric-SpecFunctions-Extra.html",
        "fct-type": "module",
        "title": "Extra"
      },
      "index": {
        "description": "Less common mathematical functions",
        "hierarchy": "Numeric SpecFunctions Extra",
        "module": "Numeric.SpecFunctions.Extra",
        "name": "Extra",
        "normalized": "",
        "package": "math-functions",
        "partial": "Extra",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions-Extra.html#v:bd0",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate the deviance term \u003ccode\u003ex log(x/np) + np - x\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions.Extra",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e Double-\u003e Double",
        "fct-type": "function",
        "title": "bd0"
      },
      "index": {
        "description": "Evaluate the deviance term log np np",
        "hierarchy": "Numeric SpecFunctions Extra",
        "module": "Numeric.SpecFunctions.Extra",
        "name": "bd0",
        "normalized": "Double-\u003eDouble-\u003eDouble",
        "package": "math-functions",
        "partial": "",
        "signature": "Double-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpecial functions and factorials.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "module",
        "fct-source": "src/Numeric-SpecFunctions.html",
        "fct-type": "module",
        "title": "SpecFunctions"
      },
      "index": {
        "description": "Special functions and factorials",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "SpecFunctions",
        "normalized": "",
        "package": "math-functions",
        "partial": "Spec Functions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:choose",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the binomial coefficient \u003cem\u003en\u003c/em\u003e \u003ccode\u003e`\u003ccode\u003e\u003ca\u003echoose\u003c/a\u003e\u003c/code\u003e`\u003c/code\u003e \u003cem\u003ek\u003c/em\u003e. For\n values of \u003cem\u003ek\u003c/em\u003e \u003e 30, this uses an approximation for performance\n reasons.  The approximation is accurate to 12 decimal places in the\n worst case\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e 7 `choose` 3 == 35\n\u003c/pre\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Int -\u003e Int -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#choose",
        "fct-type": "function",
        "title": "choose"
      },
      "index": {
        "description": "Compute the binomial coefficient choose For values of this uses an approximation for performance reasons The approximation is accurate to decimal places in the worst case Example choose",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "choose",
        "normalized": "Int-\u003eInt-\u003eDouble",
        "package": "math-functions",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:digamma",
      "description": {
        "fct-descr": "\u003cp\u003eCompute &#968;0(\u003cem\u003ex\u003c/em\u003e), the first logarithmic derivative of the gamma\n function. Uses Algorithm AS 103 by Bernardo, based on Minka's C\n implementation.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#digamma",
        "fct-type": "function",
        "title": "digamma"
      },
      "index": {
        "description": "Compute the first logarithmic derivative of the gamma function Uses Algorithm AS by Bernardo based on Minka implementation",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "digamma",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "",
        "signature": "Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:erf",
      "description": {
        "fct-descr": "\u003cp\u003eError function.\n\u003c/p\u003e\u003cpre\u003e erf -&#8734; = -1\n erf  0 =  0\n erf +&#8734; =  1\n\u003c/pre\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#erf",
        "fct-type": "function",
        "title": "erf"
      },
      "index": {
        "description": "Error function erf erf erf",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "erf",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "",
        "signature": "Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:erfc",
      "description": {
        "fct-descr": "\u003cp\u003eComplementary error function.\n\u003c/p\u003e\u003cpre\u003e erfc -&#8734; = 2\n erfc  0 = 1\n errc +&#8734; = 0\n\u003c/pre\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#erfc",
        "fct-type": "function",
        "title": "erfc"
      },
      "index": {
        "description": "Complementary error function erfc erfc errc",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "erfc",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "",
        "signature": "Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:factorial",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the factorial function \u003cem\u003en\u003c/em\u003e!.  Returns +&#8734; if the\n input is above 170 (above which the result cannot be represented by\n a 64-bit \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Int -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#factorial",
        "fct-type": "function",
        "title": "factorial"
      },
      "index": {
        "description": "Compute the factorial function Returns if the input is above above which the result cannot be represented by bit Double",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "factorial",
        "normalized": "Int-\u003eDouble",
        "package": "math-functions",
        "partial": "",
        "signature": "Int-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:incompleteBeta",
      "description": {
        "fct-descr": "\u003cp\u003eRegularized incomplete beta function. Uses algorithm AS63 by\n Majumder and Bhattachrjee and quadrature approximation for large\n \u003cem\u003ep\u003c/em\u003e and \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e Double-\u003e Double-\u003e Double",
        "fct-type": "function",
        "title": "incompleteBeta"
      },
      "index": {
        "description": "Regularized incomplete beta function Uses algorithm AS63 by Majumder and Bhattachrjee and quadrature approximation for large and",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "incompleteBeta",
        "normalized": "Double-\u003eDouble-\u003eDouble-\u003eDouble",
        "package": "math-functions",
        "partial": "Beta",
        "signature": "Double-\u003eDouble-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:incompleteBeta_",
      "description": {
        "fct-descr": "\u003cp\u003eRegularized incomplete beta function. Same as \u003ccode\u003e\u003ca\u003eincompleteBeta\u003c/a\u003e\u003c/code\u003e\n but also takes logarithm of beta function as parameter.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e Double-\u003e Double-\u003e Double-\u003e Double",
        "fct-type": "function",
        "title": "incompleteBeta_"
      },
      "index": {
        "description": "Regularized incomplete beta function Same as incompleteBeta but also takes logarithm of beta function as parameter",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "incompleteBeta_",
        "normalized": "Double-\u003eDouble-\u003eDouble-\u003eDouble-\u003eDouble",
        "package": "math-functions",
        "partial": "Beta",
        "signature": "Double-\u003eDouble-\u003eDouble-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:incompleteGamma",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the normalized lower incomplete gamma function\n &#947;\u003cem\u003es\u003c/em\u003e,\u003cem\u003ex\u003c/em\u003e). Normalization means that\n &#947;\u003cem\u003es\u003c/em\u003e,&#8734;)=1. Uses Algorithm AS 239 by Shea.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e Double-\u003e Double",
        "fct-type": "function",
        "title": "incompleteGamma"
      },
      "index": {
        "description": "Compute the normalized lower incomplete gamma function Normalization means that Uses Algorithm AS by Shea",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "incompleteGamma",
        "normalized": "Double-\u003eDouble-\u003eDouble",
        "package": "math-functions",
        "partial": "Gamma",
        "signature": "Double-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:invErf",
      "description": {
        "fct-descr": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003eerf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e Double",
        "fct-type": "function",
        "title": "invErf"
      },
      "index": {
        "description": "Inverse of erf",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "invErf",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "Erf",
        "signature": "Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:invErfc",
      "description": {
        "fct-descr": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003eerfc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e Double",
        "fct-type": "function",
        "title": "invErfc"
      },
      "index": {
        "description": "Inverse of erfc",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "invErfc",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "Erfc",
        "signature": "Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:invIncompleteBeta",
      "description": {
        "fct-descr": "\u003cp\u003eCompute inverse of regularized incomplete beta function. Uses\n initial approximation from AS109, AS64 and Halley method to solve\n equation.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e Double-\u003e Double-\u003e Double",
        "fct-type": "function",
        "title": "invIncompleteBeta"
      },
      "index": {
        "description": "Compute inverse of regularized incomplete beta function Uses initial approximation from AS109 AS64 and Halley method to solve equation",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "invIncompleteBeta",
        "normalized": "Double-\u003eDouble-\u003eDouble-\u003eDouble",
        "package": "math-functions",
        "partial": "Incomplete Beta",
        "signature": "Double-\u003eDouble-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:invIncompleteGamma",
      "description": {
        "fct-descr": "\u003cp\u003eInverse incomplete gamma function. It's approximately inverse of\n   \u003ccode\u003e\u003ca\u003eincompleteGamma\u003c/a\u003e\u003c/code\u003e for the same \u003cem\u003es\u003c/em\u003e. So following equality\n   approximately holds:\n\u003c/p\u003e\u003cpre\u003e invIncompleteGamma s . incompleteGamma s = id\n\u003c/pre\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double-\u003e Double-\u003e Double",
        "fct-type": "function",
        "title": "invIncompleteGamma"
      },
      "index": {
        "description": "Inverse incomplete gamma function It approximately inverse of incompleteGamma for the same So following equality approximately holds invIncompleteGamma incompleteGamma id",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "invIncompleteGamma",
        "normalized": "Double-\u003eDouble-\u003eDouble",
        "package": "math-functions",
        "partial": "Incomplete Gamma",
        "signature": "Double-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:log1p",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the natural logarithm of 1 + \u003ccode\u003ex\u003c/code\u003e.  This is accurate even\n for values of \u003ccode\u003ex\u003c/code\u003e near zero, where use of \u003ccode\u003elog(1+x)\u003c/code\u003e would lose\n precision.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#log1p",
        "fct-type": "function",
        "title": "log1p"
      },
      "index": {
        "description": "Compute the natural logarithm of This is accurate even for values of near zero where use of log would lose precision",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "log1p",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "",
        "signature": "Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:log2",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e Compute the logarithm in base 2 of the given value.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Int -\u003e Int",
        "fct-source": "src/Numeric-SpecFunctions.html#log2",
        "fct-type": "function",
        "title": "log2"
      },
      "index": {
        "description": "log Compute the logarithm in base of the given value",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "log2",
        "normalized": "Int-\u003eInt",
        "package": "math-functions",
        "partial": "",
        "signature": "Int-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:logBeta",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the natural logarithm of the beta function.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double -\u003e Double -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#logBeta",
        "fct-type": "function",
        "title": "logBeta"
      },
      "index": {
        "description": "Compute the natural logarithm of the beta function",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "logBeta",
        "normalized": "Double-\u003eDouble-\u003eDouble",
        "package": "math-functions",
        "partial": "Beta",
        "signature": "Double-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:logFactorial",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the natural logarithm of the factorial function.  Gives\n 16 decimal digits of precision.\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "a -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#logFactorial",
        "fct-type": "function",
        "title": "logFactorial"
      },
      "index": {
        "description": "Compute the natural logarithm of the factorial function Gives decimal digits of precision",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "logFactorial",
        "normalized": "a-\u003eDouble",
        "package": "math-functions",
        "partial": "Factorial",
        "signature": "a-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:logGamma",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the logarithm of the gamma function &#915;\u003cem\u003ex\u003c/em\u003e).  Uses\n Algorithm AS 245 by Macleod.\n\u003c/p\u003e\u003cp\u003eGives an accuracy of 10-12 significant decimal digits, except\n for small regions around \u003cem\u003ex\u003c/em\u003e = 1 and \u003cem\u003ex\u003c/em\u003e = 2, where the function\n goes to zero.  For greater accuracy, use \u003ccode\u003e\u003ca\u003elogGammaL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eReturns &#8734; if the input is outside of the range (0 \u003c \u003cem\u003ex\u003c/em\u003e &#8804; 1e305).\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#logGamma",
        "fct-type": "function",
        "title": "logGamma"
      },
      "index": {
        "description": "Compute the logarithm of the gamma function Uses Algorithm AS by Macleod Gives an accuracy of significant decimal digits except for small regions around and where the function goes to zero For greater accuracy use logGammaL Returns if the input is outside of the range e305",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "logGamma",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "Gamma",
        "signature": "Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:logGammaL",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the logarithm of the gamma function, &#915;(\u003cem\u003ex\u003c/em\u003e).  Uses a\n Lanczos approximation.\n\u003c/p\u003e\u003cp\u003eThis function is slower than \u003ccode\u003e\u003ca\u003elogGamma\u003c/a\u003e\u003c/code\u003e, but gives 14 or more\n significant decimal digits of accuracy, except around \u003cem\u003ex\u003c/em\u003e = 1 and\n \u003cem\u003ex\u003c/em\u003e = 2, where the function goes to zero.\n\u003c/p\u003e\u003cp\u003eReturns &#8734; if the input is outside of the range (0 \u003c \u003cem\u003ex\u003c/em\u003e\n &#8804; 1e305).\n\u003c/p\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#logGammaL",
        "fct-type": "function",
        "title": "logGammaL"
      },
      "index": {
        "description": "Compute the logarithm of the gamma function Uses Lanczos approximation This function is slower than logGamma but gives or more significant decimal digits of accuracy except around and where the function goes to zero Returns if the input is outside of the range e305",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "logGammaL",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "Gamma",
        "signature": "Double-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:stirlingError",
      "description": {
        "fct-descr": "\u003cp\u003eCalculate the error term of the Stirling approximation.  This is\n only defined for non-negative values.\n\u003c/p\u003e\u003cpre\u003e stirlingError @n@ = @log(n!) - log(sqrt(2*pi*n)*(n/e)^n)\n\u003c/pre\u003e",
        "fct-module": "Numeric.SpecFunctions",
        "fct-package": "math-functions",
        "fct-signature": "Double -\u003e Double",
        "fct-source": "src/Numeric-SpecFunctions.html#stirlingError",
        "fct-type": "function",
        "title": "stirlingError"
      },
      "index": {
        "description": "Calculate the error term of the Stirling approximation This is only defined for non-negative values stirlingError log log sqrt pi",
        "hierarchy": "Numeric SpecFunctions",
        "module": "Numeric.SpecFunctions",
        "name": "stirlingError",
        "normalized": "Double-\u003eDouble",
        "package": "math-functions",
        "partial": "Error",
        "signature": "Double-\u003eDouble"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Equality.html#",
      "description": {
        "fct-module": "Top.Constraint.Equality",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Constraint-Equality.html",
        "fct-type": "module",
        "title": "Equality"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Equality",
        "module": "Top.Constraint.Equality",
        "name": "Equality",
        "normalized": "",
        "package": "Top",
        "partial": "Equality",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Equality.html#t:EqualityConstraint",
      "description": {
        "fct-module": "Top.Constraint.Equality",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Constraint-Equality.html#EqualityConstraint",
        "fct-type": "data",
        "title": "EqualityConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Equality",
        "module": "Top.Constraint.Equality",
        "name": "EqualityConstraint",
        "normalized": "",
        "package": "Top",
        "partial": "Equality Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Equality.html#v:.-61--61-.",
      "description": {
        "fct-descr": "\u003cp\u003eThe constructor of an equality constraint.\n\u003c/p\u003e",
        "fct-module": "Top.Constraint.Equality",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Tp -\u003e info -\u003e EqualityConstraint info",
        "fct-source": "src/Top-Constraint-Equality.html#.%3D%3D.",
        "fct-type": "function",
        "title": "(.==.)"
      },
      "index": {
        "description": "The constructor of an equality constraint",
        "hierarchy": "Top Constraint Equality",
        "module": "Top.Constraint.Equality",
        "name": "(.==.) .==.",
        "normalized": "Tp-\u003eTp-\u003ea-\u003eEqualityConstraint a",
        "package": "Top",
        "partial": "",
        "signature": "Tp-\u003eTp-\u003einfo-\u003eEqualityConstraint info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Equality.html#v:Equality",
      "description": {
        "fct-module": "Top.Constraint.Equality",
        "fct-package": "Top",
        "fct-signature": "Equality Tp Tp info",
        "fct-source": "src/Top-Constraint-Equality.html#EqualityConstraint",
        "fct-type": "function",
        "title": "Equality"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Equality",
        "module": "Top.Constraint.Equality",
        "name": "Equality",
        "normalized": "",
        "package": "Top",
        "partial": "Equality",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Constraint-Information.html",
        "fct-type": "module",
        "title": "Information"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "Information",
        "normalized": "",
        "package": "Top",
        "partial": "Information",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#t:PolyTypeConstraintInfo",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Constraint-Information.html#PolyTypeConstraintInfo",
        "fct-type": "class",
        "title": "PolyTypeConstraintInfo"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "PolyTypeConstraintInfo",
        "normalized": "",
        "package": "Top",
        "partial": "Poly Type Constraint Info",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#t:TypeConstraintInfo",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Constraint-Information.html#TypeConstraintInfo",
        "fct-type": "class",
        "title": "TypeConstraintInfo"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "TypeConstraintInfo",
        "normalized": "",
        "package": "Top",
        "partial": "Type Constraint Info",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:ambiguousPredicate",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "Predicate -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#ambiguousPredicate",
        "fct-type": "method",
        "title": "ambiguousPredicate"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "ambiguousPredicate",
        "normalized": "Predicate-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Predicate",
        "signature": "Predicate-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:closeDirective",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "(String, info) -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#closeDirective",
        "fct-type": "method",
        "title": "closeDirective"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "closeDirective",
        "normalized": "(String,a)-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Directive",
        "signature": "(String,info)-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:disjointDirective",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "(String, info) -\u003e (String, info) -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#disjointDirective",
        "fct-type": "method",
        "title": "disjointDirective"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "disjointDirective",
        "normalized": "(String,a)-\u003e(String,a)-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Directive",
        "signature": "(String,info)-\u003e(String,info)-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:equalityTypePair",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "(Tp, Tp) -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#equalityTypePair",
        "fct-type": "method",
        "title": "equalityTypePair"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "equalityTypePair",
        "normalized": "(Tp,Tp)-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Type Pair",
        "signature": "(Tp,Tp)-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:escapedSkolems",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#escapedSkolems",
        "fct-type": "method",
        "title": "escapedSkolems"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "escapedSkolems",
        "normalized": "[Int]-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Skolems",
        "signature": "[Int]-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:instantiatedTypeScheme",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "Forall (Qualification Predicates Tp) -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#instantiatedTypeScheme",
        "fct-type": "method",
        "title": "instantiatedTypeScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "instantiatedTypeScheme",
        "normalized": "Forall(Qualification Predicates Tp)-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Type Scheme",
        "signature": "Forall(Qualification Predicates Tp)-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:neverDirective",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "(Predicate, info) -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#neverDirective",
        "fct-type": "method",
        "title": "neverDirective"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "neverDirective",
        "normalized": "(Predicate,a)-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Directive",
        "signature": "(Predicate,info)-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:parentPredicate",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "Predicate -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#parentPredicate",
        "fct-type": "method",
        "title": "parentPredicate"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "parentPredicate",
        "normalized": "Predicate-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Predicate",
        "signature": "Predicate-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:predicateArisingFrom",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "(Predicate, info) -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#predicateArisingFrom",
        "fct-type": "method",
        "title": "predicateArisingFrom"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "predicateArisingFrom",
        "normalized": "(Predicate,a)-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Arising From",
        "signature": "(Predicate,info)-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:skolemizedTypeScheme",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "(Tps, Forall (Qualification Predicates Tp)) -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#skolemizedTypeScheme",
        "fct-type": "method",
        "title": "skolemizedTypeScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "skolemizedTypeScheme",
        "normalized": "(Tps,Forall(Qualification Predicates Tp))-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Type Scheme",
        "signature": "(Tps,Forall(Qualification Predicates Tp))-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:unresolvedPredicate",
      "description": {
        "fct-module": "Top.Constraint.Information",
        "fct-package": "Top",
        "fct-signature": "Predicate -\u003e info -\u003e info",
        "fct-source": "src/Top-Constraint-Information.html#unresolvedPredicate",
        "fct-type": "method",
        "title": "unresolvedPredicate"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Information",
        "module": "Top.Constraint.Information",
        "name": "unresolvedPredicate",
        "normalized": "Predicate-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Predicate",
        "signature": "Predicate-\u003einfo-\u003einfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#",
      "description": {
        "fct-module": "Top.Constraint.Polymorphism",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Constraint-Polymorphism.html",
        "fct-type": "module",
        "title": "Polymorphism"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Polymorphism",
        "module": "Top.Constraint.Polymorphism",
        "name": "Polymorphism",
        "normalized": "",
        "package": "Top",
        "partial": "Polymorphism",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#t:PolymorphismConstraint",
      "description": {
        "fct-module": "Top.Constraint.Polymorphism",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
        "fct-type": "data",
        "title": "PolymorphismConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Polymorphism",
        "module": "Top.Constraint.Polymorphism",
        "name": "PolymorphismConstraint",
        "normalized": "",
        "package": "Top",
        "partial": "Polymorphism Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:.::.",
      "description": {
        "fct-descr": "\u003cp\u003eThe constructor of an instantiate (explicit instance) constraint.\n\u003c/p\u003e",
        "fct-module": "Top.Constraint.Polymorphism",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Scheme Predicates -\u003e info -\u003e PolymorphismConstraint info",
        "fct-source": "src/Top-Constraint-Polymorphism.html#.%3A%3A.",
        "fct-type": "function",
        "title": "(.::.)"
      },
      "index": {
        "description": "The constructor of an instantiate explicit instance constraint",
        "hierarchy": "Top Constraint Polymorphism",
        "module": "Top.Constraint.Polymorphism",
        "name": "(.::.) .::.",
        "normalized": "Tp-\u003eScheme Predicates-\u003ea-\u003ePolymorphismConstraint a",
        "package": "Top",
        "partial": "",
        "signature": "Tp-\u003eScheme Predicates-\u003einfo-\u003ePolymorphismConstraint info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:Generalize",
      "description": {
        "fct-module": "Top.Constraint.Polymorphism",
        "fct-package": "Top",
        "fct-signature": "Generalize Int (Tps, Tp) info",
        "fct-source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
        "fct-type": "function",
        "title": "Generalize"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Polymorphism",
        "module": "Top.Constraint.Polymorphism",
        "name": "Generalize",
        "normalized": "Generalize Int(Tps,Tp)a",
        "package": "Top",
        "partial": "Generalize",
        "signature": "Generalize Int(Tps,Tp)info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:Implicit",
      "description": {
        "fct-module": "Top.Constraint.Polymorphism",
        "fct-package": "Top",
        "fct-signature": "Implicit Tp (Tps, Tp) info",
        "fct-source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
        "fct-type": "function",
        "title": "Implicit"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Polymorphism",
        "module": "Top.Constraint.Polymorphism",
        "name": "Implicit",
        "normalized": "Implicit Tp(Tps,Tp)a",
        "package": "Top",
        "partial": "Implicit",
        "signature": "Implicit Tp(Tps,Tp)info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:Instantiate",
      "description": {
        "fct-module": "Top.Constraint.Polymorphism",
        "fct-package": "Top",
        "fct-signature": "Instantiate Tp (Sigma Predicates) info",
        "fct-source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
        "fct-type": "function",
        "title": "Instantiate"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Polymorphism",
        "module": "Top.Constraint.Polymorphism",
        "name": "Instantiate",
        "normalized": "",
        "package": "Top",
        "partial": "Instantiate",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:Skolemize",
      "description": {
        "fct-module": "Top.Constraint.Polymorphism",
        "fct-package": "Top",
        "fct-signature": "Skolemize Tp (Tps, Sigma Predicates) info",
        "fct-source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
        "fct-type": "function",
        "title": "Skolemize"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Polymorphism",
        "module": "Top.Constraint.Polymorphism",
        "name": "Skolemize",
        "normalized": "Skolemize Tp(Tps,Sigma Predicates)a",
        "package": "Top",
        "partial": "Skolemize",
        "signature": "Skolemize Tp(Tps,Sigma Predicates)info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Qualifier.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstraints for overloading\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Constraint.Qualifier",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Constraint-Qualifier.html",
        "fct-type": "module",
        "title": "Qualifier"
      },
      "index": {
        "description": "Constraints for overloading",
        "hierarchy": "Top Constraint Qualifier",
        "module": "Top.Constraint.Qualifier",
        "name": "Qualifier",
        "normalized": "",
        "package": "Top",
        "partial": "Qualifier",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Qualifier.html#t:ExtraConstraint",
      "description": {
        "fct-module": "Top.Constraint.Qualifier",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Constraint-Qualifier.html#ExtraConstraint",
        "fct-type": "data",
        "title": "ExtraConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Qualifier",
        "module": "Top.Constraint.Qualifier",
        "name": "ExtraConstraint",
        "normalized": "",
        "package": "Top",
        "partial": "Extra Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Qualifier.html#v:Assume",
      "description": {
        "fct-module": "Top.Constraint.Qualifier",
        "fct-package": "Top",
        "fct-signature": "Assume Predicate info",
        "fct-source": "src/Top-Constraint-Qualifier.html#ExtraConstraint",
        "fct-type": "function",
        "title": "Assume"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Qualifier",
        "module": "Top.Constraint.Qualifier",
        "name": "Assume",
        "normalized": "",
        "package": "Top",
        "partial": "Assume",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Qualifier.html#v:Prove",
      "description": {
        "fct-module": "Top.Constraint.Qualifier",
        "fct-package": "Top",
        "fct-signature": "Prove Predicate info",
        "fct-source": "src/Top-Constraint-Qualifier.html#ExtraConstraint",
        "fct-type": "function",
        "title": "Prove"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint Qualifier",
        "module": "Top.Constraint.Qualifier",
        "name": "Prove",
        "normalized": "",
        "package": "Top",
        "partial": "Prove",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA data type to represent constraints in general, and a type class for\n constraints that are solvable.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Constraint.html",
        "fct-type": "module",
        "title": "Constraint"
      },
      "index": {
        "description": "data type to represent constraints in general and type class for constraints that are solvable",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "Constraint",
        "normalized": "",
        "package": "Top",
        "partial": "Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:Constraint",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Constraint.html#Constraint",
        "fct-type": "data",
        "title": "Constraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "Constraint",
        "normalized": "",
        "package": "Top",
        "partial": "Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:ConstraintSum",
      "description": {
        "fct-descr": "\u003cp\u003eThe data type ConstraintSum is similar to the (standard) Either data type.    \n However, its Show instance is slightly different as the name of the constructor\n is not shown.\n\u003c/p\u003e",
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Constraint.html#ConstraintSum",
        "fct-type": "data",
        "title": "ConstraintSum"
      },
      "index": {
        "description": "The data type ConstraintSum is similar to the standard Either data type However its Show instance is slightly different as the name of the constructor is not shown",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "ConstraintSum",
        "normalized": "",
        "package": "Top",
        "partial": "Constraint Sum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:Constraints",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Constraint.html#Constraints",
        "fct-type": "type",
        "title": "Constraints"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "Constraints",
        "normalized": "",
        "package": "Top",
        "partial": "Constraints",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:Operation",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Constraint.html#Operation",
        "fct-type": "newtype",
        "title": "Operation"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "Operation",
        "normalized": "",
        "package": "Top",
        "partial": "Operation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:Solvable",
      "description": {
        "fct-descr": "\u003cp\u003eA constraint is solvable if it knows how it can be solved in a certain\n state (a monadic operation), if it can check afterwards whether the final\n state satisfies it, and when it can be shown.\n\u003c/p\u003e",
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Constraint.html#Solvable",
        "fct-type": "class",
        "title": "Solvable"
      },
      "index": {
        "description": "constraint is solvable if it knows how it can be solved in certain state monadic operation if it can check afterwards whether the final state satisfies it and when it can be shown",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "Solvable",
        "normalized": "",
        "package": "Top",
        "partial": "Solvable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:Constraint",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "Constraint c (c -\u003e m ()) (c -\u003e m Bool)",
        "fct-source": "src/Top-Constraint.html#Constraint",
        "fct-type": "function",
        "title": "Constraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "Constraint",
        "normalized": "Constraint a(a-\u003eb())(a-\u003eb Bool)",
        "package": "Top",
        "partial": "Constraint",
        "signature": "Constraint c(c-\u003em())(c-\u003em Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:Op_",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "Op_ String",
        "fct-source": "src/Top-Constraint.html#Operation",
        "fct-type": "function",
        "title": "Op_"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "Op_",
        "normalized": "",
        "package": "Top",
        "partial": "Op",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:SumLeft",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "SumLeft (f info)",
        "fct-source": "src/Top-Constraint.html#ConstraintSum",
        "fct-type": "function",
        "title": "SumLeft"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "SumLeft",
        "normalized": "",
        "package": "Top",
        "partial": "Sum Left",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:SumRight",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "SumRight (g info)",
        "fct-source": "src/Top-Constraint.html#ConstraintSum",
        "fct-type": "function",
        "title": "SumRight"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "SumRight",
        "normalized": "",
        "package": "Top",
        "partial": "Sum Right",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:checkCondition",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "c -\u003e m Bool",
        "fct-source": "src/Top-Constraint.html#checkCondition",
        "fct-type": "method",
        "title": "checkCondition"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "checkCondition",
        "normalized": "a-\u003eb Bool",
        "package": "Top",
        "partial": "Condition",
        "signature": "c-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:constraintSum",
      "description": {
        "fct-descr": "\u003cp\u003eSimilar to the \u003ccode\u003e\u003ca\u003eeither\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "(f info -\u003e c) -\u003e (g info -\u003e c) -\u003e ConstraintSum f g info -\u003e c",
        "fct-source": "src/Top-Constraint.html#constraintSum",
        "fct-type": "function",
        "title": "constraintSum"
      },
      "index": {
        "description": "Similar to the either function",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "constraintSum",
        "normalized": "(a b-\u003ec)-\u003e(d b-\u003ec)-\u003eConstraintSum a d b-\u003ec",
        "package": "Top",
        "partial": "Sum",
        "signature": "(f info-\u003ec)-\u003e(g info-\u003ec)-\u003eConstraintSum f g info-\u003ec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:liftConstraint",
      "description": {
        "fct-descr": "\u003cp\u003eLifting a constraint to the Constraint data type. Every instance of\n the Solvable type class can be lifted.\n\u003c/p\u003e",
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "c -\u003e Constraint m",
        "fct-source": "src/Top-Constraint.html#liftConstraint",
        "fct-type": "function",
        "title": "liftConstraint"
      },
      "index": {
        "description": "Lifting constraint to the Constraint data type Every instance of the Solvable type class can be lifted",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "liftConstraint",
        "normalized": "a-\u003eConstraint b",
        "package": "Top",
        "partial": "Constraint",
        "signature": "c-\u003eConstraint m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:liftConstraints",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "[c] -\u003e Constraints m",
        "fct-source": "src/Top-Constraint.html#liftConstraints",
        "fct-type": "function",
        "title": "liftConstraints"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "liftConstraints",
        "normalized": "[a]-\u003eConstraints b",
        "package": "Top",
        "partial": "Constraints",
        "signature": "[c]-\u003eConstraints m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:mapConstraint",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "(forall a.  m1 a -\u003e m2 a) -\u003e Constraint m1 -\u003e Constraint m2",
        "fct-source": "src/Top-Constraint.html#mapConstraint",
        "fct-type": "function",
        "title": "mapConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "mapConstraint",
        "normalized": "(a b c d-\u003ec d)-\u003eConstraint c-\u003eConstraint c",
        "package": "Top",
        "partial": "Constraint",
        "signature": "(forall a. m a-\u003em a)-\u003eConstraint m-\u003eConstraint m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:operation",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "String -\u003e m () -\u003e Constraint m",
        "fct-source": "src/Top-Constraint.html#operation",
        "fct-type": "function",
        "title": "operation"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "operation",
        "normalized": "String-\u003ea()-\u003eConstraint a",
        "package": "Top",
        "partial": "",
        "signature": "String-\u003em()-\u003eConstraint m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:solveConstraint",
      "description": {
        "fct-module": "Top.Constraint",
        "fct-package": "Top",
        "fct-signature": "c -\u003e m ()",
        "fct-source": "src/Top-Constraint.html#solveConstraint",
        "fct-type": "method",
        "title": "solveConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Constraint",
        "module": "Top.Constraint",
        "name": "solveConstraint",
        "normalized": "a-\u003eb()",
        "package": "Top",
        "partial": "Constraint",
        "signature": "c-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn interface for a monad that constains the most basic operations to \n solve constraints. Can be reused for all kinds of constraint-based\n analyses.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Implementation.Basic",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-Basic.html",
        "fct-type": "module",
        "title": "Basic"
      },
      "index": {
        "description": "An interface for monad that constains the most basic operations to solve constraints Can be reused for all kinds of constraint-based analyses",
        "hierarchy": "Top Implementation Basic",
        "module": "Top.Implementation.Basic",
        "name": "Basic",
        "normalized": "",
        "package": "Top",
        "partial": "Basic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#t:BasicState",
      "description": {
        "fct-descr": "\u003cp\u003eA BasicState is parameterized over the monad in which the constraints can\n be solved, and over the information that is stored with each constraint.\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.Basic",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-Basic.html#BasicState",
        "fct-type": "data",
        "title": "BasicState"
      },
      "index": {
        "description": "BasicState is parameterized over the monad in which the constraints can be solved and over the information that is stored with each constraint",
        "hierarchy": "Top Implementation Basic",
        "module": "Top.Implementation.Basic",
        "name": "BasicState",
        "normalized": "",
        "package": "Top",
        "partial": "Basic State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:BasicState",
      "description": {
        "fct-module": "Top.Implementation.Basic",
        "fct-package": "Top",
        "fct-signature": "BasicState",
        "fct-source": "src/Top-Implementation-Basic.html#BasicState",
        "fct-type": "function",
        "title": "BasicState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Basic",
        "module": "Top.Implementation.Basic",
        "name": "BasicState",
        "normalized": "",
        "package": "Top",
        "partial": "Basic State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:conditions",
      "description": {
        "fct-descr": "\u003cp\u003eConditions to check (for the solved constraints)\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.Basic",
        "fct-package": "Top",
        "fct-signature": "[(m Bool, String)]",
        "fct-source": "src/Top-Implementation-Basic.html#BasicState",
        "fct-type": "function",
        "title": "conditions"
      },
      "index": {
        "description": "Conditions to check for the solved constraints",
        "hierarchy": "Top Implementation Basic",
        "module": "Top.Implementation.Basic",
        "name": "conditions",
        "normalized": "[(a Bool,String)]",
        "package": "Top",
        "partial": "",
        "signature": "[(m Bool,String)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:constraints",
      "description": {
        "fct-descr": "\u003cp\u003eA stack of constraints that is to be solved\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.Basic",
        "fct-package": "Top",
        "fct-signature": "Constraints m",
        "fct-source": "src/Top-Implementation-Basic.html#BasicState",
        "fct-type": "function",
        "title": "constraints"
      },
      "index": {
        "description": "stack of constraints that is to be solved",
        "hierarchy": "Top Implementation Basic",
        "module": "Top.Implementation.Basic",
        "name": "constraints",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:errors",
      "description": {
        "fct-descr": "\u003cp\u003eThe detected errors\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.Basic",
        "fct-package": "Top",
        "fct-signature": "[(info, ErrorLabel)]",
        "fct-source": "src/Top-Implementation-Basic.html#BasicState",
        "fct-type": "function",
        "title": "errors"
      },
      "index": {
        "description": "The detected errors",
        "hierarchy": "Top Implementation Basic",
        "module": "Top.Implementation.Basic",
        "name": "errors",
        "normalized": "[(a,ErrorLabel)]",
        "package": "Top",
        "partial": "",
        "signature": "[(info,ErrorLabel)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:optionCheck",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.Basic",
        "fct-package": "Top",
        "fct-signature": "Option Bool",
        "fct-source": "src/Top-Implementation-Basic.html#BasicState",
        "fct-type": "function",
        "title": "optionCheck"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Basic",
        "module": "Top.Implementation.Basic",
        "name": "optionCheck",
        "normalized": "",
        "package": "Top",
        "partial": "Check",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:optionStop",
      "description": {
        "fct-descr": "\u003cp\u003eDiscard all remaining constraints after the first error\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.Basic",
        "fct-package": "Top",
        "fct-signature": "Option Bool",
        "fct-source": "src/Top-Implementation-Basic.html#BasicState",
        "fct-type": "function",
        "title": "optionStop"
      },
      "index": {
        "description": "Discard all remaining constraints after the first error",
        "hierarchy": "Top Implementation Basic",
        "module": "Top.Implementation.Basic",
        "name": "optionStop",
        "normalized": "",
        "package": "Top",
        "partial": "Stop",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#",
      "description": {
        "fct-module": "Top.Implementation.FastSubstitution",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-FastSubstitution.html",
        "fct-type": "module",
        "title": "FastSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation FastSubstitution",
        "module": "Top.Implementation.FastSubstitution",
        "name": "FastSubstitution",
        "normalized": "",
        "package": "Top",
        "partial": "Fast Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#t:GreedyState",
      "description": {
        "fct-module": "Top.Implementation.FastSubstitution",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Implementation-FastSubstitution.html#GreedyState",
        "fct-type": "newtype",
        "title": "GreedyState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation FastSubstitution",
        "module": "Top.Implementation.FastSubstitution",
        "name": "GreedyState",
        "normalized": "",
        "package": "Top",
        "partial": "Greedy State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#v:GreedyState",
      "description": {
        "fct-module": "Top.Implementation.FastSubstitution",
        "fct-package": "Top",
        "fct-signature": "GreedyState",
        "fct-source": "src/Top-Implementation-FastSubstitution.html#GreedyState",
        "fct-type": "function",
        "title": "GreedyState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation FastSubstitution",
        "module": "Top.Implementation.FastSubstitution",
        "name": "GreedyState",
        "normalized": "",
        "package": "Top",
        "partial": "Greedy State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#v:unGS",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.FastSubstitution",
        "fct-package": "Top",
        "fct-signature": "FixpointSubstitution",
        "fct-source": "src/Top-Implementation-FastSubstitution.html#GreedyState",
        "fct-type": "function",
        "title": "unGS"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation FastSubstitution",
        "module": "Top.Implementation.FastSubstitution",
        "name": "unGS",
        "normalized": "",
        "package": "Top",
        "partial": "GS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#v:writeExpandedType",
      "description": {
        "fct-module": "Top.Implementation.FastSubstitution",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Tp -\u003e FixpointSubstitution -\u003e FixpointSubstitution",
        "fct-source": "src/Top-Implementation-FastSubstitution.html#writeExpandedType",
        "fct-type": "function",
        "title": "writeExpandedType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation FastSubstitution",
        "module": "Top.Implementation.FastSubstitution",
        "name": "writeExpandedType",
        "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eFixpointSubstitution-\u003eFixpointSubstitution",
        "package": "Top",
        "partial": "Expanded Type",
        "signature": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eFixpointSubstitution-\u003eFixpointSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-General.html",
        "fct-type": "module",
        "title": "General"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "General",
        "normalized": "",
        "package": "Top",
        "partial": "General",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#t:And",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-General.html#And",
        "fct-type": "data",
        "title": "And"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "And",
        "normalized": "",
        "package": "Top",
        "partial": "And",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#t:Fix",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-General.html#Fix",
        "fct-type": "data",
        "title": "Fix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "Fix",
        "normalized": "",
        "package": "Top",
        "partial": "Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#t:Simple",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-General.html#Simple",
        "fct-type": "data",
        "title": "Simple"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "Simple",
        "normalized": "",
        "package": "Top",
        "partial": "Simple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#t:SolveState",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Implementation-General.html#SolveState",
        "fct-type": "class",
        "title": "SolveState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "SolveState",
        "normalized": "",
        "package": "Top",
        "partial": "Solve State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:Compose",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "Compose (f (g x m) m)",
        "fct-source": "src/Top-Implementation-General.html#And",
        "fct-type": "function",
        "title": "Compose"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "Compose",
        "normalized": "",
        "package": "Top",
        "partial": "Compose",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:Fix",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "Fix (g m) x",
        "fct-source": "src/Top-Implementation-General.html#Fix",
        "fct-type": "function",
        "title": "Fix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "Fix",
        "normalized": "",
        "package": "Top",
        "partial": "Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:Simple",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "Simple a x",
        "fct-source": "src/Top-Implementation-General.html#Simple",
        "fct-type": "function",
        "title": "Simple"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "Simple",
        "normalized": "",
        "package": "Top",
        "partial": "Simple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:allOptions",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "m [String]",
        "fct-source": "src/Top-Implementation-General.html#allOptions",
        "fct-type": "function",
        "title": "allOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "allOptions",
        "normalized": "a[String]",
        "package": "Top",
        "partial": "Options",
        "signature": "m[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:allStates",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "m [(String, String)]",
        "fct-source": "src/Top-Implementation-General.html#allStates",
        "fct-type": "function",
        "title": "allStates"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "allStates",
        "normalized": "a[(String,String)]",
        "package": "Top",
        "partial": "States",
        "signature": "m[(String,String)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:collectStates",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "s -\u003e [(String, String)]",
        "fct-source": "src/Top-Implementation-General.html#collectStates",
        "fct-type": "method",
        "title": "collectStates"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "collectStates",
        "normalized": "a-\u003e[(String,String)]",
        "package": "Top",
        "partial": "States",
        "signature": "s-\u003e[(String,String)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:fromFstFixE",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "Embedding (g m) c -\u003e Embedding (Fix g x m) c",
        "fct-source": "src/Top-Implementation-General.html#fromFstFixE",
        "fct-type": "function",
        "title": "fromFstFixE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "fromFstFixE",
        "normalized": "Embedding(a b)c-\u003eEmbedding(Fix a d b)c",
        "package": "Top",
        "partial": "Fst Fix",
        "signature": "Embedding(g m)c-\u003eEmbedding(Fix g x m)c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:fromFstSimpleE",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "Embedding a c -\u003e Embedding (Simple a x m) c",
        "fct-source": "src/Top-Implementation-General.html#fromFstSimpleE",
        "fct-type": "function",
        "title": "fromFstSimpleE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "fromFstSimpleE",
        "normalized": "Embedding a b-\u003eEmbedding(Simple a c d)b",
        "package": "Top",
        "partial": "Fst Simple",
        "signature": "Embedding a c-\u003eEmbedding(Simple a x m)c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:fstSimpleE",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "Embedding (Simple a x m) a",
        "fct-source": "src/Top-Implementation-General.html#fstSimpleE",
        "fct-type": "function",
        "title": "fstSimpleE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "fstSimpleE",
        "normalized": "",
        "package": "Top",
        "partial": "Simple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:showState",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "s -\u003e String",
        "fct-source": "src/Top-Implementation-General.html#showState",
        "fct-type": "method",
        "title": "showState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "showState",
        "normalized": "a-\u003eString",
        "package": "Top",
        "partial": "State",
        "signature": "s-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:stateName",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "s -\u003e String",
        "fct-source": "src/Top-Implementation-General.html#stateName",
        "fct-type": "method",
        "title": "stateName"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "stateName",
        "normalized": "a-\u003eString",
        "package": "Top",
        "partial": "Name",
        "signature": "s-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:stateOptions",
      "description": {
        "fct-module": "Top.Implementation.General",
        "fct-package": "Top",
        "fct-signature": "s -\u003e [String]",
        "fct-source": "src/Top-Implementation-General.html#stateOptions",
        "fct-type": "method",
        "title": "stateOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation General",
        "module": "Top.Implementation.General",
        "name": "stateOptions",
        "normalized": "a-\u003e[String]",
        "package": "Top",
        "partial": "Options",
        "signature": "s-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-Overloading.html",
        "fct-type": "module",
        "title": "Overloading"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "Overloading",
        "normalized": "",
        "package": "Top",
        "partial": "Overloading",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#t:OverloadingState",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-Overloading.html#OverloadingState",
        "fct-type": "data",
        "title": "OverloadingState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "OverloadingState",
        "normalized": "",
        "package": "Top",
        "partial": "Overloading State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#t:PredicateMap",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-Overloading.html#PredicateMap",
        "fct-type": "data",
        "title": "PredicateMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "PredicateMap",
        "normalized": "",
        "package": "Top",
        "partial": "Predicate Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#t:TypeClassDirective",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
        "fct-type": "data",
        "title": "TypeClassDirective"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "TypeClassDirective",
        "normalized": "",
        "package": "Top",
        "partial": "Type Class Directive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#t:TypeClassDirectives",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Implementation-Overloading.html#TypeClassDirectives",
        "fct-type": "type",
        "title": "TypeClassDirectives"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "TypeClassDirectives",
        "normalized": "",
        "package": "Top",
        "partial": "Type Class Directives",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:CloseDirective",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "CloseDirective String info",
        "fct-source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
        "fct-type": "function",
        "title": "CloseDirective"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "CloseDirective",
        "normalized": "",
        "package": "Top",
        "partial": "Close Directive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:DefaultDirective",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "DefaultDirective String Tps info",
        "fct-source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
        "fct-type": "function",
        "title": "DefaultDirective"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "DefaultDirective",
        "normalized": "",
        "package": "Top",
        "partial": "Default Directive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:DisjointDirective",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "DisjointDirective [String] info",
        "fct-source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
        "fct-type": "function",
        "title": "DisjointDirective"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "DisjointDirective",
        "normalized": "DisjointDirective[String]a",
        "package": "Top",
        "partial": "Disjoint Directive",
        "signature": "DisjointDirective[String]info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:NeverDirective",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "NeverDirective Predicate info",
        "fct-source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
        "fct-type": "function",
        "title": "NeverDirective"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "NeverDirective",
        "normalized": "",
        "package": "Top",
        "partial": "Never Directive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:OverloadingState",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "OverloadingState",
        "fct-source": "src/Top-Implementation-Overloading.html#OverloadingState",
        "fct-type": "function",
        "title": "OverloadingState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "OverloadingState",
        "normalized": "",
        "package": "Top",
        "partial": "Overloading State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:PredicateMap",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "PredicateMap",
        "fct-source": "src/Top-Implementation-Overloading.html#PredicateMap",
        "fct-type": "function",
        "title": "PredicateMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "PredicateMap",
        "normalized": "",
        "package": "Top",
        "partial": "Predicate Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:ambiguous",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "[(Predicate, info)] -\u003e m ()",
        "fct-source": "src/Top-Implementation-Overloading.html#ambiguous",
        "fct-type": "function",
        "title": "ambiguous"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "ambiguous",
        "normalized": "[(Predicate,a)]-\u003eb()",
        "package": "Top",
        "partial": "",
        "signature": "[(Predicate,info)]-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:ambiguousLabel",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel",
        "fct-source": "src/Top-Implementation-Overloading.html#ambiguousLabel",
        "fct-type": "function",
        "title": "ambiguousLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "ambiguousLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:assumeQsSubst",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "Select (OverloadingState info) m [(Predicate, info)]",
        "fct-source": "src/Top-Implementation-Overloading.html#proveQsSubst",
        "fct-type": "function",
        "title": "assumeQsSubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "assumeQsSubst",
        "normalized": "Select(OverloadingState a)b[(Predicate,a)]",
        "package": "Top",
        "partial": "Qs Subst",
        "signature": "Select(OverloadingState info)m[(Predicate,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:classEnvironment",
      "description": {
        "fct-descr": "\u003cp\u003eAll known type classes and instances\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "ClassEnvironment",
        "fct-source": "src/Top-Implementation-Overloading.html#OverloadingState",
        "fct-type": "function",
        "title": "classEnvironment"
      },
      "index": {
        "description": "All known type classes and instances",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "classEnvironment",
        "normalized": "",
        "package": "Top",
        "partial": "Environment",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:disjointLabel",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel",
        "fct-source": "src/Top-Implementation-Overloading.html#disjointLabel",
        "fct-type": "function",
        "title": "disjointLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "disjointLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:generalizedQsSubst",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "Select (OverloadingState info) m [(Predicate, info)]",
        "fct-source": "src/Top-Implementation-Overloading.html#proveQsSubst",
        "fct-type": "function",
        "title": "generalizedQsSubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "generalizedQsSubst",
        "normalized": "Select(OverloadingState a)b[(Predicate,a)]",
        "package": "Top",
        "partial": "Qs Subst",
        "signature": "Select(OverloadingState info)m[(Predicate,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:globalAssumptions",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "[(Predicate, info)]",
        "fct-source": "src/Top-Implementation-Overloading.html#PredicateMap",
        "fct-type": "function",
        "title": "globalAssumptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "globalAssumptions",
        "normalized": "[(Predicate,a)]",
        "package": "Top",
        "partial": "Assumptions",
        "signature": "[(Predicate,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:globalGeneralizedQs",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "[(Predicate, info)]",
        "fct-source": "src/Top-Implementation-Overloading.html#PredicateMap",
        "fct-type": "function",
        "title": "globalGeneralizedQs"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "globalGeneralizedQs",
        "normalized": "[(Predicate,a)]",
        "package": "Top",
        "partial": "Generalized Qs",
        "signature": "[(Predicate,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:globalQualifiers",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "[(Predicate, info)]",
        "fct-source": "src/Top-Implementation-Overloading.html#PredicateMap",
        "fct-type": "function",
        "title": "globalQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "globalQualifiers",
        "normalized": "[(Predicate,a)]",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "[(Predicate,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:missingInSignatureLabel",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel",
        "fct-source": "src/Top-Implementation-Overloading.html#missingInSignatureLabel",
        "fct-type": "function",
        "title": "missingInSignatureLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "missingInSignatureLabel",
        "normalized": "",
        "package": "Top",
        "partial": "In Signature Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:modifyPredicateMap",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "(PredicateMap info -\u003e PredicateMap info) -\u003e m ()",
        "fct-source": "src/Top-Implementation-Overloading.html#modifyPredicateMap",
        "fct-type": "function",
        "title": "modifyPredicateMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "modifyPredicateMap",
        "normalized": "(PredicateMap a-\u003ePredicateMap a)-\u003eb()",
        "package": "Top",
        "partial": "Predicate Map",
        "signature": "(PredicateMap info-\u003ePredicateMap info)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:predicateMap",
      "description": {
        "fct-descr": "\u003cp\u003eType class assertions\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "PredicateMap info",
        "fct-source": "src/Top-Implementation-Overloading.html#OverloadingState",
        "fct-type": "function",
        "title": "predicateMap"
      },
      "index": {
        "description": "Type class assertions",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "predicateMap",
        "normalized": "",
        "package": "Top",
        "partial": "Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:proveQsSubst",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "Select (OverloadingState info) m [(Predicate, info)]",
        "fct-source": "src/Top-Implementation-Overloading.html#proveQsSubst",
        "fct-type": "function",
        "title": "proveQsSubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "proveQsSubst",
        "normalized": "Select(OverloadingState a)b[(Predicate,a)]",
        "package": "Top",
        "partial": "Qs Subst",
        "signature": "Select(OverloadingState info)m[(Predicate,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:simplify",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e TypeClassDirectives info -\u003e [(Predicate, info)] -\u003e m [(Predicate, info)]",
        "fct-source": "src/Top-Implementation-Overloading.html#simplify",
        "fct-type": "function",
        "title": "simplify"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "simplify",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003eTypeClassDirectives a-\u003e[(Predicate,a)]-\u003eb[(Predicate,a)]",
        "package": "Top",
        "partial": "",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003eTypeClassDirectives info-\u003e[(Predicate,info)]-\u003em[(Predicate,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:substPredicate",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "(Predicate, info) -\u003e m (Predicate, info)",
        "fct-source": "src/Top-Implementation-Overloading.html#substPredicate",
        "fct-type": "function",
        "title": "substPredicate"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "substPredicate",
        "normalized": "(Predicate,a)-\u003eb(Predicate,a)",
        "package": "Top",
        "partial": "Predicate",
        "signature": "(Predicate,info)-\u003em(Predicate,info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:typeClassDirectives",
      "description": {
        "fct-descr": "\u003cp\u003eDirectives for type class assertions\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "TypeClassDirectives info",
        "fct-source": "src/Top-Implementation-Overloading.html#OverloadingState",
        "fct-type": "function",
        "title": "typeClassDirectives"
      },
      "index": {
        "description": "Directives for type class assertions",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "typeClassDirectives",
        "normalized": "",
        "package": "Top",
        "partial": "Class Directives",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:unresolvedLabel",
      "description": {
        "fct-module": "Top.Implementation.Overloading",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel",
        "fct-source": "src/Top-Implementation-Overloading.html#unresolvedLabel",
        "fct-type": "function",
        "title": "unresolvedLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation Overloading",
        "module": "Top.Implementation.Overloading",
        "name": "unresolvedLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-SimpleSubstitution.html#",
      "description": {
        "fct-module": "Top.Implementation.SimpleSubstitution",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-SimpleSubstitution.html",
        "fct-type": "module",
        "title": "SimpleSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation SimpleSubstitution",
        "module": "Top.Implementation.SimpleSubstitution",
        "name": "SimpleSubstitution",
        "normalized": "",
        "package": "Top",
        "partial": "Simple Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-SimpleSubstitution.html#t:SimpleState",
      "description": {
        "fct-module": "Top.Implementation.SimpleSubstitution",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Implementation-SimpleSubstitution.html#SimpleState",
        "fct-type": "newtype",
        "title": "SimpleState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation SimpleSubstitution",
        "module": "Top.Implementation.SimpleSubstitution",
        "name": "SimpleState",
        "normalized": "",
        "package": "Top",
        "partial": "Simple State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-SimpleSubstitution.html#v:SimpleState",
      "description": {
        "fct-module": "Top.Implementation.SimpleSubstitution",
        "fct-package": "Top",
        "fct-signature": "SimpleState",
        "fct-source": "src/Top-Implementation-SimpleSubstitution.html#SimpleState",
        "fct-type": "function",
        "title": "SimpleState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation SimpleSubstitution",
        "module": "Top.Implementation.SimpleSubstitution",
        "name": "SimpleState",
        "normalized": "",
        "package": "Top",
        "partial": "Simple State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-SimpleSubstitution.html#v:unSS",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.SimpleSubstitution",
        "fct-package": "Top",
        "fct-signature": "MapSubstitution",
        "fct-source": "src/Top-Implementation-SimpleSubstitution.html#SimpleState",
        "fct-type": "function",
        "title": "unSS"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation SimpleSubstitution",
        "module": "Top.Implementation.SimpleSubstitution",
        "name": "unSS",
        "normalized": "",
        "package": "Top",
        "partial": "SS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ApplyHeuristics.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ApplyHeuristics",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-ApplyHeuristics.html",
        "fct-type": "module",
        "title": "ApplyHeuristics"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ApplyHeuristics",
        "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
        "name": "ApplyHeuristics",
        "normalized": "",
        "package": "Top",
        "partial": "Apply Heuristics",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ApplyHeuristics.html#v:applyHeuristics",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ApplyHeuristics",
        "fct-package": "Top",
        "fct-signature": "(Path (EdgeId, info) -\u003e [Heuristic info]) -\u003e m [ErrorInfo info]",
        "fct-source": "src/Top-Implementation-TypeGraph-ApplyHeuristics.html#applyHeuristics",
        "fct-type": "function",
        "title": "applyHeuristics"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ApplyHeuristics",
        "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
        "name": "applyHeuristics",
        "normalized": "(Path(EdgeId,a)-\u003e[Heuristic a])-\u003eb[ErrorInfo a]",
        "package": "Top",
        "partial": "Heuristics",
        "signature": "(Path(EdgeId,info)-\u003e[Heuristic info])-\u003em[ErrorInfo info]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ApplyHeuristics.html#v:expandPath",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ApplyHeuristics",
        "fct-package": "Top",
        "fct-signature": "TypeGraphPath info -\u003e m (Path (EdgeId, info))",
        "fct-source": "src/Top-Implementation-TypeGraph-ApplyHeuristics.html#expandPath",
        "fct-type": "function",
        "title": "expandPath"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ApplyHeuristics",
        "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
        "name": "expandPath",
        "normalized": "TypeGraphPath a-\u003eb(Path(EdgeId,a))",
        "package": "Top",
        "partial": "Path",
        "signature": "TypeGraphPath info-\u003em(Path(EdgeId,info))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ApplyHeuristics.html#v:predicatePath",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ApplyHeuristics",
        "fct-package": "Top",
        "fct-signature": "m (Path (EdgeId, PathStep info))",
        "fct-source": "src/Top-Implementation-TypeGraph-ApplyHeuristics.html#predicatePath",
        "fct-type": "function",
        "title": "predicatePath"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ApplyHeuristics",
        "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
        "name": "predicatePath",
        "normalized": "a(Path(EdgeId,PathStep b))",
        "package": "Top",
        "partial": "Path",
        "signature": "m(Path(EdgeId,PathStep info))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html",
        "fct-type": "module",
        "title": "Basics"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "Basics",
        "normalized": "",
        "package": "Top",
        "partial": "Basics",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:ChildSide",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#ChildSide",
        "fct-type": "data",
        "title": "ChildSide"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "ChildSide",
        "normalized": "",
        "package": "Top",
        "partial": "Child Side",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:Clique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#Clique",
        "fct-type": "newtype",
        "title": "Clique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "Clique",
        "normalized": "",
        "package": "Top",
        "partial": "Clique",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:CliqueList",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#CliqueList",
        "fct-type": "type",
        "title": "CliqueList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "CliqueList",
        "normalized": "",
        "package": "Top",
        "partial": "Clique List",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:EdgeId",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#EdgeId",
        "fct-type": "data",
        "title": "EdgeId"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "EdgeId",
        "normalized": "",
        "package": "Top",
        "partial": "Edge Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:EdgeNr",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#EdgeNr",
        "fct-type": "newtype",
        "title": "EdgeNr"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "EdgeNr",
        "normalized": "",
        "package": "Top",
        "partial": "Edge Nr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:ParentChild",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
        "fct-type": "data",
        "title": "ParentChild"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "ParentChild",
        "normalized": "",
        "package": "Top",
        "partial": "Parent Child",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:PathStep",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#PathStep",
        "fct-type": "data",
        "title": "PathStep"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "PathStep",
        "normalized": "",
        "package": "Top",
        "partial": "Path Step",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:TypeGraphPath",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#TypeGraphPath",
        "fct-type": "type",
        "title": "TypeGraphPath"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "TypeGraphPath",
        "normalized": "",
        "package": "Top",
        "partial": "Type Graph Path",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:VertexId",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#VertexId",
        "fct-type": "newtype",
        "title": "VertexId"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "VertexId",
        "normalized": "",
        "package": "Top",
        "partial": "Vertex Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:VertexInfo",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#VertexInfo",
        "fct-type": "type",
        "title": "VertexInfo"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "VertexInfo",
        "normalized": "",
        "package": "Top",
        "partial": "Vertex Info",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:VertexKind",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#VertexKind",
        "fct-type": "data",
        "title": "VertexKind"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "VertexKind",
        "normalized": "",
        "package": "Top",
        "partial": "Vertex Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:Child",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Child ChildSide",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#PathStep",
        "fct-type": "function",
        "title": "Child"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "Child",
        "normalized": "",
        "package": "Top",
        "partial": "Child",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:CliqueX",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "CliqueX [ParentChild]",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#Clique",
        "fct-type": "function",
        "title": "CliqueX"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "CliqueX",
        "normalized": "CliqueX[ParentChild]",
        "package": "Top",
        "partial": "Clique",
        "signature": "CliqueX[ParentChild]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:EdgeId",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "EdgeId VertexId VertexId EdgeNr",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#EdgeId",
        "fct-type": "function",
        "title": "EdgeId"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "EdgeId",
        "normalized": "",
        "package": "Top",
        "partial": "Edge Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:EdgeNrX",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "EdgeNrX Int",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#EdgeNr",
        "fct-type": "function",
        "title": "EdgeNrX"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "EdgeNrX",
        "normalized": "",
        "package": "Top",
        "partial": "Edge Nr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:Implied",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Implied ChildSide VertexId VertexId",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#PathStep",
        "fct-type": "function",
        "title": "Implied"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "Implied",
        "normalized": "",
        "package": "Top",
        "partial": "Implied",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:Initial",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Initial info",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#PathStep",
        "fct-type": "function",
        "title": "Initial"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "Initial",
        "normalized": "",
        "package": "Top",
        "partial": "Initial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:LeftChild",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "LeftChild",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#ChildSide",
        "fct-type": "function",
        "title": "LeftChild"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "LeftChild",
        "normalized": "",
        "package": "Top",
        "partial": "Left Child",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:ParentChild",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "ParentChild",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
        "fct-type": "function",
        "title": "ParentChild"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "ParentChild",
        "normalized": "",
        "package": "Top",
        "partial": "Parent Child",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:RightChild",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "RightChild",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#ChildSide",
        "fct-type": "function",
        "title": "RightChild"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "RightChild",
        "normalized": "",
        "package": "Top",
        "partial": "Right Child",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:VApp",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "VApp VertexId VertexId",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#VertexKind",
        "fct-type": "function",
        "title": "VApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "VApp",
        "normalized": "",
        "package": "Top",
        "partial": "VApp",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:VCon",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "VCon String",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#VertexKind",
        "fct-type": "function",
        "title": "VCon"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "VCon",
        "normalized": "",
        "package": "Top",
        "partial": "VCon",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:VVar",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "VVar",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#VertexKind",
        "fct-type": "function",
        "title": "VVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "VVar",
        "normalized": "",
        "package": "Top",
        "partial": "VVar",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:VertexId",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "VertexId Int",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#VertexId",
        "fct-type": "function",
        "title": "VertexId"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "VertexId",
        "normalized": "",
        "package": "Top",
        "partial": "Vertex Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:child",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "VertexId",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
        "fct-type": "function",
        "title": "child"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "child",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:childSide",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "ChildSide",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
        "fct-type": "function",
        "title": "childSide"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "childSide",
        "normalized": "",
        "package": "Top",
        "partial": "Side",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:childrenInClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e [VertexId]",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#childrenInClique",
        "fct-type": "function",
        "title": "childrenInClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "childrenInClique",
        "normalized": "Clique-\u003e[VertexId]",
        "package": "Top",
        "partial": "In Clique",
        "signature": "Clique-\u003e[VertexId]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:cliqueRepresentative",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e VertexId",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#cliqueRepresentative",
        "fct-type": "function",
        "title": "cliqueRepresentative"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "cliqueRepresentative",
        "normalized": "Clique-\u003eVertexId",
        "package": "Top",
        "partial": "Representative",
        "signature": "Clique-\u003eVertexId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:combineCliqueList",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "CliqueList -\u003e CliqueList -\u003e CliqueList",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#combineCliqueList",
        "fct-type": "function",
        "title": "combineCliqueList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "combineCliqueList",
        "normalized": "CliqueList-\u003eCliqueList-\u003eCliqueList",
        "package": "Top",
        "partial": "Clique List",
        "signature": "CliqueList-\u003eCliqueList-\u003eCliqueList"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:impliedEdgeNr",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "EdgeNr",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#impliedEdgeNr",
        "fct-type": "function",
        "title": "impliedEdgeNr"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "impliedEdgeNr",
        "normalized": "",
        "package": "Top",
        "partial": "Edge Nr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:isDisjointClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e Clique -\u003e Bool",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#isDisjointClique",
        "fct-type": "function",
        "title": "isDisjointClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "isDisjointClique",
        "normalized": "Clique-\u003eClique-\u003eBool",
        "package": "Top",
        "partial": "Disjoint Clique",
        "signature": "Clique-\u003eClique-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:isSubsetClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e Clique -\u003e Bool",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#isSubsetClique",
        "fct-type": "function",
        "title": "isSubsetClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "isSubsetClique",
        "normalized": "Clique-\u003eClique-\u003eBool",
        "package": "Top",
        "partial": "Subset Clique",
        "signature": "Clique-\u003eClique-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:makeClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "[ParentChild] -\u003e Clique",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#makeClique",
        "fct-type": "function",
        "title": "makeClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "makeClique",
        "normalized": "[ParentChild]-\u003eClique",
        "package": "Top",
        "partial": "Clique",
        "signature": "[ParentChild]-\u003eClique"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:makeEdgeNr",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e EdgeNr",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#makeEdgeNr",
        "fct-type": "function",
        "title": "makeEdgeNr"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "makeEdgeNr",
        "normalized": "Int-\u003eEdgeNr",
        "package": "Top",
        "partial": "Edge Nr",
        "signature": "Int-\u003eEdgeNr"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:mergeCliques",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "CliqueList -\u003e Clique",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#mergeCliques",
        "fct-type": "function",
        "title": "mergeCliques"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "mergeCliques",
        "normalized": "CliqueList-\u003eClique",
        "package": "Top",
        "partial": "Cliques",
        "signature": "CliqueList-\u003eClique"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:parent",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "VertexId",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
        "fct-type": "function",
        "title": "parent"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "parent",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:triplesInClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e [ParentChild]",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#triplesInClique",
        "fct-type": "function",
        "title": "triplesInClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "triplesInClique",
        "normalized": "Clique-\u003e[ParentChild]",
        "package": "Top",
        "partial": "In Clique",
        "signature": "Clique-\u003e[ParentChild]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:vertexIdToTp",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Basics",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-Basics.html#vertexIdToTp",
        "fct-type": "function",
        "title": "vertexIdToTp"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Basics",
        "module": "Top.Implementation.TypeGraph.Basics",
        "name": "vertexIdToTp",
        "normalized": "VertexId-\u003eTp",
        "package": "Top",
        "partial": "Id To Tp",
        "signature": "VertexId-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html",
        "fct-type": "module",
        "title": "Class"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "Class",
        "normalized": "",
        "package": "Top",
        "partial": "Class",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#t:TypeGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#TypeGraph",
        "fct-type": "class",
        "title": "TypeGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "TypeGraph",
        "normalized": "",
        "package": "Top",
        "partial": "Type Graph",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:addEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "EdgeId -\u003e info -\u003e graph -\u003e graph",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#addEdge",
        "fct-type": "method",
        "title": "addEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "addEdge",
        "normalized": "EdgeId-\u003ea-\u003eb-\u003eb",
        "package": "Top",
        "partial": "Edge",
        "signature": "EdgeId-\u003einfo-\u003egraph-\u003egraph"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:addNewEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "(VertexId, VertexId) -\u003e info -\u003e graph -\u003e graph",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#addNewEdge",
        "fct-type": "method",
        "title": "addNewEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "addNewEdge",
        "normalized": "(VertexId,VertexId)-\u003ea-\u003eb-\u003eb",
        "package": "Top",
        "partial": "New Edge",
        "signature": "(VertexId,VertexId)-\u003einfo-\u003egraph-\u003egraph"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:addTermGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Int -\u003e Tp -\u003e graph -\u003e (Int, VertexId, graph)",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#addTermGraph",
        "fct-type": "method",
        "title": "addTermGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "addTermGraph",
        "normalized": "OrderedTypeSynonyms-\u003eInt-\u003eTp-\u003ea-\u003e(Int,VertexId,a)",
        "package": "Top",
        "partial": "Term Graph",
        "signature": "OrderedTypeSynonyms-\u003eInt-\u003eTp-\u003egraph-\u003e(Int,VertexId,graph)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:addVertex",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e VertexInfo -\u003e graph -\u003e graph",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#addVertex",
        "fct-type": "method",
        "title": "addVertex"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "addVertex",
        "normalized": "VertexId-\u003eVertexInfo-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Vertex",
        "signature": "VertexId-\u003eVertexInfo-\u003egraph-\u003egraph"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:allPaths",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e VertexId -\u003e graph -\u003e TypeGraphPath info",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#allPaths",
        "fct-type": "method",
        "title": "allPaths"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "allPaths",
        "normalized": "VertexId-\u003eVertexId-\u003ea-\u003eTypeGraphPath b",
        "package": "Top",
        "partial": "Paths",
        "signature": "VertexId-\u003eVertexId-\u003egraph-\u003eTypeGraphPath info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:allPathsList",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e [VertexId] -\u003e graph -\u003e TypeGraphPath info",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#allPathsList",
        "fct-type": "method",
        "title": "allPathsList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "allPathsList",
        "normalized": "VertexId-\u003e[VertexId]-\u003ea-\u003eTypeGraphPath b",
        "package": "Top",
        "partial": "Paths List",
        "signature": "VertexId-\u003e[VertexId]-\u003egraph-\u003eTypeGraphPath info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:allPathsListWithout",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "Set VertexId -\u003e VertexId -\u003e [VertexId] -\u003e graph -\u003e TypeGraphPath info",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#allPathsListWithout",
        "fct-type": "method",
        "title": "allPathsListWithout"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "allPathsListWithout",
        "normalized": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003ea-\u003eTypeGraphPath b",
        "package": "Top",
        "partial": "Paths List Without",
        "signature": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003egraph-\u003eTypeGraphPath info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:childrenInGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e graph -\u003e ([ParentChild], [ParentChild])",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#childrenInGroupOf",
        "fct-type": "method",
        "title": "childrenInGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "childrenInGroupOf",
        "normalized": "VertexId-\u003ea-\u003e([ParentChild],[ParentChild])",
        "package": "Top",
        "partial": "In Group Of",
        "signature": "VertexId-\u003egraph-\u003e([ParentChild],[ParentChild])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:constantsInGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e graph -\u003e [String]",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#constantsInGroupOf",
        "fct-type": "method",
        "title": "constantsInGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "constantsInGroupOf",
        "normalized": "VertexId-\u003ea-\u003e[String]",
        "package": "Top",
        "partial": "In Group Of",
        "signature": "VertexId-\u003egraph-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:deleteEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "EdgeId -\u003e graph -\u003e graph",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#deleteEdge",
        "fct-type": "method",
        "title": "deleteEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "deleteEdge",
        "normalized": "EdgeId-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Edge",
        "signature": "EdgeId-\u003egraph-\u003egraph"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:edgesFrom",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e graph -\u003e [(EdgeId, info)]",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#edgesFrom",
        "fct-type": "method",
        "title": "edgesFrom"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "edgesFrom",
        "normalized": "VertexId-\u003ea-\u003e[(EdgeId,b)]",
        "package": "Top",
        "partial": "From",
        "signature": "VertexId-\u003egraph-\u003e[(EdgeId,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:getMarkedPossibleErrors",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "graph -\u003e [VertexId]",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#getMarkedPossibleErrors",
        "fct-type": "method",
        "title": "getMarkedPossibleErrors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "getMarkedPossibleErrors",
        "normalized": "a-\u003e[VertexId]",
        "package": "Top",
        "partial": "Marked Possible Errors",
        "signature": "graph-\u003e[VertexId]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:makeSubstitution",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e graph -\u003e [(VertexId, Tp)]",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#makeSubstitution",
        "fct-type": "method",
        "title": "makeSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "makeSubstitution",
        "normalized": "OrderedTypeSynonyms-\u003ea-\u003e[(VertexId,Tp)]",
        "package": "Top",
        "partial": "Substitution",
        "signature": "OrderedTypeSynonyms-\u003egraph-\u003e[(VertexId,Tp)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:markAsPossibleError",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e graph -\u003e graph",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#markAsPossibleError",
        "fct-type": "method",
        "title": "markAsPossibleError"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "markAsPossibleError",
        "normalized": "VertexId-\u003ea-\u003ea",
        "package": "Top",
        "partial": "As Possible Error",
        "signature": "VertexId-\u003egraph-\u003egraph"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:representativeInGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e graph -\u003e VertexId",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#representativeInGroupOf",
        "fct-type": "method",
        "title": "representativeInGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "representativeInGroupOf",
        "normalized": "VertexId-\u003ea-\u003eVertexId",
        "package": "Top",
        "partial": "In Group Of",
        "signature": "VertexId-\u003egraph-\u003eVertexId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:substituteType",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Tp -\u003e graph -\u003e Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#substituteType",
        "fct-type": "method",
        "title": "substituteType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "substituteType",
        "normalized": "OrderedTypeSynonyms-\u003eTp-\u003ea-\u003eTp",
        "package": "Top",
        "partial": "Type",
        "signature": "OrderedTypeSynonyms-\u003eTp-\u003egraph-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:substituteTypeSafe",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Tp -\u003e graph -\u003e Maybe Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#substituteTypeSafe",
        "fct-type": "method",
        "title": "substituteTypeSafe"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "substituteTypeSafe",
        "normalized": "OrderedTypeSynonyms-\u003eTp-\u003ea-\u003eMaybe Tp",
        "package": "Top",
        "partial": "Type Safe",
        "signature": "OrderedTypeSynonyms-\u003eTp-\u003egraph-\u003eMaybe Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:substituteVariable",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Int -\u003e graph -\u003e Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#substituteVariable",
        "fct-type": "method",
        "title": "substituteVariable"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "substituteVariable",
        "normalized": "OrderedTypeSynonyms-\u003eInt-\u003ea-\u003eTp",
        "package": "Top",
        "partial": "Variable",
        "signature": "OrderedTypeSynonyms-\u003eInt-\u003egraph-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:typeFromTermGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e graph -\u003e Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#typeFromTermGraph",
        "fct-type": "method",
        "title": "typeFromTermGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "typeFromTermGraph",
        "normalized": "VertexId-\u003ea-\u003eTp",
        "package": "Top",
        "partial": "From Term Graph",
        "signature": "VertexId-\u003egraph-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:unmarkPossibleErrors",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "graph -\u003e graph",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#unmarkPossibleErrors",
        "fct-type": "method",
        "title": "unmarkPossibleErrors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "unmarkPossibleErrors",
        "normalized": "a-\u003ea",
        "package": "Top",
        "partial": "Possible Errors",
        "signature": "graph-\u003egraph"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:verticesInGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Class",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e graph -\u003e [(VertexId, VertexInfo)]",
        "fct-source": "src/Top-Implementation-TypeGraph-Class.html#verticesInGroupOf",
        "fct-type": "method",
        "title": "verticesInGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Class",
        "module": "Top.Implementation.TypeGraph.Class",
        "name": "verticesInGroupOf",
        "normalized": "VertexId-\u003ea-\u003e[(VertexId,VertexInfo)]",
        "package": "Top",
        "partial": "In Group Of",
        "signature": "VertexId-\u003egraph-\u003e[(VertexId,VertexInfo)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html",
        "fct-type": "module",
        "title": "ClassMonadic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "ClassMonadic",
        "normalized": "",
        "package": "Top",
        "partial": "Class Monadic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#t:HasTG",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#HasTG",
        "fct-type": "class",
        "title": "HasTG"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "HasTG",
        "normalized": "",
        "package": "Top",
        "partial": "Has TG",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#t:HasTypeGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#HasTypeGraph",
        "fct-type": "class",
        "title": "HasTypeGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "HasTypeGraph",
        "normalized": "",
        "package": "Top",
        "partial": "Has Type Graph",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:addEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "EdgeId -\u003e info -\u003e m ()",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#addEdge",
        "fct-type": "function",
        "title": "addEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "addEdge",
        "normalized": "EdgeId-\u003ea-\u003eb()",
        "package": "Top",
        "partial": "Edge",
        "signature": "EdgeId-\u003einfo-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:addNewEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "(VertexId, VertexId) -\u003e info -\u003e m ()",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#addNewEdge",
        "fct-type": "function",
        "title": "addNewEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "addNewEdge",
        "normalized": "(VertexId,VertexId)-\u003ea-\u003eb()",
        "package": "Top",
        "partial": "New Edge",
        "signature": "(VertexId,VertexId)-\u003einfo-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:addTermGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e m VertexId",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#addTermGraph",
        "fct-type": "function",
        "title": "addTermGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "addTermGraph",
        "normalized": "Tp-\u003ea VertexId",
        "package": "Top",
        "partial": "Term Graph",
        "signature": "Tp-\u003em VertexId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:addVertex",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e VertexInfo -\u003e m ()",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#addVertex",
        "fct-type": "function",
        "title": "addVertex"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "addVertex",
        "normalized": "VertexId-\u003eVertexInfo-\u003ea()",
        "package": "Top",
        "partial": "Vertex",
        "signature": "VertexId-\u003eVertexInfo-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:allPaths",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e VertexId -\u003e m (TypeGraphPath info)",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#allPaths",
        "fct-type": "function",
        "title": "allPaths"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "allPaths",
        "normalized": "VertexId-\u003eVertexId-\u003ea(TypeGraphPath b)",
        "package": "Top",
        "partial": "Paths",
        "signature": "VertexId-\u003eVertexId-\u003em(TypeGraphPath info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:allPathsList",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e [VertexId] -\u003e m (TypeGraphPath info)",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#allPathsList",
        "fct-type": "function",
        "title": "allPathsList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "allPathsList",
        "normalized": "VertexId-\u003e[VertexId]-\u003ea(TypeGraphPath b)",
        "package": "Top",
        "partial": "Paths List",
        "signature": "VertexId-\u003e[VertexId]-\u003em(TypeGraphPath info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:allPathsListWithout",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "Set VertexId -\u003e VertexId -\u003e [VertexId] -\u003e m (TypeGraphPath info)",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#allPathsListWithout",
        "fct-type": "function",
        "title": "allPathsListWithout"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "allPathsListWithout",
        "normalized": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003ea(TypeGraphPath b)",
        "package": "Top",
        "partial": "Paths List Without",
        "signature": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003em(TypeGraphPath info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:changeTypeGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "graph -\u003e graph) -\u003e m ()",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#changeTypeGraph",
        "fct-type": "function",
        "title": "changeTypeGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "changeTypeGraph",
        "normalized": "a-\u003ea)-\u003eb()",
        "package": "Top",
        "partial": "Type Graph",
        "signature": "graph-\u003egraph)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:childrenInGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e m ([ParentChild], [ParentChild])",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#childrenInGroupOf",
        "fct-type": "function",
        "title": "childrenInGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "childrenInGroupOf",
        "normalized": "VertexId-\u003ea([ParentChild],[ParentChild])",
        "package": "Top",
        "partial": "In Group Of",
        "signature": "VertexId-\u003em([ParentChild],[ParentChild])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:constantsInGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e m [String]",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#constantsInGroupOf",
        "fct-type": "function",
        "title": "constantsInGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "constantsInGroupOf",
        "normalized": "VertexId-\u003ea[String]",
        "package": "Top",
        "partial": "In Group Of",
        "signature": "VertexId-\u003em[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:deleteEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "EdgeId -\u003e m ()",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#deleteEdge",
        "fct-type": "function",
        "title": "deleteEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "deleteEdge",
        "normalized": "EdgeId-\u003ea()",
        "package": "Top",
        "partial": "Edge",
        "signature": "EdgeId-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:edgesFrom",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e m [(EdgeId, info)]",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#edgesFrom",
        "fct-type": "function",
        "title": "edgesFrom"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "edgesFrom",
        "normalized": "VertexId-\u003ea[(EdgeId,b)]",
        "package": "Top",
        "partial": "From",
        "signature": "VertexId-\u003em[(EdgeId,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:getMarkedPossibleErrors",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "m [VertexId]",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#getMarkedPossibleErrors",
        "fct-type": "function",
        "title": "getMarkedPossibleErrors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "getMarkedPossibleErrors",
        "normalized": "a[VertexId]",
        "package": "Top",
        "partial": "Marked Possible Errors",
        "signature": "m[VertexId]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:makeFixpointSubst",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "m FixpointSubstitution",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#makeFixpointSubst",
        "fct-type": "function",
        "title": "makeFixpointSubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "makeFixpointSubst",
        "normalized": "",
        "package": "Top",
        "partial": "Fixpoint Subst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:makeSubstitution",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "m [(VertexId, Tp)]",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#makeSubstitution",
        "fct-type": "function",
        "title": "makeSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "makeSubstitution",
        "normalized": "a[(VertexId,Tp)]",
        "package": "Top",
        "partial": "Substitution",
        "signature": "m[(VertexId,Tp)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:markAsPossibleError",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e m ()",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#markAsPossibleError",
        "fct-type": "function",
        "title": "markAsPossibleError"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "markAsPossibleError",
        "normalized": "VertexId-\u003ea()",
        "package": "Top",
        "partial": "As Possible Error",
        "signature": "VertexId-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:representativeInGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e m VertexId",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#representativeInGroupOf",
        "fct-type": "function",
        "title": "representativeInGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "representativeInGroupOf",
        "normalized": "VertexId-\u003ea VertexId",
        "package": "Top",
        "partial": "In Group Of",
        "signature": "VertexId-\u003em VertexId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:substituteType",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e m Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#substituteType",
        "fct-type": "function",
        "title": "substituteType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "substituteType",
        "normalized": "Tp-\u003ea Tp",
        "package": "Top",
        "partial": "Type",
        "signature": "Tp-\u003em Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:substituteTypeSafe",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e m (Maybe Tp)",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#substituteTypeSafe",
        "fct-type": "function",
        "title": "substituteTypeSafe"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "substituteTypeSafe",
        "normalized": "Tp-\u003ea(Maybe Tp)",
        "package": "Top",
        "partial": "Type Safe",
        "signature": "Tp-\u003em(Maybe Tp)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:substituteVariable",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e m Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#substituteVariable",
        "fct-type": "function",
        "title": "substituteVariable"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "substituteVariable",
        "normalized": "Int-\u003ea Tp",
        "package": "Top",
        "partial": "Variable",
        "signature": "Int-\u003em Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:theUnifyTerms",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "info -\u003e Tp -\u003e Tp -\u003e m ()",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#theUnifyTerms",
        "fct-type": "function",
        "title": "theUnifyTerms"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "theUnifyTerms",
        "normalized": "a-\u003eTp-\u003eTp-\u003eb()",
        "package": "Top",
        "partial": "Unify Terms",
        "signature": "info-\u003eTp-\u003eTp-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:typeFromTermGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e m Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#typeFromTermGraph",
        "fct-type": "function",
        "title": "typeFromTermGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "typeFromTermGraph",
        "normalized": "VertexId-\u003ea Tp",
        "package": "Top",
        "partial": "From Term Graph",
        "signature": "VertexId-\u003em Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:unmarkPossibleErrors",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#unmarkPossibleErrors",
        "fct-type": "function",
        "title": "unmarkPossibleErrors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "unmarkPossibleErrors",
        "normalized": "a()",
        "package": "Top",
        "partial": "Possible Errors",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:useTypeGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "graph -\u003e a) -\u003e m a",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#useTypeGraph",
        "fct-type": "function",
        "title": "useTypeGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "useTypeGraph",
        "normalized": "a-\u003eb)-\u003ec b",
        "package": "Top",
        "partial": "Type Graph",
        "signature": "graph-\u003ea)-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:verticesInGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e m [(VertexId, VertexInfo)]",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#verticesInGroupOf",
        "fct-type": "function",
        "title": "verticesInGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "verticesInGroupOf",
        "normalized": "VertexId-\u003ea[(VertexId,VertexInfo)]",
        "package": "Top",
        "partial": "In Group Of",
        "signature": "VertexId-\u003em[(VertexId,VertexInfo)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:withTypeGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.ClassMonadic",
        "fct-package": "Top",
        "fct-signature": "graph -\u003e (a, graph)) -\u003e m a",
        "fct-source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#withTypeGraph",
        "fct-type": "method",
        "title": "withTypeGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph ClassMonadic",
        "module": "Top.Implementation.TypeGraph.ClassMonadic",
        "name": "withTypeGraph",
        "normalized": "a-\u003e(b,a))-\u003ec b",
        "package": "Top",
        "partial": "Type Graph",
        "signature": "graph-\u003e(a,graph))-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html",
        "fct-type": "module",
        "title": "DefaultHeuristics"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
        "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "name": "DefaultHeuristics",
        "normalized": "",
        "package": "Top",
        "partial": "Default Heuristics",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:defaultHeuristics",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "fct-package": "Top",
        "fct-signature": "Path (EdgeId, info) -\u003e [Heuristic info]",
        "fct-source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#defaultHeuristics",
        "fct-type": "function",
        "title": "defaultHeuristics"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
        "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "name": "defaultHeuristics",
        "normalized": "Path(EdgeId,a)-\u003e[Heuristic a]",
        "package": "Top",
        "partial": "Heuristics",
        "signature": "Path(EdgeId,info)-\u003e[Heuristic info]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:firstComeFirstBlamed",
      "description": {
        "fct-descr": "\u003cp\u003eSelect the \u003ca\u003elatest\u003c/a\u003e constraint\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "fct-package": "Top",
        "fct-signature": "Heuristic info",
        "fct-source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#firstComeFirstBlamed",
        "fct-type": "function",
        "title": "firstComeFirstBlamed"
      },
      "index": {
        "description": "Select the latest constraint",
        "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
        "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "name": "firstComeFirstBlamed",
        "normalized": "",
        "package": "Top",
        "partial": "Come First Blamed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:highParticipation",
      "description": {
        "fct-descr": "\u003cp\u003eAlthough not as precise as the minimal set analysis, this calculates the participation of\n each edge in all error paths. \n Default ratio = 1.0  (100 percent)\n   (the ratio determines which scores compared to the best are accepted)\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "fct-package": "Top",
        "fct-signature": "Double -\u003e Path (EdgeId, info) -\u003e Heuristic info",
        "fct-source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#highParticipation",
        "fct-type": "function",
        "title": "highParticipation"
      },
      "index": {
        "description": "Although not as precise as the minimal set analysis this calculates the participation of each edge in all error paths Default ratio percent the ratio determines which scores compared to the best are accepted",
        "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
        "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "name": "highParticipation",
        "normalized": "Double-\u003ePath(EdgeId,a)-\u003eHeuristic a",
        "package": "Top",
        "partial": "Participation",
        "signature": "Double-\u003ePath(EdgeId,info)-\u003eHeuristic info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:inMininalSet",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the smallest \u003ccode\u003eminimal\u003c/code\u003e sets. This computation is very(!) costly\n   (might take a long time for complex inconsistencies)\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "fct-package": "Top",
        "fct-signature": "Path (EdgeId, info) -\u003e Heuristic info",
        "fct-source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#inMininalSet",
        "fct-type": "function",
        "title": "inMininalSet"
      },
      "index": {
        "description": "Compute the smallest minimal sets This computation is very costly might take long time for complex inconsistencies",
        "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
        "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "name": "inMininalSet",
        "normalized": "Path(EdgeId,a)-\u003eHeuristic a",
        "package": "Top",
        "partial": "Mininal Set",
        "signature": "Path(EdgeId,info)-\u003eHeuristic info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:inPredicatePath",
      "description": {
        "fct-descr": "\u003cp\u003eSelect only the constraints for which there is evidence in the predicates\n of the current state that the constraint at hand is incorrect. \n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "fct-package": "Top",
        "fct-signature": "Heuristic info",
        "fct-source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#inPredicatePath",
        "fct-type": "function",
        "title": "inPredicatePath"
      },
      "index": {
        "description": "Select only the constraints for which there is evidence in the predicates of the current state that the constraint at hand is incorrect",
        "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
        "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "name": "inPredicatePath",
        "normalized": "",
        "package": "Top",
        "partial": "Predicate Path",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:selectConstraintNumbers",
      "description": {
        "fct-descr": "\u003cp\u003eSelect only specific constraint numbers\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "fct-package": "Top",
        "fct-signature": "[EdgeNr] -\u003e Heuristic info",
        "fct-source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#selectConstraintNumbers",
        "fct-type": "function",
        "title": "selectConstraintNumbers"
      },
      "index": {
        "description": "Select only specific constraint numbers",
        "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
        "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
        "name": "selectConstraintNumbers",
        "normalized": "[EdgeNr]-\u003eHeuristic a",
        "package": "Top",
        "partial": "Constraint Numbers",
        "signature": "[EdgeNr]-\u003eHeuristic info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn equivalence group is a graph-like structure containing type variables and \n type constants that should all be equivalent. The edges explain why they should\n be equal.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html",
        "fct-type": "module",
        "title": "EquivalenceGroup"
      },
      "index": {
        "description": "An equivalence group is graph-like structure containing type variables and type constants that should all be equivalent The edges explain why they should be equal",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "EquivalenceGroup",
        "normalized": "",
        "package": "Top",
        "partial": "Equivalence Group",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#t:EquivalenceGroup",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#EquivalenceGroup",
        "fct-type": "data",
        "title": "EquivalenceGroup"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "EquivalenceGroup",
        "normalized": "",
        "package": "Top",
        "partial": "Equivalence Group",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:checkGroup",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#checkGroup",
        "fct-type": "function",
        "title": "checkGroup"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "checkGroup",
        "normalized": "EquivalenceGroup a-\u003eEquivalenceGroup a",
        "package": "Top",
        "partial": "Group",
        "signature": "EquivalenceGroup info-\u003eEquivalenceGroup info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:combineGroups",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#combineGroups",
        "fct-type": "function",
        "title": "combineGroups"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "combineGroups",
        "normalized": "EquivalenceGroup a-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
        "package": "Top",
        "partial": "Groups",
        "signature": "EquivalenceGroup info-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:consistent",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e Bool",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#consistent",
        "fct-type": "function",
        "title": "consistent"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "consistent",
        "normalized": "EquivalenceGroup a-\u003eBool",
        "package": "Top",
        "partial": "",
        "signature": "EquivalenceGroup info-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:constants",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e [String]",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#constants",
        "fct-type": "function",
        "title": "constants"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "constants",
        "normalized": "EquivalenceGroup a-\u003e[String]",
        "package": "Top",
        "partial": "",
        "signature": "EquivalenceGroup info-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:edges",
      "description": {
        "fct-descr": "\u003cp\u003e(initial) edges in this equivalence group\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e [(EdgeId, info)]",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#edges",
        "fct-type": "function",
        "title": "edges"
      },
      "index": {
        "description": "initial edges in this equivalence group",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "edges",
        "normalized": "EquivalenceGroup a-\u003e[(EdgeId,a)]",
        "package": "Top",
        "partial": "",
        "signature": "EquivalenceGroup info-\u003e[(EdgeId,info)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:emptyGroup",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#emptyGroup",
        "fct-type": "function",
        "title": "emptyGroup"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "emptyGroup",
        "normalized": "",
        "package": "Top",
        "partial": "Group",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:equalPaths",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "Set VertexId -\u003e VertexId -\u003e [VertexId] -\u003e EquivalenceGroup info -\u003e TypeGraphPath info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#equalPaths",
        "fct-type": "function",
        "title": "equalPaths"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "equalPaths",
        "normalized": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003eEquivalenceGroup a-\u003eTypeGraphPath a",
        "package": "Top",
        "partial": "Paths",
        "signature": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003eEquivalenceGroup info-\u003eTypeGraphPath info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:insertClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#insertClique",
        "fct-type": "function",
        "title": "insertClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "insertClique",
        "normalized": "Clique-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
        "package": "Top",
        "partial": "Clique",
        "signature": "Clique-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:insertEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EdgeId -\u003e info -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#insertEdge",
        "fct-type": "function",
        "title": "insertEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "insertEdge",
        "normalized": "EdgeId-\u003ea-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
        "package": "Top",
        "partial": "Edge",
        "signature": "EdgeId-\u003einfo-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:insertVertex",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e VertexInfo -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#insertVertex",
        "fct-type": "function",
        "title": "insertVertex"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "insertVertex",
        "normalized": "VertexId-\u003eVertexInfo-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
        "package": "Top",
        "partial": "Vertex",
        "signature": "VertexId-\u003eVertexInfo-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:removeClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#removeClique",
        "fct-type": "function",
        "title": "removeClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "removeClique",
        "normalized": "Clique-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
        "package": "Top",
        "partial": "Clique",
        "signature": "Clique-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:removeEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EdgeId -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#removeEdge",
        "fct-type": "function",
        "title": "removeEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "removeEdge",
        "normalized": "EdgeId-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
        "package": "Top",
        "partial": "Edge",
        "signature": "EdgeId-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:splitGroup",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e [EquivalenceGroup info]",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#splitGroup",
        "fct-type": "function",
        "title": "splitGroup"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "splitGroup",
        "normalized": "EquivalenceGroup a-\u003e[EquivalenceGroup a]",
        "package": "Top",
        "partial": "Group",
        "signature": "EquivalenceGroup info-\u003e[EquivalenceGroup info]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:typeOfGroup",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e EquivalenceGroup info -\u003e Maybe Tp",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#typeOfGroup",
        "fct-type": "function",
        "title": "typeOfGroup"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "typeOfGroup",
        "normalized": "OrderedTypeSynonyms-\u003eEquivalenceGroup a-\u003eMaybe Tp",
        "package": "Top",
        "partial": "Of Group",
        "signature": "OrderedTypeSynonyms-\u003eEquivalenceGroup info-\u003eMaybe Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:vertices",
      "description": {
        "fct-descr": "\u003cp\u003evertices in this equivalence group\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e [(VertexId, VertexInfo)]",
        "fct-source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#vertices",
        "fct-type": "function",
        "title": "vertices"
      },
      "index": {
        "description": "vertices in this equivalence group",
        "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
        "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
        "name": "vertices",
        "normalized": "EquivalenceGroup a-\u003e[(VertexId,VertexInfo)]",
        "package": "Top",
        "partial": "",
        "signature": "EquivalenceGroup info-\u003e[(VertexId,VertexInfo)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html",
        "fct-type": "module",
        "title": "Heuristic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "Heuristic",
        "normalized": "",
        "package": "Top",
        "partial": "Heuristic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:HComponent",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#HComponent",
        "fct-type": "data",
        "title": "HComponent"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "HComponent",
        "normalized": "",
        "package": "Top",
        "partial": "HComponent",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:HasTwoTypes",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#HasTwoTypes",
        "fct-type": "class",
        "title": "HasTwoTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "HasTwoTypes",
        "normalized": "",
        "package": "Top",
        "partial": "Has Two Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:Heuristic",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#Heuristic",
        "fct-type": "newtype",
        "title": "Heuristic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "Heuristic",
        "normalized": "",
        "package": "Top",
        "partial": "Heuristic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:PathHeuristics",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#PathHeuristics",
        "fct-type": "type",
        "title": "PathHeuristics"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "PathHeuristics",
        "normalized": "",
        "package": "Top",
        "partial": "Path Heuristics",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:Selector",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#Selector",
        "fct-type": "data",
        "title": "Selector"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "Selector",
        "normalized": "",
        "package": "Top",
        "partial": "Selector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:Filter",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "Filter String ([(EdgeId, info)] -\u003e m [(EdgeId, info)])",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#HComponent",
        "fct-type": "function",
        "title": "Filter"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "Filter",
        "normalized": "Filter String([(EdgeId,a)]-\u003eb[(EdgeId,a)])",
        "package": "Top",
        "partial": "Filter",
        "signature": "Filter String([(EdgeId,info)]-\u003em[(EdgeId,info)])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:Heuristic",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "HComponent m info)",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#Heuristic",
        "fct-type": "function",
        "title": "Heuristic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "Heuristic",
        "normalized": "",
        "package": "Top",
        "partial": "Heuristic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:Selector",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "Selector (String, (EdgeId, info) -\u003e m (Maybe (Int, String, [EdgeId], info)))",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#Selector",
        "fct-type": "function",
        "title": "Selector"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "Selector",
        "normalized": "Selector(String,(EdgeId,a)-\u003eb(Maybe(Int,String,[EdgeId],a)))",
        "package": "Top",
        "partial": "Selector",
        "signature": "Selector(String,(EdgeId,info)-\u003em(Maybe(Int,String,[EdgeId],info)))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:SelectorList",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "SelectorList (String, [(EdgeId, info)] -\u003e m (Maybe (Int, String, [EdgeId], info)))",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#Selector",
        "fct-type": "function",
        "title": "SelectorList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "SelectorList",
        "normalized": "SelectorList(String,[(EdgeId,a)]-\u003eb(Maybe(Int,String,[EdgeId],a)))",
        "package": "Top",
        "partial": "Selector List",
        "signature": "SelectorList(String,[(EdgeId,info)]-\u003em(Maybe(Int,String,[EdgeId],info)))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:Voting",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "Voting [Selector m info]",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#HComponent",
        "fct-type": "function",
        "title": "Voting"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "Voting",
        "normalized": "Voting[Selector a b]",
        "package": "Top",
        "partial": "Voting",
        "signature": "Voting[Selector m info]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:doWithoutEdge",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "(EdgeId, info) -\u003e m result -\u003e m result",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#doWithoutEdge",
        "fct-type": "function",
        "title": "doWithoutEdge"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "doWithoutEdge",
        "normalized": "(EdgeId,a)-\u003eb c-\u003eb c",
        "package": "Top",
        "partial": "Without Edge",
        "signature": "(EdgeId,info)-\u003em result-\u003em result"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:doWithoutEdges",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "[(EdgeId, info)] -\u003e m result -\u003e m result",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#doWithoutEdges",
        "fct-type": "function",
        "title": "doWithoutEdges"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "doWithoutEdges",
        "normalized": "[(EdgeId,a)]-\u003eb c-\u003eb c",
        "package": "Top",
        "partial": "Without Edges",
        "signature": "[(EdgeId,info)]-\u003em result-\u003em result"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:edgeFilter",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "String -\u003e ((EdgeId, info) -\u003e m Bool) -\u003e HComponent m info",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#edgeFilter",
        "fct-type": "function",
        "title": "edgeFilter"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "edgeFilter",
        "normalized": "String-\u003e((EdgeId,a)-\u003eb Bool)-\u003eHComponent b a",
        "package": "Top",
        "partial": "Filter",
        "signature": "String-\u003e((EdgeId,info)-\u003em Bool)-\u003eHComponent m info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:eqInfo2",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "(EdgeId, info) -\u003e (EdgeId, info) -\u003e Bool",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#eqInfo2",
        "fct-type": "function",
        "title": "eqInfo2"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "eqInfo2",
        "normalized": "(EdgeId,a)-\u003e(EdgeId,a)-\u003eBool",
        "package": "Top",
        "partial": "Info",
        "signature": "(EdgeId,info)-\u003e(EdgeId,info)-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:getSelectorName",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "Selector m info -\u003e String",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#getSelectorName",
        "fct-type": "function",
        "title": "getSelectorName"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "getSelectorName",
        "normalized": "Selector a b-\u003eString",
        "package": "Top",
        "partial": "Selector Name",
        "signature": "Selector m info-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:getSubstitutedTypes",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "info -\u003e m (Maybe Tp, Maybe Tp)",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#getSubstitutedTypes",
        "fct-type": "function",
        "title": "getSubstitutedTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "getSubstitutedTypes",
        "normalized": "a-\u003eb(Maybe Tp,Maybe Tp)",
        "package": "Top",
        "partial": "Substituted Types",
        "signature": "info-\u003em(Maybe Tp,Maybe Tp)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:getTwoTypes",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "a -\u003e (Tp, Tp)",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#getTwoTypes",
        "fct-type": "method",
        "title": "getTwoTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "getTwoTypes",
        "normalized": "a-\u003e(Tp,Tp)",
        "package": "Top",
        "partial": "Two Types",
        "signature": "a-\u003e(Tp,Tp)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:info2ToEdgeNr",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "(EdgeId, info) -\u003e EdgeNr",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#info2ToEdgeNr",
        "fct-type": "function",
        "title": "info2ToEdgeNr"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "info2ToEdgeNr",
        "normalized": "(EdgeId,a)-\u003eEdgeNr",
        "package": "Top",
        "partial": "To Edge Nr",
        "signature": "(EdgeId,info)-\u003eEdgeNr"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:maximalEdgeFilter",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "String -\u003e ((EdgeId, info) -\u003e m a) -\u003e HComponent m info",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#maximalEdgeFilter",
        "fct-type": "function",
        "title": "maximalEdgeFilter"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "maximalEdgeFilter",
        "normalized": "String-\u003e((EdgeId,a)-\u003eb c)-\u003eHComponent b a",
        "package": "Top",
        "partial": "Edge Filter",
        "signature": "String-\u003e((EdgeId,info)-\u003em a)-\u003eHComponent m info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:minimalEdgeFilter",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "String -\u003e ((EdgeId, info) -\u003e m a) -\u003e HComponent m info",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#minimalEdgeFilter",
        "fct-type": "function",
        "title": "minimalEdgeFilter"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "minimalEdgeFilter",
        "normalized": "String-\u003e((EdgeId,a)-\u003eb c)-\u003eHComponent b a",
        "package": "Top",
        "partial": "Edge Filter",
        "signature": "String-\u003e((EdgeId,info)-\u003em a)-\u003eHComponent m info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:resultsEdgeFilter",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Heuristic",
        "fct-package": "Top",
        "fct-signature": "([a] -\u003e a) -\u003e String -\u003e ((EdgeId, info) -\u003e m a) -\u003e HComponent m info",
        "fct-source": "src/Top-Implementation-TypeGraph-Heuristic.html#resultsEdgeFilter",
        "fct-type": "function",
        "title": "resultsEdgeFilter"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Heuristic",
        "module": "Top.Implementation.TypeGraph.Heuristic",
        "name": "resultsEdgeFilter",
        "normalized": "([a]-\u003ea)-\u003eString-\u003e((EdgeId,b)-\u003ec a)-\u003eHComponent c b",
        "package": "Top",
        "partial": "Edge Filter",
        "signature": "([a]-\u003ea)-\u003eString-\u003e((EdgeId,info)-\u003em a)-\u003eHComponent m info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html",
        "fct-type": "module",
        "title": "Path"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "Path",
        "normalized": "",
        "package": "Top",
        "partial": "Path",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#t:Path",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#Path",
        "fct-type": "data",
        "title": "Path"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "Path",
        "normalized": "",
        "package": "Top",
        "partial": "Path",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:-60--124--62-",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "m (Path a) -\u003e m (Path a) -\u003e m (Path a)",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#%3C%2B%3E",
        "fct-type": "function",
        "title": "(\u003c|\u003e)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "(\u003c|\u003e) \u003c|\u003e",
        "normalized": "a(Path b)-\u003ea(Path b)-\u003ea(Path b)",
        "package": "Top",
        "partial": "",
        "signature": "m(Path a)-\u003em(Path a)-\u003em(Path a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:-60--43--43--62-",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "m [Path a] -\u003e m [Path a] -\u003e m [Path a]",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#%3C%2B%2B%3E",
        "fct-type": "function",
        "title": "(\u003c++\u003e)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "(\u003c++\u003e) \u003c++\u003e",
        "normalized": "a[Path b]-\u003ea[Path b]-\u003ea[Path b]",
        "package": "Top",
        "partial": "",
        "signature": "m[Path a]-\u003em[Path a]-\u003em[Path a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:-60--43--62-",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "m (Path a) -\u003e m (Path a) -\u003e m (Path a)",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#%3C%2B%3E",
        "fct-type": "function",
        "title": "(\u003c+\u003e)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "(\u003c+\u003e) \u003c+\u003e",
        "normalized": "a(Path b)-\u003ea(Path b)-\u003ea(Path b)",
        "package": "Top",
        "partial": "",
        "signature": "m(Path a)-\u003em(Path a)-\u003em(Path a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v::-124-:",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(Path a) :|: (Path a)",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#Path",
        "fct-type": "function",
        "title": ":|:"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": ":|:",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v::-43-:",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(Path a) :+: (Path a)",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#Path",
        "fct-type": "function",
        "title": ":+:"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": ":+:",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:Empty",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Empty",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#Path",
        "fct-type": "function",
        "title": "Empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "Empty",
        "normalized": "",
        "package": "Top",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:Fail",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Fail",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#Path",
        "fct-type": "function",
        "title": "Fail"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "Fail",
        "normalized": "",
        "package": "Top",
        "partial": "Fail",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:Step",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Step a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#Path",
        "fct-type": "function",
        "title": "Step"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "Step",
        "normalized": "",
        "package": "Top",
        "partial": "Step",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:altList",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "[Path a] -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#altList",
        "fct-type": "function",
        "title": "altList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "altList",
        "normalized": "[Path a]-\u003ePath a",
        "package": "Top",
        "partial": "List",
        "signature": "[Path a]-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:altList1",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "[Path a] -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#altList",
        "fct-type": "function",
        "title": "altList1"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "altList1",
        "normalized": "[Path a]-\u003ePath a",
        "package": "Top",
        "partial": "List",
        "signature": "[Path a]-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:changeStep",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e Path b) -\u003e Path a -\u003e Path b",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#changeStep",
        "fct-type": "function",
        "title": "changeStep"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "changeStep",
        "normalized": "(a-\u003ePath b)-\u003ePath a-\u003ePath b",
        "package": "Top",
        "partial": "Step",
        "signature": "(a-\u003ePath b)-\u003ePath a-\u003ePath b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:changeStepM",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e m (Path b)) -\u003e Path a -\u003e m (Path b)",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#changeStepM",
        "fct-type": "function",
        "title": "changeStepM"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "changeStepM",
        "normalized": "(a-\u003eb(Path c))-\u003ePath a-\u003eb(Path c)",
        "package": "Top",
        "partial": "Step",
        "signature": "(a-\u003em(Path b))-\u003ePath a-\u003em(Path b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:flattenPath",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Path a -\u003e [[a]]",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#flattenPath",
        "fct-type": "function",
        "title": "flattenPath"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "flattenPath",
        "normalized": "Path a-\u003e[[a]]",
        "package": "Top",
        "partial": "Path",
        "signature": "Path a-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:limitNumberOfPaths",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Path a -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#limitNumberOfPaths",
        "fct-type": "function",
        "title": "limitNumberOfPaths"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "limitNumberOfPaths",
        "normalized": "Int-\u003ePath a-\u003ePath a",
        "package": "Top",
        "partial": "Number Of Paths",
        "signature": "Int-\u003ePath a-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:mCombine",
      "description": {
        "fct-descr": "\u003cp\u003eCombine two monadic computations\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e m a -\u003e m b -\u003e m c",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#mCombine",
        "fct-type": "function",
        "title": "mCombine"
      },
      "index": {
        "description": "Combine two monadic computations",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "mCombine",
        "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
        "package": "Top",
        "partial": "Combine",
        "signature": "(a-\u003eb-\u003ec)-\u003em a-\u003em b-\u003em c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:mapPath",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e b) -\u003e Path a -\u003e Path b",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#mapPath",
        "fct-type": "function",
        "title": "mapPath"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "mapPath",
        "normalized": "(a-\u003eb)-\u003ePath a-\u003ePath b",
        "package": "Top",
        "partial": "Path",
        "signature": "(a-\u003eb)-\u003ePath a-\u003ePath b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:maxNumberOfEqualPaths",
      "description": {
        "fct-descr": "\u003cp\u003eThe maximal number of equality paths that is returned by equalPaths \n (although this number can be exceeded...it is more or less used as approximation)\n Nothing indicates that there is no limit\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Maybe Int",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#maxNumberOfEqualPaths",
        "fct-type": "function",
        "title": "maxNumberOfEqualPaths"
      },
      "index": {
        "description": "The maximal number of equality paths that is returned by equalPaths although this number can be exceeded...it is more or less used as approximation Nothing indicates that there is no limit",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "maxNumberOfEqualPaths",
        "normalized": "",
        "package": "Top",
        "partial": "Number Of Equal Paths",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:minCompleteInPath",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Path a -\u003e Maybe a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#minCompleteInPath",
        "fct-type": "function",
        "title": "minCompleteInPath"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "minCompleteInPath",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003ePath a-\u003eMaybe a",
        "package": "Top",
        "partial": "Complete In Path",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ePath a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:minimalSets",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e a -\u003e Bool) -\u003e Path a -\u003e [[a]]",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#minimalSets",
        "fct-type": "function",
        "title": "minimalSets"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "minimalSets",
        "normalized": "(a-\u003ea-\u003eBool)-\u003ePath a-\u003e[[a]]",
        "package": "Top",
        "partial": "Sets",
        "signature": "(a-\u003ea-\u003eBool)-\u003ePath a-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:participationMap",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Path a -\u003e (Integer, Map a Integer)",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#participationMap",
        "fct-type": "function",
        "title": "participationMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "participationMap",
        "normalized": "Path a-\u003e(Integer,Map a Integer)",
        "package": "Top",
        "partial": "Map",
        "signature": "Path a-\u003e(Integer,Map a Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:pathSize",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Path a -\u003e Int",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#pathSize",
        "fct-type": "function",
        "title": "pathSize"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "pathSize",
        "normalized": "Path a-\u003eInt",
        "package": "Top",
        "partial": "Size",
        "signature": "Path a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:reduceNumberOfPaths",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Path a -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#reduceNumberOfPaths",
        "fct-type": "function",
        "title": "reduceNumberOfPaths"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "reduceNumberOfPaths",
        "normalized": "Path a-\u003ePath a",
        "package": "Top",
        "partial": "Number Of Paths",
        "signature": "Path a-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:removeSomeDuplicates",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e b) -\u003e Path a -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#removeSomeDuplicates",
        "fct-type": "function",
        "title": "removeSomeDuplicates"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "removeSomeDuplicates",
        "normalized": "(a-\u003eb)-\u003ePath a-\u003ePath a",
        "package": "Top",
        "partial": "Some Duplicates",
        "signature": "(a-\u003eb)-\u003ePath a-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:seqList",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "[Path a] -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#seqList",
        "fct-type": "function",
        "title": "seqList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "seqList",
        "normalized": "[Path a]-\u003ePath a",
        "package": "Top",
        "partial": "List",
        "signature": "[Path a]-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:seqList1",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "[Path a] -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#seqList",
        "fct-type": "function",
        "title": "seqList1"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "seqList1",
        "normalized": "[Path a]-\u003ePath a",
        "package": "Top",
        "partial": "List",
        "signature": "[Path a]-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:simplifyPath",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Path a -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#simplifyPath",
        "fct-type": "function",
        "title": "simplifyPath"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "simplifyPath",
        "normalized": "Path a-\u003ePath a",
        "package": "Top",
        "partial": "Path",
        "signature": "Path a-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:steps",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "Path a -\u003e [a]",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#steps",
        "fct-type": "function",
        "title": "steps"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "steps",
        "normalized": "Path a-\u003e[a]",
        "package": "Top",
        "partial": "",
        "signature": "Path a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:tailSharingBy",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Path",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Path a -\u003e Path a",
        "fct-source": "src/Top-Implementation-TypeGraph-Path.html#tailSharingBy",
        "fct-type": "function",
        "title": "tailSharingBy"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Path",
        "module": "Top.Implementation.TypeGraph.Path",
        "name": "tailSharingBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003ePath a-\u003ePath a",
        "package": "Top",
        "partial": "Sharing By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ePath a-\u003ePath a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html",
        "fct-type": "module",
        "title": "Standard"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "Standard",
        "normalized": "",
        "package": "Top",
        "partial": "Standard",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#t:StandardTypeGraph",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
        "fct-type": "data",
        "title": "StandardTypeGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "StandardTypeGraph",
        "normalized": "",
        "package": "Top",
        "partial": "Standard Type Graph",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:STG",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "STG",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
        "fct-type": "function",
        "title": "STG"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "STG",
        "normalized": "",
        "package": "Top",
        "partial": "STG",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:addClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#addClique",
        "fct-type": "function",
        "title": "addClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "addClique",
        "normalized": "Clique-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Clique",
        "signature": "Clique-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:addPossibleInconsistentGroup",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#addPossibleInconsistentGroup",
        "fct-type": "function",
        "title": "addPossibleInconsistentGroup"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "addPossibleInconsistentGroup",
        "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Possible Inconsistent Group",
        "signature": "VertexId-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:combineClasses",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "[VertexId] -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#combineClasses",
        "fct-type": "function",
        "title": "combineClasses"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "combineClasses",
        "normalized": "[VertexId]-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Classes",
        "signature": "[VertexId]-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:constraintNumber",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "Int",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
        "fct-type": "function",
        "title": "constraintNumber"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "constraintNumber",
        "normalized": "",
        "package": "Top",
        "partial": "Number",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:createGroup",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#createGroup",
        "fct-type": "function",
        "title": "createGroup"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "createGroup",
        "normalized": "EquivalenceGroup a-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Group",
        "signature": "EquivalenceGroup info-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:deleteClique",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "Clique -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#deleteClique",
        "fct-type": "function",
        "title": "deleteClique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "deleteClique",
        "normalized": "Clique-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Clique",
        "signature": "Clique-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:equivalenceGroupCounter",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "Int",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
        "fct-type": "function",
        "title": "equivalenceGroupCounter"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "equivalenceGroupCounter",
        "normalized": "",
        "package": "Top",
        "partial": "Group Counter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:equivalenceGroupMap",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "Map Int (EquivalenceGroup info)",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
        "fct-type": "function",
        "title": "equivalenceGroupMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "equivalenceGroupMap",
        "normalized": "",
        "package": "Top",
        "partial": "Group Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:getAllGroups",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "StandardTypeGraph info -\u003e [EquivalenceGroup info]",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#getAllGroups",
        "fct-type": "function",
        "title": "getAllGroups"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "getAllGroups",
        "normalized": "StandardTypeGraph a-\u003e[EquivalenceGroup a]",
        "package": "Top",
        "partial": "All Groups",
        "signature": "StandardTypeGraph info-\u003e[EquivalenceGroup info]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:getGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e StandardTypeGraph info -\u003e EquivalenceGroup info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#getGroupOf",
        "fct-type": "function",
        "title": "getGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "getGroupOf",
        "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eEquivalenceGroup a",
        "package": "Top",
        "partial": "Group Of",
        "signature": "VertexId-\u003eStandardTypeGraph info-\u003eEquivalenceGroup info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:getPossibleInconsistentGroups",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "StandardTypeGraph info -\u003e [VertexId]",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#getPossibleInconsistentGroups",
        "fct-type": "function",
        "title": "getPossibleInconsistentGroups"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "getPossibleInconsistentGroups",
        "normalized": "StandardTypeGraph a-\u003e[VertexId]",
        "package": "Top",
        "partial": "Possible Inconsistent Groups",
        "signature": "StandardTypeGraph info-\u003e[VertexId]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:maybeGetGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e StandardTypeGraph info -\u003e Maybe (EquivalenceGroup info)",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#maybeGetGroupOf",
        "fct-type": "function",
        "title": "maybeGetGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "maybeGetGroupOf",
        "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eMaybe(EquivalenceGroup a)",
        "package": "Top",
        "partial": "Get Group Of",
        "signature": "VertexId-\u003eStandardTypeGraph info-\u003eMaybe(EquivalenceGroup info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:possibleErrors",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "[VertexId]",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
        "fct-type": "function",
        "title": "possibleErrors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "possibleErrors",
        "normalized": "[VertexId]",
        "package": "Top",
        "partial": "Errors",
        "signature": "[VertexId]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:propagateEquality",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#propagateEquality",
        "fct-type": "function",
        "title": "propagateEquality"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "propagateEquality",
        "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Equality",
        "signature": "VertexId-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:propagateRemoval",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#propagateRemoval",
        "fct-type": "function",
        "title": "propagateRemoval"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "propagateRemoval",
        "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Removal",
        "signature": "VertexId-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:referenceMap",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "Map VertexId Int",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
        "fct-type": "function",
        "title": "referenceMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "referenceMap",
        "normalized": "",
        "package": "Top",
        "partial": "Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:removeGroup",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "EquivalenceGroup info -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#removeGroup",
        "fct-type": "function",
        "title": "removeGroup"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "removeGroup",
        "normalized": "EquivalenceGroup a-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Group",
        "signature": "EquivalenceGroup info-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:setPossibleInconsistentGroups",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "[VertexId] -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#setPossibleInconsistentGroups",
        "fct-type": "function",
        "title": "setPossibleInconsistentGroups"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "setPossibleInconsistentGroups",
        "normalized": "[VertexId]-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Possible Inconsistent Groups",
        "signature": "[VertexId]-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:splitClass",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e StandardTypeGraph info -\u003e ([VertexId], StandardTypeGraph info)",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#splitClass",
        "fct-type": "function",
        "title": "splitClass"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "splitClass",
        "normalized": "VertexId-\u003eStandardTypeGraph a-\u003e([VertexId],StandardTypeGraph a)",
        "package": "Top",
        "partial": "Class",
        "signature": "VertexId-\u003eStandardTypeGraph info-\u003e([VertexId],StandardTypeGraph info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:updateGroupOf",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e (EquivalenceGroup info -\u003e EquivalenceGroup info) -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#updateGroupOf",
        "fct-type": "function",
        "title": "updateGroupOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "updateGroupOf",
        "normalized": "VertexId-\u003e(EquivalenceGroup a-\u003eEquivalenceGroup a)-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
        "package": "Top",
        "partial": "Group Of",
        "signature": "VertexId-\u003e(EquivalenceGroup info-\u003eEquivalenceGroup info)-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:vertexExists",
      "description": {
        "fct-module": "Top.Implementation.TypeGraph.Standard",
        "fct-package": "Top",
        "fct-signature": "VertexId -\u003e StandardTypeGraph info -\u003e Bool",
        "fct-source": "src/Top-Implementation-TypeGraph-Standard.html#vertexExists",
        "fct-type": "function",
        "title": "vertexExists"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraph Standard",
        "module": "Top.Implementation.TypeGraph.Standard",
        "name": "vertexExists",
        "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eBool",
        "package": "Top",
        "partial": "Exists",
        "signature": "VertexId-\u003eStandardTypeGraph info-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#",
      "description": {
        "fct-module": "Top.Implementation.TypeGraphSubstitution",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeGraphSubstitution.html",
        "fct-type": "module",
        "title": "TypeGraphSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraphSubstitution",
        "module": "Top.Implementation.TypeGraphSubstitution",
        "name": "TypeGraphSubstitution",
        "normalized": "",
        "package": "Top",
        "partial": "Type Graph Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#t:TypeGraphState",
      "description": {
        "fct-module": "Top.Implementation.TypeGraphSubstitution",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeGraphSubstitution.html#TypeGraphState",
        "fct-type": "data",
        "title": "TypeGraphState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraphSubstitution",
        "module": "Top.Implementation.TypeGraphSubstitution",
        "name": "TypeGraphState",
        "normalized": "",
        "package": "Top",
        "partial": "Type Graph State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#v:TypeGraphState",
      "description": {
        "fct-module": "Top.Implementation.TypeGraphSubstitution",
        "fct-package": "Top",
        "fct-signature": "TypeGraphState",
        "fct-source": "src/Top-Implementation-TypeGraphSubstitution.html#TypeGraphState",
        "fct-type": "function",
        "title": "TypeGraphState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraphSubstitution",
        "module": "Top.Implementation.TypeGraphSubstitution",
        "name": "TypeGraphState",
        "normalized": "",
        "package": "Top",
        "partial": "Type Graph State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#v:heuristics",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraphSubstitution",
        "fct-package": "Top",
        "fct-signature": "PathHeuristics info",
        "fct-source": "src/Top-Implementation-TypeGraphSubstitution.html#TypeGraphState",
        "fct-type": "function",
        "title": "heuristics"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraphSubstitution",
        "module": "Top.Implementation.TypeGraphSubstitution",
        "name": "heuristics",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#v:removeInconsistencies",
      "description": {
        "fct-module": "Top.Implementation.TypeGraphSubstitution",
        "fct-package": "Top",
        "fct-signature": "PathHeuristics info -\u003e m ()",
        "fct-source": "src/Top-Implementation-TypeGraphSubstitution.html#removeInconsistencies",
        "fct-type": "function",
        "title": "removeInconsistencies"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraphSubstitution",
        "module": "Top.Implementation.TypeGraphSubstitution",
        "name": "removeInconsistencies",
        "normalized": "PathHeuristics a-\u003eb()",
        "package": "Top",
        "partial": "Inconsistencies",
        "signature": "PathHeuristics info-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#v:typegraph",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Implementation.TypeGraphSubstitution",
        "fct-package": "Top",
        "fct-signature": "StandardTypeGraph info",
        "fct-source": "src/Top-Implementation-TypeGraphSubstitution.html#TypeGraphState",
        "fct-type": "function",
        "title": "typegraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeGraphSubstitution",
        "module": "Top.Implementation.TypeGraphSubstitution",
        "name": "typegraph",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAdditional state information that should be stored in order to perform\n type inference.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Implementation.TypeInference",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Implementation-TypeInference.html",
        "fct-type": "module",
        "title": "TypeInference"
      },
      "index": {
        "description": "Additional state information that should be stored in order to perform type inference",
        "hierarchy": "Top Implementation TypeInference",
        "module": "Top.Implementation.TypeInference",
        "name": "TypeInference",
        "normalized": "",
        "package": "Top",
        "partial": "Type Inference",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#t:TIState",
      "description": {
        "fct-module": "Top.Implementation.TypeInference",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Implementation-TypeInference.html#TIState",
        "fct-type": "data",
        "title": "TIState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeInference",
        "module": "Top.Implementation.TypeInference",
        "name": "TIState",
        "normalized": "",
        "package": "Top",
        "partial": "TIState",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:TIState",
      "description": {
        "fct-module": "Top.Implementation.TypeInference",
        "fct-package": "Top",
        "fct-signature": "TIState",
        "fct-source": "src/Top-Implementation-TypeInference.html#TIState",
        "fct-type": "function",
        "title": "TIState"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Implementation TypeInference",
        "module": "Top.Implementation.TypeInference",
        "name": "TIState",
        "normalized": "",
        "package": "Top",
        "partial": "TIState",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:counter",
      "description": {
        "fct-descr": "\u003cp\u003eA counter for fresh type variables\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Int",
        "fct-source": "src/Top-Implementation-TypeInference.html#TIState",
        "fct-type": "function",
        "title": "counter"
      },
      "index": {
        "description": "counter for fresh type variables",
        "hierarchy": "Top Implementation TypeInference",
        "module": "Top.Implementation.TypeInference",
        "name": "counter",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:schemeMap",
      "description": {
        "fct-descr": "\u003cp\u003eType scheme map\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Map Int (Scheme Predicates)",
        "fct-source": "src/Top-Implementation-TypeInference.html#TIState",
        "fct-type": "function",
        "title": "schemeMap"
      },
      "index": {
        "description": "Type scheme map",
        "hierarchy": "Top Implementation TypeInference",
        "module": "Top.Implementation.TypeInference",
        "name": "schemeMap",
        "normalized": "",
        "package": "Top",
        "partial": "Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:skolems",
      "description": {
        "fct-descr": "\u003cp\u003eList of skolem constants\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeInference",
        "fct-package": "Top",
        "fct-signature": "[([Int], info, Tps)]",
        "fct-source": "src/Top-Implementation-TypeInference.html#TIState",
        "fct-type": "function",
        "title": "skolems"
      },
      "index": {
        "description": "List of skolem constants",
        "hierarchy": "Top Implementation TypeInference",
        "module": "Top.Implementation.TypeInference",
        "name": "skolems",
        "normalized": "[([Int],a,Tps)]",
        "package": "Top",
        "partial": "",
        "signature": "[([Int],info,Tps)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:synonyms",
      "description": {
        "fct-descr": "\u003cp\u003eAll known type synonyms\n\u003c/p\u003e",
        "fct-module": "Top.Implementation.TypeInference",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms",
        "fct-source": "src/Top-Implementation-TypeInference.html#TIState",
        "fct-type": "function",
        "title": "synonyms"
      },
      "index": {
        "description": "All known type synonyms",
        "hierarchy": "Top Implementation TypeInference",
        "module": "Top.Implementation.TypeInference",
        "name": "synonyms",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Interface-Basic.html",
        "fct-type": "module",
        "title": "Basic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "Basic",
        "normalized": "",
        "package": "Top",
        "partial": "Basic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#t:ClassBasic",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Interface-Basic.html#ClassBasic",
        "fct-type": "data",
        "title": "ClassBasic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "ClassBasic",
        "normalized": "",
        "package": "Top",
        "partial": "Class Basic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#t:ErrorLabel",
      "description": {
        "fct-descr": "\u003cp\u003eA datatype to label the errors that are detected.\n\u003c/p\u003e",
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Interface-Basic.html#ErrorLabel",
        "fct-type": "data",
        "title": "ErrorLabel"
      },
      "index": {
        "description": "datatype to label the errors that are detected",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "ErrorLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Error Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#t:HasBasic",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Interface-Basic.html#HasBasic",
        "fct-type": "class",
        "title": "HasBasic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "HasBasic",
        "normalized": "",
        "package": "Top",
        "partial": "Has Basic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:ClassBasic",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "ClassBasic",
        "fct-source": "src/Top-Interface-Basic.html#ClassBasic",
        "fct-type": "function",
        "title": "ClassBasic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "ClassBasic",
        "normalized": "",
        "package": "Top",
        "partial": "Class Basic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:ErrorLabel",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel String",
        "fct-source": "src/Top-Interface-Basic.html#ErrorLabel",
        "fct-type": "function",
        "title": "ErrorLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "ErrorLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Error Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:NoErrorLabel",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "NoErrorLabel",
        "fct-source": "src/Top-Interface-Basic.html#ErrorLabel",
        "fct-type": "function",
        "title": "NoErrorLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "NoErrorLabel",
        "normalized": "",
        "package": "Top",
        "partial": "No Error Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:addCheck",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "String -\u003e m Bool -\u003e m ()",
        "fct-source": "src/Top-Interface-Basic.html#addCheck",
        "fct-type": "method",
        "title": "addCheck"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "addCheck",
        "normalized": "String-\u003ea Bool-\u003ea()",
        "package": "Top",
        "partial": "Check",
        "signature": "String-\u003em Bool-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:addError",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "info -\u003e m ()",
        "fct-source": "src/Top-Interface-Basic.html#addError",
        "fct-type": "function",
        "title": "addError"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "addError",
        "normalized": "a-\u003eb()",
        "package": "Top",
        "partial": "Error",
        "signature": "info-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:addLabeledError",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel -\u003e info -\u003e m ()",
        "fct-source": "src/Top-Interface-Basic.html#addLabeledError",
        "fct-type": "method",
        "title": "addLabeledError"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "addLabeledError",
        "normalized": "ErrorLabel-\u003ea-\u003eb()",
        "package": "Top",
        "partial": "Labeled Error",
        "signature": "ErrorLabel-\u003einfo-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:checkConditions",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "OptionAccess m Bool",
        "fct-source": "src/Top-Interface-Basic.html#checkConditions",
        "fct-type": "method",
        "title": "checkConditions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "checkConditions",
        "normalized": "",
        "package": "Top",
        "partial": "Conditions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:checkOption",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "Option Bool",
        "fct-source": "src/Top-Interface-Basic.html#stopOption",
        "fct-type": "function",
        "title": "checkOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "checkOption",
        "normalized": "",
        "package": "Top",
        "partial": "Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:deBasic",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "SelectFix t (StateFixT s m) a -\u003e StateFixT s m a",
        "fct-source": "src/Top-Interface-Basic.html#deBasic",
        "fct-type": "function",
        "title": "deBasic"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "deBasic",
        "normalized": "SelectFix a(StateFixT b c)d-\u003eStateFixT b c d",
        "package": "Top",
        "partial": "Basic",
        "signature": "SelectFix t(StateFixT s m)a-\u003eStateFixT s m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:discardConstraints",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-Basic.html#discardConstraints",
        "fct-type": "method",
        "title": "discardConstraints"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "discardConstraints",
        "normalized": "a()",
        "package": "Top",
        "partial": "Constraints",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:doChecks",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-Basic.html#doChecks",
        "fct-type": "function",
        "title": "doChecks"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "doChecks",
        "normalized": "a()",
        "package": "Top",
        "partial": "Checks",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:getChecks",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "m [(m Bool, String)]",
        "fct-source": "src/Top-Interface-Basic.html#getChecks",
        "fct-type": "method",
        "title": "getChecks"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "getChecks",
        "normalized": "a[(a Bool,String)]",
        "package": "Top",
        "partial": "Checks",
        "signature": "m[(m Bool,String)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:getErrors",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "m [info]",
        "fct-source": "src/Top-Interface-Basic.html#getErrors",
        "fct-type": "function",
        "title": "getErrors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "getErrors",
        "normalized": "a[b]",
        "package": "Top",
        "partial": "Errors",
        "signature": "m[info]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:getLabeledErrors",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "m [(info, ErrorLabel)]",
        "fct-source": "src/Top-Interface-Basic.html#getLabeledErrors",
        "fct-type": "method",
        "title": "getLabeledErrors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "getLabeledErrors",
        "normalized": "a[(b,ErrorLabel)]",
        "package": "Top",
        "partial": "Labeled Errors",
        "signature": "m[(info,ErrorLabel)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:popConstraint",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "m (Maybe (Constraint m))",
        "fct-source": "src/Top-Interface-Basic.html#popConstraint",
        "fct-type": "method",
        "title": "popConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "popConstraint",
        "normalized": "",
        "package": "Top",
        "partial": "Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:pushConstraint",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "Constraint m -\u003e m ()",
        "fct-source": "src/Top-Interface-Basic.html#pushConstraint",
        "fct-type": "method",
        "title": "pushConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "pushConstraint",
        "normalized": "Constraint a-\u003ea()",
        "package": "Top",
        "partial": "Constraint",
        "signature": "Constraint m-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:pushConstraints",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "Constraints m -\u003e m ()",
        "fct-source": "src/Top-Interface-Basic.html#pushConstraints",
        "fct-type": "method",
        "title": "pushConstraints"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "pushConstraints",
        "normalized": "Constraints a-\u003ea()",
        "package": "Top",
        "partial": "Constraints",
        "signature": "Constraints m-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:pushNamedOperation",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "String -\u003e m () -\u003e m ()",
        "fct-source": "src/Top-Interface-Basic.html#pushNamedOperation",
        "fct-type": "function",
        "title": "pushNamedOperation"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "pushNamedOperation",
        "normalized": "String-\u003ea()-\u003ea()",
        "package": "Top",
        "partial": "Named Operation",
        "signature": "String-\u003em()-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:pushOperation",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "m () -\u003e m ()",
        "fct-source": "src/Top-Interface-Basic.html#pushOperation",
        "fct-type": "function",
        "title": "pushOperation"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "pushOperation",
        "normalized": "a()-\u003ea()",
        "package": "Top",
        "partial": "Operation",
        "signature": "m()-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:startSolving",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-Basic.html#startSolving",
        "fct-type": "function",
        "title": "startSolving"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "startSolving",
        "normalized": "a()",
        "package": "Top",
        "partial": "Solving",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:stopAfterFirstError",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "OptionAccess m Bool",
        "fct-source": "src/Top-Interface-Basic.html#stopAfterFirstError",
        "fct-type": "method",
        "title": "stopAfterFirstError"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "stopAfterFirstError",
        "normalized": "",
        "package": "Top",
        "partial": "After First Error",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:stopOption",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "Option Bool",
        "fct-source": "src/Top-Interface-Basic.html#stopOption",
        "fct-type": "function",
        "title": "stopOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "stopOption",
        "normalized": "",
        "package": "Top",
        "partial": "Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:updateErrorInfo",
      "description": {
        "fct-module": "Top.Interface.Basic",
        "fct-package": "Top",
        "fct-signature": "(info -\u003e m info) -\u003e m ()",
        "fct-source": "src/Top-Interface-Basic.html#updateErrorInfo",
        "fct-type": "method",
        "title": "updateErrorInfo"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Basic",
        "module": "Top.Interface.Basic",
        "name": "updateErrorInfo",
        "normalized": "(a-\u003eb a)-\u003eb()",
        "package": "Top",
        "partial": "Error Info",
        "signature": "(info-\u003em info)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Interface-Qualification.html",
        "fct-type": "module",
        "title": "Qualification"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "Qualification",
        "normalized": "",
        "package": "Top",
        "partial": "Qualification",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#t:ClassQual",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Interface-Qualification.html#ClassQual",
        "fct-type": "data",
        "title": "ClassQual"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "ClassQual",
        "normalized": "",
        "package": "Top",
        "partial": "Class Qual",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#t:HasQual",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Interface-Qualification.html#HasQual",
        "fct-type": "class",
        "title": "HasQual"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "HasQual",
        "normalized": "",
        "package": "Top",
        "partial": "Has Qual",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:ClassQual",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "ClassQual",
        "fct-source": "src/Top-Interface-Qualification.html#ClassQual",
        "fct-type": "function",
        "title": "ClassQual"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "ClassQual",
        "normalized": "",
        "package": "Top",
        "partial": "Class Qual",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:allQualifiers",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "m [Predicate]",
        "fct-source": "src/Top-Interface-Qualification.html#allQualifiers",
        "fct-type": "method",
        "title": "allQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "allQualifiers",
        "normalized": "a[Predicate]",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "m[Predicate]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:ambiguities",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-Qualification.html#ambiguities",
        "fct-type": "function",
        "title": "ambiguities"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "ambiguities",
        "normalized": "a()",
        "package": "Top",
        "partial": "",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:ambiguousQualifiers",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-Qualification.html#ambiguousQualifiers",
        "fct-type": "method",
        "title": "ambiguousQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "ambiguousQualifiers",
        "normalized": "a()",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:assumeQualifier",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "info -\u003e Predicate -\u003e m ()",
        "fct-source": "src/Top-Interface-Qualification.html#assumeQualifier",
        "fct-type": "method",
        "title": "assumeQualifier"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "assumeQualifier",
        "normalized": "a-\u003ePredicate-\u003eb()",
        "package": "Top",
        "partial": "Qualifier",
        "signature": "info-\u003ePredicate-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:assumeQualifiers",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "info -\u003e Predicates -\u003e m ()",
        "fct-source": "src/Top-Interface-Qualification.html#assumeQualifiers",
        "fct-type": "function",
        "title": "assumeQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "assumeQualifiers",
        "normalized": "a-\u003ePredicates-\u003eb()",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "info-\u003ePredicates-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:changeQualifiers",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "(Predicate -\u003e m Predicate) -\u003e m ()",
        "fct-source": "src/Top-Interface-Qualification.html#changeQualifiers",
        "fct-type": "method",
        "title": "changeQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "changeQualifiers",
        "normalized": "(Predicate-\u003ea Predicate)-\u003ea()",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "(Predicate-\u003em Predicate)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:contextReduction",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-Qualification.html#contextReduction",
        "fct-type": "function",
        "title": "contextReduction"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "contextReduction",
        "normalized": "a()",
        "package": "Top",
        "partial": "Reduction",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:deQual",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "Select t (StateFixT s m) a -\u003e StateFixT s m a",
        "fct-source": "src/Top-Interface-Qualification.html#deQual",
        "fct-type": "function",
        "title": "deQual"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "deQual",
        "normalized": "Select a(StateFixT b c)d-\u003eStateFixT b c d",
        "package": "Top",
        "partial": "Qual",
        "signature": "Select t(StateFixT s m)a-\u003eStateFixT s m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:generalizeWithQualifiers",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "Tps -\u003e Tp -\u003e m (Scheme [Predicate])",
        "fct-source": "src/Top-Interface-Qualification.html#generalizeWithQualifiers",
        "fct-type": "method",
        "title": "generalizeWithQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "generalizeWithQualifiers",
        "normalized": "Tps-\u003eTp-\u003ea(Scheme[Predicate])",
        "package": "Top",
        "partial": "With Qualifiers",
        "signature": "Tps-\u003eTp-\u003em(Scheme[Predicate])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:getClassEnvironment",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "m ClassEnvironment",
        "fct-source": "src/Top-Interface-Qualification.html#getClassEnvironment",
        "fct-type": "method",
        "title": "getClassEnvironment"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "getClassEnvironment",
        "normalized": "",
        "package": "Top",
        "partial": "Class Environment",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:improveQualifiers",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "Bool -\u003e m [(info, Tp, Tp)]",
        "fct-source": "src/Top-Interface-Qualification.html#improveQualifiers",
        "fct-type": "method",
        "title": "improveQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "improveQualifiers",
        "normalized": "Bool-\u003ea[(b,Tp,Tp)]",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "Bool-\u003em[(info,Tp,Tp)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:improveQualifiersFinal",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "m [(info, Tp, Tp)]",
        "fct-source": "src/Top-Interface-Qualification.html#improveQualifiersFinal",
        "fct-type": "method",
        "title": "improveQualifiersFinal"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "improveQualifiersFinal",
        "normalized": "a[(b,Tp,Tp)]",
        "package": "Top",
        "partial": "Qualifiers Final",
        "signature": "m[(info,Tp,Tp)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:improveQualifiersFix",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "Bool -\u003e m ()",
        "fct-source": "src/Top-Interface-Qualification.html#improveQualifiersFix",
        "fct-type": "function",
        "title": "improveQualifiersFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "improveQualifiersFix",
        "normalized": "Bool-\u003ea()",
        "package": "Top",
        "partial": "Qualifiers Fix",
        "signature": "Bool-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:improveQualifiersNormal",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "m [(info, Tp, Tp)]",
        "fct-source": "src/Top-Interface-Qualification.html#improveQualifiersNormal",
        "fct-type": "method",
        "title": "improveQualifiersNormal"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "improveQualifiersNormal",
        "normalized": "a[(b,Tp,Tp)]",
        "package": "Top",
        "partial": "Qualifiers Normal",
        "signature": "m[(info,Tp,Tp)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:proveQualifier",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "info -\u003e Predicate -\u003e m ()",
        "fct-source": "src/Top-Interface-Qualification.html#proveQualifier",
        "fct-type": "method",
        "title": "proveQualifier"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "proveQualifier",
        "normalized": "a-\u003ePredicate-\u003eb()",
        "package": "Top",
        "partial": "Qualifier",
        "signature": "info-\u003ePredicate-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:proveQualifiers",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "info -\u003e Predicates -\u003e m ()",
        "fct-source": "src/Top-Interface-Qualification.html#proveQualifiers",
        "fct-type": "function",
        "title": "proveQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "proveQualifiers",
        "normalized": "a-\u003ePredicates-\u003eb()",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "info-\u003ePredicates-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:setClassEnvironment",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "ClassEnvironment -\u003e m ()",
        "fct-source": "src/Top-Interface-Qualification.html#setClassEnvironment",
        "fct-type": "method",
        "title": "setClassEnvironment"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "setClassEnvironment",
        "normalized": "ClassEnvironment-\u003ea()",
        "package": "Top",
        "partial": "Class Environment",
        "signature": "ClassEnvironment-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:simplifyQualifiers",
      "description": {
        "fct-module": "Top.Interface.Qualification",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-Qualification.html#simplifyQualifiers",
        "fct-type": "method",
        "title": "simplifyQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Qualification",
        "module": "Top.Interface.Qualification",
        "name": "simplifyQualifiers",
        "normalized": "a()",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#",
      "description": {
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Interface-Substitution.html",
        "fct-type": "module",
        "title": "Substitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "Substitution",
        "normalized": "",
        "package": "Top",
        "partial": "Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#t:ClassSubst",
      "description": {
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Interface-Substitution.html#ClassSubst",
        "fct-type": "data",
        "title": "ClassSubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "ClassSubst",
        "normalized": "",
        "package": "Top",
        "partial": "Class Subst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#t:HasSubst",
      "description": {
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Interface-Substitution.html#HasSubst",
        "fct-type": "class",
        "title": "HasSubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "HasSubst",
        "normalized": "",
        "package": "Top",
        "partial": "Has Subst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:ClassSubst",
      "description": {
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "ClassSubst",
        "fct-source": "src/Top-Interface-Substitution.html#ClassSubst",
        "fct-type": "function",
        "title": "ClassSubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "ClassSubst",
        "normalized": "",
        "package": "Top",
        "partial": "Class Subst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:applySubst",
      "description": {
        "fct-descr": "\u003cp\u003eApply the substitution to a value that contains type variables (a \n member of the Substitutable type class). \n\u003c/p\u003e",
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "a -\u003e m a",
        "fct-source": "src/Top-Interface-Substitution.html#applySubst",
        "fct-type": "function",
        "title": "applySubst"
      },
      "index": {
        "description": "Apply the substitution to value that contains type variables member of the Substitutable type class",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "applySubst",
        "normalized": "a-\u003eb a",
        "package": "Top",
        "partial": "Subst",
        "signature": "a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:deSubst",
      "description": {
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "Select t (StateFixT s m) a -\u003e StateFixT s m a",
        "fct-source": "src/Top-Interface-Substitution.html#deSubst",
        "fct-type": "function",
        "title": "deSubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "deSubst",
        "normalized": "Select a(StateFixT b c)d-\u003eStateFixT b c d",
        "package": "Top",
        "partial": "Subst",
        "signature": "Select t(StateFixT s m)a-\u003eStateFixT s m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:findSubstForVar",
      "description": {
        "fct-descr": "\u003cp\u003eLookup the value of a type variable in the substitution\n\u003c/p\u003e",
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e m Tp",
        "fct-source": "src/Top-Interface-Substitution.html#findSubstForVar",
        "fct-type": "method",
        "title": "findSubstForVar"
      },
      "index": {
        "description": "Lookup the value of type variable in the substitution",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "findSubstForVar",
        "normalized": "Int-\u003ea Tp",
        "package": "Top",
        "partial": "Subst For Var",
        "signature": "Int-\u003em Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:fixpointSubst",
      "description": {
        "fct-descr": "\u003cp\u003eReturn a fixpoint substitution.\n\u003c/p\u003e",
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "m FixpointSubstitution",
        "fct-source": "src/Top-Interface-Substitution.html#fixpointSubst",
        "fct-type": "method",
        "title": "fixpointSubst"
      },
      "index": {
        "description": "Return fixpoint substitution",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "fixpointSubst",
        "normalized": "",
        "package": "Top",
        "partial": "Subst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:makeSubstConsistent",
      "description": {
        "fct-descr": "\u003cp\u003eMake the state consistent. Only relevant for substitution states that \n can be inconsistent (for instance, the type graph substitution state).\n\u003c/p\u003e",
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-Substitution.html#makeSubstConsistent",
        "fct-type": "method",
        "title": "makeSubstConsistent"
      },
      "index": {
        "description": "Make the state consistent Only relevant for substitution states that can be inconsistent for instance the type graph substitution state",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "makeSubstConsistent",
        "normalized": "a()",
        "package": "Top",
        "partial": "Subst Consistent",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:unificationErrorLabel",
      "description": {
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel",
        "fct-source": "src/Top-Interface-Substitution.html#unificationErrorLabel",
        "fct-type": "function",
        "title": "unificationErrorLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "unificationErrorLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Error Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:unifyTerms",
      "description": {
        "fct-descr": "\u003cp\u003eUnify two terms. Supply additional information for this unification.\n\u003c/p\u003e",
        "fct-module": "Top.Interface.Substitution",
        "fct-package": "Top",
        "fct-signature": "info -\u003e Tp -\u003e Tp -\u003e m ()",
        "fct-source": "src/Top-Interface-Substitution.html#unifyTerms",
        "fct-type": "method",
        "title": "unifyTerms"
      },
      "index": {
        "description": "Unify two terms Supply additional information for this unification",
        "hierarchy": "Top Interface Substitution",
        "module": "Top.Interface.Substitution",
        "name": "unifyTerms",
        "normalized": "a-\u003eTp-\u003eTp-\u003eb()",
        "package": "Top",
        "partial": "Terms",
        "signature": "info-\u003eTp-\u003eTp-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Interface-TypeInference.html",
        "fct-type": "module",
        "title": "TypeInference"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "TypeInference",
        "normalized": "",
        "package": "Top",
        "partial": "Type Inference",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#t:ClassTI",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Interface-TypeInference.html#ClassTI",
        "fct-type": "data",
        "title": "ClassTI"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "ClassTI",
        "normalized": "",
        "package": "Top",
        "partial": "Class TI",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#t:HasTI",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Interface-TypeInference.html#HasTI",
        "fct-type": "class",
        "title": "HasTI"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "HasTI",
        "normalized": "",
        "package": "Top",
        "partial": "Has TI",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:ClassTI",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "ClassTI",
        "fct-source": "src/Top-Interface-TypeInference.html#ClassTI",
        "fct-type": "function",
        "title": "ClassTI"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "ClassTI",
        "normalized": "",
        "package": "Top",
        "partial": "Class TI",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:addSkolem",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "([Int], info, Tps) -\u003e m ()",
        "fct-source": "src/Top-Interface-TypeInference.html#addSkolem",
        "fct-type": "function",
        "title": "addSkolem"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "addSkolem",
        "normalized": "([Int],a,Tps)-\u003eb()",
        "package": "Top",
        "partial": "Skolem",
        "signature": "([Int],info,Tps)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:allTypeSchemes",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "m (Map Int (Scheme Predicates))",
        "fct-source": "src/Top-Interface-TypeInference.html#allTypeSchemes",
        "fct-type": "method",
        "title": "allTypeSchemes"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "allTypeSchemes",
        "normalized": "",
        "package": "Top",
        "partial": "Type Schemes",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:checkSkolems",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-TypeInference.html#checkSkolems",
        "fct-type": "function",
        "title": "checkSkolems"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "checkSkolems",
        "normalized": "a()",
        "package": "Top",
        "partial": "Skolems",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:deTI",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Select t (StateFixT s m) a -\u003e StateFixT s m a",
        "fct-source": "src/Top-Interface-TypeInference.html#deTI",
        "fct-type": "function",
        "title": "deTI"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "deTI",
        "normalized": "Select a(StateFixT b c)d-\u003eStateFixT b c d",
        "package": "Top",
        "partial": "TI",
        "signature": "Select t(StateFixT s m)a-\u003eStateFixT s m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:escapingSkolemLabel",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel",
        "fct-source": "src/Top-Interface-TypeInference.html#escapingSkolemLabel",
        "fct-type": "function",
        "title": "escapingSkolemLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "escapingSkolemLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Skolem Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:findScheme",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Sigma Predicates -\u003e m (Scheme Predicates)",
        "fct-source": "src/Top-Interface-TypeInference.html#findScheme",
        "fct-type": "function",
        "title": "findScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "findScheme",
        "normalized": "Sigma Predicates-\u003ea(Scheme Predicates)",
        "package": "Top",
        "partial": "Scheme",
        "signature": "Sigma Predicates-\u003em(Scheme Predicates)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getSkolemSubstitution",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "m MapSubstitution",
        "fct-source": "src/Top-Interface-TypeInference.html#getSkolemSubstitution",
        "fct-type": "function",
        "title": "getSkolemSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "getSkolemSubstitution",
        "normalized": "",
        "package": "Top",
        "partial": "Skolem Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getSkolems",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "m [([Int], info, Tps)]",
        "fct-source": "src/Top-Interface-TypeInference.html#getSkolems",
        "fct-type": "method",
        "title": "getSkolems"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "getSkolems",
        "normalized": "a[([Int],b,Tps)]",
        "package": "Top",
        "partial": "Skolems",
        "signature": "m[([Int],info,Tps)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getTypeScheme",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e m (Scheme Predicates)",
        "fct-source": "src/Top-Interface-TypeInference.html#getTypeScheme",
        "fct-type": "method",
        "title": "getTypeScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "getTypeScheme",
        "normalized": "Int-\u003ea(Scheme Predicates)",
        "package": "Top",
        "partial": "Type Scheme",
        "signature": "Int-\u003em(Scheme Predicates)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getTypeSynonyms",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "m OrderedTypeSynonyms",
        "fct-source": "src/Top-Interface-TypeInference.html#getTypeSynonyms",
        "fct-type": "method",
        "title": "getTypeSynonyms"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "getTypeSynonyms",
        "normalized": "",
        "package": "Top",
        "partial": "Type Synonyms",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getUnique",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "m Int",
        "fct-source": "src/Top-Interface-TypeInference.html#getUnique",
        "fct-type": "method",
        "title": "getUnique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "getUnique",
        "normalized": "",
        "package": "Top",
        "partial": "Unique",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:instantiateM",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Forall a -\u003e m a",
        "fct-source": "src/Top-Interface-TypeInference.html#instantiateM",
        "fct-type": "function",
        "title": "instantiateM"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "instantiateM",
        "normalized": "Forall a-\u003eb a",
        "package": "Top",
        "partial": "",
        "signature": "Forall a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:makeConsistent",
      "description": {
        "fct-descr": "\u003cp\u003eFirst, make the substitution consistent. Then check the skolem constants(?)\n\u003c/p\u003e",
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Interface-TypeInference.html#makeConsistent",
        "fct-type": "function",
        "title": "makeConsistent"
      },
      "index": {
        "description": "First make the substitution consistent Then check the skolem constants",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "makeConsistent",
        "normalized": "a()",
        "package": "Top",
        "partial": "Consistent",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:nextUnique",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "m Int",
        "fct-source": "src/Top-Interface-TypeInference.html#nextUnique",
        "fct-type": "function",
        "title": "nextUnique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "nextUnique",
        "normalized": "",
        "package": "Top",
        "partial": "Unique",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:replaceSchemeVar",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Sigma Predicates -\u003e m (Scheme Predicates)",
        "fct-source": "src/Top-Interface-TypeInference.html#replaceSchemeVar",
        "fct-type": "function",
        "title": "replaceSchemeVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "replaceSchemeVar",
        "normalized": "Sigma Predicates-\u003ea(Scheme Predicates)",
        "package": "Top",
        "partial": "Scheme Var",
        "signature": "Sigma Predicates-\u003em(Scheme Predicates)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:setSkolems",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "[([Int], info, Tps)] -\u003e m ()",
        "fct-source": "src/Top-Interface-TypeInference.html#setSkolems",
        "fct-type": "method",
        "title": "setSkolems"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "setSkolems",
        "normalized": "[([Int],a,Tps)]-\u003eb()",
        "package": "Top",
        "partial": "Skolems",
        "signature": "[([Int],info,Tps)]-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:setTypeSynonyms",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e m ()",
        "fct-source": "src/Top-Interface-TypeInference.html#setTypeSynonyms",
        "fct-type": "method",
        "title": "setTypeSynonyms"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "setTypeSynonyms",
        "normalized": "OrderedTypeSynonyms-\u003ea()",
        "package": "Top",
        "partial": "Type Synonyms",
        "signature": "OrderedTypeSynonyms-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:setUnique",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e m ()",
        "fct-source": "src/Top-Interface-TypeInference.html#setUnique",
        "fct-type": "method",
        "title": "setUnique"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "setUnique",
        "normalized": "Int-\u003ea()",
        "package": "Top",
        "partial": "Unique",
        "signature": "Int-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:skolemVersusConstantLabel",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel",
        "fct-source": "src/Top-Interface-TypeInference.html#skolemVersusConstantLabel",
        "fct-type": "function",
        "title": "skolemVersusConstantLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "skolemVersusConstantLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Versus Constant Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:skolemVersusSkolemLabel",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "ErrorLabel",
        "fct-source": "src/Top-Interface-TypeInference.html#skolemVersusSkolemLabel",
        "fct-type": "function",
        "title": "skolemVersusSkolemLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "skolemVersusSkolemLabel",
        "normalized": "",
        "package": "Top",
        "partial": "Versus Skolem Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:skolemizeFaked",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "info -\u003e Tps -\u003e Forall a -\u003e m a",
        "fct-source": "src/Top-Interface-TypeInference.html#skolemizeFaked",
        "fct-type": "function",
        "title": "skolemizeFaked"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "skolemizeFaked",
        "normalized": "a-\u003eTps-\u003eForall b-\u003ec b",
        "package": "Top",
        "partial": "Faked",
        "signature": "info-\u003eTps-\u003eForall a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:skolemizeTruly",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Forall a -\u003e m a",
        "fct-source": "src/Top-Interface-TypeInference.html#skolemizeTruly",
        "fct-type": "function",
        "title": "skolemizeTruly"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "skolemizeTruly",
        "normalized": "Forall a-\u003eb a",
        "package": "Top",
        "partial": "Truly",
        "signature": "Forall a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:storeTypeScheme",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Scheme Predicates -\u003e m ()",
        "fct-source": "src/Top-Interface-TypeInference.html#storeTypeScheme",
        "fct-type": "method",
        "title": "storeTypeScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "storeTypeScheme",
        "normalized": "Int-\u003eScheme Predicates-\u003ea()",
        "package": "Top",
        "partial": "Type Scheme",
        "signature": "Int-\u003eScheme Predicates-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:zipWithUniques",
      "description": {
        "fct-module": "Top.Interface.TypeInference",
        "fct-package": "Top",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e [a] -\u003e m [b]",
        "fct-source": "src/Top-Interface-TypeInference.html#zipWithUniques",
        "fct-type": "function",
        "title": "zipWithUniques"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Interface TypeInference",
        "module": "Top.Interface.TypeInference",
        "name": "zipWithUniques",
        "normalized": "(Int-\u003ea-\u003eb)-\u003e[a]-\u003ec[b]",
        "package": "Top",
        "partial": "With Uniques",
        "signature": "(Int-\u003ea-\u003eb)-\u003e[a]-\u003em[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Monad-Select.html",
        "fct-type": "module",
        "title": "Select"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "Select",
        "normalized": "",
        "package": "Top",
        "partial": "Select",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#t:Embedded",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Monad-Select.html#Embedded",
        "fct-type": "class",
        "title": "Embedded"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "Embedded",
        "normalized": "",
        "package": "Top",
        "partial": "Embedded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#t:Select",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Monad-Select.html#Select",
        "fct-type": "newtype",
        "title": "Select"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "Select",
        "normalized": "",
        "package": "Top",
        "partial": "Select",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#t:SelectFix",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Monad-Select.html#SelectFix",
        "fct-type": "data",
        "title": "SelectFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "SelectFix",
        "normalized": "",
        "package": "Top",
        "partial": "Select Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:Select",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "Select (m a)",
        "fct-source": "src/Top-Monad-Select.html#Select",
        "fct-type": "function",
        "title": "Select"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "Select",
        "normalized": "",
        "package": "Top",
        "partial": "Select",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:SelectFix",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "SelectFix (m a)",
        "fct-source": "src/Top-Monad-Select.html#SelectFix",
        "fct-type": "function",
        "title": "SelectFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "SelectFix",
        "normalized": "",
        "package": "Top",
        "partial": "Select Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:deselect",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "Select t m a -\u003e m a",
        "fct-source": "src/Top-Monad-Select.html#deselect",
        "fct-type": "function",
        "title": "deselect"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "deselect",
        "normalized": "Select a b c-\u003eb c",
        "package": "Top",
        "partial": "",
        "signature": "Select t m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:deselectFix",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "SelectFix t m a -\u003e m a",
        "fct-source": "src/Top-Monad-Select.html#deselectFix",
        "fct-type": "function",
        "title": "deselectFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "deselectFix",
        "normalized": "SelectFix a b c-\u003eb c",
        "package": "Top",
        "partial": "Fix",
        "signature": "SelectFix t m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:deselectFixFor",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "label -\u003e SelectFix t m a -\u003e m a",
        "fct-source": "src/Top-Monad-Select.html#deselectFixFor",
        "fct-type": "function",
        "title": "deselectFixFor"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "deselectFixFor",
        "normalized": "a-\u003eSelectFix b c d-\u003ec d",
        "package": "Top",
        "partial": "Fix For",
        "signature": "label-\u003eSelectFix t m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:deselectFor",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "label -\u003e Select t m a -\u003e m a",
        "fct-source": "src/Top-Monad-Select.html#deselectFor",
        "fct-type": "function",
        "title": "deselectFor"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "deselectFor",
        "normalized": "a-\u003eSelect b c d-\u003ec d",
        "package": "Top",
        "partial": "For",
        "signature": "label-\u003eSelect t m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:embedding",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "Embedding s t",
        "fct-source": "src/Top-Monad-Select.html#embedding",
        "fct-type": "method",
        "title": "embedding"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "embedding",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:select",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "m a -\u003e Select t m a",
        "fct-source": "src/Top-Monad-Select.html#select",
        "fct-type": "function",
        "title": "select"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "select",
        "normalized": "a b-\u003eSelect c a b",
        "package": "Top",
        "partial": "",
        "signature": "m a-\u003eSelect t m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:selectFix",
      "description": {
        "fct-module": "Top.Monad.Select",
        "fct-package": "Top",
        "fct-signature": "m a -\u003e SelectFix t m a",
        "fct-source": "src/Top-Monad-Select.html#selectFix",
        "fct-type": "function",
        "title": "selectFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad Select",
        "module": "Top.Monad.Select",
        "name": "selectFix",
        "normalized": "a b-\u003eSelectFix c a b",
        "package": "Top",
        "partial": "Fix",
        "signature": "m a-\u003eSelectFix t m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Monad-StateFix.html",
        "fct-type": "module",
        "title": "StateFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "StateFix",
        "normalized": "",
        "package": "Top",
        "partial": "State Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#t:StateFix",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Monad-StateFix.html#StateFix",
        "fct-type": "type",
        "title": "StateFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "StateFix",
        "normalized": "",
        "package": "Top",
        "partial": "State Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#t:StateFixT",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Monad-StateFix.html#StateFixT",
        "fct-type": "data",
        "title": "StateFixT"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "StateFixT",
        "normalized": "",
        "package": "Top",
        "partial": "State Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:Fix",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "Fix",
        "fct-source": "src/Top-Monad-StateFix.html#StateFixT",
        "fct-type": "function",
        "title": "Fix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "Fix",
        "normalized": "",
        "package": "Top",
        "partial": "Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:evalStateFix",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "StateFix s a -\u003e s (StateFix s) -\u003e a",
        "fct-source": "src/Top-Monad-StateFix.html#evalStateFix",
        "fct-type": "function",
        "title": "evalStateFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "evalStateFix",
        "normalized": "StateFix a b-\u003ea(StateFix a)-\u003eb",
        "package": "Top",
        "partial": "State Fix",
        "signature": "StateFix s a-\u003es(StateFix s)-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:evalStateFixT",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "StateFixT s m a -\u003e s (StateFixT s m) -\u003e m a",
        "fct-source": "src/Top-Monad-StateFix.html#evalStateFixT",
        "fct-type": "function",
        "title": "evalStateFixT"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "evalStateFixT",
        "normalized": "StateFixT a b c-\u003ea(StateFixT a b)-\u003eb c",
        "package": "Top",
        "partial": "State Fix",
        "signature": "StateFixT s m a-\u003es(StateFixT s m)-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:execStateFix",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "StateFix s a -\u003e s (StateFix s) -\u003e s (StateFix s)",
        "fct-source": "src/Top-Monad-StateFix.html#execStateFix",
        "fct-type": "function",
        "title": "execStateFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "execStateFix",
        "normalized": "StateFix a b-\u003ea(StateFix a)-\u003ea(StateFix a)",
        "package": "Top",
        "partial": "State Fix",
        "signature": "StateFix s a-\u003es(StateFix s)-\u003es(StateFix s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:execStateFixT",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "StateFixT s m a -\u003e s (StateFixT s m) -\u003e m (s (StateFixT s m))",
        "fct-source": "src/Top-Monad-StateFix.html#execStateFixT",
        "fct-type": "function",
        "title": "execStateFixT"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "execStateFixT",
        "normalized": "StateFixT a b c-\u003ea(StateFixT a b)-\u003eb(a(StateFixT a b))",
        "package": "Top",
        "partial": "State Fix",
        "signature": "StateFixT s m a-\u003es(StateFixT s m)-\u003em(s(StateFixT s m))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:runStateFix",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "StateFix s a -\u003e s (StateFix s) -\u003e (a, s (StateFix s))",
        "fct-source": "src/Top-Monad-StateFix.html#runStateFix",
        "fct-type": "function",
        "title": "runStateFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "runStateFix",
        "normalized": "StateFix a b-\u003ea(StateFix a)-\u003e(b,a(StateFix a))",
        "package": "Top",
        "partial": "State Fix",
        "signature": "StateFix s a-\u003es(StateFix s)-\u003e(a,s(StateFix s))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:runStateFixT",
      "description": {
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "StateFixT s m a -\u003e s (StateFixT s m) -\u003e m (a, s (StateFixT s m))",
        "fct-source": "src/Top-Monad-StateFix.html#runStateFixT",
        "fct-type": "function",
        "title": "runStateFixT"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "runStateFixT",
        "normalized": "StateFixT a b c-\u003ea(StateFixT a b)-\u003eb(c,a(StateFixT a b))",
        "package": "Top",
        "partial": "State Fix",
        "signature": "StateFixT s m a-\u003es(StateFixT s m)-\u003em(a,s(StateFixT s m))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:unFix",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Monad.StateFix",
        "fct-package": "Top",
        "fct-signature": "StateT (s (StateFixT s m)) m a",
        "fct-source": "src/Top-Monad-StateFix.html#StateFixT",
        "fct-type": "function",
        "title": "unFix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Monad StateFix",
        "module": "Top.Monad.StateFix",
        "name": "unFix",
        "normalized": "",
        "package": "Top",
        "partial": "Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Ordering-Tree.html",
        "fct-type": "module",
        "title": "Tree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Tree",
        "normalized": "",
        "package": "Top",
        "partial": "Tree",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Direction",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Ordering-Tree.html#Direction",
        "fct-type": "data",
        "title": "Direction"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Direction",
        "normalized": "",
        "package": "Top",
        "partial": "Direction",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Phased",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Ordering-Tree.html#Phased",
        "fct-type": "type",
        "title": "Phased"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Phased",
        "normalized": "",
        "package": "Top",
        "partial": "Phased",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Spreaded",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Ordering-Tree.html#Spreaded",
        "fct-type": "type",
        "title": "Spreaded"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Spreaded",
        "normalized": "",
        "package": "Top",
        "partial": "Spreaded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Tree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Ordering-Tree.html#Tree",
        "fct-type": "data",
        "title": "Tree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Tree",
        "normalized": "",
        "package": "Top",
        "partial": "Tree",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Trees",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Ordering-Tree.html#Trees",
        "fct-type": "type",
        "title": "Trees"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Trees",
        "normalized": "",
        "package": "Top",
        "partial": "Trees",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:.-60--60-.",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "[a] -\u003e Tree a -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#.%3E.",
        "fct-type": "function",
        "title": "(.\u003c\u003c.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "(.\u003c\u003c.) .\u003c\u003c.",
        "normalized": "[a]-\u003eTree a-\u003eTree a",
        "package": "Top",
        "partial": "",
        "signature": "[a]-\u003eTree a-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:.-60-.",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "[a] -\u003e Tree a -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#.%3E.",
        "fct-type": "function",
        "title": "(.\u003c.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "(.\u003c.) .\u003c.",
        "normalized": "[a]-\u003eTree a-\u003eTree a",
        "package": "Top",
        "partial": "",
        "signature": "[a]-\u003eTree a-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:.-62--62-.",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "[a] -\u003e Tree a -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#.%3E.",
        "fct-type": "function",
        "title": "(.\u003e\u003e.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "(.\u003e\u003e.) .\u003e\u003e.",
        "normalized": "[a]-\u003eTree a-\u003eTree a",
        "package": "Top",
        "partial": "",
        "signature": "[a]-\u003eTree a-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:.-62-.",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "[a] -\u003e Tree a -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#.%3E.",
        "fct-type": "function",
        "title": "(.\u003e.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "(.\u003e.) .\u003e.",
        "normalized": "[a]-\u003eTree a-\u003eTree a",
        "package": "Top",
        "partial": "",
        "signature": "[a]-\u003eTree a-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:AddList",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "AddList Direction [a] (Tree a)",
        "fct-source": "src/Top-Ordering-Tree.html#Tree",
        "fct-type": "function",
        "title": "AddList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "AddList",
        "normalized": "AddList Direction[a](Tree a)",
        "package": "Top",
        "partial": "Add List",
        "signature": "AddList Direction[a](Tree a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Chunk",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Chunk Int (Tree a)",
        "fct-source": "src/Top-Ordering-Tree.html#Tree",
        "fct-type": "function",
        "title": "Chunk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Chunk",
        "normalized": "",
        "package": "Top",
        "partial": "Chunk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Down",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Down",
        "fct-source": "src/Top-Ordering-Tree.html#Direction",
        "fct-type": "function",
        "title": "Down"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Down",
        "normalized": "",
        "package": "Top",
        "partial": "Down",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Node",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Node (Trees a)",
        "fct-source": "src/Top-Ordering-Tree.html#Tree",
        "fct-type": "function",
        "title": "Node"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Node",
        "normalized": "",
        "package": "Top",
        "partial": "Node",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Phase",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Phase Int [a]",
        "fct-source": "src/Top-Ordering-Tree.html#Tree",
        "fct-type": "function",
        "title": "Phase"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Phase",
        "normalized": "Phase Int[a]",
        "package": "Top",
        "partial": "Phase",
        "signature": "Phase Int[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Receive",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Receive Int",
        "fct-source": "src/Top-Ordering-Tree.html#Tree",
        "fct-type": "function",
        "title": "Receive"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Receive",
        "normalized": "",
        "package": "Top",
        "partial": "Receive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Spread",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Spread Direction [a] (Tree a)",
        "fct-source": "src/Top-Ordering-Tree.html#Tree",
        "fct-type": "function",
        "title": "Spread"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Spread",
        "normalized": "Spread Direction[a](Tree a)",
        "package": "Top",
        "partial": "Spread",
        "signature": "Spread Direction[a](Tree a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:StrictOrder",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "StrictOrder (Tree a) (Tree a)",
        "fct-source": "src/Top-Ordering-Tree.html#Tree",
        "fct-type": "function",
        "title": "StrictOrder"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "StrictOrder",
        "normalized": "",
        "package": "Top",
        "partial": "Strict Order",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Up",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Up",
        "fct-source": "src/Top-Ordering-Tree.html#Direction",
        "fct-type": "function",
        "title": "Up"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "Up",
        "normalized": "",
        "package": "Top",
        "partial": "Up",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:binTree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Tree a -\u003e Tree a -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#binTree",
        "fct-type": "function",
        "title": "binTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "binTree",
        "normalized": "Tree a-\u003eTree a-\u003eTree a",
        "package": "Top",
        "partial": "Tree",
        "signature": "Tree a-\u003eTree a-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:chunkTree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Tree a -\u003e [(Int, Tree a)]",
        "fct-source": "src/Top-Ordering-Tree.html#chunkTree",
        "fct-type": "function",
        "title": "chunkTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "chunkTree",
        "normalized": "Tree a-\u003e[(Int,Tree a)]",
        "package": "Top",
        "partial": "Tree",
        "signature": "Tree a-\u003e[(Int,Tree a)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:emptyTree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#emptyTree",
        "fct-type": "function",
        "title": "emptyTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "emptyTree",
        "normalized": "",
        "package": "Top",
        "partial": "Tree",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:flattenTree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "TreeWalk -\u003e Tree a -\u003e [a]",
        "fct-source": "src/Top-Ordering-Tree.html#flattenTree",
        "fct-type": "function",
        "title": "flattenTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "flattenTree",
        "normalized": "TreeWalk-\u003eTree a-\u003e[a]",
        "package": "Top",
        "partial": "Tree",
        "signature": "TreeWalk-\u003eTree a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:listTree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "[a] -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#listTree",
        "fct-type": "function",
        "title": "listTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "listTree",
        "normalized": "[a]-\u003eTree a",
        "package": "Top",
        "partial": "Tree",
        "signature": "[a]-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:makeTreeHelper",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "(t -\u003e [a] -\u003e t1 -\u003e t1) -\u003e t -\u003e [a] -\u003e t1 -\u003e t1",
        "fct-source": "src/Top-Ordering-Tree.html#makeTreeHelper",
        "fct-type": "function",
        "title": "makeTreeHelper"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "makeTreeHelper",
        "normalized": "(a-\u003e[b]-\u003ea-\u003ea)-\u003ea-\u003e[b]-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Tree Helper",
        "signature": "(t-\u003e[a]-\u003et-\u003et)-\u003et-\u003e[a]-\u003et-\u003et"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:phaseTree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "a -\u003e Tree a -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#phaseTree",
        "fct-type": "function",
        "title": "phaseTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "phaseTree",
        "normalized": "a-\u003eTree a-\u003eTree a",
        "package": "Top",
        "partial": "Tree",
        "signature": "a-\u003eTree a-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:spreadTree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "(a -\u003e Maybe Int) -\u003e Tree a -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#spreadTree",
        "fct-type": "function",
        "title": "spreadTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "spreadTree",
        "normalized": "(a-\u003eMaybe Int)-\u003eTree a-\u003eTree a",
        "package": "Top",
        "partial": "Tree",
        "signature": "(a-\u003eMaybe Int)-\u003eTree a-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:unitTree",
      "description": {
        "fct-module": "Top.Ordering.Tree",
        "fct-package": "Top",
        "fct-signature": "a -\u003e Tree a",
        "fct-source": "src/Top-Ordering-Tree.html#unitTree",
        "fct-type": "function",
        "title": "unitTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering Tree",
        "module": "Top.Ordering.Tree",
        "name": "unitTree",
        "normalized": "a-\u003eTree a",
        "package": "Top",
        "partial": "Tree",
        "signature": "a-\u003eTree a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Ordering-TreeWalk.html",
        "fct-type": "module",
        "title": "TreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "TreeWalk",
        "normalized": "",
        "package": "Top",
        "partial": "Tree Walk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#t:List",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Ordering-TreeWalk.html#List",
        "fct-type": "type",
        "title": "List"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "List",
        "normalized": "",
        "package": "Top",
        "partial": "List",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#t:TreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Ordering-TreeWalk.html#TreeWalk",
        "fct-type": "newtype",
        "title": "TreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "TreeWalk",
        "normalized": "",
        "package": "Top",
        "partial": "Tree Walk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:TreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "TreeWalk (forall a.  List a -\u003e [(List a, List a)] -\u003e List a)",
        "fct-source": "src/Top-Ordering-TreeWalk.html#TreeWalk",
        "fct-type": "function",
        "title": "TreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "TreeWalk",
        "normalized": "TreeWalk(a b List c-\u003e[(List c,List c)]-\u003eList c)",
        "package": "Top",
        "partial": "Tree Walk",
        "signature": "TreeWalk(forall a. List a-\u003e[(List a,List a)]-\u003eList a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:bottomUpTreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "TreeWalk",
        "fct-source": "src/Top-Ordering-TreeWalk.html#bottomUpTreeWalk",
        "fct-type": "function",
        "title": "bottomUpTreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "bottomUpTreeWalk",
        "normalized": "",
        "package": "Top",
        "partial": "Up Tree Walk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:concatList",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "[List a] -\u003e List a",
        "fct-source": "src/Top-Ordering-TreeWalk.html#concatList",
        "fct-type": "function",
        "title": "concatList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "concatList",
        "normalized": "[List a]-\u003eList a",
        "package": "Top",
        "partial": "List",
        "signature": "[List a]-\u003eList a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:inorderTopFirstPostTreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "TreeWalk",
        "fct-source": "src/Top-Ordering-TreeWalk.html#inorderTopFirstPostTreeWalk",
        "fct-type": "function",
        "title": "inorderTopFirstPostTreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "inorderTopFirstPostTreeWalk",
        "normalized": "",
        "package": "Top",
        "partial": "Top First Post Tree Walk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:inorderTopFirstPreTreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "TreeWalk",
        "fct-source": "src/Top-Ordering-TreeWalk.html#inorderTopFirstPreTreeWalk",
        "fct-type": "function",
        "title": "inorderTopFirstPreTreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "inorderTopFirstPreTreeWalk",
        "normalized": "",
        "package": "Top",
        "partial": "Top First Pre Tree Walk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:inorderTopLastPostTreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "TreeWalk",
        "fct-source": "src/Top-Ordering-TreeWalk.html#inorderTopLastPostTreeWalk",
        "fct-type": "function",
        "title": "inorderTopLastPostTreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "inorderTopLastPostTreeWalk",
        "normalized": "",
        "package": "Top",
        "partial": "Top Last Post Tree Walk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:inorderTopLastPreTreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "TreeWalk",
        "fct-source": "src/Top-Ordering-TreeWalk.html#inorderTopLastPreTreeWalk",
        "fct-type": "function",
        "title": "inorderTopLastPreTreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "inorderTopLastPreTreeWalk",
        "normalized": "",
        "package": "Top",
        "partial": "Top Last Pre Tree Walk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:reverseTreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "TreeWalk -\u003e TreeWalk",
        "fct-source": "src/Top-Ordering-TreeWalk.html#reverseTreeWalk",
        "fct-type": "function",
        "title": "reverseTreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "reverseTreeWalk",
        "normalized": "TreeWalk-\u003eTreeWalk",
        "package": "Top",
        "partial": "Tree Walk",
        "signature": "TreeWalk-\u003eTreeWalk"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:topDownTreeWalk",
      "description": {
        "fct-module": "Top.Ordering.TreeWalk",
        "fct-package": "Top",
        "fct-signature": "TreeWalk",
        "fct-source": "src/Top-Ordering-TreeWalk.html#topDownTreeWalk",
        "fct-type": "function",
        "title": "topDownTreeWalk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Ordering TreeWalk",
        "module": "Top.Ordering.TreeWalk",
        "name": "topDownTreeWalk",
        "normalized": "",
        "package": "Top",
        "partial": "Down Tree Walk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Solver-Greedy.html",
        "fct-type": "module",
        "title": "Greedy"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "Greedy",
        "normalized": "",
        "package": "Top",
        "partial": "Greedy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#t:Greedy",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-Greedy.html#Greedy",
        "fct-type": "type",
        "title": "Greedy"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "Greedy",
        "normalized": "",
        "package": "Top",
        "partial": "Greedy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#t:GreedyS",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-Greedy.html#GreedyS",
        "fct-type": "type",
        "title": "GreedyS"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "GreedyS",
        "normalized": "",
        "package": "Top",
        "partial": "Greedy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#t:GreedySimple",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-Greedy.html#GreedySimple",
        "fct-type": "type",
        "title": "GreedySimple"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "GreedySimple",
        "normalized": "",
        "package": "Top",
        "partial": "Greedy Simple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#t:GreedySimpleS",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-Greedy.html#GreedySimpleS",
        "fct-type": "type",
        "title": "GreedySimpleS"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "GreedySimpleS",
        "normalized": "",
        "package": "Top",
        "partial": "Greedy Simple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#v:greedyConstraintSolver",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "ConstraintSolver constraint info",
        "fct-source": "src/Top-Solver-Greedy.html#greedyConstraintSolver",
        "fct-type": "function",
        "title": "greedyConstraintSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "greedyConstraintSolver",
        "normalized": "",
        "package": "Top",
        "partial": "Constraint Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#v:greedySimpleConstraintSolver",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "ConstraintSolver constraint info",
        "fct-source": "src/Top-Solver-Greedy.html#greedySimpleConstraintSolver",
        "fct-type": "function",
        "title": "greedySimpleConstraintSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "greedySimpleConstraintSolver",
        "normalized": "",
        "package": "Top",
        "partial": "Simple Constraint Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#v:solveGreedy",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "SolveOptions -\u003e [constraint] -\u003e Greedy info (SolveResult info)",
        "fct-source": "src/Top-Solver-Greedy.html#solveGreedy",
        "fct-type": "function",
        "title": "solveGreedy"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "solveGreedy",
        "normalized": "SolveOptions-\u003e[a]-\u003eGreedy b(SolveResult b)",
        "package": "Top",
        "partial": "Greedy",
        "signature": "SolveOptions-\u003e[constraint]-\u003eGreedy info(SolveResult info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#v:solveSimple",
      "description": {
        "fct-module": "Top.Solver.Greedy",
        "fct-package": "Top",
        "fct-signature": "SolveOptions -\u003e [constraint] -\u003e GreedySimple info (SolveResult info)",
        "fct-source": "src/Top-Solver-Greedy.html#solveSimple",
        "fct-type": "function",
        "title": "solveSimple"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver Greedy",
        "module": "Top.Solver.Greedy",
        "name": "solveSimple",
        "normalized": "SolveOptions-\u003e[a]-\u003eGreedySimple b(SolveResult b)",
        "package": "Top",
        "partial": "Simple",
        "signature": "SolveOptions-\u003e[constraint]-\u003eGreedySimple info(SolveResult info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#",
      "description": {
        "fct-module": "Top.Solver.PartitionCombinator",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Solver-PartitionCombinator.html",
        "fct-type": "module",
        "title": "PartitionCombinator"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver PartitionCombinator",
        "module": "Top.Solver.PartitionCombinator",
        "name": "PartitionCombinator",
        "normalized": "",
        "package": "Top",
        "partial": "Partition Combinator",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#t:Chunk",
      "description": {
        "fct-module": "Top.Solver.PartitionCombinator",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-PartitionCombinator.html#Chunk",
        "fct-type": "type",
        "title": "Chunk"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver PartitionCombinator",
        "module": "Top.Solver.PartitionCombinator",
        "name": "Chunk",
        "normalized": "",
        "package": "Top",
        "partial": "Chunk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#t:ChunkID",
      "description": {
        "fct-module": "Top.Solver.PartitionCombinator",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-PartitionCombinator.html#ChunkID",
        "fct-type": "type",
        "title": "ChunkID"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver PartitionCombinator",
        "module": "Top.Solver.PartitionCombinator",
        "name": "ChunkID",
        "normalized": "",
        "package": "Top",
        "partial": "Chunk ID",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#t:Chunks",
      "description": {
        "fct-module": "Top.Solver.PartitionCombinator",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-PartitionCombinator.html#Chunks",
        "fct-type": "type",
        "title": "Chunks"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver PartitionCombinator",
        "module": "Top.Solver.PartitionCombinator",
        "name": "Chunks",
        "normalized": "",
        "package": "Top",
        "partial": "Chunks",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#v:solveChunkConstraints",
      "description": {
        "fct-module": "Top.Solver.PartitionCombinator",
        "fct-package": "Top",
        "fct-signature": "(Map Int (Scheme Predicates) -\u003e constraint -\u003e constraint) -\u003e ConstraintSolver constraint info -\u003e (Tree constraint -\u003e [constraint]) -\u003e Chunks constraint -\u003e ConstraintSolver constraint info",
        "fct-source": "src/Top-Solver-PartitionCombinator.html#solveChunkConstraints",
        "fct-type": "function",
        "title": "solveChunkConstraints"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver PartitionCombinator",
        "module": "Top.Solver.PartitionCombinator",
        "name": "solveChunkConstraints",
        "normalized": "(Map Int(Scheme Predicates)-\u003ea-\u003ea)-\u003eConstraintSolver a b-\u003e(Tree a-\u003e[a])-\u003eChunks a-\u003eConstraintSolver a b",
        "package": "Top",
        "partial": "Chunk Constraints",
        "signature": "(Map Int(Scheme Predicates)-\u003econstraint-\u003econstraint)-\u003eConstraintSolver constraint info-\u003e(Tree constraint-\u003e[constraint])-\u003eChunks constraint-\u003eConstraintSolver constraint info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-SwitchCombinator.html#",
      "description": {
        "fct-module": "Top.Solver.SwitchCombinator",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Solver-SwitchCombinator.html",
        "fct-type": "module",
        "title": "SwitchCombinator"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver SwitchCombinator",
        "module": "Top.Solver.SwitchCombinator",
        "name": "SwitchCombinator",
        "normalized": "",
        "package": "Top",
        "partial": "Switch Combinator",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-SwitchCombinator.html#v:-124--62--62--124-",
      "description": {
        "fct-descr": "\u003cp\u003eThe first solver is used to solve the constraint set. If this fails (at least one \n error is returned), then the second solver takes over.     \n\u003c/p\u003e",
        "fct-module": "Top.Solver.SwitchCombinator",
        "fct-package": "Top",
        "fct-signature": "ConstraintSolver constraint info -\u003e ConstraintSolver constraint info -\u003e ConstraintSolver constraint info",
        "fct-source": "src/Top-Solver-SwitchCombinator.html#%7C%3E%3E%7C",
        "fct-type": "function",
        "title": "(|\u003e\u003e|)"
      },
      "index": {
        "description": "The first solver is used to solve the constraint set If this fails at least one error is returned then the second solver takes over",
        "hierarchy": "Top Solver SwitchCombinator",
        "module": "Top.Solver.SwitchCombinator",
        "name": "(|\u003e\u003e|) |\u003e\u003e|",
        "normalized": "ConstraintSolver a b-\u003eConstraintSolver a b-\u003eConstraintSolver a b",
        "package": "Top",
        "partial": "",
        "signature": "ConstraintSolver constraint info-\u003eConstraintSolver constraint info-\u003eConstraintSolver constraint info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#",
      "description": {
        "fct-module": "Top.Solver.TypeGraph",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Solver-TypeGraph.html",
        "fct-type": "module",
        "title": "TypeGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver TypeGraph",
        "module": "Top.Solver.TypeGraph",
        "name": "TypeGraph",
        "normalized": "",
        "package": "Top",
        "partial": "Type Graph",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#t:TG",
      "description": {
        "fct-module": "Top.Solver.TypeGraph",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-TypeGraph.html#TG",
        "fct-type": "type",
        "title": "TG"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver TypeGraph",
        "module": "Top.Solver.TypeGraph",
        "name": "TG",
        "normalized": "",
        "package": "Top",
        "partial": "TG",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#t:TGS",
      "description": {
        "fct-module": "Top.Solver.TypeGraph",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver-TypeGraph.html#TGS",
        "fct-type": "type",
        "title": "TGS"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver TypeGraph",
        "module": "Top.Solver.TypeGraph",
        "name": "TGS",
        "normalized": "",
        "package": "Top",
        "partial": "TGS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#v:solveTypeGraph",
      "description": {
        "fct-module": "Top.Solver.TypeGraph",
        "fct-package": "Top",
        "fct-signature": "TG info () -\u003e SolveOptions -\u003e [constraint] -\u003e TG info (SolveResult info)",
        "fct-source": "src/Top-Solver-TypeGraph.html#solveTypeGraph",
        "fct-type": "function",
        "title": "solveTypeGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver TypeGraph",
        "module": "Top.Solver.TypeGraph",
        "name": "solveTypeGraph",
        "normalized": "TG a()-\u003eSolveOptions-\u003e[b]-\u003eTG a(SolveResult a)",
        "package": "Top",
        "partial": "Type Graph",
        "signature": "TG info()-\u003eSolveOptions-\u003e[constraint]-\u003eTG info(SolveResult info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#v:typegraphConstraintSolver",
      "description": {
        "fct-module": "Top.Solver.TypeGraph",
        "fct-package": "Top",
        "fct-signature": "PathHeuristics info -\u003e ConstraintSolver constraint info",
        "fct-source": "src/Top-Solver-TypeGraph.html#typegraphConstraintSolver",
        "fct-type": "function",
        "title": "typegraphConstraintSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver TypeGraph",
        "module": "Top.Solver.TypeGraph",
        "name": "typegraphConstraintSolver",
        "normalized": "PathHeuristics a-\u003eConstraintSolver b a",
        "package": "Top",
        "partial": "Constraint Solver",
        "signature": "PathHeuristics info-\u003eConstraintSolver constraint info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#v:typegraphConstraintSolverDefault",
      "description": {
        "fct-module": "Top.Solver.TypeGraph",
        "fct-package": "Top",
        "fct-signature": "ConstraintSolver constraint info",
        "fct-source": "src/Top-Solver-TypeGraph.html#typegraphConstraintSolverDefault",
        "fct-type": "function",
        "title": "typegraphConstraintSolverDefault"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver TypeGraph",
        "module": "Top.Solver.TypeGraph",
        "name": "typegraphConstraintSolverDefault",
        "normalized": "",
        "package": "Top",
        "partial": "Constraint Solver Default",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Solver.html",
        "fct-type": "module",
        "title": "Solver"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "Solver",
        "normalized": "",
        "package": "Top",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:BasicMonad",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Solver.html#BasicMonad",
        "fct-type": "type",
        "title": "BasicMonad"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "BasicMonad",
        "normalized": "",
        "package": "Top",
        "partial": "Basic Monad",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:ConstraintSolver",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Solver.html#ConstraintSolver",
        "fct-type": "data",
        "title": "ConstraintSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "ConstraintSolver",
        "normalized": "",
        "package": "Top",
        "partial": "Constraint Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:LogEntries",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Solver.html#LogEntries",
        "fct-type": "newtype",
        "title": "LogEntries"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "LogEntries",
        "normalized": "",
        "package": "Top",
        "partial": "Log Entries",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:LogEntry",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Solver.html#LogEntry",
        "fct-type": "data",
        "title": "LogEntry"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "LogEntry",
        "normalized": "",
        "package": "Top",
        "partial": "Log Entry",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:SolveOptions",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Solver.html#SolveOptions",
        "fct-type": "data",
        "title": "SolveOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "SolveOptions",
        "normalized": "",
        "package": "Top",
        "partial": "Solve Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:SolveResult",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Solver.html#SolveResult",
        "fct-type": "data",
        "title": "SolveResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "SolveResult",
        "normalized": "",
        "package": "Top",
        "partial": "Solve Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:ConstraintSolver",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "ConstraintSolver (SolveOptions -\u003e [constraint] -\u003e (SolveResult info, LogEntries))",
        "fct-source": "src/Top-Solver.html#ConstraintSolver",
        "fct-type": "function",
        "title": "ConstraintSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "ConstraintSolver",
        "normalized": "ConstraintSolver(SolveOptions-\u003e[a]-\u003e(SolveResult b,LogEntries))",
        "package": "Top",
        "partial": "Constraint Solver",
        "signature": "ConstraintSolver(SolveOptions-\u003e[constraint]-\u003e(SolveResult info,LogEntries))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:LogEntries",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "LogEntries ([LogEntry] -\u003e [LogEntry])",
        "fct-source": "src/Top-Solver.html#LogEntries",
        "fct-type": "function",
        "title": "LogEntries"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "LogEntries",
        "normalized": "LogEntries([LogEntry]-\u003e[LogEntry])",
        "package": "Top",
        "partial": "Log Entries",
        "signature": "LogEntries([LogEntry]-\u003e[LogEntry])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:LogEntry",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "LogEntry",
        "fct-source": "src/Top-Solver.html#LogEntry",
        "fct-type": "function",
        "title": "LogEntry"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "LogEntry",
        "normalized": "",
        "package": "Top",
        "partial": "Log Entry",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:SolveOptions_",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "SolveOptions_",
        "fct-source": "src/Top-Solver.html#SolveOptions",
        "fct-type": "function",
        "title": "SolveOptions_"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "SolveOptions_",
        "normalized": "",
        "package": "Top",
        "partial": "Solve Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:SolveResult",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "SolveResult",
        "fct-source": "src/Top-Solver.html#SolveResult",
        "fct-type": "function",
        "title": "SolveResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "SolveResult",
        "normalized": "",
        "package": "Top",
        "partial": "Solve Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:classEnvironment",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "ClassEnvironment",
        "fct-source": "src/Top-Solver.html#SolveOptions",
        "fct-type": "function",
        "title": "classEnvironment"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "classEnvironment",
        "normalized": "",
        "package": "Top",
        "partial": "Environment",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:combineResults",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "SolveResult info -\u003e SolveResult info -\u003e SolveResult info",
        "fct-source": "src/Top-Solver.html#combineResults",
        "fct-type": "function",
        "title": "combineResults"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "combineResults",
        "normalized": "SolveResult a-\u003eSolveResult a-\u003eSolveResult a",
        "package": "Top",
        "partial": "Results",
        "signature": "SolveResult info-\u003eSolveResult info-\u003eSolveResult info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:emptyResult",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e SolveResult info",
        "fct-source": "src/Top-Solver.html#emptyResult",
        "fct-type": "function",
        "title": "emptyResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "emptyResult",
        "normalized": "Int-\u003eSolveResult a",
        "package": "Top",
        "partial": "Result",
        "signature": "Int-\u003eSolveResult info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:errorsFromResult",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "[(info, ErrorLabel)]",
        "fct-source": "src/Top-Solver.html#SolveResult",
        "fct-type": "function",
        "title": "errorsFromResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "errorsFromResult",
        "normalized": "[(a,ErrorLabel)]",
        "package": "Top",
        "partial": "From Result",
        "signature": "[(info,ErrorLabel)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:evalBasicMonad",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "BasicMonad f a -\u003e (a, LogEntries)",
        "fct-source": "src/Top-Solver.html#evalBasicMonad",
        "fct-type": "function",
        "title": "evalBasicMonad"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "evalBasicMonad",
        "normalized": "BasicMonad a b-\u003e(b,LogEntries)",
        "package": "Top",
        "partial": "Basic Monad",
        "signature": "BasicMonad f a-\u003e(a,LogEntries)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:initialize",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "a -\u003e SolveOptions -\u003e m ()",
        "fct-source": "src/Top-Solver.html#initialize",
        "fct-type": "function",
        "title": "initialize"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "initialize",
        "normalized": "a-\u003eSolveOptions-\u003eb()",
        "package": "Top",
        "partial": "",
        "signature": "a-\u003eSolveOptions-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:logMsg",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "String -\u003e m ()",
        "fct-source": "src/Top-Solver.html#logMsg",
        "fct-type": "function",
        "title": "logMsg"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "logMsg",
        "normalized": "String-\u003ea()",
        "package": "Top",
        "partial": "Msg",
        "signature": "String-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:logMsgPrio",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e String -\u003e m ()",
        "fct-source": "src/Top-Solver.html#logMsgPrio",
        "fct-type": "function",
        "title": "logMsgPrio"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "logMsgPrio",
        "normalized": "Int-\u003eString-\u003ea()",
        "package": "Top",
        "partial": "Msg Prio",
        "signature": "Int-\u003eString-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:logState",
      "description": {
        "fct-descr": "\u003cp\u003ePrint the current state and add this as a debug message. \n\u003c/p\u003e",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "m ()",
        "fct-source": "src/Top-Solver.html#logState",
        "fct-type": "function",
        "title": "logState"
      },
      "index": {
        "description": "Print the current state and add this as debug message",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "logState",
        "normalized": "a()",
        "package": "Top",
        "partial": "State",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:makeConstraintSolver",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "(SolveOptions -\u003e [constraint] -\u003e BasicMonad f (SolveResult info)) -\u003e ConstraintSolver constraint info",
        "fct-source": "src/Top-Solver.html#makeConstraintSolver",
        "fct-type": "function",
        "title": "makeConstraintSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "makeConstraintSolver",
        "normalized": "(SolveOptions-\u003e[a]-\u003eBasicMonad b(SolveResult c))-\u003eConstraintSolver a c",
        "package": "Top",
        "partial": "Constraint Solver",
        "signature": "(SolveOptions-\u003e[constraint]-\u003eBasicMonad f(SolveResult info))-\u003eConstraintSolver constraint info"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:msg",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "String",
        "fct-source": "src/Top-Solver.html#LogEntry",
        "fct-type": "function",
        "title": "msg"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "msg",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:noLogEntries",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "LogEntries",
        "fct-source": "src/Top-Solver.html#noLogEntries",
        "fct-type": "function",
        "title": "noLogEntries"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "noLogEntries",
        "normalized": "",
        "package": "Top",
        "partial": "Log Entries",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:onlySolveConstraints",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "[constraint] -\u003e m ()",
        "fct-source": "src/Top-Solver.html#onlySolveConstraints",
        "fct-type": "function",
        "title": "onlySolveConstraints"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "onlySolveConstraints",
        "normalized": "[a]-\u003eb()",
        "package": "Top",
        "partial": "Solve Constraints",
        "signature": "[constraint]-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:priority",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Int",
        "fct-source": "src/Top-Solver.html#LogEntry",
        "fct-type": "function",
        "title": "priority"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "priority",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:qualifiersFromResult",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Predicates",
        "fct-source": "src/Top-Solver.html#SolveResult",
        "fct-type": "function",
        "title": "qualifiersFromResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "qualifiersFromResult",
        "normalized": "",
        "package": "Top",
        "partial": "From Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:setCheckConditions",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Bool",
        "fct-source": "src/Top-Solver.html#SolveOptions",
        "fct-type": "function",
        "title": "setCheckConditions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "setCheckConditions",
        "normalized": "",
        "package": "Top",
        "partial": "Check Conditions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:setStopAfterFirstError",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Bool",
        "fct-source": "src/Top-Solver.html#SolveOptions",
        "fct-type": "function",
        "title": "setStopAfterFirstError"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "setStopAfterFirstError",
        "normalized": "",
        "package": "Top",
        "partial": "Stop After First Error",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:singleEntry",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e String -\u003e LogEntries",
        "fct-source": "src/Top-Solver.html#singleEntry",
        "fct-type": "function",
        "title": "singleEntry"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "singleEntry",
        "normalized": "Int-\u003eString-\u003eLogEntries",
        "package": "Top",
        "partial": "Entry",
        "signature": "Int-\u003eString-\u003eLogEntries"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:solve",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "SolveOptions -\u003e [constraint] -\u003e ConstraintSolver constraint info -\u003e (SolveResult info, LogEntries)",
        "fct-source": "src/Top-Solver.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "solve",
        "normalized": "SolveOptions-\u003e[a]-\u003eConstraintSolver a b-\u003e(SolveResult b,LogEntries)",
        "package": "Top",
        "partial": "",
        "signature": "SolveOptions-\u003e[constraint]-\u003eConstraintSolver constraint info-\u003e(SolveResult info,LogEntries)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:solveConstraints",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "SolveOptions -\u003e [constraint] -\u003e m (SolveResult info)",
        "fct-source": "src/Top-Solver.html#solveConstraints",
        "fct-type": "function",
        "title": "solveConstraints"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "solveConstraints",
        "normalized": "SolveOptions-\u003e[a]-\u003eb(SolveResult c)",
        "package": "Top",
        "partial": "Constraints",
        "signature": "SolveOptions-\u003e[constraint]-\u003em(SolveResult info)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:solveOptions",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "SolveOptions",
        "fct-source": "src/Top-Solver.html#solveOptions",
        "fct-type": "function",
        "title": "solveOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "solveOptions",
        "normalized": "",
        "package": "Top",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:solveResult",
      "description": {
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "m (SolveResult info)",
        "fct-source": "src/Top-Solver.html#solveResult",
        "fct-type": "function",
        "title": "solveResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "solveResult",
        "normalized": "",
        "package": "Top",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:substitutionFromResult",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "FixpointSubstitution",
        "fct-source": "src/Top-Solver.html#SolveResult",
        "fct-type": "function",
        "title": "substitutionFromResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "substitutionFromResult",
        "normalized": "",
        "package": "Top",
        "partial": "From Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:typeSynonyms",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms",
        "fct-source": "src/Top-Solver.html#SolveOptions",
        "fct-type": "function",
        "title": "typeSynonyms"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "typeSynonyms",
        "normalized": "",
        "package": "Top",
        "partial": "Synonyms",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:typeschemesFromResult",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Map Int (Scheme Predicates)",
        "fct-source": "src/Top-Solver.html#SolveResult",
        "fct-type": "function",
        "title": "typeschemesFromResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "typeschemesFromResult",
        "normalized": "",
        "package": "Top",
        "partial": "From Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:uniqueCounter",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Int",
        "fct-source": "src/Top-Solver.html#SolveOptions",
        "fct-type": "function",
        "title": "uniqueCounter"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "uniqueCounter",
        "normalized": "",
        "package": "Top",
        "partial": "Counter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:uniqueFromResult",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Solver",
        "fct-package": "Top",
        "fct-signature": "Int",
        "fct-source": "src/Top-Solver.html#SolveResult",
        "fct-type": "function",
        "title": "uniqueFromResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Solver",
        "module": "Top.Solver",
        "name": "uniqueFromResult",
        "normalized": "",
        "package": "Top",
        "partial": "From Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType classes and the standard reduction instances. A part of the code\n was taken from the paper \u003ca\u003eTyping Haskell in Haskell\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Classes.html",
        "fct-type": "module",
        "title": "Classes"
      },
      "index": {
        "description": "Type classes and the standard reduction instances part of the code was taken from the paper Typing Haskell in Haskell",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "Classes",
        "normalized": "",
        "package": "Top",
        "partial": "Classes",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Class",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Classes.html#Class",
        "fct-type": "type",
        "title": "Class"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "Class",
        "normalized": "",
        "package": "Top",
        "partial": "Class",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:ClassEnvironment",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Classes.html#ClassEnvironment",
        "fct-type": "type",
        "title": "ClassEnvironment"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "ClassEnvironment",
        "normalized": "",
        "package": "Top",
        "partial": "Class Environment",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Instance",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Classes.html#Instance",
        "fct-type": "type",
        "title": "Instance"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "Instance",
        "normalized": "",
        "package": "Top",
        "partial": "Instance",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Instances",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Classes.html#Instances",
        "fct-type": "type",
        "title": "Instances"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "Instances",
        "normalized": "",
        "package": "Top",
        "partial": "Instances",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Predicate",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Types-Classes.html#Predicate",
        "fct-type": "data",
        "title": "Predicate"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "Predicate",
        "normalized": "",
        "package": "Top",
        "partial": "Predicate",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Predicates",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Classes.html#Predicates",
        "fct-type": "type",
        "title": "Predicates"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "Predicates",
        "normalized": "",
        "package": "Top",
        "partial": "Predicates",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:ReductionError",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Types-Classes.html#ReductionError",
        "fct-type": "newtype",
        "title": "ReductionError"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "ReductionError",
        "normalized": "",
        "package": "Top",
        "partial": "Reduction Error",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:Predicate",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "Predicate String Tp",
        "fct-source": "src/Top-Types-Classes.html#Predicate",
        "fct-type": "function",
        "title": "Predicate"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "Predicate",
        "normalized": "",
        "package": "Top",
        "partial": "Predicate",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:ReductionError",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "ReductionError a",
        "fct-source": "src/Top-Types-Classes.html#ReductionError",
        "fct-type": "function",
        "title": "ReductionError"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "ReductionError",
        "normalized": "",
        "package": "Top",
        "partial": "Reduction Error",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:associatedContextReduction",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e [(Predicate, a)] -\u003e ([(Predicate, a)], [ReductionError (Predicate, a)])",
        "fct-source": "src/Top-Types-Classes.html#associatedContextReduction",
        "fct-type": "function",
        "title": "associatedContextReduction"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "associatedContextReduction",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003e[(Predicate,a)]-\u003e([(Predicate,a)],[ReductionError(Predicate,a)])",
        "package": "Top",
        "partial": "Context Reduction",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003e[(Predicate,a)]-\u003e([(Predicate,a)],[ReductionError(Predicate,a)])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:byInstance",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicate -\u003e Maybe Predicates",
        "fct-source": "src/Top-Types-Classes.html#byInstance",
        "fct-type": "function",
        "title": "byInstance"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "byInstance",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicate-\u003eMaybe Predicates",
        "package": "Top",
        "partial": "Instance",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicate-\u003eMaybe Predicates"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:bySuperclass",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "ClassEnvironment -\u003e Predicate -\u003e Predicates",
        "fct-source": "src/Top-Types-Classes.html#bySuperclass",
        "fct-type": "function",
        "title": "bySuperclass"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "bySuperclass",
        "normalized": "ClassEnvironment-\u003ePredicate-\u003ePredicates",
        "package": "Top",
        "partial": "Superclass",
        "signature": "ClassEnvironment-\u003ePredicate-\u003ePredicates"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:contextReduction",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicates -\u003e (Predicates, [ReductionError Predicate])",
        "fct-source": "src/Top-Types-Classes.html#contextReduction",
        "fct-type": "function",
        "title": "contextReduction"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "contextReduction",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003e(Predicates,[ReductionError Predicate])",
        "package": "Top",
        "partial": "Reduction",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003e(Predicates,[ReductionError Predicate])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:emptyClassEnvironment",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty class environment\n\u003c/p\u003e",
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "ClassEnvironment",
        "fct-source": "src/Top-Types-Classes.html#emptyClassEnvironment",
        "fct-type": "function",
        "title": "emptyClassEnvironment"
      },
      "index": {
        "description": "The empty class environment",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "emptyClassEnvironment",
        "normalized": "",
        "package": "Top",
        "partial": "Class Environment",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:entail",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicates -\u003e Predicate -\u003e Bool",
        "fct-source": "src/Top-Types-Classes.html#entail",
        "fct-type": "function",
        "title": "entail"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "entail",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003ePredicate-\u003eBool",
        "package": "Top",
        "partial": "",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003ePredicate-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:entailList",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicates -\u003e Predicates -\u003e Bool",
        "fct-source": "src/Top-Types-Classes.html#entailList",
        "fct-type": "function",
        "title": "entailList"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "entailList",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003ePredicates-\u003eBool",
        "package": "Top",
        "partial": "List",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003ePredicates-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:inClassEnvironment",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "String -\u003e ClassEnvironment -\u003e Bool",
        "fct-source": "src/Top-Types-Classes.html#inClassEnvironment",
        "fct-type": "function",
        "title": "inClassEnvironment"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "inClassEnvironment",
        "normalized": "String-\u003eClassEnvironment-\u003eBool",
        "package": "Top",
        "partial": "Class Environment",
        "signature": "String-\u003eClassEnvironment-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:inHeadNormalForm",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "Predicate -\u003e Bool",
        "fct-source": "src/Top-Types-Classes.html#inHeadNormalForm",
        "fct-type": "function",
        "title": "inHeadNormalForm"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "inHeadNormalForm",
        "normalized": "Predicate-\u003eBool",
        "package": "Top",
        "partial": "Head Normal Form",
        "signature": "Predicate-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:insertInstance",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "String -\u003e Instance -\u003e ClassEnvironment -\u003e ClassEnvironment",
        "fct-source": "src/Top-Types-Classes.html#insertInstance",
        "fct-type": "function",
        "title": "insertInstance"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "insertInstance",
        "normalized": "String-\u003eInstance-\u003eClassEnvironment-\u003eClassEnvironment",
        "package": "Top",
        "partial": "Instance",
        "signature": "String-\u003eInstance-\u003eClassEnvironment-\u003eClassEnvironment"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:instances",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "String -\u003e ClassEnvironment -\u003e Instances",
        "fct-source": "src/Top-Types-Classes.html#instances",
        "fct-type": "function",
        "title": "instances"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "instances",
        "normalized": "String-\u003eClassEnvironment-\u003eInstances",
        "package": "Top",
        "partial": "",
        "signature": "String-\u003eClassEnvironment-\u003eInstances"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:listToHeadNormalForm",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicates -\u003e Maybe Predicates",
        "fct-source": "src/Top-Types-Classes.html#listToHeadNormalForm",
        "fct-type": "function",
        "title": "listToHeadNormalForm"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "listToHeadNormalForm",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003eMaybe Predicates",
        "package": "Top",
        "partial": "To Head Normal Form",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003eMaybe Predicates"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:matchPredicates",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Predicate -\u003e Predicate -\u003e Maybe MapSubstitution",
        "fct-source": "src/Top-Types-Classes.html#matchPredicates",
        "fct-type": "function",
        "title": "matchPredicates"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "matchPredicates",
        "normalized": "OrderedTypeSynonyms-\u003ePredicate-\u003ePredicate-\u003eMaybe MapSubstitution",
        "package": "Top",
        "partial": "Predicates",
        "signature": "OrderedTypeSynonyms-\u003ePredicate-\u003ePredicate-\u003eMaybe MapSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:scEntail",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "ClassEnvironment -\u003e Predicates -\u003e Predicate -\u003e Bool",
        "fct-source": "src/Top-Types-Classes.html#scEntail",
        "fct-type": "function",
        "title": "scEntail"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "scEntail",
        "normalized": "ClassEnvironment-\u003ePredicates-\u003ePredicate-\u003eBool",
        "package": "Top",
        "partial": "Entail",
        "signature": "ClassEnvironment-\u003ePredicates-\u003ePredicate-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:standardClasses",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "ClassEnvironment",
        "fct-source": "src/Top-Types-Classes.html#standardClasses",
        "fct-type": "function",
        "title": "standardClasses"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "standardClasses",
        "normalized": "",
        "package": "Top",
        "partial": "Classes",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:superclassPaths",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "String -\u003e String -\u003e ClassEnvironment -\u003e [[String]]",
        "fct-source": "src/Top-Types-Classes.html#superclassPaths",
        "fct-type": "function",
        "title": "superclassPaths"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "superclassPaths",
        "normalized": "String-\u003eString-\u003eClassEnvironment-\u003e[[String]]",
        "package": "Top",
        "partial": "Paths",
        "signature": "String-\u003eString-\u003eClassEnvironment-\u003e[[String]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:superclasses",
      "description": {
        "fct-descr": "\u003cp\u003eFor example, Eq is a superclass of Ord\n\u003c/p\u003e",
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "String -\u003e ClassEnvironment -\u003e [String]",
        "fct-source": "src/Top-Types-Classes.html#superclasses",
        "fct-type": "function",
        "title": "superclasses"
      },
      "index": {
        "description": "For example Eq is superclass of Ord",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "superclasses",
        "normalized": "String-\u003eClassEnvironment-\u003e[String]",
        "package": "Top",
        "partial": "",
        "signature": "String-\u003eClassEnvironment-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:toHeadNormalForm",
      "description": {
        "fct-module": "Top.Types.Classes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicate -\u003e Maybe Predicates",
        "fct-source": "src/Top-Types-Classes.html#toHeadNormalForm",
        "fct-type": "function",
        "title": "toHeadNormalForm"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Classes",
        "module": "Top.Types.Classes",
        "name": "toHeadNormalForm",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicate-\u003eMaybe Predicates",
        "package": "Top",
        "partial": "Head Normal Form",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicate-\u003eMaybe Predicates"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eKinds can be represented by a type.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Kinds",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Kinds.html",
        "fct-type": "module",
        "title": "Kinds"
      },
      "index": {
        "description": "Kinds can be represented by type",
        "hierarchy": "Top Types Kinds",
        "module": "Top.Types.Kinds",
        "name": "Kinds",
        "normalized": "",
        "package": "Top",
        "partial": "Kinds",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#t:Kind",
      "description": {
        "fct-module": "Top.Types.Kinds",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Kinds.html#Kind",
        "fct-type": "type",
        "title": "Kind"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Kinds",
        "module": "Top.Types.Kinds",
        "name": "Kind",
        "normalized": "",
        "package": "Top",
        "partial": "Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#t:KindScheme",
      "description": {
        "fct-module": "Top.Types.Kinds",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Kinds.html#KindScheme",
        "fct-type": "type",
        "title": "KindScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Kinds",
        "module": "Top.Types.Kinds",
        "name": "KindScheme",
        "normalized": "",
        "package": "Top",
        "partial": "Kind Scheme",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#t:Kinds",
      "description": {
        "fct-module": "Top.Types.Kinds",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Kinds.html#Kinds",
        "fct-type": "type",
        "title": "Kinds"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Kinds",
        "module": "Top.Types.Kinds",
        "name": "Kinds",
        "normalized": "",
        "package": "Top",
        "partial": "Kinds",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#v:defaultToStar",
      "description": {
        "fct-descr": "\u003cp\u003eIn traditional kind inference systems, a kind cannot contain variables.\n At some point in the inference process the kind variables are defaulted\n to star.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Kinds",
        "fct-package": "Top",
        "fct-signature": "Kind -\u003e Kind",
        "fct-source": "src/Top-Types-Kinds.html#defaultToStar",
        "fct-type": "function",
        "title": "defaultToStar"
      },
      "index": {
        "description": "In traditional kind inference systems kind cannot contain variables At some point in the inference process the kind variables are defaulted to star",
        "hierarchy": "Top Types Kinds",
        "module": "Top.Types.Kinds",
        "name": "defaultToStar",
        "normalized": "Kind-\u003eKind",
        "package": "Top",
        "partial": "To Star",
        "signature": "Kind-\u003eKind"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#v:showKind",
      "description": {
        "fct-descr": "\u003cp\u003eA function to show kinds.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Kinds",
        "fct-package": "Top",
        "fct-signature": "Kind -\u003e String",
        "fct-source": "src/Top-Types-Kinds.html#showKind",
        "fct-type": "function",
        "title": "showKind"
      },
      "index": {
        "description": "function to show kinds",
        "hierarchy": "Top Types Kinds",
        "module": "Top.Types.Kinds",
        "name": "showKind",
        "normalized": "Kind-\u003eString",
        "package": "Top",
        "partial": "Kind",
        "signature": "Kind-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#v:showKindScheme",
      "description": {
        "fct-module": "Top.Types.Kinds",
        "fct-package": "Top",
        "fct-signature": "KindScheme -\u003e String",
        "fct-source": "src/Top-Types-Kinds.html#showKindScheme",
        "fct-type": "function",
        "title": "showKindScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Kinds",
        "module": "Top.Types.Kinds",
        "name": "showKindScheme",
        "normalized": "KindScheme-\u003eString",
        "package": "Top",
        "partial": "Kind Scheme",
        "signature": "KindScheme-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#v:star",
      "description": {
        "fct-descr": "\u003cp\u003eStar is the kind of all values.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Kinds",
        "fct-package": "Top",
        "fct-signature": "Kind",
        "fct-source": "src/Top-Types-Kinds.html#star",
        "fct-type": "function",
        "title": "star"
      },
      "index": {
        "description": "Star is the kind of all values",
        "hierarchy": "Top Types Kinds",
        "module": "Top.Types.Kinds",
        "name": "star",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a data type to represent (plain) types, some basic \n functionality for types, and an instance for Show.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Primitive.html",
        "fct-type": "module",
        "title": "Primitive"
      },
      "index": {
        "description": "This module contains data type to represent plain types some basic functionality for types and an instance for Show",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "Primitive",
        "normalized": "",
        "package": "Top",
        "partial": "Primitive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#t:HasTypes",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Types-Primitive.html#HasTypes",
        "fct-type": "class",
        "title": "HasTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "HasTypes",
        "normalized": "",
        "package": "Top",
        "partial": "Has Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#t:Tp",
      "description": {
        "fct-descr": "\u003cp\u003eA data type to represent monotypes. Note that \u003ccode\u003eType\u003c/code\u003e is already in use\n in the Unified Haskell Architecture (UHA) which is used in the Helium compiler\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Types-Primitive.html#Tp",
        "fct-type": "data",
        "title": "Tp"
      },
      "index": {
        "description": "data type to represent monotypes Note that Type is already in use in the Unified Haskell Architecture UHA which is used in the Helium compiler",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "Tp",
        "normalized": "",
        "package": "Top",
        "partial": "Tp",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#t:Tps",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Primitive.html#Tps",
        "fct-type": "type",
        "title": "Tps"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "Tps",
        "normalized": "",
        "package": "Top",
        "partial": "Tps",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:.-45--62-.",
      "description": {
        "fct-descr": "\u003cp\u003eConstructs a function type from one type to another. This operator is\n left associative.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Tp -\u003e Tp",
        "fct-source": "src/Top-Types-Primitive.html#.-%3E.",
        "fct-type": "function",
        "title": "(.-\u003e.)"
      },
      "index": {
        "description": "Constructs function type from one type to another This operator is left associative",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "(.-\u003e.) .-\u003e.",
        "normalized": "Tp-\u003eTp-\u003eTp",
        "package": "Top",
        "partial": "",
        "signature": "Tp-\u003eTp-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:TApp",
      "description": {
        "fct-descr": "\u003cp\u003eThe application of two Top.Types. Not all types that can be\n constructed are well-formed.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "TApp Tp Tp",
        "fct-source": "src/Top-Types-Primitive.html#Tp",
        "fct-type": "function",
        "title": "TApp"
      },
      "index": {
        "description": "The application of two Top.Types Not all types that can be constructed are well-formed",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "TApp",
        "normalized": "",
        "package": "Top",
        "partial": "TApp",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:TCon",
      "description": {
        "fct-descr": "\u003cp\u003eA type constant is represented by a string.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "TCon String",
        "fct-source": "src/Top-Types-Primitive.html#Tp",
        "fct-type": "function",
        "title": "TCon"
      },
      "index": {
        "description": "type constant is represented by string",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "TCon",
        "normalized": "",
        "package": "Top",
        "partial": "TCon",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:TVar",
      "description": {
        "fct-descr": "\u003cp\u003eThe type variables are numbered.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "TVar Int",
        "fct-source": "src/Top-Types-Primitive.html#Tp",
        "fct-type": "function",
        "title": "TVar"
      },
      "index": {
        "description": "The type variables are numbered",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "TVar",
        "normalized": "",
        "package": "Top",
        "partial": "TVar",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:arityOfTp",
      "description": {
        "fct-descr": "\u003cp\u003eReturns the arity of a type, that is, the number of expected arguments.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Int",
        "fct-source": "src/Top-Types-Primitive.html#arityOfTp",
        "fct-type": "function",
        "title": "arityOfTp"
      },
      "index": {
        "description": "Returns the arity of type that is the number of expected arguments",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "arityOfTp",
        "normalized": "Tp-\u003eInt",
        "package": "Top",
        "partial": "Of Tp",
        "signature": "Tp-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:boolType",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp",
        "fct-source": "src/Top-Types-Primitive.html#intType",
        "fct-type": "function",
        "title": "boolType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "boolType",
        "normalized": "",
        "package": "Top",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:changeTypes",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "(Tp -\u003e Tp) -\u003e a -\u003e a",
        "fct-source": "src/Top-Types-Primitive.html#changeTypes",
        "fct-type": "method",
        "title": "changeTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "changeTypes",
        "normalized": "(Tp-\u003eTp)-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Types",
        "signature": "(Tp-\u003eTp)-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:charType",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp",
        "fct-source": "src/Top-Types-Primitive.html#intType",
        "fct-type": "function",
        "title": "charType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "charType",
        "normalized": "",
        "package": "Top",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:constantsInType",
      "description": {
        "fct-descr": "\u003cp\u003eReturns the list of type constants of a type. (no duplicates)\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e [String]",
        "fct-source": "src/Top-Types-Primitive.html#constantsInType",
        "fct-type": "function",
        "title": "constantsInType"
      },
      "index": {
        "description": "Returns the list of type constants of type no duplicates",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "constantsInType",
        "normalized": "Tp-\u003e[String]",
        "package": "Top",
        "partial": "In Type",
        "signature": "Tp-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:floatType",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp",
        "fct-source": "src/Top-Types-Primitive.html#intType",
        "fct-type": "function",
        "title": "floatType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "floatType",
        "normalized": "",
        "package": "Top",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:freezeVariablesInType",
      "description": {
        "fct-descr": "\u003cp\u003eAll the type variables in a type are frozen by turning them into a type\n constant. The integer numeral is prefixed with an underscore ('_').\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Tp",
        "fct-source": "src/Top-Types-Primitive.html#freezeVariablesInType",
        "fct-type": "function",
        "title": "freezeVariablesInType"
      },
      "index": {
        "description": "All the type variables in type are frozen by turning them into type constant The integer numeral is prefixed with an underscore",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "freezeVariablesInType",
        "normalized": "Tp-\u003eTp",
        "package": "Top",
        "partial": "Variables In Type",
        "signature": "Tp-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:functionSpine",
      "description": {
        "fct-descr": "\u003cp\u003eReturns the right spine of a function type. For instance,\n if type \u003ccode\u003et\u003c/code\u003e is \u003ccode\u003eInt -\u003e (Bool -\u003e String)\u003c/code\u003e, then \u003ccode\u003efunctionSpine t\u003c/code\u003e\n is \u003ccode\u003e([Int,Bool],String)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e (Tps, Tp)",
        "fct-source": "src/Top-Types-Primitive.html#functionSpine",
        "fct-type": "function",
        "title": "functionSpine"
      },
      "index": {
        "description": "Returns the right spine of function type For instance if type is Int Bool String then functionSpine is Int Bool String",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "functionSpine",
        "normalized": "Tp-\u003e(Tps,Tp)",
        "package": "Top",
        "partial": "Spine",
        "signature": "Tp-\u003e(Tps,Tp)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:functionSpineOfLength",
      "description": {
        "fct-descr": "\u003cp\u003eReturns the right spine of a function type of a maximal length.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Tp -\u003e (Tps, Tp)",
        "fct-source": "src/Top-Types-Primitive.html#functionSpineOfLength",
        "fct-type": "function",
        "title": "functionSpineOfLength"
      },
      "index": {
        "description": "Returns the right spine of function type of maximal length",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "functionSpineOfLength",
        "normalized": "Int-\u003eTp-\u003e(Tps,Tp)",
        "package": "Top",
        "partial": "Spine Of Length",
        "signature": "Int-\u003eTp-\u003e(Tps,Tp)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:getTypes",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "a -\u003e Tps",
        "fct-source": "src/Top-Types-Primitive.html#getTypes",
        "fct-type": "method",
        "title": "getTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "getTypes",
        "normalized": "a-\u003eTps",
        "package": "Top",
        "partial": "Types",
        "signature": "a-\u003eTps"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:intType",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp",
        "fct-source": "src/Top-Types-Primitive.html#intType",
        "fct-type": "function",
        "title": "intType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "intType",
        "normalized": "",
        "package": "Top",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:ioType",
      "description": {
        "fct-descr": "\u003cp\u003eFor instance, \u003ccode\u003e(ioType boolType)\u003c/code\u003e represents \u003ccode\u003e(IO Bool)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Tp",
        "fct-source": "src/Top-Types-Primitive.html#ioType",
        "fct-type": "function",
        "title": "ioType"
      },
      "index": {
        "description": "For instance ioType boolType represents IO Bool",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "ioType",
        "normalized": "Tp-\u003eTp",
        "package": "Top",
        "partial": "Type",
        "signature": "Tp-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isFunctionType",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Bool",
        "fct-source": "src/Top-Types-Primitive.html#isFunctionType",
        "fct-type": "function",
        "title": "isFunctionType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "isFunctionType",
        "normalized": "Tp-\u003eBool",
        "package": "Top",
        "partial": "Function Type",
        "signature": "Tp-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isIOType",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Bool",
        "fct-source": "src/Top-Types-Primitive.html#isIOType",
        "fct-type": "function",
        "title": "isIOType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "isIOType",
        "normalized": "Tp-\u003eBool",
        "package": "Top",
        "partial": "IOType",
        "signature": "Tp-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isTApp",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Bool",
        "fct-source": "src/Top-Types-Primitive.html#isTApp",
        "fct-type": "function",
        "title": "isTApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "isTApp",
        "normalized": "Tp-\u003eBool",
        "package": "Top",
        "partial": "TApp",
        "signature": "Tp-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isTCon",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Bool",
        "fct-source": "src/Top-Types-Primitive.html#isTCon",
        "fct-type": "function",
        "title": "isTCon"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "isTCon",
        "normalized": "Tp-\u003eBool",
        "package": "Top",
        "partial": "TCon",
        "signature": "Tp-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isTVar",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Bool",
        "fct-source": "src/Top-Types-Primitive.html#isTVar",
        "fct-type": "function",
        "title": "isTVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "isTVar",
        "normalized": "Tp-\u003eBool",
        "package": "Top",
        "partial": "TVar",
        "signature": "Tp-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isTupleConstructor",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "String -\u003e Bool",
        "fct-source": "src/Top-Types-Primitive.html#isTupleConstructor",
        "fct-type": "function",
        "title": "isTupleConstructor"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "isTupleConstructor",
        "normalized": "String-\u003eBool",
        "package": "Top",
        "partial": "Tuple Constructor",
        "signature": "String-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:leftSpine",
      "description": {
        "fct-descr": "\u003cp\u003eReturns the left spine of a type. For instance, if type \u003ccode\u003et\u003c/code\u003e\n is \u003ccode\u003eEither Bool [Int]\u003c/code\u003e, then \u003ccode\u003eleftSpine t\u003c/code\u003e is \u003ccode\u003e(Either,[Bool,[Int]])\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e (Tp, Tps)",
        "fct-source": "src/Top-Types-Primitive.html#leftSpine",
        "fct-type": "function",
        "title": "leftSpine"
      },
      "index": {
        "description": "Returns the left spine of type For instance if type is Either Bool Int then leftSpine is Either Bool Int",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "leftSpine",
        "normalized": "Tp-\u003e(Tp,Tps)",
        "package": "Top",
        "partial": "Spine",
        "signature": "Tp-\u003e(Tp,Tps)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:listType",
      "description": {
        "fct-descr": "\u003cp\u003eFor instance, \u003ccode\u003e(listType intType)\u003c/code\u003e represents \u003ccode\u003e[Int]\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Tp",
        "fct-source": "src/Top-Types-Primitive.html#listType",
        "fct-type": "function",
        "title": "listType"
      },
      "index": {
        "description": "For instance listType intType represents Int",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "listType",
        "normalized": "Tp-\u003eTp",
        "package": "Top",
        "partial": "Type",
        "signature": "Tp-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:priorityOfType",
      "description": {
        "fct-descr": "\u003cp\u003eThe priority of a type, primarily used for the insertion of parentheses \n in pretty printing.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Int",
        "fct-source": "src/Top-Types-Primitive.html#priorityOfType",
        "fct-type": "function",
        "title": "priorityOfType"
      },
      "index": {
        "description": "The priority of type primarily used for the insertion of parentheses in pretty printing",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "priorityOfType",
        "normalized": "Tp-\u003eInt",
        "package": "Top",
        "partial": "Of Type",
        "signature": "Tp-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:stringType",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp",
        "fct-source": "src/Top-Types-Primitive.html#intType",
        "fct-type": "function",
        "title": "stringType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "stringType",
        "normalized": "",
        "package": "Top",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:tpParser",
      "description": {
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "String -\u003e [(Tp, String)]",
        "fct-source": "src/Top-Types-Primitive.html#tpParser",
        "fct-type": "function",
        "title": "tpParser"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "tpParser",
        "normalized": "String-\u003e[(Tp,String)]",
        "package": "Top",
        "partial": "Parser",
        "signature": "String-\u003e[(Tp,String)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:tupleType",
      "description": {
        "fct-descr": "\u003cp\u003eA cathesian product of zero or more Top.Types. For instance,\n \u003ccode\u003e(tupleType [])\u003c/code\u003e represents \u003ccode\u003e()\u003c/code\u003e, and \u003ccode\u003e(tupleType [charType, stringType])\u003c/code\u003e\n represents \u003ccode\u003e(Char,String)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tps -\u003e Tp",
        "fct-source": "src/Top-Types-Primitive.html#tupleType",
        "fct-type": "function",
        "title": "tupleType"
      },
      "index": {
        "description": "cathesian product of zero or more Top.Types For instance tupleType represents and tupleType charType stringType represents Char String",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "tupleType",
        "normalized": "Tps-\u003eTp",
        "package": "Top",
        "partial": "Type",
        "signature": "Tps-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:unfreezeVariablesInType",
      "description": {
        "fct-descr": "\u003cp\u003eRecover the type variables that are frozen in a type.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Tp",
        "fct-source": "src/Top-Types-Primitive.html#unfreezeVariablesInType",
        "fct-type": "function",
        "title": "unfreezeVariablesInType"
      },
      "index": {
        "description": "Recover the type variables that are frozen in type",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "unfreezeVariablesInType",
        "normalized": "Tp-\u003eTp",
        "package": "Top",
        "partial": "Variables In Type",
        "signature": "Tp-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:variablesInType",
      "description": {
        "fct-descr": "\u003cp\u003eReturns the list of type variables of a type. (no duplicates)\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e [Int]",
        "fct-source": "src/Top-Types-Primitive.html#variablesInType",
        "fct-type": "function",
        "title": "variablesInType"
      },
      "index": {
        "description": "Returns the list of type variables of type no duplicates",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "variablesInType",
        "normalized": "Tp-\u003e[Int]",
        "package": "Top",
        "partial": "In Type",
        "signature": "Tp-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:voidType",
      "description": {
        "fct-descr": "\u003cp\u003eThe unit type. A special instance of of tuple type.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Primitive",
        "fct-package": "Top",
        "fct-signature": "Tp",
        "fct-source": "src/Top-Types-Primitive.html#voidType",
        "fct-type": "function",
        "title": "voidType"
      },
      "index": {
        "description": "The unit type special instance of of tuple type",
        "hierarchy": "Top Types Primitive",
        "module": "Top.Types.Primitive",
        "name": "voidType",
        "normalized": "",
        "package": "Top",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eQualification of types (for instance, predicates to deal with type classes).\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Qualification.html",
        "fct-type": "module",
        "title": "Qualification"
      },
      "index": {
        "description": "Qualification of types for instance predicates to deal with type classes",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "Qualification",
        "normalized": "",
        "package": "Top",
        "partial": "Qualification",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#t:Qualification",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Types-Qualification.html#Qualification",
        "fct-type": "newtype",
        "title": "Qualification"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "Qualification",
        "normalized": "",
        "package": "Top",
        "partial": "Qualification",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#t:ShowQualifiers",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Types-Qualification.html#ShowQualifiers",
        "fct-type": "class",
        "title": "ShowQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "ShowQualifiers",
        "normalized": "",
        "package": "Top",
        "partial": "Show Qualifiers",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:.-61--62-.",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "q -\u003e a -\u003e Qualification q a",
        "fct-source": "src/Top-Types-Qualification.html#.%3D%3E.",
        "fct-type": "function",
        "title": "(.=\u003e.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "(.=\u003e.) .=\u003e.",
        "normalized": "a-\u003eb-\u003eQualification a b",
        "package": "Top",
        "partial": "",
        "signature": "q-\u003ea-\u003eQualification q a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:Qualification",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "Qualification (q, a)",
        "fct-source": "src/Top-Types-Qualification.html#Qualification",
        "fct-type": "function",
        "title": "Qualification"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "Qualification",
        "normalized": "Qualification(a,b)",
        "package": "Top",
        "partial": "Qualification",
        "signature": "Qualification(q,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:qualifiers",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "Qualification q a -\u003e q",
        "fct-source": "src/Top-Types-Qualification.html#qualifiers",
        "fct-type": "function",
        "title": "qualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "qualifiers",
        "normalized": "Qualification a b-\u003ea",
        "package": "Top",
        "partial": "",
        "signature": "Qualification q a-\u003eq"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:qualify",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "context -\u003e [q] -\u003e a -\u003e Qualification [q] a",
        "fct-source": "src/Top-Types-Qualification.html#qualify",
        "fct-type": "function",
        "title": "qualify"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "qualify",
        "normalized": "a-\u003e[b]-\u003ec-\u003eQualification[b]c",
        "package": "Top",
        "partial": "",
        "signature": "context-\u003e[q]-\u003ea-\u003eQualification[q]a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:showContext",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Top-Types-Qualification.html#showContext",
        "fct-type": "function",
        "title": "showContext"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "showContext",
        "normalized": "a-\u003eString",
        "package": "Top",
        "partial": "Context",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:showContextSimple",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "[String] -\u003e String",
        "fct-source": "src/Top-Types-Qualification.html#showContextSimple",
        "fct-type": "function",
        "title": "showContextSimple"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "showContextSimple",
        "normalized": "[String]-\u003eString",
        "package": "Top",
        "partial": "Context Simple",
        "signature": "[String]-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:showQualifiers",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "a -\u003e [String]",
        "fct-source": "src/Top-Types-Qualification.html#showQualifiers",
        "fct-type": "method",
        "title": "showQualifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "showQualifiers",
        "normalized": "a-\u003e[String]",
        "package": "Top",
        "partial": "Qualifiers",
        "signature": "a-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:split",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "Qualification q a -\u003e (q, a)",
        "fct-source": "src/Top-Types-Qualification.html#split",
        "fct-type": "function",
        "title": "split"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "split",
        "normalized": "Qualification a b-\u003e(a,b)",
        "package": "Top",
        "partial": "",
        "signature": "Qualification q a-\u003e(q,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:unqualify",
      "description": {
        "fct-module": "Top.Types.Qualification",
        "fct-package": "Top",
        "fct-signature": "Qualification q a -\u003e a",
        "fct-source": "src/Top-Types-Qualification.html#unqualify",
        "fct-type": "function",
        "title": "unqualify"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Qualification",
        "module": "Top.Types.Qualification",
        "name": "unqualify",
        "normalized": "Qualification a b-\u003eb",
        "package": "Top",
        "partial": "",
        "signature": "Qualification q a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUniversal and existential quantification of types\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Quantification.html",
        "fct-type": "module",
        "title": "Quantification"
      },
      "index": {
        "description": "Universal and existential quantification of types",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "Quantification",
        "normalized": "",
        "package": "Top",
        "partial": "Quantification",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Existential",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Types-Quantification.html#Existential",
        "fct-type": "data",
        "title": "Existential"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "Existential",
        "normalized": "",
        "package": "Top",
        "partial": "Existential",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Exists",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Quantification.html#Exists",
        "fct-type": "type",
        "title": "Exists"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "Exists",
        "normalized": "",
        "package": "Top",
        "partial": "Exists",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Forall",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Quantification.html#Forall",
        "fct-type": "type",
        "title": "Forall"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "Forall",
        "normalized": "",
        "package": "Top",
        "partial": "Forall",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:HasSkolems",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Types-Quantification.html#HasSkolems",
        "fct-type": "class",
        "title": "HasSkolems"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "HasSkolems",
        "normalized": "",
        "package": "Top",
        "partial": "Has Skolems",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Quantification",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Types-Quantification.html#Quantification",
        "fct-type": "newtype",
        "title": "Quantification"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "Quantification",
        "normalized": "",
        "package": "Top",
        "partial": "Quantification",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:QuantorMap",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Quantification.html#QuantorMap",
        "fct-type": "type",
        "title": "QuantorMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "QuantorMap",
        "normalized": "",
        "package": "Top",
        "partial": "Quantor Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:ShowQuantorOptions",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
        "fct-type": "data",
        "title": "ShowQuantorOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "ShowQuantorOptions",
        "normalized": "",
        "package": "Top",
        "partial": "Show Quantor Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:ShowQuantors",
      "description": {
        "fct-descr": "\u003cp\u003eThis class can deal with the pretty printing of (possibly nested) quantifiers.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Types-Quantification.html#ShowQuantors",
        "fct-type": "class",
        "title": "ShowQuantors"
      },
      "index": {
        "description": "This class can deal with the pretty printing of possibly nested quantifiers",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "ShowQuantors",
        "normalized": "",
        "package": "Top",
        "partial": "Show Quantors",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Universal",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Types-Quantification.html#Universal",
        "fct-type": "data",
        "title": "Universal"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "Universal",
        "normalized": "",
        "package": "Top",
        "partial": "Universal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:Quantification",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Quantification ([Int], QuantorMap, a)",
        "fct-source": "src/Top-Types-Quantification.html#Quantification",
        "fct-type": "function",
        "title": "Quantification"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "Quantification",
        "normalized": "Quantification([Int],QuantorMap,a)",
        "package": "Top",
        "partial": "Quantification",
        "signature": "Quantification([Int],QuantorMap,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:ShowQuantorOptions",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "ShowQuantorOptions",
        "fct-source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
        "fct-type": "function",
        "title": "ShowQuantorOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "ShowQuantorOptions",
        "normalized": "",
        "package": "Top",
        "partial": "Show Quantor Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:allSkolems",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "a -\u003e [Int]",
        "fct-source": "src/Top-Types-Quantification.html#allSkolems",
        "fct-type": "method",
        "title": "allSkolems"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "allSkolems",
        "normalized": "a-\u003e[Int]",
        "package": "Top",
        "partial": "Skolems",
        "signature": "a-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:bindSkolemConstants",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e a -\u003e Quantification q a",
        "fct-source": "src/Top-Types-Quantification.html#bindSkolemConstants",
        "fct-type": "function",
        "title": "bindSkolemConstants"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "bindSkolemConstants",
        "normalized": "[Int]-\u003ea-\u003eQuantification b a",
        "package": "Top",
        "partial": "Skolem Constants",
        "signature": "[Int]-\u003ea-\u003eQuantification q a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:bindTypeVariables",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e a -\u003e Quantification q a",
        "fct-source": "src/Top-Types-Quantification.html#bindTypeVariables",
        "fct-type": "function",
        "title": "bindTypeVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "bindTypeVariables",
        "normalized": "[Int]-\u003ea-\u003eQuantification b a",
        "package": "Top",
        "partial": "Type Variables",
        "signature": "[Int]-\u003ea-\u003eQuantification q a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:changeSkolems",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[(Int, Tp)] -\u003e a -\u003e a",
        "fct-source": "src/Top-Types-Quantification.html#changeSkolems",
        "fct-type": "method",
        "title": "changeSkolems"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "changeSkolems",
        "normalized": "[(Int,Tp)]-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Skolems",
        "signature": "[(Int,Tp)]-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:close",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e a -\u003e Exists a",
        "fct-source": "src/Top-Types-Quantification.html#close",
        "fct-type": "function",
        "title": "close"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "close",
        "normalized": "[Int]-\u003ea-\u003eExists a",
        "package": "Top",
        "partial": "",
        "signature": "[Int]-\u003ea-\u003eExists a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:defaultOptions",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "ShowQuantorOptions",
        "fct-source": "src/Top-Types-Quantification.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "defaultOptions",
        "normalized": "",
        "package": "Top",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:dontUseIdentifiers",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[String]",
        "fct-source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
        "fct-type": "function",
        "title": "dontUseIdentifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "dontUseIdentifiers",
        "normalized": "[String]",
        "package": "Top",
        "partial": "Use Identifiers",
        "signature": "[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:fromSkolemString",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "String -\u003e Maybe Int",
        "fct-source": "src/Top-Types-Quantification.html#fromSkolemString",
        "fct-type": "function",
        "title": "fromSkolemString"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "fromSkolemString",
        "normalized": "String-\u003eMaybe Int",
        "package": "Top",
        "partial": "Skolem String",
        "signature": "String-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:generalize",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "context -\u003e a -\u003e Forall a",
        "fct-source": "src/Top-Types-Quantification.html#generalize",
        "fct-type": "function",
        "title": "generalize"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "generalize",
        "normalized": "a-\u003eb-\u003eForall b",
        "package": "Top",
        "partial": "",
        "signature": "context-\u003ea-\u003eForall a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:generalizeAll",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "a -\u003e Forall a",
        "fct-source": "src/Top-Types-Quantification.html#generalizeAll",
        "fct-type": "function",
        "title": "generalizeAll"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "generalizeAll",
        "normalized": "a-\u003eForall a",
        "package": "Top",
        "partial": "All",
        "signature": "a-\u003eForall a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:getQuantorMap",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Quantification q a -\u003e QuantorMap",
        "fct-source": "src/Top-Types-Quantification.html#getQuantorMap",
        "fct-type": "function",
        "title": "getQuantorMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "getQuantorMap",
        "normalized": "Quantification a b-\u003eQuantorMap",
        "package": "Top",
        "partial": "Quantor Map",
        "signature": "Quantification q a-\u003eQuantorMap"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:instantiate",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Forall a -\u003e (Int, a)",
        "fct-source": "src/Top-Types-Quantification.html#instantiate",
        "fct-type": "function",
        "title": "instantiate"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "instantiate",
        "normalized": "Int-\u003eForall a-\u003e(Int,a)",
        "package": "Top",
        "partial": "",
        "signature": "Int-\u003eForall a-\u003e(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:introduceSkolemConstants",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Quantification q a -\u003e (Int, a)",
        "fct-source": "src/Top-Types-Quantification.html#introduceSkolemConstants",
        "fct-type": "function",
        "title": "introduceSkolemConstants"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "introduceSkolemConstants",
        "normalized": "Int-\u003eQuantification a b-\u003e(Int,b)",
        "package": "Top",
        "partial": "Skolem Constants",
        "signature": "Int-\u003eQuantification q a-\u003e(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:introduceTypeVariables",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Quantification q a -\u003e (Int, a)",
        "fct-source": "src/Top-Types-Quantification.html#introduceTypeVariables",
        "fct-type": "function",
        "title": "introduceTypeVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "introduceTypeVariables",
        "normalized": "Int-\u003eQuantification a b-\u003e(Int,b)",
        "package": "Top",
        "partial": "Type Variables",
        "signature": "Int-\u003eQuantification q a-\u003e(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:makeSkolemConstant",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Tp",
        "fct-source": "src/Top-Types-Quantification.html#makeSkolemConstant",
        "fct-type": "function",
        "title": "makeSkolemConstant"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "makeSkolemConstant",
        "normalized": "Int-\u003eTp",
        "package": "Top",
        "partial": "Skolem Constant",
        "signature": "Int-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:noQuantifiers",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "a -\u003e Quantification q a",
        "fct-source": "src/Top-Types-Quantification.html#noQuantifiers",
        "fct-type": "function",
        "title": "noQuantifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "noQuantifiers",
        "normalized": "a-\u003eQuantification b a",
        "package": "Top",
        "partial": "Quantifiers",
        "signature": "a-\u003eQuantification q a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:open",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Exists a -\u003e (Int, a)",
        "fct-source": "src/Top-Types-Quantification.html#open",
        "fct-type": "function",
        "title": "open"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "open",
        "normalized": "Int-\u003eExists a-\u003e(Int,a)",
        "package": "Top",
        "partial": "",
        "signature": "Int-\u003eExists a-\u003e(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:quantifiers",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Quantification q a -\u003e [Int]",
        "fct-source": "src/Top-Types-Quantification.html#quantifiers",
        "fct-type": "function",
        "title": "quantifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "quantifiers",
        "normalized": "Quantification a b-\u003e[Int]",
        "package": "Top",
        "partial": "",
        "signature": "Quantification q a-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:quantify",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e a -\u003e Forall a",
        "fct-source": "src/Top-Types-Quantification.html#quantify",
        "fct-type": "function",
        "title": "quantify"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "quantify",
        "normalized": "[Int]-\u003ea-\u003eForall a",
        "package": "Top",
        "partial": "",
        "signature": "[Int]-\u003ea-\u003eForall a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:reveal",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Exists a -\u003e (Int, a)",
        "fct-source": "src/Top-Types-Quantification.html#open",
        "fct-type": "function",
        "title": "reveal"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "reveal",
        "normalized": "Int-\u003eExists a-\u003e(Int,a)",
        "package": "Top",
        "partial": "",
        "signature": "Int-\u003eExists a-\u003e(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showAllTheSame",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Bool",
        "fct-source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
        "fct-type": "function",
        "title": "showAllTheSame"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "showAllTheSame",
        "normalized": "",
        "package": "Top",
        "partial": "All The Same",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showQuantor",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Quantification q a -\u003e String",
        "fct-source": "src/Top-Types-Quantification.html#showQuantor",
        "fct-type": "function",
        "title": "showQuantor"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "showQuantor",
        "normalized": "Quantification a b-\u003eString",
        "package": "Top",
        "partial": "Quantor",
        "signature": "Quantification q a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showQuantors",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Top-Types-Quantification.html#showQuantors",
        "fct-type": "function",
        "title": "showQuantors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "showQuantors",
        "normalized": "a-\u003eString",
        "package": "Top",
        "partial": "Quantors",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showQuantorsWithout",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "ShowQuantorOptions -\u003e a -\u003e String",
        "fct-source": "src/Top-Types-Quantification.html#showQuantorsWithout",
        "fct-type": "method",
        "title": "showQuantorsWithout"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "showQuantorsWithout",
        "normalized": "ShowQuantorOptions-\u003ea-\u003eString",
        "package": "Top",
        "partial": "Quantors Without",
        "signature": "ShowQuantorOptions-\u003ea-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showTopLevelQuantors",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Bool",
        "fct-source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
        "fct-type": "function",
        "title": "showTopLevelQuantors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "showTopLevelQuantors",
        "normalized": "",
        "package": "Top",
        "partial": "Top Level Quantors",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:skolemPrefix",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "String",
        "fct-source": "src/Top-Types-Quantification.html#skolemPrefix",
        "fct-type": "function",
        "title": "skolemPrefix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "skolemPrefix",
        "normalized": "",
        "package": "Top",
        "partial": "Prefix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:skolemize",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Forall a -\u003e (Int, a)",
        "fct-source": "src/Top-Types-Quantification.html#instantiate",
        "fct-type": "function",
        "title": "skolemize"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "skolemize",
        "normalized": "Int-\u003eForall a-\u003e(Int,a)",
        "package": "Top",
        "partial": "",
        "signature": "Int-\u003eForall a-\u003e(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:skolemizeFTV",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "a -\u003e a",
        "fct-source": "src/Top-Types-Quantification.html#skolemizeFTV",
        "fct-type": "function",
        "title": "skolemizeFTV"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "skolemizeFTV",
        "normalized": "a-\u003ea",
        "package": "Top",
        "partial": "FTV",
        "signature": "a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:unquantify",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Quantification q a -\u003e a",
        "fct-source": "src/Top-Types-Quantification.html#unquantify",
        "fct-type": "function",
        "title": "unquantify"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "unquantify",
        "normalized": "Quantification a b-\u003eb",
        "package": "Top",
        "partial": "",
        "signature": "Quantification q a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:unreveal",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e a -\u003e Exists a",
        "fct-source": "src/Top-Types-Quantification.html#unreveal",
        "fct-type": "function",
        "title": "unreveal"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "unreveal",
        "normalized": "[Int]-\u003ea-\u003eExists a",
        "package": "Top",
        "partial": "",
        "signature": "[Int]-\u003ea-\u003eExists a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:unskolemize",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e a -\u003e Forall a",
        "fct-source": "src/Top-Types-Quantification.html#unskolemize",
        "fct-type": "function",
        "title": "unskolemize"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "unskolemize",
        "normalized": "[Int]-\u003ea-\u003eForall a",
        "package": "Top",
        "partial": "",
        "signature": "[Int]-\u003ea-\u003eForall a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:useTheNameMap",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Bool",
        "fct-source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
        "fct-type": "function",
        "title": "useTheNameMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "useTheNameMap",
        "normalized": "",
        "package": "Top",
        "partial": "The Name Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:variableList",
      "description": {
        "fct-descr": "\u003cp\u003eList of unique identifiers.(a, b, .., z, a1, b1 .., z1, a2, ..)\n\u003c/p\u003e",
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "[String]",
        "fct-source": "src/Top-Types-Quantification.html#variableList",
        "fct-type": "function",
        "title": "variableList"
      },
      "index": {
        "description": "List of unique identifiers a1 b1 z1 a2",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "variableList",
        "normalized": "[String]",
        "package": "Top",
        "partial": "List",
        "signature": "[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:variablePrefix",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "String",
        "fct-source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
        "fct-type": "function",
        "title": "variablePrefix"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "variablePrefix",
        "normalized": "",
        "package": "Top",
        "partial": "Prefix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:withoutQuantors",
      "description": {
        "fct-module": "Top.Types.Quantification",
        "fct-package": "Top",
        "fct-signature": "Quantification q a -\u003e Bool",
        "fct-source": "src/Top-Types-Quantification.html#withoutQuantors",
        "fct-type": "function",
        "title": "withoutQuantors"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Quantification",
        "module": "Top.Types.Quantification",
        "name": "withoutQuantors",
        "normalized": "Quantification a b-\u003eBool",
        "package": "Top",
        "partial": "Quantors",
        "signature": "Quantification q a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA representation of type schemes. A type scheme is a (qualified) type\n with a number of quantifiers (foralls) in front of it. A partial mapping \n from type variable (Int) to their name (String) is preserved.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Schemes.html",
        "fct-type": "module",
        "title": "Schemes"
      },
      "index": {
        "description": "representation of type schemes type scheme is qualified type with number of quantifiers foralls in front of it partial mapping from type variable Int to their name String is preserved",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "Schemes",
        "normalized": "",
        "package": "Top",
        "partial": "Schemes",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:IsSigmaPreds",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Types-Schemes.html#IsSigmaPreds",
        "fct-type": "class",
        "title": "IsSigmaPreds"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "IsSigmaPreds",
        "normalized": "",
        "package": "Top",
        "partial": "Is Sigma Preds",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:IsTpScheme",
      "description": {
        "fct-descr": "\u003cp\u003eA type class to convert something into a type scheme\n\u003c/p\u003e",
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Types-Schemes.html#IsTpScheme",
        "fct-type": "class",
        "title": "IsTpScheme"
      },
      "index": {
        "description": "type class to convert something into type scheme",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "IsTpScheme",
        "normalized": "",
        "package": "Top",
        "partial": "Is Tp Scheme",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:QType",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Schemes.html#QType",
        "fct-type": "type",
        "title": "QType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "QType",
        "normalized": "",
        "package": "Top",
        "partial": "QType",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:Scheme",
      "description": {
        "fct-descr": "\u003cp\u003eA sigma is a type scheme or a type scheme variable\n\u003c/p\u003e",
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Schemes.html#Scheme",
        "fct-type": "type",
        "title": "Scheme"
      },
      "index": {
        "description": "sigma is type scheme or type scheme variable",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "Scheme",
        "normalized": "",
        "package": "Top",
        "partial": "Scheme",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:Sigma",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Types-Schemes.html#Sigma",
        "fct-type": "data",
        "title": "Sigma"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "Sigma",
        "normalized": "",
        "package": "Top",
        "partial": "Sigma",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:SigmaPreds",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Schemes.html#SigmaPreds",
        "fct-type": "type",
        "title": "SigmaPreds"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "SigmaPreds",
        "normalized": "",
        "package": "Top",
        "partial": "Sigma Preds",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:SigmaVar",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Schemes.html#SigmaVar",
        "fct-type": "type",
        "title": "SigmaVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "SigmaVar",
        "normalized": "",
        "package": "Top",
        "partial": "Sigma Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:TpScheme",
      "description": {
        "fct-descr": "\u003cp\u003eA type scheme consists of a list of quantified type variables, a finite map \n that partially maps these type variables to their original identifier, and a\n qualified type.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Schemes.html#TpScheme",
        "fct-type": "type",
        "title": "TpScheme"
      },
      "index": {
        "description": "type scheme consists of list of quantified type variables finite map that partially maps these type variables to their original identifier and qualified type",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "TpScheme",
        "normalized": "",
        "package": "Top",
        "partial": "Tp Scheme",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:TpSchemeMap",
      "description": {
        "fct-descr": "\u003cp\u003eA substitution for type scheme variables\n\u003c/p\u003e",
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Schemes.html#TpSchemeMap",
        "fct-type": "type",
        "title": "TpSchemeMap"
      },
      "index": {
        "description": "substitution for type scheme variables",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "TpSchemeMap",
        "normalized": "",
        "package": "Top",
        "partial": "Tp Scheme Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:SigmaScheme",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "SigmaScheme (Scheme qs)",
        "fct-source": "src/Top-Types-Schemes.html#Sigma",
        "fct-type": "function",
        "title": "SigmaScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "SigmaScheme",
        "normalized": "",
        "package": "Top",
        "partial": "Sigma Scheme",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:SigmaVar",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "SigmaVar SigmaVar",
        "fct-source": "src/Top-Types-Schemes.html#Sigma",
        "fct-type": "function",
        "title": "SigmaVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "SigmaVar",
        "normalized": "",
        "package": "Top",
        "partial": "Sigma Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:arityOfTpScheme",
      "description": {
        "fct-descr": "\u003cp\u003eDetermine the arity of a type scheme.    \n\u003c/p\u003e",
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "TpScheme -\u003e Int",
        "fct-source": "src/Top-Types-Schemes.html#arityOfTpScheme",
        "fct-type": "function",
        "title": "arityOfTpScheme"
      },
      "index": {
        "description": "Determine the arity of type scheme",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "arityOfTpScheme",
        "normalized": "TpScheme-\u003eInt",
        "package": "Top",
        "partial": "Of Tp Scheme",
        "signature": "TpScheme-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:genericInstanceOf",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e TpScheme -\u003e TpScheme -\u003e Bool",
        "fct-source": "src/Top-Types-Schemes.html#genericInstanceOf",
        "fct-type": "function",
        "title": "genericInstanceOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "genericInstanceOf",
        "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003eTpScheme-\u003eTpScheme-\u003eBool",
        "package": "Top",
        "partial": "Instance Of",
        "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003eTpScheme-\u003eTpScheme-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:instantiateWithNameMap",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e TpScheme -\u003e (Int, Predicates, Tp)",
        "fct-source": "src/Top-Types-Schemes.html#instantiateWithNameMap",
        "fct-type": "function",
        "title": "instantiateWithNameMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "instantiateWithNameMap",
        "normalized": "Int-\u003eTpScheme-\u003e(Int,Predicates,Tp)",
        "package": "Top",
        "partial": "With Name Map",
        "signature": "Int-\u003eTpScheme-\u003e(Int,Predicates,Tp)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:isOverloaded",
      "description": {
        "fct-descr": "\u003cp\u003eIs the type scheme overloaded (does it contain predicates)?\n\u003c/p\u003e",
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "TpScheme -\u003e Bool",
        "fct-source": "src/Top-Types-Schemes.html#isOverloaded",
        "fct-type": "function",
        "title": "isOverloaded"
      },
      "index": {
        "description": "Is the type scheme overloaded does it contain predicates",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "isOverloaded",
        "normalized": "TpScheme-\u003eBool",
        "package": "Top",
        "partial": "Overloaded",
        "signature": "TpScheme-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:makeScheme",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e Predicates -\u003e Tp -\u003e TpScheme",
        "fct-source": "src/Top-Types-Schemes.html#makeScheme",
        "fct-type": "function",
        "title": "makeScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "makeScheme",
        "normalized": "[Int]-\u003ePredicates-\u003eTp-\u003eTpScheme",
        "package": "Top",
        "partial": "Scheme",
        "signature": "[Int]-\u003ePredicates-\u003eTp-\u003eTpScheme"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:toSigmaPreds",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "a -\u003e SigmaPreds",
        "fct-source": "src/Top-Types-Schemes.html#toSigmaPreds",
        "fct-type": "method",
        "title": "toSigmaPreds"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "toSigmaPreds",
        "normalized": "a-\u003eSigmaPreds",
        "package": "Top",
        "partial": "Sigma Preds",
        "signature": "a-\u003eSigmaPreds"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:toTpScheme",
      "description": {
        "fct-module": "Top.Types.Schemes",
        "fct-package": "Top",
        "fct-signature": "a -\u003e TpScheme",
        "fct-source": "src/Top-Types-Schemes.html#toTpScheme",
        "fct-type": "method",
        "title": "toTpScheme"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Schemes",
        "module": "Top.Types.Schemes",
        "name": "toTpScheme",
        "normalized": "a-\u003eTpScheme",
        "package": "Top",
        "partial": "Tp Scheme",
        "signature": "a-\u003eTpScheme"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a data type to represent (plain) types, some basic \n functionality for types, and an instance for Show.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Substitution.html",
        "fct-type": "module",
        "title": "Substitution"
      },
      "index": {
        "description": "This module contains data type to represent plain types some basic functionality for types and an instance for Show",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "Substitution",
        "normalized": "",
        "package": "Top",
        "partial": "Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:FixpointSubstitution",
      "description": {
        "fct-descr": "\u003cp\u003eA fixpoint is computed when looking up the target of a type variable in this substitution. \n Combining two substitutions is cheap, whereas a lookup is more expensive than the \n normal finite map substitution.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "newtype",
        "fct-source": "src/Top-Types-Substitution.html#FixpointSubstitution",
        "fct-type": "newtype",
        "title": "FixpointSubstitution"
      },
      "index": {
        "description": "fixpoint is computed when looking up the target of type variable in this substitution Combining two substitutions is cheap whereas lookup is more expensive than the normal finite map substitution",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "FixpointSubstitution",
        "normalized": "",
        "package": "Top",
        "partial": "Fixpoint Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:MapSubstitution",
      "description": {
        "fct-descr": "\u003cp\u003eA substitution represented by a finite map.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Substitution.html#MapSubstitution",
        "fct-type": "type",
        "title": "MapSubstitution"
      },
      "index": {
        "description": "substitution represented by finite map",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "MapSubstitution",
        "normalized": "",
        "package": "Top",
        "partial": "Map Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:Substitutable",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Types-Substitution.html#Substitutable",
        "fct-type": "class",
        "title": "Substitutable"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "Substitutable",
        "normalized": "",
        "package": "Top",
        "partial": "Substitutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:Substitution",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Types-Substitution.html#Substitution",
        "fct-type": "class",
        "title": "Substitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "Substitution",
        "normalized": "",
        "package": "Top",
        "partial": "Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:WrappedSubstitution",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Types-Substitution.html#WrappedSubstitution",
        "fct-type": "data",
        "title": "WrappedSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "WrappedSubstitution",
        "normalized": "",
        "package": "Top",
        "partial": "Wrapped Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:-124--45--62-",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "s -\u003e a -\u003e a",
        "fct-source": "src/Top-Types-Substitution.html#%7C-%3E",
        "fct-type": "method",
        "title": "(|-\u003e)"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "(|-\u003e) |-\u003e",
        "normalized": "a-\u003eb-\u003eb",
        "package": "Top",
        "partial": "",
        "signature": "s-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:-64--64-",
      "description": {
        "fct-descr": "\u003cp\u003eCompose two finite map substitutions: safe.\n Note for \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e: bindings in right argument shadow those in the left\n\u003c/p\u003e",
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "MapSubstitution -\u003e MapSubstitution -\u003e MapSubstitution",
        "fct-source": "src/Top-Types-Substitution.html#%40%40",
        "fct-type": "function",
        "title": "(@@)"
      },
      "index": {
        "description": "Compose two finite map substitutions safe Note for union bindings in right argument shadow those in the left",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "(@@) @@",
        "normalized": "MapSubstitution-\u003eMapSubstitution-\u003eMapSubstitution",
        "package": "Top",
        "partial": "",
        "signature": "MapSubstitution-\u003eMapSubstitution-\u003eMapSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:-64--64--64-",
      "description": {
        "fct-descr": "\u003cp\u003eCompose two finite map substitutions: quick and dirty!\n\u003c/p\u003e",
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "MapSubstitution -\u003e MapSubstitution -\u003e MapSubstitution",
        "fct-source": "src/Top-Types-Substitution.html#%40%40%40",
        "fct-type": "function",
        "title": "(@@@)"
      },
      "index": {
        "description": "Compose two finite map substitutions quick and dirty",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "(@@@) @@@",
        "normalized": "MapSubstitution-\u003eMapSubstitution-\u003eMapSubstitution",
        "package": "Top",
        "partial": "",
        "signature": "MapSubstitution-\u003eMapSubstitution-\u003eMapSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:FixpointSubstitution",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "FixpointSubstitution (Map Int Tp)",
        "fct-source": "src/Top-Types-Substitution.html#FixpointSubstitution",
        "fct-type": "function",
        "title": "FixpointSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "FixpointSubstitution",
        "normalized": "",
        "package": "Top",
        "partial": "Fixpoint Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:WrappedSubstitution",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "WrappedSubstitution a (Int -\u003e a -\u003e Tp, [Int] -\u003e a -\u003e a, [Int] -\u003e a -\u003e a, a -\u003e [Int], a -\u003e Tps)",
        "fct-source": "src/Top-Types-Substitution.html#WrappedSubstitution",
        "fct-type": "function",
        "title": "WrappedSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "WrappedSubstitution",
        "normalized": "WrappedSubstitution a(Int-\u003ea-\u003eTp,[Int]-\u003ea-\u003ea,[Int]-\u003ea-\u003ea,a-\u003e[Int],a-\u003eTps)",
        "package": "Top",
        "partial": "Wrapped Substitution",
        "signature": "WrappedSubstitution a(Int-\u003ea-\u003eTp,[Int]-\u003ea-\u003ea,[Int]-\u003ea-\u003ea,a-\u003e[Int],a-\u003eTps)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:allTypeConstants",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "a -\u003e [String]",
        "fct-source": "src/Top-Types-Substitution.html#allTypeConstants",
        "fct-type": "function",
        "title": "allTypeConstants"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "allTypeConstants",
        "normalized": "a-\u003e[String]",
        "package": "Top",
        "partial": "Type Constants",
        "signature": "a-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:allTypeVariables",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "a -\u003e [Int]",
        "fct-source": "src/Top-Types-Substitution.html#allTypeVariables",
        "fct-type": "function",
        "title": "allTypeVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "allTypeVariables",
        "normalized": "a-\u003e[Int]",
        "package": "Top",
        "partial": "Type Variables",
        "signature": "a-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:cod",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "s -\u003e Tps",
        "fct-source": "src/Top-Types-Substitution.html#cod",
        "fct-type": "method",
        "title": "cod"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "cod",
        "normalized": "a-\u003eTps",
        "package": "Top",
        "partial": "",
        "signature": "s-\u003eTps"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:disjointFPS",
      "description": {
        "fct-descr": "\u003cp\u003eCombine two fixpoint substitutions that are disjoint\n\u003c/p\u003e",
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "FixpointSubstitution -\u003e FixpointSubstitution -\u003e FixpointSubstitution",
        "fct-source": "src/Top-Types-Substitution.html#disjointFPS",
        "fct-type": "function",
        "title": "disjointFPS"
      },
      "index": {
        "description": "Combine two fixpoint substitutions that are disjoint",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "disjointFPS",
        "normalized": "FixpointSubstitution-\u003eFixpointSubstitution-\u003eFixpointSubstitution",
        "package": "Top",
        "partial": "FPS",
        "signature": "FixpointSubstitution-\u003eFixpointSubstitution-\u003eFixpointSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:dom",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "s -\u003e [Int]",
        "fct-source": "src/Top-Types-Substitution.html#dom",
        "fct-type": "method",
        "title": "dom"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "dom",
        "normalized": "a-\u003e[Int]",
        "package": "Top",
        "partial": "",
        "signature": "s-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:emptyFPS",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty fixpoint substitution \n\u003c/p\u003e",
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "FixpointSubstitution",
        "fct-source": "src/Top-Types-Substitution.html#emptyFPS",
        "fct-type": "function",
        "title": "emptyFPS"
      },
      "index": {
        "description": "The empty fixpoint substitution",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "emptyFPS",
        "normalized": "",
        "package": "Top",
        "partial": "FPS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:emptySubst",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "MapSubstitution",
        "fct-source": "src/Top-Types-Substitution.html#emptySubst",
        "fct-type": "function",
        "title": "emptySubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "emptySubst",
        "normalized": "",
        "package": "Top",
        "partial": "Subst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:freezeFTV",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "a -\u003e a",
        "fct-source": "src/Top-Types-Substitution.html#freezeFTV",
        "fct-type": "function",
        "title": "freezeFTV"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "freezeFTV",
        "normalized": "a-\u003ea",
        "package": "Top",
        "partial": "FTV",
        "signature": "a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:ftv",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "a -\u003e [Int]",
        "fct-source": "src/Top-Types-Substitution.html#ftv",
        "fct-type": "method",
        "title": "ftv"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "ftv",
        "normalized": "a-\u003e[Int]",
        "package": "Top",
        "partial": "",
        "signature": "a-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:listToSubstitution",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "[(Int, Tp)] -\u003e MapSubstitution",
        "fct-source": "src/Top-Types-Substitution.html#listToSubstitution",
        "fct-type": "function",
        "title": "listToSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "listToSubstitution",
        "normalized": "[(Int,Tp)]-\u003eMapSubstitution",
        "package": "Top",
        "partial": "To Substitution",
        "signature": "[(Int,Tp)]-\u003eMapSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:lookupInt",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e s -\u003e Tp",
        "fct-source": "src/Top-Types-Substitution.html#lookupInt",
        "fct-type": "method",
        "title": "lookupInt"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "lookupInt",
        "normalized": "Int-\u003ea-\u003eTp",
        "package": "Top",
        "partial": "Int",
        "signature": "Int-\u003es-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:nextFTV",
      "description": {
        "fct-descr": "\u003cp\u003eThe next type variable that is not free (default is zero)\n\u003c/p\u003e",
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "a -\u003e Int",
        "fct-source": "src/Top-Types-Substitution.html#nextFTV",
        "fct-type": "function",
        "title": "nextFTV"
      },
      "index": {
        "description": "The next type variable that is not free default is zero",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "nextFTV",
        "normalized": "a-\u003eInt",
        "package": "Top",
        "partial": "FTV",
        "signature": "a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:removeDom",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e s -\u003e s",
        "fct-source": "src/Top-Types-Substitution.html#removeDom",
        "fct-type": "method",
        "title": "removeDom"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "removeDom",
        "normalized": "[Int]-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Dom",
        "signature": "[Int]-\u003es-\u003es"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:restrictDom",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "[Int] -\u003e s -\u003e s",
        "fct-source": "src/Top-Types-Substitution.html#restrictDom",
        "fct-type": "method",
        "title": "restrictDom"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "restrictDom",
        "normalized": "[Int]-\u003ea-\u003ea",
        "package": "Top",
        "partial": "Dom",
        "signature": "[Int]-\u003es-\u003es"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:singleSubstitution",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "Int -\u003e Tp -\u003e MapSubstitution",
        "fct-source": "src/Top-Types-Substitution.html#singleSubstitution",
        "fct-type": "function",
        "title": "singleSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "singleSubstitution",
        "normalized": "Int-\u003eTp-\u003eMapSubstitution",
        "package": "Top",
        "partial": "Substitution",
        "signature": "Int-\u003eTp-\u003eMapSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:wrapSubstitution",
      "description": {
        "fct-module": "Top.Types.Substitution",
        "fct-package": "Top",
        "fct-signature": "substitution -\u003e WrappedSubstitution",
        "fct-source": "src/Top-Types-Substitution.html#wrapSubstitution",
        "fct-type": "function",
        "title": "wrapSubstitution"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Substitution",
        "module": "Top.Types.Substitution",
        "name": "wrapSubstitution",
        "normalized": "a-\u003eWrappedSubstitution",
        "package": "Top",
        "partial": "Substitution",
        "signature": "substitution-\u003eWrappedSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains type synonyms to represent type synonyms. A collection\n of type synonyms can always be ordered, since (mutually) recursive type\n synonyms are not permitted. The ordering of type synonyms must be determined\n to find a minimal number of unfold steps to make two types syntactically \n equivalent.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Synonym.html",
        "fct-type": "module",
        "title": "Synonym"
      },
      "index": {
        "description": "This module contains type synonyms to represent type synonyms collection of type synonyms can always be ordered since mutually recursive type synonyms are not permitted The ordering of type synonyms must be determined to find minimal number of unfold steps to make two types syntactically equivalent",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "Synonym",
        "normalized": "",
        "package": "Top",
        "partial": "Synonym",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#t:OrderedTypeSynonyms",
      "description": {
        "fct-descr": "\u003cp\u003eAn (unordered) collection of type synonyms, together with an ordering.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Synonym.html#OrderedTypeSynonyms",
        "fct-type": "type",
        "title": "OrderedTypeSynonyms"
      },
      "index": {
        "description": "An unordered collection of type synonyms together with an ordering",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "OrderedTypeSynonyms",
        "normalized": "",
        "package": "Top",
        "partial": "Ordered Type Synonyms",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#t:TypeSynonymOrdering",
      "description": {
        "fct-descr": "\u003cp\u003eAn ordering of type synonyms maps a name of a type synonym to \n a position in the ordering.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Synonym.html#TypeSynonymOrdering",
        "fct-type": "type",
        "title": "TypeSynonymOrdering"
      },
      "index": {
        "description": "An ordering of type synonyms maps name of type synonym to position in the ordering",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "TypeSynonymOrdering",
        "normalized": "",
        "package": "Top",
        "partial": "Type Synonym Ordering",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#t:TypeSynonyms",
      "description": {
        "fct-descr": "\u003cp\u003eA (unordered) collection of type synonyms is represented by a finite map of\n strings (the name of the type synonym) to pairs that have an int\n (the number of arguments of the type synonym) and a function.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "type",
        "fct-source": "src/Top-Types-Synonym.html#TypeSynonyms",
        "fct-type": "type",
        "title": "TypeSynonyms"
      },
      "index": {
        "description": "unordered collection of type synonyms is represented by finite map of strings the name of the type synonym to pairs that have an int the number of arguments of the type synonym and function",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "TypeSynonyms",
        "normalized": "",
        "package": "Top",
        "partial": "Type Synonyms",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandOneStepOrdered",
      "description": {
        "fct-descr": "\u003cp\u003eTry to expand the top-level type constructor of one of the two paired Top.Types. If both\n top-level type constructors can be expanded, then the type synonym thast appears first\n in the ordering is expanded.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e (Tp, Tp) -\u003e Maybe (Tp, Tp)",
        "fct-source": "src/Top-Types-Synonym.html#expandOneStepOrdered",
        "fct-type": "function",
        "title": "expandOneStepOrdered"
      },
      "index": {
        "description": "Try to expand the top-level type constructor of one of the two paired Top.Types If both top-level type constructors can be expanded then the type synonym thast appears first in the ordering is expanded",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "expandOneStepOrdered",
        "normalized": "OrderedTypeSynonyms-\u003e(Tp,Tp)-\u003eMaybe(Tp,Tp)",
        "package": "Top",
        "partial": "One Step Ordered",
        "signature": "OrderedTypeSynonyms-\u003e(Tp,Tp)-\u003eMaybe(Tp,Tp)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandToplevelTC",
      "description": {
        "fct-descr": "\u003cp\u003eFully expand the top-level type constructor.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Maybe Tp",
        "fct-source": "src/Top-Types-Synonym.html#expandToplevelTC",
        "fct-type": "function",
        "title": "expandToplevelTC"
      },
      "index": {
        "description": "Fully expand the top-level type constructor",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "expandToplevelTC",
        "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eMaybe Tp",
        "package": "Top",
        "partial": "Toplevel TC",
        "signature": "OrderedTypeSynonyms-\u003eTp-\u003eMaybe Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandType",
      "description": {
        "fct-descr": "\u003cp\u003eFully expand a type in a recursive way.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "TypeSynonyms -\u003e Tp -\u003e Tp",
        "fct-source": "src/Top-Types-Synonym.html#expandType",
        "fct-type": "function",
        "title": "expandType"
      },
      "index": {
        "description": "Fully expand type in recursive way",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "expandType",
        "normalized": "TypeSynonyms-\u003eTp-\u003eTp",
        "package": "Top",
        "partial": "Type",
        "signature": "TypeSynonyms-\u003eTp-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandTypeConstructor",
      "description": {
        "fct-descr": "\u003cp\u003eFully expand the top-level type constructor.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "TypeSynonyms -\u003e Tp -\u003e Tp",
        "fct-source": "src/Top-Types-Synonym.html#expandTypeConstructor",
        "fct-type": "function",
        "title": "expandTypeConstructor"
      },
      "index": {
        "description": "Fully expand the top-level type constructor",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "expandTypeConstructor",
        "normalized": "TypeSynonyms-\u003eTp-\u003eTp",
        "package": "Top",
        "partial": "Type Constructor",
        "signature": "TypeSynonyms-\u003eTp-\u003eTp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandTypeConstructorOneStep",
      "description": {
        "fct-descr": "\u003cp\u003eTry to expand the top-level type constructor one step.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "TypeSynonyms -\u003e Tp -\u003e Maybe Tp",
        "fct-source": "src/Top-Types-Synonym.html#expandTypeConstructorOneStep",
        "fct-type": "function",
        "title": "expandTypeConstructorOneStep"
      },
      "index": {
        "description": "Try to expand the top-level type constructor one step",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "expandTypeConstructorOneStep",
        "normalized": "TypeSynonyms-\u003eTp-\u003eMaybe Tp",
        "package": "Top",
        "partial": "Type Constructor One Step",
        "signature": "TypeSynonyms-\u003eTp-\u003eMaybe Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:getTypeSynonymOrdering",
      "description": {
        "fct-descr": "\u003cp\u003eOrder a collection of type synonyms, and return this ordering paired with\n sets of mutually recursive type synonyms that are detected.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "TypeSynonyms -\u003e (TypeSynonymOrdering, [[String]])",
        "fct-source": "src/Top-Types-Synonym.html#getTypeSynonymOrdering",
        "fct-type": "function",
        "title": "getTypeSynonymOrdering"
      },
      "index": {
        "description": "Order collection of type synonyms and return this ordering paired with sets of mutually recursive type synonyms that are detected",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "getTypeSynonymOrdering",
        "normalized": "TypeSynonyms-\u003e(TypeSynonymOrdering,[[String]])",
        "package": "Top",
        "partial": "Type Synonym Ordering",
        "signature": "TypeSynonyms-\u003e(TypeSynonymOrdering,[[String]])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:isPhantomTypeSynonym",
      "description": {
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e String -\u003e Bool",
        "fct-source": "src/Top-Types-Synonym.html#isPhantomTypeSynonym",
        "fct-type": "function",
        "title": "isPhantomTypeSynonym"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "isPhantomTypeSynonym",
        "normalized": "OrderedTypeSynonyms-\u003eString-\u003eBool",
        "package": "Top",
        "partial": "Phantom Type Synonym",
        "signature": "OrderedTypeSynonyms-\u003eString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:noOrderedTypeSynonyms",
      "description": {
        "fct-descr": "\u003cp\u003eAn empty collection of ordered type synonyms.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms",
        "fct-source": "src/Top-Types-Synonym.html#noOrderedTypeSynonyms",
        "fct-type": "function",
        "title": "noOrderedTypeSynonyms"
      },
      "index": {
        "description": "An empty collection of ordered type synonyms",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "noOrderedTypeSynonyms",
        "normalized": "",
        "package": "Top",
        "partial": "Ordered Type Synonyms",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:stringAsTypeSynonym",
      "description": {
        "fct-descr": "\u003cp\u003eA string is a list of characters\n\u003c/p\u003e",
        "fct-module": "Top.Types.Synonym",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms",
        "fct-source": "src/Top-Types-Synonym.html#stringAsTypeSynonym",
        "fct-type": "function",
        "title": "stringAsTypeSynonym"
      },
      "index": {
        "description": "string is list of characters",
        "hierarchy": "Top Types Synonym",
        "module": "Top.Types.Synonym",
        "name": "stringAsTypeSynonym",
        "normalized": "",
        "package": "Top",
        "partial": "As Type Synonym",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA unification algorithm for types, which can take a list of (ordered) \n type synonyms into account.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types-Unification.html",
        "fct-type": "module",
        "title": "Unification"
      },
      "index": {
        "description": "unification algorithm for types which can take list of ordered type synonyms into account",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "Unification",
        "normalized": "",
        "package": "Top",
        "partial": "Unification",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#t:UnificationError",
      "description": {
        "fct-descr": "\u003cp\u003eThere are two reasons why two types cannot be unified: either two (different) type constants clash (they\n should be the same), or a type variable should be unified with a composed type that contains this same\n type variable.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Types-Unification.html#UnificationError",
        "fct-type": "data",
        "title": "UnificationError"
      },
      "index": {
        "description": "There are two reasons why two types cannot be unified either two different type constants clash they should be the same or type variable should be unified with composed type that contains this same type variable",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "UnificationError",
        "normalized": "",
        "package": "Top",
        "partial": "Unification Error",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:ConstantClash",
      "description": {
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "ConstantClash String String",
        "fct-source": "src/Top-Types-Unification.html#UnificationError",
        "fct-type": "function",
        "title": "ConstantClash"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "ConstantClash",
        "normalized": "",
        "package": "Top",
        "partial": "Constant Clash",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:InfiniteType",
      "description": {
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "InfiniteType Int",
        "fct-source": "src/Top-Types-Unification.html#UnificationError",
        "fct-type": "function",
        "title": "InfiniteType"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "InfiniteType",
        "normalized": "",
        "package": "Top",
        "partial": "Infinite Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:equalUnderTypeSynonyms",
      "description": {
        "fct-descr": "\u003cp\u003eFind the most general type for two types that are equal under type synonyms\n (i.e., the least number of expansions)\n\u003c/p\u003e",
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Tp -\u003e Maybe Tp",
        "fct-source": "src/Top-Types-Unification.html#equalUnderTypeSynonyms",
        "fct-type": "function",
        "title": "equalUnderTypeSynonyms"
      },
      "index": {
        "description": "Find the most general type for two types that are equal under type synonyms i.e the least number of expansions",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "equalUnderTypeSynonyms",
        "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eMaybe Tp",
        "package": "Top",
        "partial": "Under Type Synonyms",
        "signature": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eMaybe Tp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:mgu",
      "description": {
        "fct-descr": "\u003cp\u003eThe most general unification (substitution) of two types.\n\u003c/p\u003e",
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "Tp -\u003e Tp -\u003e Either UnificationError MapSubstitution",
        "fct-source": "src/Top-Types-Unification.html#mgu",
        "fct-type": "function",
        "title": "mgu"
      },
      "index": {
        "description": "The most general unification substitution of two types",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "mgu",
        "normalized": "Tp-\u003eTp-\u003eEither UnificationError MapSubstitution",
        "package": "Top",
        "partial": "",
        "signature": "Tp-\u003eTp-\u003eEither UnificationError MapSubstitution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:mguWithTypeSynonyms",
      "description": {
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Tp -\u003e Either UnificationError (Bool, MapSubstitution)",
        "fct-source": "src/Top-Types-Unification.html#mguWithTypeSynonyms",
        "fct-type": "function",
        "title": "mguWithTypeSynonyms"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "mguWithTypeSynonyms",
        "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eEither UnificationError(Bool,MapSubstitution)",
        "package": "Top",
        "partial": "With Type Synonyms",
        "signature": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eEither UnificationError(Bool,MapSubstitution)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:unifiable",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a set of (ordered) type synonyms, can two types be unified?                              \n\u003c/p\u003e",
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Tp -\u003e Bool",
        "fct-source": "src/Top-Types-Unification.html#unifiable",
        "fct-type": "function",
        "title": "unifiable"
      },
      "index": {
        "description": "Given set of ordered type synonyms can two types be unified",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "unifiable",
        "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eBool",
        "package": "Top",
        "partial": "",
        "signature": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:unifiableList",
      "description": {
        "fct-descr": "\u003cp\u003eSame as unifiable, but takes as input a list of types\n\u003c/p\u003e",
        "fct-module": "Top.Types.Unification",
        "fct-package": "Top",
        "fct-signature": "OrderedTypeSynonyms -\u003e Tps -\u003e Bool",
        "fct-source": "src/Top-Types-Unification.html#unifiableList",
        "fct-type": "function",
        "title": "unifiableList"
      },
      "index": {
        "description": "Same as unifiable but takes as input list of types",
        "hierarchy": "Top Types Unification",
        "module": "Top.Types.Unification",
        "name": "unifiableList",
        "normalized": "OrderedTypeSynonyms-\u003eTps-\u003eBool",
        "package": "Top",
        "partial": "List",
        "signature": "OrderedTypeSynonyms-\u003eTps-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA collection of type utilities.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Top.Types",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Types.html",
        "fct-type": "module",
        "title": "Types"
      },
      "index": {
        "description": "collection of type utilities",
        "hierarchy": "Top Types",
        "module": "Top.Types",
        "name": "Types",
        "normalized": "",
        "package": "Top",
        "partial": "Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Util-Embedding.html",
        "fct-type": "module",
        "title": "Embedding"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "Embedding",
        "normalized": "",
        "package": "Top",
        "partial": "Embedding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#t:Embedding",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Util-Embedding.html#Embedding",
        "fct-type": "data",
        "title": "Embedding"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "Embedding",
        "normalized": "",
        "package": "Top",
        "partial": "Embedding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:Embedding",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding",
        "fct-source": "src/Top-Util-Embedding.html#Embedding",
        "fct-type": "function",
        "title": "Embedding"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "Embedding",
        "normalized": "",
        "package": "Top",
        "partial": "Embedding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:changeE",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "(b -\u003e b) -\u003e a -\u003e a",
        "fct-source": "src/Top-Util-Embedding.html#Embedding",
        "fct-type": "function",
        "title": "changeE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "changeE",
        "normalized": "(a-\u003ea)-\u003eb-\u003eb",
        "package": "Top",
        "partial": "",
        "signature": "(b-\u003eb)-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:composeE",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding a b -\u003e Embedding b c -\u003e Embedding a c",
        "fct-source": "src/Top-Util-Embedding.html#composeE",
        "fct-type": "function",
        "title": "composeE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "composeE",
        "normalized": "Embedding a b-\u003eEmbedding b c-\u003eEmbedding a c",
        "package": "Top",
        "partial": "",
        "signature": "Embedding a b-\u003eEmbedding b c-\u003eEmbedding a c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:fromFstE",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding a c -\u003e Embedding (a, b) c",
        "fct-source": "src/Top-Util-Embedding.html#fromFstE",
        "fct-type": "function",
        "title": "fromFstE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "fromFstE",
        "normalized": "Embedding a b-\u003eEmbedding(a,c)b",
        "package": "Top",
        "partial": "Fst",
        "signature": "Embedding a c-\u003eEmbedding(a,b)c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:fromSndE",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding b c -\u003e Embedding (a, b) c",
        "fct-source": "src/Top-Util-Embedding.html#fromSndE",
        "fct-type": "function",
        "title": "fromSndE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "fromSndE",
        "normalized": "Embedding a b-\u003eEmbedding(c,a)b",
        "package": "Top",
        "partial": "Snd",
        "signature": "Embedding b c-\u003eEmbedding(a,b)c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:fstE",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding (a, b) a",
        "fct-source": "src/Top-Util-Embedding.html#fstE",
        "fct-type": "function",
        "title": "fstE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "fstE",
        "normalized": "Embedding(a,b)a",
        "package": "Top",
        "partial": "",
        "signature": "Embedding(a,b)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:getE",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "a -\u003e b",
        "fct-source": "src/Top-Util-Embedding.html#Embedding",
        "fct-type": "function",
        "title": "getE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "getE",
        "normalized": "a-\u003eb",
        "package": "Top",
        "partial": "",
        "signature": "a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:idE",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding a a",
        "fct-source": "src/Top-Util-Embedding.html#idE",
        "fct-type": "function",
        "title": "idE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "idE",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:setE",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding a b -\u003e b -\u003e a -\u003e a",
        "fct-source": "src/Top-Util-Embedding.html#setE",
        "fct-type": "function",
        "title": "setE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "setE",
        "normalized": "Embedding a b-\u003eb-\u003ea-\u003ea",
        "package": "Top",
        "partial": "",
        "signature": "Embedding a b-\u003eb-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:sndE",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding (a, b) b",
        "fct-source": "src/Top-Util-Embedding.html#sndE",
        "fct-type": "function",
        "title": "sndE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "sndE",
        "normalized": "Embedding(a,b)b",
        "package": "Top",
        "partial": "",
        "signature": "Embedding(a,b)b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:withE",
      "description": {
        "fct-module": "Top.Util.Embedding",
        "fct-package": "Top",
        "fct-signature": "Embedding a b -\u003e (b -\u003e c) -\u003e a -\u003e c",
        "fct-source": "src/Top-Util-Embedding.html#withE",
        "fct-type": "function",
        "title": "withE"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Embedding",
        "module": "Top.Util.Embedding",
        "name": "withE",
        "normalized": "Embedding a b-\u003e(b-\u003ec)-\u003ea-\u003ec",
        "package": "Top",
        "partial": "",
        "signature": "Embedding a b-\u003e(b-\u003ec)-\u003ea-\u003ec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Empty.html#",
      "description": {
        "fct-module": "Top.Util.Empty",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Util-Empty.html",
        "fct-type": "module",
        "title": "Empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Empty",
        "module": "Top.Util.Empty",
        "name": "Empty",
        "normalized": "",
        "package": "Top",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Empty.html#t:Empty",
      "description": {
        "fct-module": "Top.Util.Empty",
        "fct-package": "Top",
        "fct-signature": "class",
        "fct-source": "src/Top-Util-Empty.html#Empty",
        "fct-type": "class",
        "title": "Empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Empty",
        "module": "Top.Util.Empty",
        "name": "Empty",
        "normalized": "",
        "package": "Top",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Empty.html#v:empty",
      "description": {
        "fct-module": "Top.Util.Empty",
        "fct-package": "Top",
        "fct-signature": "a",
        "fct-source": "src/Top-Util-Empty.html#empty",
        "fct-type": "method",
        "title": "empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Empty",
        "module": "Top.Util.Empty",
        "name": "empty",
        "normalized": "",
        "package": "Top",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "module",
        "fct-source": "src/Top-Util-Option.html",
        "fct-type": "module",
        "title": "Option"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "Option",
        "normalized": "",
        "package": "Top",
        "partial": "Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#t:Option",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Util-Option.html#Option",
        "fct-type": "data",
        "title": "Option"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "Option",
        "normalized": "",
        "package": "Top",
        "partial": "Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#t:OptionAccess",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "data",
        "fct-source": "src/Top-Util-Option.html#OptionAccess",
        "fct-type": "data",
        "title": "OptionAccess"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "OptionAccess",
        "normalized": "",
        "package": "Top",
        "partial": "Option Access",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:Access",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "Access",
        "fct-source": "src/Top-Util-Option.html#OptionAccess",
        "fct-type": "function",
        "title": "Access"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "Access",
        "normalized": "",
        "package": "Top",
        "partial": "Access",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:Option",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "Option",
        "fct-source": "src/Top-Util-Option.html#Option",
        "fct-type": "function",
        "title": "Option"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "Option",
        "normalized": "",
        "package": "Top",
        "partial": "Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:currentValue",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "a",
        "fct-source": "src/Top-Util-Option.html#Option",
        "fct-type": "function",
        "title": "currentValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "currentValue",
        "normalized": "",
        "package": "Top",
        "partial": "Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:defaultValue",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "a",
        "fct-source": "src/Top-Util-Option.html#Option",
        "fct-type": "function",
        "title": "defaultValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "defaultValue",
        "normalized": "",
        "package": "Top",
        "partial": "Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:getOption",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "m a",
        "fct-source": "src/Top-Util-Option.html#OptionAccess",
        "fct-type": "function",
        "title": "getOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "getOption",
        "normalized": "",
        "package": "Top",
        "partial": "Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:ignoreOption",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "Option a -\u003e OptionAccess m a",
        "fct-source": "src/Top-Util-Option.html#ignoreOption",
        "fct-type": "function",
        "title": "ignoreOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "ignoreOption",
        "normalized": "Option a-\u003eOptionAccess b a",
        "package": "Top",
        "partial": "Option",
        "signature": "Option a-\u003eOptionAccess m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:option",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "a -\u003e String -\u003e Option a",
        "fct-source": "src/Top-Util-Option.html#option",
        "fct-type": "function",
        "title": "option"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "option",
        "normalized": "a-\u003eString-\u003eOption a",
        "package": "Top",
        "partial": "",
        "signature": "a-\u003eString-\u003eOption a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:optionAccessTrans",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "(forall a.  m1 a -\u003e m2 a) -\u003e OptionAccess m1 b -\u003e OptionAccess m2 b",
        "fct-source": "src/Top-Util-Option.html#optionAccessTrans",
        "fct-type": "function",
        "title": "optionAccessTrans"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "optionAccessTrans",
        "normalized": "(a b c d-\u003ec d)-\u003eOptionAccess c e-\u003eOptionAccess c e",
        "package": "Top",
        "partial": "Access Trans",
        "signature": "(forall a. m a-\u003em a)-\u003eOptionAccess m b-\u003eOptionAccess m b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:optionDescription",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "String",
        "fct-source": "src/Top-Util-Option.html#Option",
        "fct-type": "function",
        "title": "optionDescription"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "optionDescription",
        "normalized": "",
        "package": "Top",
        "partial": "Description",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:setOption",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "a -\u003e m ()",
        "fct-source": "src/Top-Util-Option.html#OptionAccess",
        "fct-type": "function",
        "title": "setOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "setOption",
        "normalized": "a-\u003eb()",
        "package": "Top",
        "partial": "Option",
        "signature": "a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:useOption",
      "description": {
        "fct-module": "Top.Util.Option",
        "fct-package": "Top",
        "fct-signature": "(s -\u003e Option a) -\u003e (Option a -\u003e s -\u003e s) -\u003e OptionAccess m a",
        "fct-source": "src/Top-Util-Option.html#useOption",
        "fct-type": "function",
        "title": "useOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Top Util Option",
        "module": "Top.Util.Option",
        "name": "useOption",
        "normalized": "(a-\u003eOption b)-\u003e(Option b-\u003ea-\u003ea)-\u003eOptionAccess c b",
        "package": "Top",
        "partial": "Option",
        "signature": "(s-\u003eOption a)-\u003e(Option a-\u003es-\u003es)-\u003eOptionAccess m a"
      }
    }
  }
]
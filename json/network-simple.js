[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports functions that abstract simple TCP \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e\n usage patterns.\n\u003c/p\u003e\u003cp\u003eThis module uses \u003ccode\u003e\u003ca\u003eMonadIO\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e extensively so that you can\n reuse these functions in monads other than \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e. However, if you don't care\n about any of that, just pretend you are using the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad all the time\n and everything will work as expected.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "module",
        "fct-source": "src/Network-Simple-TCP.html",
        "fct-type": "module",
        "title": "TCP"
      },
      "index": {
        "description": "This module exports functions that abstract simple TCP Socket usage patterns This module uses MonadIO and MonadCatch extensively so that you can reuse these functions in monads other than IO However if you don care about any of that just pretend you are using the IO monad all the time and everything will work as expected",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "TCP",
        "normalized": "",
        "package": "network-simple",
        "partial": "TCP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#t:HostName",
      "description": {
        "fct-descr": "\u003cp\u003eEither a host name e.g., \u003ccode\u003e\"haskell.org\"\u003c/code\u003e or a numeric host\n address string consisting of a dotted decimal IPv4 address or an\n IPv6 address e.g., \u003ccode\u003e\"192.168.0.1\"\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "type",
        "fct-type": "type",
        "title": "HostName"
      },
      "index": {
        "description": "Either host name e.g haskell.org or numeric host address string consisting of dotted decimal IPv4 address or an IPv6 address e.g",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "HostName",
        "normalized": "",
        "package": "network-simple",
        "partial": "Host Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#t:HostPreference",
      "description": {
        "fct-descr": "\u003cp\u003ePreferred host to bind.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "data",
        "fct-source": "src/Network-Simple-Internal.html#HostPreference",
        "fct-type": "data",
        "title": "HostPreference"
      },
      "index": {
        "description": "Preferred host to bind",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "HostPreference",
        "normalized": "",
        "package": "network-simple",
        "partial": "Host Preference",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#t:ServiceName",
      "description": {
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "type",
        "fct-type": "type",
        "title": "ServiceName"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "ServiceName",
        "normalized": "",
        "package": "network-simple",
        "partial": "Service Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#t:SockAddr",
      "description": {
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "SockAddr"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "SockAddr",
        "normalized": "",
        "package": "network-simple",
        "partial": "Sock Addr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#t:Socket",
      "description": {
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "Socket"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "Socket",
        "normalized": "",
        "package": "network-simple",
        "partial": "Socket",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:Host",
      "description": {
        "fct-descr": "\u003cp\u003eAn explicit host name.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "Host HostName",
        "fct-source": "src/Network-Simple-Internal.html#HostPreference",
        "fct-type": "function",
        "title": "Host"
      },
      "index": {
        "description": "An explicit host name",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "Host",
        "normalized": "",
        "package": "network-simple",
        "partial": "Host",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:HostAny",
      "description": {
        "fct-descr": "\u003cp\u003eAny available host.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "HostAny",
        "fct-source": "src/Network-Simple-Internal.html#HostPreference",
        "fct-type": "function",
        "title": "HostAny"
      },
      "index": {
        "description": "Any available host",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "HostAny",
        "normalized": "",
        "package": "network-simple",
        "partial": "Host Any",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:HostIPv4",
      "description": {
        "fct-descr": "\u003cp\u003eAny available IPv4 host.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "HostIPv4",
        "fct-source": "src/Network-Simple-Internal.html#HostPreference",
        "fct-type": "function",
        "title": "HostIPv4"
      },
      "index": {
        "description": "Any available IPv4 host",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "HostIPv4",
        "normalized": "",
        "package": "network-simple",
        "partial": "Host IPv",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:HostIPv6",
      "description": {
        "fct-descr": "\u003cp\u003eAny available IPv6 host.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "HostIPv6",
        "fct-source": "src/Network-Simple-Internal.html#HostPreference",
        "fct-type": "function",
        "title": "HostIPv6"
      },
      "index": {
        "description": "Any available IPv6 host",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "HostIPv6",
        "normalized": "",
        "package": "network-simple",
        "partial": "Host IPv",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:accept",
      "description": {
        "fct-descr": "\u003cp\u003eAccept a single incoming connection and use it.\n\u003c/p\u003e\u003cp\u003eThe connection socket is closed when done or in case of exceptions.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "Socket-\u003e ((Socket, SockAddr) -\u003e m r)-\u003e m r",
        "fct-type": "function",
        "title": "accept"
      },
      "index": {
        "description": "Accept single incoming connection and use it The connection socket is closed when done or in case of exceptions",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "accept",
        "normalized": "Socket-\u003e((Socket,SockAddr)-\u003ea b)-\u003ea b",
        "package": "network-simple",
        "partial": "",
        "signature": "Socket-\u003e((Socket,SockAddr)-\u003em r)-\u003em r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:acceptFork",
      "description": {
        "fct-descr": "\u003cp\u003eAccept a single incoming connection and use it in a different thread.\n\u003c/p\u003e\u003cp\u003eThe connection socket is closed when done or in case of exceptions.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "Socket-\u003e ((Socket, SockAddr) -\u003e IO ())-\u003e m ThreadId",
        "fct-type": "function",
        "title": "acceptFork"
      },
      "index": {
        "description": "Accept single incoming connection and use it in different thread The connection socket is closed when done or in case of exceptions",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "acceptFork",
        "normalized": "Socket-\u003e((Socket,SockAddr)-\u003eIO())-\u003ea ThreadId",
        "package": "network-simple",
        "partial": "Fork",
        "signature": "Socket-\u003e((Socket,SockAddr)-\u003eIO())-\u003em ThreadId"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:bindSock",
      "description": {
        "fct-descr": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e bound to the given host name and TCP service port.\n\u003c/p\u003e\u003cp\u003eThe obtained \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e should be closed manually using \u003ccode\u003e\u003ca\u003ecloseSock\u003c/a\u003e\u003c/code\u003e when\n it's not needed anymore.\n\u003c/p\u003e\u003cp\u003ePrefer to use \u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e if you will be listening on this socket and using it\n within a limited scope, and would like it to be closed immediately after its\n usage or in case of exceptions.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "HostPreference -\u003e ServiceName -\u003e m (Socket, SockAddr)",
        "fct-source": "src/Network-Simple-TCP.html#bindSock",
        "fct-type": "function",
        "title": "bindSock"
      },
      "index": {
        "description": "Obtain Socket bound to the given host name and TCP service port The obtained Socket should be closed manually using closeSock when it not needed anymore Prefer to use listen if you will be listening on this socket and using it within limited scope and would like it to be closed immediately after its usage or in case of exceptions",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "bindSock",
        "normalized": "HostPreference-\u003eServiceName-\u003ea(Socket,SockAddr)",
        "package": "network-simple",
        "partial": "Sock",
        "signature": "HostPreference-\u003eServiceName-\u003em(Socket,SockAddr)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:closeSock",
      "description": {
        "fct-descr": "\u003cp\u003eClose the \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "Socket -\u003e m ()",
        "fct-source": "src/Network-Simple-TCP.html#closeSock",
        "fct-type": "function",
        "title": "closeSock"
      },
      "index": {
        "description": "Close the Socket",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "closeSock",
        "normalized": "Socket-\u003ea()",
        "package": "network-simple",
        "partial": "Sock",
        "signature": "Socket-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:connect",
      "description": {
        "fct-descr": "\u003cp\u003eConnect to a TCP server and use the connection.\n\u003c/p\u003e\u003cp\u003eThe connection socket is closed when done or in case of exceptions.\n\u003c/p\u003e\u003cp\u003eIf you prefer to acquire and close the socket yourself, then use\n \u003ccode\u003e\u003ca\u003econnectSock\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ecloseSock\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "HostName-\u003e ServiceName-\u003e ((Socket, SockAddr) -\u003e m r)-\u003e m r",
        "fct-type": "function",
        "title": "connect"
      },
      "index": {
        "description": "Connect to TCP server and use the connection The connection socket is closed when done or in case of exceptions If you prefer to acquire and close the socket yourself then use connectSock and closeSock",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "connect",
        "normalized": "HostName-\u003eServiceName-\u003e((Socket,SockAddr)-\u003ea b)-\u003ea b",
        "package": "network-simple",
        "partial": "",
        "signature": "HostName-\u003eServiceName-\u003e((Socket,SockAddr)-\u003em r)-\u003em r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:connectSock",
      "description": {
        "fct-descr": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e connected to the given host and TCP service port.\n\u003c/p\u003e\u003cp\u003eThe obtained \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e should be closed manually using \u003ccode\u003e\u003ca\u003ecloseSock\u003c/a\u003e\u003c/code\u003e when\n it's not needed anymore, otherwise you risk having the socket open for much\n longer than needed.\n\u003c/p\u003e\u003cp\u003ePrefer to use \u003ccode\u003e\u003ca\u003econnect\u003c/a\u003e\u003c/code\u003e if you will be using the socket within a limited\n scope and would like it to be closed immediately after its usage or in case\n of exceptions.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "HostName -\u003e ServiceName -\u003e m (Socket, SockAddr)",
        "fct-source": "src/Network-Simple-TCP.html#connectSock",
        "fct-type": "function",
        "title": "connectSock"
      },
      "index": {
        "description": "Obtain Socket connected to the given host and TCP service port The obtained Socket should be closed manually using closeSock when it not needed anymore otherwise you risk having the socket open for much longer than needed Prefer to use connect if you will be using the socket within limited scope and would like it to be closed immediately after its usage or in case of exceptions",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "connectSock",
        "normalized": "HostName-\u003eServiceName-\u003ea(Socket,SockAddr)",
        "package": "network-simple",
        "partial": "Sock",
        "signature": "HostName-\u003eServiceName-\u003em(Socket,SockAddr)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:listen",
      "description": {
        "fct-descr": "\u003cp\u003eBind a TCP listening socket and use it.\n\u003c/p\u003e\u003cp\u003eThe listening socket is closed when done or in case of exceptions.\n\u003c/p\u003e\u003cp\u003eIf you prefer to acquire and close the socket yourself, then use \u003ccode\u003e\u003ca\u003ebindSock\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003ecloseSock\u003c/a\u003e\u003c/code\u003e and the \u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e function from \u003ca\u003eNetwork.Socket\u003c/a\u003e instead.\n\u003c/p\u003e\u003cp\u003eNote: \u003ccode\u003e\u003ca\u003emaxListenQueue\u003c/a\u003e\u003c/code\u003e is tipically 128, which is too small for high\n performance servers. So, we use the maximum between \u003ccode\u003e\u003ca\u003emaxListenQueue\u003c/a\u003e\u003c/code\u003e and\n 2048 as the default size of the listening queue. The \u003ccode\u003e\u003ca\u003eNoDelay\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eReuseAddr\u003c/a\u003e\u003c/code\u003e options are set on the socket.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "HostPreference-\u003e ServiceName-\u003e ((Socket, SockAddr) -\u003e m r)-\u003e m r",
        "fct-type": "function",
        "title": "listen"
      },
      "index": {
        "description": "Bind TCP listening socket and use it The listening socket is closed when done or in case of exceptions If you prefer to acquire and close the socket yourself then use bindSock closeSock and the listen function from Network.Socket instead Note maxListenQueue is tipically which is too small for high performance servers So we use the maximum between maxListenQueue and as the default size of the listening queue The NoDelay and ReuseAddr options are set on the socket",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "listen",
        "normalized": "HostPreference-\u003eServiceName-\u003e((Socket,SockAddr)-\u003ea b)-\u003ea b",
        "package": "network-simple",
        "partial": "",
        "signature": "HostPreference-\u003eServiceName-\u003e((Socket,SockAddr)-\u003em r)-\u003em r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:recv",
      "description": {
        "fct-descr": "\u003cp\u003eRead up to a limited number of bytes from a socket.\n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the remote end closed the connection or end-of-input was\n reached. The number of returned bytes might be less than the specified limit.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "Socket -\u003e Int -\u003e m (Maybe ByteString)",
        "fct-source": "src/Network-Simple-TCP.html#recv",
        "fct-type": "function",
        "title": "recv"
      },
      "index": {
        "description": "Read up to limited number of bytes from socket Returns Nothing if the remote end closed the connection or end-of-input was reached The number of returned bytes might be less than the specified limit",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "recv",
        "normalized": "Socket-\u003eInt-\u003ea(Maybe ByteString)",
        "package": "network-simple",
        "partial": "",
        "signature": "Socket-\u003eInt-\u003em(Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:send",
      "description": {
        "fct-descr": "\u003cp\u003eWrites the given bytes to the socket.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "Socket -\u003e ByteString -\u003e m ()",
        "fct-source": "src/Network-Simple-TCP.html#send",
        "fct-type": "function",
        "title": "send"
      },
      "index": {
        "description": "Writes the given bytes to the socket",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "send",
        "normalized": "Socket-\u003eByteString-\u003ea()",
        "package": "network-simple",
        "partial": "",
        "signature": "Socket-\u003eByteString-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:serve",
      "description": {
        "fct-descr": "\u003cp\u003eStart a TCP server that accepts incoming connections and handles them\n concurrently in different threads.\n\u003c/p\u003e\u003cp\u003eAny acquired network resources are properly closed and discarded when done or\n in case of exceptions.\n\u003c/p\u003e\u003cp\u003eNote: This function performs \u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eacceptFork\u003c/a\u003e\u003c/code\u003e, so you don't need to\n perform those manually.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "HostPreference-\u003e ServiceName-\u003e ((Socket, SockAddr) -\u003e IO ())-\u003e m ()",
        "fct-type": "function",
        "title": "serve"
      },
      "index": {
        "description": "Start TCP server that accepts incoming connections and handles them concurrently in different threads Any acquired network resources are properly closed and discarded when done or in case of exceptions Note This function performs listen and acceptFork so you don need to perform those manually",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "serve",
        "normalized": "HostPreference-\u003eServiceName-\u003e((Socket,SockAddr)-\u003eIO())-\u003ea()",
        "package": "network-simple",
        "partial": "",
        "signature": "HostPreference-\u003eServiceName-\u003e((Socket,SockAddr)-\u003eIO())-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/network-simple/docs/Network-Simple-TCP.html#v:withSocketsDo",
      "description": {
        "fct-descr": "\u003cp\u003eOn Windows operating systems, the networking subsystem has to be\ninitialised using \u003ccode\u003e\u003ca\u003ewithSocketsDo\u003c/a\u003e\u003c/code\u003e before any networking operations can\nbe used.  eg.\n\u003c/p\u003e\u003cpre\u003e main = withSocketsDo $ do {...}\n\u003c/pre\u003e\u003cp\u003eAlthough this is only strictly necessary on Windows platforms, it is\nharmless on other platforms, so for portability it is good practice to\nuse it all the time.\n\u003c/p\u003e",
        "fct-module": "Network.Simple.TCP",
        "fct-package": "network-simple",
        "fct-signature": "IO a -\u003e IO a",
        "fct-type": "function",
        "title": "withSocketsDo"
      },
      "index": {
        "description": "On Windows operating systems the networking subsystem has to be initialised using withSocketsDo before any networking operations can be used eg main withSocketsDo do Although this is only strictly necessary on Windows platforms it is harmless on other platforms so for portability it is good practice to use it all the time",
        "hierarchy": "Network Simple TCP",
        "module": "Network.Simple.TCP",
        "name": "withSocketsDo",
        "normalized": "IO a-\u003eIO a",
        "package": "network-simple",
        "partial": "Sockets Do",
        "signature": "IO a-\u003eIO a"
      }
    }
  }
]
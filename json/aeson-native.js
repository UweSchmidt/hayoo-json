[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Encode.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEfficiently serialize a JSON value as a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e,\n encoded as UTF-8.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Aeson.Encode",
        "fct-package": "aeson-native",
        "fct-signature": "module",
        "fct-source": "src/Data-Aeson-Encode.html",
        "fct-type": "module",
        "title": "Encode"
      },
      "index": {
        "description": "Efficiently serialize JSON value as lazy ByteString encoded as UTF-8",
        "hierarchy": "Data Aeson Encode",
        "module": "Data.Aeson.Encode",
        "name": "Encode",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Encode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Encode.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEfficiently serialize a JSON value as a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Encode",
        "fct-package": "aeson-native",
        "fct-signature": "a -\u003e ByteString",
        "fct-source": "src/Data-Aeson-Encode.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Efficiently serialize JSON value as lazy ByteString",
        "hierarchy": "Data Aeson Encode",
        "module": "Data.Aeson.Encode",
        "name": "encode",
        "normalized": "a-\u003eByteString",
        "package": "aeson-native",
        "partial": "",
        "signature": "a-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Encode.html#v:fromValue",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a JSON value to a \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Encode",
        "fct-package": "aeson-native",
        "fct-signature": "Value -\u003e Builder",
        "fct-source": "src/Data-Aeson-Encode.html#fromValue",
        "fct-type": "function",
        "title": "fromValue"
      },
      "index": {
        "description": "Encode JSON value to Builder",
        "hierarchy": "Data Aeson Encode",
        "module": "Data.Aeson.Encode",
        "name": "fromValue",
        "normalized": "Value-\u003eBuilder",
        "package": "aeson-native",
        "partial": "Value",
        "signature": "Value-\u003eBuilder"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Generic.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eJSON handling using \u003ccode\u003eData.Generics\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is based on the \u003ccode\u003eText.JSON.Generic\u003c/code\u003e package originally written\n by Lennart Augustsson.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Aeson.Generic",
        "fct-package": "aeson-native",
        "fct-signature": "module",
        "fct-source": "src/Data-Aeson-Generic.html",
        "fct-type": "module",
        "title": "Generic"
      },
      "index": {
        "description": "JSON handling using Data.Generics This is based on the Text.JSON.Generic package originally written by Lennart Augustsson",
        "hierarchy": "Data Aeson Generic",
        "module": "Data.Aeson.Generic",
        "name": "Generic",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Generic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Generic.html#v:fromJSON",
      "description": {
        "fct-module": "Data.Aeson.Generic",
        "fct-package": "aeson-native",
        "fct-signature": "Value -\u003e Result a",
        "fct-source": "src/Data-Aeson-Generic.html#fromJSON",
        "fct-type": "function",
        "title": "fromJSON"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Generic",
        "module": "Data.Aeson.Generic",
        "name": "fromJSON",
        "normalized": "Value-\u003eResult a",
        "package": "aeson-native",
        "partial": "JSON",
        "signature": "Value-\u003eResult a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Generic.html#v:toJSON",
      "description": {
        "fct-module": "Data.Aeson.Generic",
        "fct-package": "aeson-native",
        "fct-signature": "a -\u003e Value",
        "fct-source": "src/Data-Aeson-Generic.html#toJSON",
        "fct-type": "function",
        "title": "toJSON"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Generic",
        "module": "Data.Aeson.Generic",
        "name": "toJSON",
        "normalized": "a-\u003eValue",
        "package": "aeson-native",
        "partial": "JSON",
        "signature": "a-\u003eValue"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Parser.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEfficiently and correctly parse a JSON string.  The string must be\n encoded as UTF-8.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Aeson.Parser",
        "fct-package": "aeson-native",
        "fct-signature": "module",
        "fct-source": "src/Data-Aeson-Parser.html",
        "fct-type": "module",
        "title": "Parser"
      },
      "index": {
        "description": "Efficiently and correctly parse JSON string The string must be encoded as UTF-8",
        "hierarchy": "Data Aeson Parser",
        "module": "Data.Aeson.Parser",
        "name": "Parser",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Parser.html#v:json",
      "description": {
        "fct-descr": "\u003cp\u003eParse a top-level JSON value.  This must be either an object or\n an array.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Parser",
        "fct-package": "aeson-native",
        "fct-signature": "Parser Value",
        "fct-source": "src/Data-Aeson-Parser.html#json",
        "fct-type": "function",
        "title": "json"
      },
      "index": {
        "description": "Parse top-level JSON value This must be either an object or an array",
        "hierarchy": "Data Aeson Parser",
        "module": "Data.Aeson.Parser",
        "name": "json",
        "normalized": "",
        "package": "aeson-native",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Parser.html#v:value",
      "description": {
        "fct-descr": "\u003cp\u003eParse any JSON value.  Use \u003ccode\u003e\u003ca\u003ejson\u003c/a\u003e\u003c/code\u003e in preference to this function\n if you are parsing data from an untrusted source.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Parser",
        "fct-package": "aeson-native",
        "fct-signature": "Parser Value",
        "fct-source": "src/Data-Aeson-Parser.html#value",
        "fct-type": "function",
        "title": "value"
      },
      "index": {
        "description": "Parse any JSON value Use json in preference to this function if you are parsing data from an untrusted source",
        "hierarchy": "Data Aeson Parser",
        "module": "Data.Aeson.Parser",
        "name": "value",
        "normalized": "",
        "package": "aeson-native",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes for working with JSON data.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "module",
        "fct-source": "src/Data-Aeson-Types.html",
        "fct-type": "module",
        "title": "Types"
      },
      "index": {
        "description": "Types for working with JSON data",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Types",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:Array",
      "description": {
        "fct-descr": "\u003cp\u003eA JSON \"array\" (sequence).\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "type",
        "fct-source": "src/Data-Aeson-Types.html#Array",
        "fct-type": "type",
        "title": "Array"
      },
      "index": {
        "description": "JSON array sequence",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Array",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Array",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:DotNetTime",
      "description": {
        "fct-descr": "\u003cp\u003eA newtype wrapper for \u003ccode\u003e\u003ca\u003eUTCTime\u003c/a\u003e\u003c/code\u003e that uses the same non-standard\n serialization format as Microsoft .NET, whose \u003ccode\u003eSystem.DateTime\u003c/code\u003e\n type is by default serialized to JSON as in the following example:\n\u003c/p\u003e\u003cpre\u003e /Date(1302547608878)/\n\u003c/pre\u003e\u003cp\u003eThe number represents milliseconds since the Unix epoch.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Aeson-Types.html#DotNetTime",
        "fct-type": "newtype",
        "title": "DotNetTime"
      },
      "index": {
        "description": "newtype wrapper for UTCTime that uses the same non-standard serialization format as Microsoft NET whose System.DateTime type is by default serialized to JSON as in the following example Date The number represents milliseconds since the Unix epoch",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "DotNetTime",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Dot Net Time",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:FromJSON",
      "description": {
        "fct-descr": "\u003cp\u003eA type that can be converted from JSON, with the possibility of\n failure.\n\u003c/p\u003e\u003cp\u003eWhen writing an instance, use \u003ccode\u003e\u003ca\u003emzero\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efail\u003c/a\u003e\u003c/code\u003e to make a\n conversion fail, e.g. if an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e is missing a required key, or\n the value is of the wrong type.\n\u003c/p\u003e\u003cp\u003eAn example type and instance:\n\u003c/p\u003e\u003cpre\u003edata Coord { x :: Double, y :: Double }\n\ninstance FromJSON Coord where\n   parseJSON (\u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e v) = Coord \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e\n                         v \u003ccode\u003e\u003ca\u003e.:\u003c/a\u003e\u003c/code\u003e \"x\" \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e\n                         v \u003ccode\u003e\u003ca\u003e.:\u003c/a\u003e\u003c/code\u003e \"y\"\n\n-- A non-\u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e value is of the wrong type, so use \u003ccode\u003e\u003ca\u003emzero\u003c/a\u003e\u003c/code\u003e to fail.\n   parseJSON _          = \u003ccode\u003e\u003ca\u003emzero\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "class",
        "fct-source": "src/Data-Aeson-Types.html#FromJSON",
        "fct-type": "class",
        "title": "FromJSON"
      },
      "index": {
        "description": "type that can be converted from JSON with the possibility of failure When writing an instance use mzero or fail to make conversion fail e.g if an Object is missing required key or the value is of the wrong type An example type and instance data Coord Double Double instance FromJSON Coord where parseJSON Object Coord non Object value is of the wrong type so use mzero to fail parseJSON mzero",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "FromJSON",
        "normalized": "",
        "package": "aeson-native",
        "partial": "From JSON",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:Object",
      "description": {
        "fct-descr": "\u003cp\u003eA JSON \"object\" (key/value map).\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "type",
        "fct-source": "src/Data-Aeson-Types.html#Object",
        "fct-type": "type",
        "title": "Object"
      },
      "index": {
        "description": "JSON object key value map",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Object",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Object",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:Pair",
      "description": {
        "fct-descr": "\u003cp\u003eA key/value pair for an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "type",
        "fct-source": "src/Data-Aeson-Types.html#Pair",
        "fct-type": "type",
        "title": "Pair"
      },
      "index": {
        "description": "key value pair for an Object",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Pair",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Pair",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:Parser",
      "description": {
        "fct-descr": "\u003cp\u003eA continuation-based parser type.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "data",
        "fct-source": "src/Data-Aeson-Types.html#Parser",
        "fct-type": "data",
        "title": "Parser"
      },
      "index": {
        "description": "continuation-based parser type",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Parser",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eThe result of running a \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "data",
        "fct-source": "src/Data-Aeson-Types.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "The result of running Parser",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Result",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:ToJSON",
      "description": {
        "fct-descr": "\u003cp\u003eA type that can be converted to JSON.\n\u003c/p\u003e\u003cp\u003eAn example type and instance:\n\u003c/p\u003e\u003cpre\u003edata Coord { x :: Double, y :: Double }\n\ninstance ToJSON Coord where\n   toJSON (Coord x y) = \u003ccode\u003e\u003ca\u003eobject\u003c/a\u003e\u003c/code\u003e [\"x\" \u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e x, \"y\" \u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e y]\n\u003c/pre\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "class",
        "fct-source": "src/Data-Aeson-Types.html#ToJSON",
        "fct-type": "class",
        "title": "ToJSON"
      },
      "index": {
        "description": "type that can be converted to JSON An example type and instance data Coord Double Double instance ToJSON Coord where toJSON Coord object",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "ToJSON",
        "normalized": "",
        "package": "aeson-native",
        "partial": "To JSON",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#t:Value",
      "description": {
        "fct-descr": "\u003cp\u003eA JSON value represented as a Haskell value.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "data",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "data",
        "title": "Value"
      },
      "index": {
        "description": "JSON value represented as Haskell value",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Value",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:.-61-",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003ePair\u003c/a\u003e\u003c/code\u003e from a key and a value.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Text -\u003e a -\u003e Pair",
        "fct-source": "src/Data-Aeson-Types.html#.%3D",
        "fct-type": "function",
        "title": "(.=)"
      },
      "index": {
        "description": "Construct Pair from key and value",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "(.=) .=",
        "normalized": "Text-\u003ea-\u003ePair",
        "package": "aeson-native",
        "partial": "",
        "signature": "Text-\u003ea-\u003ePair"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:.:",
      "description": {
        "fct-descr": "\u003cp\u003eRetrieve the value associated with the given key of an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e.\n The result is \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e if the key is not present or the value cannot\n be converted to the desired type.\n\u003c/p\u003e\u003cp\u003eThis accessor is appropriate if the key and value \u003cem\u003emust\u003c/em\u003e be present\n in an object for it to be valid.  If the key and value are\n optional, use '(.:?)' instead.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Object -\u003e Text -\u003e Parser a",
        "fct-source": "src/Data-Aeson-Types.html#.%3A",
        "fct-type": "function",
        "title": "(.:)"
      },
      "index": {
        "description": "Retrieve the value associated with the given key of an Object The result is empty if the key is not present or the value cannot be converted to the desired type This accessor is appropriate if the key and value must be present in an object for it to be valid If the key and value are optional use instead",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "(.:) .:",
        "normalized": "Object-\u003eText-\u003eParser a",
        "package": "aeson-native",
        "partial": "",
        "signature": "Object-\u003eText-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:.:-63-",
      "description": {
        "fct-descr": "\u003cp\u003eRetrieve the value associated with the given key of an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e.\n The result is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the key is not present, or \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e if\n the value cannot be converted to the desired type.\n\u003c/p\u003e\u003cp\u003eThis accessor is most useful if the key and value can be absent\n from an object without affecting its validity.  If the key and\n value are mandatory, use '(.:)' instead.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Object -\u003e Text -\u003e Parser (Maybe a)",
        "fct-source": "src/Data-Aeson-Types.html#.%3A%3F",
        "fct-type": "function",
        "title": "(.:?)"
      },
      "index": {
        "description": "Retrieve the value associated with the given key of an Object The result is Nothing if the key is not present or empty if the value cannot be converted to the desired type This accessor is most useful if the key and value can be absent from an object without affecting its validity If the key and value are mandatory use instead",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "(.:?) .:?",
        "normalized": "Object-\u003eText-\u003eParser(Maybe a)",
        "package": "aeson-native",
        "partial": "",
        "signature": "Object-\u003eText-\u003eParser(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:Array",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Array Array",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Array"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Array",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Array",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:Bool",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Bool !Bool",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Bool"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Bool",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Bool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:DotNetTime",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "DotNetTime",
        "fct-source": "src/Data-Aeson-Types.html#DotNetTime",
        "fct-type": "function",
        "title": "DotNetTime"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "DotNetTime",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Dot Net Time",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:Error",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Error String",
        "fct-source": "src/Data-Aeson-Types.html#Result",
        "fct-type": "function",
        "title": "Error"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Error",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Error",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:Null",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Null",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Null"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Null",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Null",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:Number",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Number Number",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Number"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Number",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Number",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:Object",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Object Object",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Object"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Object",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Object",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:String",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "String Text",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "String"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "String",
        "normalized": "",
        "package": "aeson-native",
        "partial": "String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:Success",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Success a",
        "fct-source": "src/Data-Aeson-Types.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "Success",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:emptyArray",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty array.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Value",
        "fct-source": "src/Data-Aeson-Types.html#emptyArray",
        "fct-type": "function",
        "title": "emptyArray"
      },
      "index": {
        "description": "The empty array",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "emptyArray",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Array",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:emptyObject",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty object.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Value",
        "fct-source": "src/Data-Aeson-Types.html#emptyObject",
        "fct-type": "function",
        "title": "emptyObject"
      },
      "index": {
        "description": "The empty object",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "emptyObject",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Object",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:fromDotNetTime",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "UTCTime",
        "fct-source": "src/Data-Aeson-Types.html#DotNetTime",
        "fct-type": "function",
        "title": "fromDotNetTime"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "fromDotNetTime",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Dot Net Time",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:fromJSON",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a value from JSON, failing if the types do not match.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Value -\u003e Result a",
        "fct-source": "src/Data-Aeson-Types.html#fromJSON",
        "fct-type": "function",
        "title": "fromJSON"
      },
      "index": {
        "description": "Convert value from JSON failing if the types do not match",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "fromJSON",
        "normalized": "Value-\u003eResult a",
        "package": "aeson-native",
        "partial": "JSON",
        "signature": "Value-\u003eResult a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:object",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e from a list of name/value \u003ccode\u003e\u003ca\u003ePair\u003c/a\u003e\u003c/code\u003es.  If duplicate\n keys arise, earlier keys and their associated values win.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "[Pair] -\u003e Value",
        "fct-source": "src/Data-Aeson-Types.html#object",
        "fct-type": "function",
        "title": "object"
      },
      "index": {
        "description": "Create Value from list of name value Pair If duplicate keys arise earlier keys and their associated values win",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "object",
        "normalized": "[Pair]-\u003eValue",
        "package": "aeson-native",
        "partial": "",
        "signature": "[Pair]-\u003eValue"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:parse",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "(a -\u003e Parser b) -\u003e a -\u003e Result b",
        "fct-source": "src/Data-Aeson-Types.html#parse",
        "fct-type": "function",
        "title": "parse"
      },
      "index": {
        "description": "Run Parser",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "parse",
        "normalized": "(a-\u003eParser b)-\u003ea-\u003eResult b",
        "package": "aeson-native",
        "partial": "",
        "signature": "(a-\u003eParser b)-\u003ea-\u003eResult b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:parseEither",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e with an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e result type.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "(a -\u003e Parser b) -\u003e a -\u003e Either String b",
        "fct-source": "src/Data-Aeson-Types.html#parseEither",
        "fct-type": "function",
        "title": "parseEither"
      },
      "index": {
        "description": "Run Parser with an Either result type",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "parseEither",
        "normalized": "(a-\u003eParser b)-\u003ea-\u003eEither String b",
        "package": "aeson-native",
        "partial": "Either",
        "signature": "(a-\u003eParser b)-\u003ea-\u003eEither String b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:parseJSON",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "Value -\u003e Parser a",
        "fct-source": "src/Data-Aeson-Types.html#parseJSON",
        "fct-type": "method",
        "title": "parseJSON"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "parseJSON",
        "normalized": "Value-\u003eParser a",
        "package": "aeson-native",
        "partial": "JSON",
        "signature": "Value-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:parseMaybe",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e result type.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "(a -\u003e Parser b) -\u003e a -\u003e Maybe b",
        "fct-source": "src/Data-Aeson-Types.html#parseMaybe",
        "fct-type": "function",
        "title": "parseMaybe"
      },
      "index": {
        "description": "Run Parser with Maybe result type",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "parseMaybe",
        "normalized": "(a-\u003eParser b)-\u003ea-\u003eMaybe b",
        "package": "aeson-native",
        "partial": "Maybe",
        "signature": "(a-\u003eParser b)-\u003ea-\u003eMaybe b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:toJSON",
      "description": {
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "a -\u003e Value",
        "fct-source": "src/Data-Aeson-Types.html#toJSON",
        "fct-type": "method",
        "title": "toJSON"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "toJSON",
        "normalized": "a-\u003eValue",
        "package": "aeson-native",
        "partial": "JSON",
        "signature": "a-\u003eValue"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson-Types.html#v:typeMismatch",
      "description": {
        "fct-descr": "\u003cp\u003eFail parsing due to a type mismatch, with a descriptive message.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson.Types",
        "fct-package": "aeson-native",
        "fct-signature": "String-\u003e Value-\u003e Parser a",
        "fct-type": "function",
        "title": "typeMismatch"
      },
      "index": {
        "description": "Fail parsing due to type mismatch with descriptive message",
        "hierarchy": "Data Aeson Types",
        "module": "Data.Aeson.Types",
        "name": "typeMismatch",
        "normalized": "String-\u003eValue-\u003eParser a",
        "package": "aeson-native",
        "partial": "Mismatch",
        "signature": "String-\u003eValue-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes and functions for working efficiently with JSON data.\n\u003c/p\u003e\u003cp\u003e(A note on naming: in Greek mythology, Aeson was the father of Jason.)\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "module",
        "fct-source": "src/Data-Aeson.html",
        "fct-type": "module",
        "title": "Aeson"
      },
      "index": {
        "description": "Types and functions for working efficiently with JSON data note on naming in Greek mythology Aeson was the father of Jason",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Aeson",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Aeson",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#t:Array",
      "description": {
        "fct-descr": "\u003cp\u003eA JSON \"array\" (sequence).\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "type",
        "fct-source": "src/Data-Aeson-Types.html#Array",
        "fct-type": "type",
        "title": "Array"
      },
      "index": {
        "description": "JSON array sequence",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Array",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Array",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#t:DotNetTime",
      "description": {
        "fct-descr": "\u003cp\u003eA newtype wrapper for \u003ccode\u003e\u003ca\u003eUTCTime\u003c/a\u003e\u003c/code\u003e that uses the same non-standard\n serialization format as Microsoft .NET, whose \u003ccode\u003eSystem.DateTime\u003c/code\u003e\n type is by default serialized to JSON as in the following example:\n\u003c/p\u003e\u003cpre\u003e /Date(1302547608878)/\n\u003c/pre\u003e\u003cp\u003eThe number represents milliseconds since the Unix epoch.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Aeson-Types.html#DotNetTime",
        "fct-type": "newtype",
        "title": "DotNetTime"
      },
      "index": {
        "description": "newtype wrapper for UTCTime that uses the same non-standard serialization format as Microsoft NET whose System.DateTime type is by default serialized to JSON as in the following example Date The number represents milliseconds since the Unix epoch",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "DotNetTime",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Dot Net Time",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#t:FromJSON",
      "description": {
        "fct-descr": "\u003cp\u003eA type that can be converted from JSON, with the possibility of\n failure.\n\u003c/p\u003e\u003cp\u003eWhen writing an instance, use \u003ccode\u003e\u003ca\u003emzero\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efail\u003c/a\u003e\u003c/code\u003e to make a\n conversion fail, e.g. if an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e is missing a required key, or\n the value is of the wrong type.\n\u003c/p\u003e\u003cp\u003eAn example type and instance:\n\u003c/p\u003e\u003cpre\u003edata Coord { x :: Double, y :: Double }\n\ninstance FromJSON Coord where\n   parseJSON (\u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e v) = Coord \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e\n                         v \u003ccode\u003e\u003ca\u003e.:\u003c/a\u003e\u003c/code\u003e \"x\" \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e\n                         v \u003ccode\u003e\u003ca\u003e.:\u003c/a\u003e\u003c/code\u003e \"y\"\n\n-- A non-\u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e value is of the wrong type, so use \u003ccode\u003e\u003ca\u003emzero\u003c/a\u003e\u003c/code\u003e to fail.\n   parseJSON _          = \u003ccode\u003e\u003ca\u003emzero\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "class",
        "fct-source": "src/Data-Aeson-Types.html#FromJSON",
        "fct-type": "class",
        "title": "FromJSON"
      },
      "index": {
        "description": "type that can be converted from JSON with the possibility of failure When writing an instance use mzero or fail to make conversion fail e.g if an Object is missing required key or the value is of the wrong type An example type and instance data Coord Double Double instance FromJSON Coord where parseJSON Object Coord non Object value is of the wrong type so use mzero to fail parseJSON mzero",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "FromJSON",
        "normalized": "",
        "package": "aeson-native",
        "partial": "From JSON",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#t:Object",
      "description": {
        "fct-descr": "\u003cp\u003eA JSON \"object\" (key/value map).\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "type",
        "fct-source": "src/Data-Aeson-Types.html#Object",
        "fct-type": "type",
        "title": "Object"
      },
      "index": {
        "description": "JSON object key value map",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Object",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Object",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003eThe result of running a \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "data",
        "fct-source": "src/Data-Aeson-Types.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "The result of running Parser",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Result",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#t:ToJSON",
      "description": {
        "fct-descr": "\u003cp\u003eA type that can be converted to JSON.\n\u003c/p\u003e\u003cp\u003eAn example type and instance:\n\u003c/p\u003e\u003cpre\u003edata Coord { x :: Double, y :: Double }\n\ninstance ToJSON Coord where\n   toJSON (Coord x y) = \u003ccode\u003e\u003ca\u003eobject\u003c/a\u003e\u003c/code\u003e [\"x\" \u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e x, \"y\" \u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e y]\n\u003c/pre\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "class",
        "fct-source": "src/Data-Aeson-Types.html#ToJSON",
        "fct-type": "class",
        "title": "ToJSON"
      },
      "index": {
        "description": "type that can be converted to JSON An example type and instance data Coord Double Double instance ToJSON Coord where toJSON Coord object",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "ToJSON",
        "normalized": "",
        "package": "aeson-native",
        "partial": "To JSON",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#t:Value",
      "description": {
        "fct-descr": "\u003cp\u003eA JSON value represented as a Haskell value.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "data",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "data",
        "title": "Value"
      },
      "index": {
        "description": "JSON value represented as Haskell value",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Value",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:.-61-",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003ePair\u003c/a\u003e\u003c/code\u003e from a key and a value.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Text -\u003e a -\u003e Pair",
        "fct-source": "src/Data-Aeson-Types.html#.%3D",
        "fct-type": "function",
        "title": "(.=)"
      },
      "index": {
        "description": "Construct Pair from key and value",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "(.=) .=",
        "normalized": "Text-\u003ea-\u003ePair",
        "package": "aeson-native",
        "partial": "",
        "signature": "Text-\u003ea-\u003ePair"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:.:",
      "description": {
        "fct-descr": "\u003cp\u003eRetrieve the value associated with the given key of an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e.\n The result is \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e if the key is not present or the value cannot\n be converted to the desired type.\n\u003c/p\u003e\u003cp\u003eThis accessor is appropriate if the key and value \u003cem\u003emust\u003c/em\u003e be present\n in an object for it to be valid.  If the key and value are\n optional, use '(.:?)' instead.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Object -\u003e Text -\u003e Parser a",
        "fct-source": "src/Data-Aeson-Types.html#.%3A",
        "fct-type": "function",
        "title": "(.:)"
      },
      "index": {
        "description": "Retrieve the value associated with the given key of an Object The result is empty if the key is not present or the value cannot be converted to the desired type This accessor is appropriate if the key and value must be present in an object for it to be valid If the key and value are optional use instead",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "(.:) .:",
        "normalized": "Object-\u003eText-\u003eParser a",
        "package": "aeson-native",
        "partial": "",
        "signature": "Object-\u003eText-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:.:-63-",
      "description": {
        "fct-descr": "\u003cp\u003eRetrieve the value associated with the given key of an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e.\n The result is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the key is not present, or \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e if\n the value cannot be converted to the desired type.\n\u003c/p\u003e\u003cp\u003eThis accessor is most useful if the key and value can be absent\n from an object without affecting its validity.  If the key and\n value are mandatory, use '(.:)' instead.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Object -\u003e Text -\u003e Parser (Maybe a)",
        "fct-source": "src/Data-Aeson-Types.html#.%3A%3F",
        "fct-type": "function",
        "title": "(.:?)"
      },
      "index": {
        "description": "Retrieve the value associated with the given key of an Object The result is Nothing if the key is not present or empty if the value cannot be converted to the desired type This accessor is most useful if the key and value can be absent from an object without affecting its validity If the key and value are mandatory use instead",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "(.:?) .:?",
        "normalized": "Object-\u003eText-\u003eParser(Maybe a)",
        "package": "aeson-native",
        "partial": "",
        "signature": "Object-\u003eText-\u003eParser(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:Array",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Array Array",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Array"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Array",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Array",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:Bool",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Bool !Bool",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Bool"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Bool",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Bool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:DotNetTime",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "DotNetTime",
        "fct-source": "src/Data-Aeson-Types.html#DotNetTime",
        "fct-type": "function",
        "title": "DotNetTime"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "DotNetTime",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Dot Net Time",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:Error",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Error String",
        "fct-source": "src/Data-Aeson-Types.html#Result",
        "fct-type": "function",
        "title": "Error"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Error",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Error",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:Null",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Null",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Null"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Null",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Null",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:Number",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Number Number",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Number"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Number",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Number",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:Object",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Object Object",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "Object"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Object",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Object",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:String",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "String Text",
        "fct-source": "src/Data-Aeson-Types.html#Value",
        "fct-type": "function",
        "title": "String"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "String",
        "normalized": "",
        "package": "aeson-native",
        "partial": "String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:Success",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Success a",
        "fct-source": "src/Data-Aeson-Types.html#Result",
        "fct-type": "function",
        "title": "Success"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "Success",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEfficiently serialize a JSON value as a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "a -\u003e ByteString",
        "fct-source": "src/Data-Aeson-Encode.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Efficiently serialize JSON value as lazy ByteString",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "encode",
        "normalized": "a-\u003eByteString",
        "package": "aeson-native",
        "partial": "",
        "signature": "a-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:fromDotNetTime",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "UTCTime",
        "fct-source": "src/Data-Aeson-Types.html#DotNetTime",
        "fct-type": "function",
        "title": "fromDotNetTime"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "fromDotNetTime",
        "normalized": "",
        "package": "aeson-native",
        "partial": "Dot Net Time",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:fromJSON",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a value from JSON, failing if the types do not match.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Value -\u003e Result a",
        "fct-source": "src/Data-Aeson-Types.html#fromJSON",
        "fct-type": "function",
        "title": "fromJSON"
      },
      "index": {
        "description": "Convert value from JSON failing if the types do not match",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "fromJSON",
        "normalized": "Value-\u003eResult a",
        "package": "aeson-native",
        "partial": "JSON",
        "signature": "Value-\u003eResult a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:json",
      "description": {
        "fct-descr": "\u003cp\u003eParse a top-level JSON value.  This must be either an object or\n an array.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Parser Value",
        "fct-source": "src/Data-Aeson-Parser.html#json",
        "fct-type": "function",
        "title": "json"
      },
      "index": {
        "description": "Parse top-level JSON value This must be either an object or an array",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "json",
        "normalized": "",
        "package": "aeson-native",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:object",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e from a list of name/value \u003ccode\u003e\u003ca\u003ePair\u003c/a\u003e\u003c/code\u003es.  If duplicate\n keys arise, earlier keys and their associated values win.\n\u003c/p\u003e",
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "[Pair] -\u003e Value",
        "fct-source": "src/Data-Aeson-Types.html#object",
        "fct-type": "function",
        "title": "object"
      },
      "index": {
        "description": "Create Value from list of name value Pair If duplicate keys arise earlier keys and their associated values win",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "object",
        "normalized": "[Pair]-\u003eValue",
        "package": "aeson-native",
        "partial": "",
        "signature": "[Pair]-\u003eValue"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:parseJSON",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "Value -\u003e Parser a",
        "fct-source": "src/Data-Aeson-Types.html#parseJSON",
        "fct-type": "method",
        "title": "parseJSON"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "parseJSON",
        "normalized": "Value-\u003eParser a",
        "package": "aeson-native",
        "partial": "JSON",
        "signature": "Value-\u003eParser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/aeson-native/docs/Data-Aeson.html#v:toJSON",
      "description": {
        "fct-module": "Data.Aeson",
        "fct-package": "aeson-native",
        "fct-signature": "a -\u003e Value",
        "fct-source": "src/Data-Aeson-Types.html#toJSON",
        "fct-type": "method",
        "title": "toJSON"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Aeson",
        "module": "Data.Aeson",
        "name": "toJSON",
        "normalized": "a-\u003eValue",
        "package": "aeson-native",
        "partial": "JSON",
        "signature": "a-\u003eValue"
      }
    }
  }
]
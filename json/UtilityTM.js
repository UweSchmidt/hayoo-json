[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/UtilityTM/docs/Control-Monad-TM.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonadic combinators missing from the standard library\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.TM",
        "fct-package": "UtilityTM",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-TM.html",
        "fct-type": "module",
        "title": "TM"
      },
      "index": {
        "description": "Monadic combinators missing from the standard library",
        "hierarchy": "Control Monad TM",
        "module": "Control.Monad.TM",
        "name": "TM",
        "normalized": "",
        "package": "UtilityTM",
        "partial": "TM",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/UtilityTM/docs/Control-Monad-TM.html#v:.-61--60--60-.",
      "description": {
        "fct-descr": "\u003cp\u003eLifting bind into a monad. Often denoted \u003cem\u003econcatMapM\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.TM",
        "fct-package": "UtilityTM",
        "fct-signature": "(a -\u003e q (m b)) -\u003e m a -\u003e q (m b)",
        "fct-source": "src/Control-Monad-TM.html#.%3D%3C%3C.",
        "fct-type": "function",
        "title": "(.=\u003c\u003c.)"
      },
      "index": {
        "description": "Lifting bind into monad Often denoted concatMapM",
        "hierarchy": "Control Monad TM",
        "module": "Control.Monad.TM",
        "name": "(.=\u003c\u003c.) .=\u003c\u003c.",
        "normalized": "(a-\u003eb(c d))-\u003ec a-\u003eb(c d)",
        "package": "UtilityTM",
        "partial": "",
        "signature": "(a-\u003eq(m b))-\u003em a-\u003eq(m b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/UtilityTM/docs/Control-Monad-TM.html#v:.-62--62--61-.",
      "description": {
        "fct-descr": "\u003cp\u003eLifting bind into a monad. Often denoted \u003cem\u003econcatMapM\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.TM",
        "fct-package": "UtilityTM",
        "fct-signature": "m a -\u003e (a -\u003e q (m b)) -\u003e q (m b)",
        "fct-source": "src/Control-Monad-TM.html#.%3E%3E%3D.",
        "fct-type": "function",
        "title": "(.\u003e\u003e=.)"
      },
      "index": {
        "description": "Lifting bind into monad Often denoted concatMapM",
        "hierarchy": "Control Monad TM",
        "module": "Control.Monad.TM",
        "name": "(.\u003e\u003e=.) .\u003e\u003e=.",
        "normalized": "a b-\u003e(b-\u003ec(a d))-\u003ec(a d)",
        "package": "UtilityTM",
        "partial": "",
        "signature": "m a-\u003e(a-\u003eq(m b))-\u003eq(m b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/UtilityTM/docs/Control-Monad-TM.html#v:allM",
      "description": {
        "fct-descr": "\u003cp\u003eUniversal quantification.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.TM",
        "fct-package": "UtilityTM",
        "fct-signature": "(a -\u003e m Bool) -\u003e [a] -\u003e m Bool",
        "fct-source": "src/Control-Monad-TM.html#allM",
        "fct-type": "function",
        "title": "allM"
      },
      "index": {
        "description": "Universal quantification",
        "hierarchy": "Control Monad TM",
        "module": "Control.Monad.TM",
        "name": "allM",
        "normalized": "(a-\u003eb Bool)-\u003e[a]-\u003eb Bool",
        "package": "UtilityTM",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003e[a]-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/UtilityTM/docs/Control-Monad-TM.html#v:anyM",
      "description": {
        "fct-descr": "\u003cp\u003eExistential quantification.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.TM",
        "fct-package": "UtilityTM",
        "fct-signature": "(a -\u003e m Bool) -\u003e [a] -\u003e m Bool",
        "fct-source": "src/Control-Monad-TM.html#anyM",
        "fct-type": "function",
        "title": "anyM"
      },
      "index": {
        "description": "Existential quantification",
        "hierarchy": "Control Monad TM",
        "module": "Control.Monad.TM",
        "name": "anyM",
        "normalized": "(a-\u003eb Bool)-\u003e[a]-\u003eb Bool",
        "package": "UtilityTM",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003e[a]-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/UtilityTM/docs/Control-Monad-TM.html#v:findM",
      "description": {
        "fct-descr": "\u003cp\u003eFind an element satisfying a predicate\n\u003c/p\u003e",
        "fct-module": "Control.Monad.TM",
        "fct-package": "UtilityTM",
        "fct-signature": "(a -\u003e m Bool) -\u003e [a] -\u003e m (Maybe a)",
        "fct-source": "src/Control-Monad-TM.html#findM",
        "fct-type": "function",
        "title": "findM"
      },
      "index": {
        "description": "Find an element satisfying predicate",
        "hierarchy": "Control Monad TM",
        "module": "Control.Monad.TM",
        "name": "findM",
        "normalized": "(a-\u003eb Bool)-\u003e[a]-\u003eb(Maybe a)",
        "package": "UtilityTM",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003e[a]-\u003em(Maybe a)"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSmartCheck arguments.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-Args.html",
        "fct-type": "module",
        "title": "Args"
      },
      "index": {
        "description": "SmartCheck arguments",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "Args",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Args",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#t:Format",
      "description": {
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "data",
        "fct-source": "src/Test-SmartCheck-Args.html#Format",
        "fct-type": "data",
        "title": "Format"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "Format",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Format",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#t:ScArgs",
      "description": {
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "data",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "data",
        "title": "ScArgs"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "ScArgs",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Sc Args",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:PrintString",
      "description": {
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "PrintString",
        "fct-source": "src/Test-SmartCheck-Args.html#Format",
        "fct-type": "function",
        "title": "PrintString"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "PrintString",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Print String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:PrintTree",
      "description": {
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "PrintTree",
        "fct-source": "src/Test-SmartCheck-Args.html#Format",
        "fct-type": "function",
        "title": "PrintTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "PrintTree",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Print Tree",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:ScArgs",
      "description": {
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "ScArgs",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "ScArgs"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "ScArgs",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Sc Args",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:format",
      "description": {
        "fct-descr": "\u003cp\u003eHow to show extrapolated formula\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Format",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "format"
      },
      "index": {
        "description": "How to show extrapolated formula",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "format",
        "normalized": "",
        "package": "smartcheck",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:qc",
      "description": {
        "fct-descr": "\u003cp\u003eShould we run QuickCheck?  (If not,\n   you are expected to pass in data to\n   analyze.)\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Bool",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "qc"
      },
      "index": {
        "description": "Should we run QuickCheck If not you are expected to pass in data to analyze",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "qc",
        "normalized": "",
        "package": "smartcheck",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:qcArgs",
      "description": {
        "fct-descr": "\u003cp\u003eQuickCheck arguments\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Args",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "qcArgs"
      },
      "index": {
        "description": "QuickCheck arguments",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "qcArgs",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Args",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:runExists",
      "description": {
        "fct-descr": "\u003cp\u003eShould we try to generalize\n   constructors?\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Bool",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "runExists"
      },
      "index": {
        "description": "Should we try to generalize constructors",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "runExists",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Exists",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:runForall",
      "description": {
        "fct-descr": "\u003cp\u003eShould we extrapolate?\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Bool",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "runForall"
      },
      "index": {
        "description": "Should we extrapolate",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "runForall",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Forall",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:scMaxDepth",
      "description": {
        "fct-descr": "\u003cp\u003eHow many levels into the structure of\n   the failed value should we descend\n   when reducing or generalizing?\n   Nothing means we go down to base\n   types.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Maybe Int",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "scMaxDepth"
      },
      "index": {
        "description": "How many levels into the structure of the failed value should we descend when reducing or generalizing Nothing means we go down to base types",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "scMaxDepth",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Max Depth",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:scMaxExists",
      "description": {
        "fct-descr": "\u003cp\u003eHow hard (number of rounds) to look\n for failing values with each\n constructor.  For \u003ca\u003ewide\u003c/a\u003e sum types, this\n value should be increased.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Int",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "scMaxExists"
      },
      "index": {
        "description": "How hard number of rounds to look for failing values with each constructor For wide sum types this value should be increased",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "scMaxExists",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Max Exists",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:scMaxForall",
      "description": {
        "fct-descr": "\u003cp\u003eHow hard (number of rounds) to look\n   for failures during the extrapolation\n   stage.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Int",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "scMaxForall"
      },
      "index": {
        "description": "How hard number of rounds to look for failures during the extrapolation stage",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "scMaxForall",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Max Forall",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:scMaxReduce",
      "description": {
        "fct-descr": "\u003cp\u003eHow hard (number of rounds) to look\n   for failure in the reduction stage.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Int",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "scMaxReduce"
      },
      "index": {
        "description": "How hard number of rounds to look for failure in the reduction stage",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "scMaxReduce",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Max Reduce",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:scMaxSize",
      "description": {
        "fct-descr": "\u003cp\u003eMaximum size of data to generate, in\n   terms of the size parameter of\n   QuickCheck's Arbitrary instance for\n   your data.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Int",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "scMaxSize"
      },
      "index": {
        "description": "Maximum size of data to generate in terms of the size parameter of QuickCheck Arbitrary instance for your data",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "scMaxSize",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Max Size",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:scMinForall",
      "description": {
        "fct-descr": "\u003cp\u003eMinimum number of times a property's\n precondition must be passed to\n generalize it.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "Int",
        "fct-source": "src/Test-SmartCheck-Args.html#ScArgs",
        "fct-type": "function",
        "title": "scMinForall"
      },
      "index": {
        "description": "Minimum number of times property precondition must be passed to generalize it",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "scMinForall",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Min Forall",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Args.html#v:scStdArgs",
      "description": {
        "fct-module": "Test.SmartCheck.Args",
        "fct-package": "smartcheck",
        "fct-signature": "ScArgs",
        "fct-source": "src/Test-SmartCheck-Args.html#scStdArgs",
        "fct-type": "function",
        "title": "scStdArgs"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Args",
        "module": "Test.SmartCheck.Args",
        "name": "scStdArgs",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Std Args",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-ConstructorGen.html#",
      "description": {
        "fct-module": "Test.SmartCheck.ConstructorGen",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-ConstructorGen.html",
        "fct-type": "module",
        "title": "ConstructorGen"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck ConstructorGen",
        "module": "Test.SmartCheck.ConstructorGen",
        "name": "ConstructorGen",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Constructor Gen",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-ConstructorGen.html#v:constrsGen",
      "description": {
        "fct-descr": "\u003cp\u003eEntry point to generalize constructors.  We pass in a list of indexes from\n value generalizations so we don't try to generalize those constructors (or\n anything below).\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.ConstructorGen",
        "fct-package": "smartcheck",
        "fct-signature": "ScArgs -\u003e a -\u003e (a -\u003e Property) -\u003e [Idx] -\u003e IO [Idx]",
        "fct-source": "src/Test-SmartCheck-ConstructorGen.html#constrsGen",
        "fct-type": "function",
        "title": "constrsGen"
      },
      "index": {
        "description": "Entry point to generalize constructors We pass in list of indexes from value generalizations so we don try to generalize those constructors or anything below",
        "hierarchy": "Test SmartCheck ConstructorGen",
        "module": "Test.SmartCheck.ConstructorGen",
        "name": "constrsGen",
        "normalized": "ScArgs-\u003ea-\u003e(a-\u003eProperty)-\u003e[Idx]-\u003eIO[Idx]",
        "package": "smartcheck",
        "partial": "Gen",
        "signature": "ScArgs-\u003ea-\u003e(a-\u003eProperty)-\u003e[Idx]-\u003eIO[Idx]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#",
      "description": {
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-DataToTree.html",
        "fct-type": "module",
        "title": "DataToTree"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "DataToTree",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Data To Tree",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#v:breadthLevels",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the list of values at each level in a Forest Not like levels in\n Data.Tree (but what I imagined it should have done!).\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "Forest a -\u003e [[a]]",
        "fct-source": "src/Test-SmartCheck-DataToTree.html#breadthLevels",
        "fct-type": "function",
        "title": "breadthLevels"
      },
      "index": {
        "description": "Return the list of values at each level in Forest Not like levels in Data.Tree but what imagined it should have done",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "breadthLevels",
        "normalized": "Forest a-\u003e[[a]]",
        "package": "smartcheck",
        "partial": "Levels",
        "signature": "Forest a-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#v:depth",
      "description": {
        "fct-descr": "\u003cp\u003eGet the depth of a Forest.  0-based (an empty Forest has depth 0).\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "Forest a -\u003e Int",
        "fct-source": "src/Test-SmartCheck-DataToTree.html#depth",
        "fct-type": "function",
        "title": "depth"
      },
      "index": {
        "description": "Get the depth of Forest based an empty Forest has depth",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "depth",
        "normalized": "Forest a-\u003eInt",
        "package": "smartcheck",
        "partial": "",
        "signature": "Forest a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#v:forestReplaceChildren",
      "description": {
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "Forest a -\u003e Idx -\u003e a -\u003e Forest a",
        "fct-source": "src/Test-SmartCheck-DataToTree.html#forestReplaceChildren",
        "fct-type": "function",
        "title": "forestReplaceChildren"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "forestReplaceChildren",
        "normalized": "Forest a-\u003eIdx-\u003ea-\u003eForest a",
        "package": "smartcheck",
        "partial": "Replace Children",
        "signature": "Forest a-\u003eIdx-\u003ea-\u003eForest a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#v:getAtIdx",
      "description": {
        "fct-descr": "\u003cp\u003eReturns the value at index idx.  Returns nothing if the index is out of\n bounds.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "a-\u003e Idx-\u003e Maybe Int-\u003e Maybe SubT",
        "fct-type": "function",
        "title": "getAtIdx"
      },
      "index": {
        "description": "Returns the value at index idx Returns nothing if the index is out of bounds",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "getAtIdx",
        "normalized": "a-\u003eIdx-\u003eMaybe Int-\u003eMaybe SubT",
        "package": "smartcheck",
        "partial": "At Idx",
        "signature": "a-\u003eIdx-\u003eMaybe Int-\u003eMaybe SubT"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#v:getIdxForest",
      "description": {
        "fct-descr": "\u003cp\u003eGet the tree at idx in a forest.  Nothing if the index is out-of-bounds.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "Forest a -\u003e Idx -\u003e Maybe (Tree a)",
        "fct-source": "src/Test-SmartCheck-DataToTree.html#getIdxForest",
        "fct-type": "function",
        "title": "getIdxForest"
      },
      "index": {
        "description": "Get the tree at idx in forest Nothing if the index is out-of-bounds",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "getIdxForest",
        "normalized": "Forest a-\u003eIdx-\u003eMaybe(Tree a)",
        "package": "smartcheck",
        "partial": "Idx Forest",
        "signature": "Forest a-\u003eIdx-\u003eMaybe(Tree a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#v:mkSubstForest",
      "description": {
        "fct-descr": "\u003cp\u003eMake a substitution Forest (all proper children).  Initially we don't\n replace anything.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e b -\u003e Forest b",
        "fct-source": "src/Test-SmartCheck-DataToTree.html#mkSubstForest",
        "fct-type": "function",
        "title": "mkSubstForest"
      },
      "index": {
        "description": "Make substitution Forest all proper children Initially we don replace anything",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "mkSubstForest",
        "normalized": "a-\u003eb-\u003eForest b",
        "package": "smartcheck",
        "partial": "Subst Forest",
        "signature": "a-\u003eb-\u003eForest b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#v:replaceAtIdx",
      "description": {
        "fct-descr": "\u003cp\u003eReplace a value at index idx generically in a Tree/Forest generically.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "a-\u003e Idx-\u003e b-\u003e Maybe a",
        "fct-type": "function",
        "title": "replaceAtIdx"
      },
      "index": {
        "description": "Replace value at index idx generically in Tree Forest generically",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "replaceAtIdx",
        "normalized": "a-\u003eIdx-\u003eb-\u003eMaybe a",
        "package": "smartcheck",
        "partial": "At Idx",
        "signature": "a-\u003eIdx-\u003eb-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-DataToTree.html#v:tooDeep",
      "description": {
        "fct-module": "Test.SmartCheck.DataToTree",
        "fct-package": "smartcheck",
        "fct-signature": "Int -\u003e Maybe Int -\u003e Bool",
        "fct-source": "src/Test-SmartCheck-DataToTree.html#tooDeep",
        "fct-type": "function",
        "title": "tooDeep"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck DataToTree",
        "module": "Test.SmartCheck.DataToTree",
        "name": "tooDeep",
        "normalized": "Int-\u003eMaybe Int-\u003eBool",
        "package": "smartcheck",
        "partial": "Deep",
        "signature": "Int-\u003eMaybe Int-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Extrapolate.html#",
      "description": {
        "fct-module": "Test.SmartCheck.Extrapolate",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-Extrapolate.html",
        "fct-type": "module",
        "title": "Extrapolate"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Extrapolate",
        "module": "Test.SmartCheck.Extrapolate",
        "name": "Extrapolate",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Extrapolate",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Extrapolate.html#v:extrapolate",
      "description": {
        "fct-descr": "\u003cp\u003eTest d with arbitrary values replacing its children.  For anything we get\n 100% failure for, we claim we can generalize it---any term in that hole\n fails.\n\u003c/p\u003e\u003cp\u003eWe extrapolate if there exists at least one test that satisfies the\n precondition, and for all tests that satisfy the precondition, they fail.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Extrapolate",
        "fct-package": "smartcheck",
        "fct-signature": "ScArgs-\u003e a-\u003e (a -\u003e Property)-\u003e IO [Idx]",
        "fct-type": "function",
        "title": "extrapolate"
      },
      "index": {
        "description": "Test with arbitrary values replacing its children For anything we get failure for we claim we can generalize it---any term in that hole fails We extrapolate if there exists at least one test that satisfies the precondition and for all tests that satisfy the precondition they fail",
        "hierarchy": "Test SmartCheck Extrapolate",
        "module": "Test.SmartCheck.Extrapolate",
        "name": "extrapolate",
        "normalized": "ScArgs-\u003ea-\u003e(a-\u003eProperty)-\u003eIO[Idx]",
        "package": "smartcheck",
        "partial": "",
        "signature": "ScArgs-\u003ea-\u003e(a-\u003eProperty)-\u003eIO[Idx]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Matches.html#",
      "description": {
        "fct-module": "Test.SmartCheck.Matches",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-Matches.html",
        "fct-type": "module",
        "title": "Matches"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Matches",
        "module": "Test.SmartCheck.Matches",
        "name": "Matches",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Matches",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Matches.html#v:matchesShapes",
      "description": {
        "fct-descr": "\u003cp\u003eTrue if d matches any ds.  Assume all ds are unequal to each other.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Matches",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e [(a, Replace Idx)] -\u003e Bool",
        "fct-source": "src/Test-SmartCheck-Matches.html#matchesShapes",
        "fct-type": "function",
        "title": "matchesShapes"
      },
      "index": {
        "description": "True if matches any ds Assume all ds are unequal to each other",
        "hierarchy": "Test SmartCheck Matches",
        "module": "Test.SmartCheck.Matches",
        "name": "matchesShapes",
        "normalized": "a-\u003e[(a,Replace Idx)]-\u003eBool",
        "package": "smartcheck",
        "partial": "Shapes",
        "signature": "a-\u003e[(a,Replace Idx)]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Reduce.html#",
      "description": {
        "fct-module": "Test.SmartCheck.Reduce",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-Reduce.html",
        "fct-type": "module",
        "title": "Reduce"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Reduce",
        "module": "Test.SmartCheck.Reduce",
        "name": "Reduce",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Reduce",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Reduce.html#v:smartRun",
      "description": {
        "fct-module": "Test.SmartCheck.Reduce",
        "fct-package": "smartcheck",
        "fct-signature": "ScArgs -\u003e a -\u003e (a -\u003e Property) -\u003e IO a",
        "fct-source": "src/Test-SmartCheck-Reduce.html#smartRun",
        "fct-type": "function",
        "title": "smartRun"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Reduce",
        "module": "Test.SmartCheck.Reduce",
        "name": "smartRun",
        "normalized": "ScArgs-\u003ea-\u003e(a-\u003eProperty)-\u003eIO a",
        "package": "smartcheck",
        "partial": "Run",
        "signature": "ScArgs-\u003ea-\u003e(a-\u003eProperty)-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Render.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRendering arbitrary data, and filling in holes in the data with variables.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Test.SmartCheck.Render",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-Render.html",
        "fct-type": "module",
        "title": "Render"
      },
      "index": {
        "description": "Rendering arbitrary data and filling in holes in the data with variables",
        "hierarchy": "Test SmartCheck Render",
        "module": "Test.SmartCheck.Render",
        "name": "Render",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Render",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Render.html#v:renderWithVars",
      "description": {
        "fct-module": "Test.SmartCheck.Render",
        "fct-package": "smartcheck",
        "fct-signature": "Format -\u003e a -\u003e Replace Idx -\u003e IO ()",
        "fct-source": "src/Test-SmartCheck-Render.html#renderWithVars",
        "fct-type": "function",
        "title": "renderWithVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Render",
        "module": "Test.SmartCheck.Render",
        "name": "renderWithVars",
        "normalized": "Format-\u003ea-\u003eReplace Idx-\u003eIO()",
        "package": "smartcheck",
        "partial": "With Vars",
        "signature": "Format-\u003ea-\u003eReplace Idx-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Render.html#v:smartPrtLn",
      "description": {
        "fct-module": "Test.SmartCheck.Render",
        "fct-package": "smartcheck",
        "fct-signature": "String -\u003e IO ()",
        "fct-source": "src/Test-SmartCheck-Render.html#smartPrtLn",
        "fct-type": "function",
        "title": "smartPrtLn"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Render",
        "module": "Test.SmartCheck.Render",
        "name": "smartPrtLn",
        "normalized": "String-\u003eIO()",
        "package": "smartcheck",
        "partial": "Prt Ln",
        "signature": "String-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-SmartGen.html#",
      "description": {
        "fct-module": "Test.SmartCheck.SmartGen",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-SmartGen.html",
        "fct-type": "module",
        "title": "SmartGen"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck SmartGen",
        "module": "Test.SmartCheck.SmartGen",
        "name": "SmartGen",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Smart Gen",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-SmartGen.html#v:iter",
      "description": {
        "fct-module": "Test.SmartCheck.SmartGen",
        "fct-package": "smartcheck",
        "fct-signature": "a-\u003e Test a b-\u003e Next a b-\u003e (a -\u003e Property)-\u003e Maybe Int-\u003e Forest Bool-\u003e Idx-\u003e [Idx]-\u003e IO (a, [Idx])",
        "fct-type": "function",
        "title": "iter"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck SmartGen",
        "module": "Test.SmartCheck.SmartGen",
        "name": "iter",
        "normalized": "a-\u003eTest a b-\u003eNext a b-\u003e(a-\u003eProperty)-\u003eMaybe Int-\u003eForest Bool-\u003eIdx-\u003e[Idx]-\u003eIO(a,[Idx])",
        "package": "smartcheck",
        "partial": "",
        "signature": "a-\u003eTest a b-\u003eNext a b-\u003e(a-\u003eProperty)-\u003eMaybe Int-\u003eForest Bool-\u003eIdx-\u003e[Idx]-\u003eIO(a,[Idx])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-SmartGen.html#v:iterateArb",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the hole in d indexed by idx with a bunch of random values, and\n test the new d against the property.  Returns the first new d (the full d but\n with the hole replaced) that succeeds.  \u003ca\u003eSucceeds\u003c/a\u003e is determined by the call\n to resultify---if we're expecting failure, then we succeed by getting a value\n that passes the precondition but fails the property; otherwise we succeed by\n getting a value that passes the precondition and satisfies the property.  If\n no value ever satisfies the precondition, then we return FailedPreCond.\n (Thus, there's an implied linear order on the Result type: FailedPreCond \u003c\n FailedProp \u003c Result a.)\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.SmartGen",
        "fct-package": "smartcheck",
        "fct-signature": "a-\u003e SubT-\u003e Idx-\u003e Int-\u003e Int-\u003e (a -\u003e Property)-\u003e IO (Int, Result a)",
        "fct-type": "function",
        "title": "iterateArb"
      },
      "index": {
        "description": "Replace the hole in indexed by idx with bunch of random values and test the new against the property Returns the first new the full but with the hole replaced that succeeds Succeeds is determined by the call to resultify---if we re expecting failure then we succeed by getting value that passes the precondition but fails the property otherwise we succeed by getting value that passes the precondition and satisfies the property If no value ever satisfies the precondition then we return FailedPreCond Thus there an implied linear order on the Result type FailedPreCond FailedProp Result",
        "hierarchy": "Test SmartCheck SmartGen",
        "module": "Test.SmartCheck.SmartGen",
        "name": "iterateArb",
        "normalized": "a-\u003eSubT-\u003eIdx-\u003eInt-\u003eInt-\u003e(a-\u003eProperty)-\u003eIO(Int,Result a)",
        "package": "smartcheck",
        "partial": "Arb",
        "signature": "a-\u003eSubT-\u003eIdx-\u003eInt-\u003eInt-\u003e(a-\u003eProperty)-\u003eIO(Int,Result a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-SmartGen.html#v:iterateArbIdx",
      "description": {
        "fct-descr": "\u003cp\u003eDriver for iterateArb.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.SmartGen",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e (Idx, Maybe Int) -\u003e Int -\u003e Int -\u003e (a -\u003e Property) -\u003e IO (Int, Result a)",
        "fct-source": "src/Test-SmartCheck-SmartGen.html#iterateArbIdx",
        "fct-type": "function",
        "title": "iterateArbIdx"
      },
      "index": {
        "description": "Driver for iterateArb",
        "hierarchy": "Test SmartCheck SmartGen",
        "module": "Test.SmartCheck.SmartGen",
        "name": "iterateArbIdx",
        "normalized": "a-\u003e(Idx,Maybe Int)-\u003eInt-\u003eInt-\u003e(a-\u003eProperty)-\u003eIO(Int,Result a)",
        "package": "smartcheck",
        "partial": "Arb Idx",
        "signature": "a-\u003e(Idx,Maybe Int)-\u003eInt-\u003eInt-\u003e(a-\u003eProperty)-\u003eIO(Int,Result a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-SmartGen.html#v:replace",
      "description": {
        "fct-descr": "\u003cp\u003ePut a value v into a another value d at a hole idx, if v is well-typed.\n Return Nothing if dynamic typing fails.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.SmartGen",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Idx -\u003e SubT -\u003e Maybe a",
        "fct-source": "src/Test-SmartCheck-SmartGen.html#replace",
        "fct-type": "function",
        "title": "replace"
      },
      "index": {
        "description": "Put value into another value at hole idx if is well-typed Return Nothing if dynamic typing fails",
        "hierarchy": "Test SmartCheck SmartGen",
        "module": "Test.SmartCheck.SmartGen",
        "name": "replace",
        "normalized": "a-\u003eIdx-\u003eSubT-\u003eMaybe a",
        "package": "smartcheck",
        "partial": "",
        "signature": "a-\u003eIdx-\u003eSubT-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-SmartGen.html#v:resultify",
      "description": {
        "fct-descr": "\u003cp\u003eMake a QuickCheck Result by applying a property function to a value and\n then get out the Result using our result type.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.SmartGen",
        "fct-package": "smartcheck",
        "fct-signature": "(a -\u003e Property) -\u003e a -\u003e IO (Result a)",
        "fct-source": "src/Test-SmartCheck-SmartGen.html#resultify",
        "fct-type": "function",
        "title": "resultify"
      },
      "index": {
        "description": "Make QuickCheck Result by applying property function to value and then get out the Result using our result type",
        "hierarchy": "Test SmartCheck SmartGen",
        "module": "Test.SmartCheck.SmartGen",
        "name": "resultify",
        "normalized": "(a-\u003eProperty)-\u003ea-\u003eIO(Result a)",
        "package": "smartcheck",
        "partial": "",
        "signature": "(a-\u003eProperty)-\u003ea-\u003eIO(Result a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck-Types.html",
        "fct-type": "module",
        "title": "Types"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Types",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#t:Idx",
      "description": {
        "fct-descr": "\u003cp\u003eIndex into a Tree/Forest, where level is the depth from the root and column\n is the distance d is the dth value on the same level.  Thus, all left-most\n nodes are in column 0.  This is a \u003ca\u003ematrix view\u003c/a\u003e of tree-structured data.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "data",
        "fct-source": "src/Test-SmartCheck-Types.html#Idx",
        "fct-type": "data",
        "title": "Idx"
      },
      "index": {
        "description": "Index into Tree Forest where level is the depth from the root and column is the distance is the dth value on the same level Thus all left-most nodes are in column This is matrix view of tree-structured data",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Idx",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Idx",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#t:Replace",
      "description": {
        "fct-descr": "\u003cp\u003eNominally, a list for value generalization indexes and existential\n generalization.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "data",
        "fct-source": "src/Test-SmartCheck-Types.html#Replace",
        "fct-type": "data",
        "title": "Replace"
      },
      "index": {
        "description": "Nominally list for value generalization indexes and existential generalization",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Replace",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Replace",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#t:Result",
      "description": {
        "fct-descr": "\u003cp\u003ePossible results of iterateArb.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "data",
        "fct-source": "src/Test-SmartCheck-Types.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "Possible results of iterateArb",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Result",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#t:SubT",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "data",
        "fct-source": "src/Test-SmartCheck-Types.html#SubT",
        "fct-type": "data",
        "title": "SubT"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "SubT",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Sub",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#t:SubTypes",
      "description": {
        "fct-descr": "\u003cp\u003eThis class covers algebraic datatypes that can be transformed into Trees.\n subTypes is the main method, placing values into trees.  For types that can't\n be put into a *structural* order (e.g., Int), we don't want SmartCheck to\n touch them, so that aren't placed in the tree (the baseType method tells\n subTypes which types have this property).\n\u003c/p\u003e\u003cp\u003efor a datatype with constructors A and C,\n\u003c/p\u003e\u003cpre\u003e subTypes (A (C 0) 1)\n [Node {rootLabel = C 0, subForest = []}]\n\u003c/pre\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "class",
        "fct-source": "src/Test-SmartCheck-Types.html#SubTypes",
        "fct-type": "class",
        "title": "SubTypes"
      },
      "index": {
        "description": "This class covers algebraic datatypes that can be transformed into Trees subTypes is the main method placing values into trees For types that can be put into structural order e.g Int we don want SmartCheck to touch them so that aren placed in the tree the baseType method tells subTypes which types have this property for datatype with constructors and subTypes Node rootLabel subForest",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "SubTypes",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Sub Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#t:Subst",
      "description": {
        "fct-descr": "\u003cp\u003eKeep or substitue a value in the tree.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "data",
        "fct-source": "src/Test-SmartCheck-Types.html#Subst",
        "fct-type": "data",
        "title": "Subst"
      },
      "index": {
        "description": "Keep or substitue value in the tree",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Subst",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Subst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:FailedPreCond",
      "description": {
        "fct-descr": "\u003cp\u003eCouldn't satisfy the precondition of a\n   QuickCheck property\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "FailedPreCond",
        "fct-source": "src/Test-SmartCheck-Types.html#Result",
        "fct-type": "function",
        "title": "FailedPreCond"
      },
      "index": {
        "description": "Couldn satisfy the precondition of QuickCheck property",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "FailedPreCond",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Failed Pre Cond",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:FailedProp",
      "description": {
        "fct-descr": "\u003cp\u003eFailed the property---either we expect\n   failure and it passes or we expect to pass it\n   and we fail.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "FailedProp",
        "fct-source": "src/Test-SmartCheck-Types.html#Result",
        "fct-type": "function",
        "title": "FailedProp"
      },
      "index": {
        "description": "Failed the property---either we expect failure and it passes or we expect to pass it and we fail",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "FailedProp",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Failed Prop",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:Idx",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "Idx",
        "fct-source": "src/Test-SmartCheck-Types.html#Idx",
        "fct-type": "function",
        "title": "Idx"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Idx",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Idx",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:Keep",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "Keep",
        "fct-source": "src/Test-SmartCheck-Types.html#Subst",
        "fct-type": "function",
        "title": "Keep"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Keep",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Keep",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:Replace",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "Replace",
        "fct-source": "src/Test-SmartCheck-Types.html#Replace",
        "fct-type": "function",
        "title": "Replace"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Replace",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Replace",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:Result",
      "description": {
        "fct-descr": "\u003cp\u003eSatisfied it, with the satisfying value.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "Result a",
        "fct-source": "src/Test-SmartCheck-Types.html#Result",
        "fct-type": "function",
        "title": "Result"
      },
      "index": {
        "description": "Satisfied it with the satisfying value",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Result",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:SubT",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "SubT",
        "fct-source": "src/Test-SmartCheck-Types.html#SubT",
        "fct-type": "function",
        "title": "SubT"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "SubT",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Sub",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:Subst",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "Subst",
        "fct-source": "src/Test-SmartCheck-Types.html#Subst",
        "fct-type": "function",
        "title": "Subst"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "Subst",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Subst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:baseType",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Bool",
        "fct-source": "src/Test-SmartCheck-Types.html#baseType",
        "fct-type": "method",
        "title": "baseType"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "baseType",
        "normalized": "a-\u003eBool",
        "package": "smartcheck",
        "partial": "Type",
        "signature": "a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:column",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "Int",
        "fct-source": "src/Test-SmartCheck-Types.html#Idx",
        "fct-type": "function",
        "title": "column"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "column",
        "normalized": "",
        "package": "smartcheck",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:errorMsg",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "String -\u003e a",
        "fct-source": "src/Test-SmartCheck-Types.html#errorMsg",
        "fct-type": "function",
        "title": "errorMsg"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "errorMsg",
        "normalized": "String-\u003ea",
        "package": "smartcheck",
        "partial": "Msg",
        "signature": "String-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:grc",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e Forest Subst -\u003e b -\u003e Maybe (f a)",
        "fct-source": "src/Test-SmartCheck-Types.html#grc",
        "fct-type": "function",
        "title": "grc"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "grc",
        "normalized": "a b-\u003eForest Subst-\u003ec-\u003eMaybe(a b)",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eForest Subst-\u003eb-\u003eMaybe(f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:gsf",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e Forest String",
        "fct-source": "src/Test-SmartCheck-Types.html#gsf",
        "fct-type": "function",
        "title": "gsf"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "gsf",
        "normalized": "a b-\u003eForest String",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eForest String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:gst",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e Forest SubT",
        "fct-source": "src/Test-SmartCheck-Types.html#gst",
        "fct-type": "function",
        "title": "gst"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "gst",
        "normalized": "a b-\u003eForest SubT",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eForest SubT"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:gsz",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e Int",
        "fct-source": "src/Test-SmartCheck-Types.html#gsz",
        "fct-type": "function",
        "title": "gsz"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "gsz",
        "normalized": "a b-\u003eInt",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:gtc",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e String",
        "fct-source": "src/Test-SmartCheck-Types.html#gtc",
        "fct-type": "function",
        "title": "gtc"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "gtc",
        "normalized": "a b-\u003eString",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:level",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "Int",
        "fct-source": "src/Test-SmartCheck-Types.html#Idx",
        "fct-type": "function",
        "title": "level"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "level",
        "normalized": "",
        "package": "smartcheck",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:replaceChild",
      "description": {
        "fct-descr": "\u003cp\u003eGenerically replace child i in m with value s.  A total function: returns\n Nothing if you try to replace a child with an ill-typed child s.  (Returns\n Just (the original data) if your index is out of bounds).\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Forest Subst -\u003e b -\u003e Maybe a",
        "fct-source": "src/Test-SmartCheck-Types.html#replaceChild",
        "fct-type": "method",
        "title": "replaceChild"
      },
      "index": {
        "description": "Generically replace child in with value total function returns Nothing if you try to replace child with an ill-typed child Returns Just the original data if your index is out of bounds",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "replaceChild",
        "normalized": "a-\u003eForest Subst-\u003eb-\u003eMaybe a",
        "package": "smartcheck",
        "partial": "Child",
        "signature": "a-\u003eForest Subst-\u003eb-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:showForest",
      "description": {
        "fct-descr": "\u003cp\u003eshowForest generically shows a value while preserving its structure (in a\n Tree).  You should always end up with either a singleton list containing\n the tree or an empty list for baseTypes.  Also, it must be the case that\n for a value v,\n\u003c/p\u003e\u003cp\u003enull (subTypes v) iff null (showForest v)\n and\n if not . null (subTypes v), then subForest . head (showForest v)\n has the same structure as subTypes v.\n\u003c/p\u003e\u003cp\u003eWe can't just return a Tree String or Maybe (Tree String).  The reason is\n that in generically constructing the value, we have to deal with product\n types.  There is no sane way to join them other than list-like\n concatenation (i.e., gsf (a :*: b) = gsf a ++ gsf b).\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Forest String",
        "fct-source": "src/Test-SmartCheck-Types.html#showForest",
        "fct-type": "method",
        "title": "showForest"
      },
      "index": {
        "description": "showForest generically shows value while preserving its structure in Tree You should always end up with either singleton list containing the tree or an empty list for baseTypes Also it must be the case that for value null subTypes iff null showForest and if not null subTypes then subForest head showForest has the same structure as subTypes We can just return Tree String or Maybe Tree String The reason is that in generically constructing the value we have to deal with product types There is no sane way to join them other than list-like concatenation i.e gsf gsf gsf",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "showForest",
        "normalized": "a-\u003eForest String",
        "package": "smartcheck",
        "partial": "Forest",
        "signature": "a-\u003eForest String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:subT",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e SubT",
        "fct-source": "src/Test-SmartCheck-Types.html#subT",
        "fct-type": "function",
        "title": "subT"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "subT",
        "normalized": "a-\u003eSubT",
        "package": "smartcheck",
        "partial": "",
        "signature": "a-\u003eSubT"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:subTypes",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Forest SubT",
        "fct-source": "src/Test-SmartCheck-Types.html#subTypes",
        "fct-type": "method",
        "title": "subTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "subTypes",
        "normalized": "a-\u003eForest SubT",
        "package": "smartcheck",
        "partial": "Types",
        "signature": "a-\u003eForest SubT"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:toConstr",
      "description": {
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Test-SmartCheck-Types.html#toConstr",
        "fct-type": "method",
        "title": "toConstr"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "toConstr",
        "normalized": "a-\u003eString",
        "package": "smartcheck",
        "partial": "Constr",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:unConstrs",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "[a]",
        "fct-source": "src/Test-SmartCheck-Types.html#Replace",
        "fct-type": "function",
        "title": "unConstrs"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "unConstrs",
        "normalized": "[a]",
        "package": "smartcheck",
        "partial": "Constrs",
        "signature": "[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:unSubT",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "a",
        "fct-source": "src/Test-SmartCheck-Types.html#SubT",
        "fct-type": "function",
        "title": "unSubT"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "unSubT",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Sub",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck-Types.html#v:unVals",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Test.SmartCheck.Types",
        "fct-package": "smartcheck",
        "fct-signature": "[a]",
        "fct-source": "src/Test-SmartCheck-Types.html#Replace",
        "fct-type": "function",
        "title": "unVals"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck Types",
        "module": "Test.SmartCheck.Types",
        "name": "unVals",
        "normalized": "[a]",
        "package": "smartcheck",
        "partial": "Vals",
        "signature": "[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterface module.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "module",
        "fct-source": "src/Test-SmartCheck.html",
        "fct-type": "module",
        "title": "SmartCheck"
      },
      "index": {
        "description": "Interface module",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "SmartCheck",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Smart Check",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#t:ScProperty",
      "description": {
        "fct-descr": "\u003cp\u003eType for SmartCheck properties.  Moral equivalent of QuickCheck's\n \u003ccode\u003eProperty\u003c/code\u003e type.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "data",
        "fct-source": "src/Test-SmartCheck.html#ScProperty",
        "fct-type": "data",
        "title": "ScProperty"
      },
      "index": {
        "description": "Type for SmartCheck properties Moral equivalent of QuickCheck Property type",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "ScProperty",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Sc Property",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#t:SubTypes",
      "description": {
        "fct-descr": "\u003cp\u003eThis class covers algebraic datatypes that can be transformed into Trees.\n subTypes is the main method, placing values into trees.  For types that can't\n be put into a *structural* order (e.g., Int), we don't want SmartCheck to\n touch them, so that aren't placed in the tree (the baseType method tells\n subTypes which types have this property).\n\u003c/p\u003e\u003cp\u003efor a datatype with constructors A and C,\n\u003c/p\u003e\u003cpre\u003e subTypes (A (C 0) 1)\n [Node {rootLabel = C 0, subForest = []}]\n\u003c/pre\u003e",
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "class",
        "fct-source": "src/Test-SmartCheck-Types.html#SubTypes",
        "fct-type": "class",
        "title": "SubTypes"
      },
      "index": {
        "description": "This class covers algebraic datatypes that can be transformed into Trees subTypes is the main method placing values into trees For types that can be put into structural order e.g Int we don want SmartCheck to touch them so that aren placed in the tree the baseType method tells subTypes which types have this property for datatype with constructors and subTypes Node rootLabel subForest",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "SubTypes",
        "normalized": "",
        "package": "smartcheck",
        "partial": "Sub Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:-45--45--62-",
      "description": {
        "fct-descr": "\u003cp\u003eMoral equivalent of QuickCheck's \u003ccode\u003e==\u003e\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "Bool -\u003e Bool -\u003e ScProperty",
        "fct-source": "src/Test-SmartCheck.html#--%3E",
        "fct-type": "function",
        "title": "(--\u003e)"
      },
      "index": {
        "description": "Moral equivalent of QuickCheck operator",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "(--\u003e) --\u003e",
        "normalized": "Bool-\u003eBool-\u003eScProperty",
        "package": "smartcheck",
        "partial": "",
        "signature": "Bool-\u003eBool-\u003eScProperty"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:baseType",
      "description": {
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Bool",
        "fct-source": "src/Test-SmartCheck-Types.html#baseType",
        "fct-type": "method",
        "title": "baseType"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "baseType",
        "normalized": "a-\u003eBool",
        "package": "smartcheck",
        "partial": "Type",
        "signature": "a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:grc",
      "description": {
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e Forest Subst -\u003e b -\u003e Maybe (f a)",
        "fct-source": "src/Test-SmartCheck-Types.html#grc",
        "fct-type": "function",
        "title": "grc"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "grc",
        "normalized": "a b-\u003eForest Subst-\u003ec-\u003eMaybe(a b)",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eForest Subst-\u003eb-\u003eMaybe(f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:gsf",
      "description": {
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e Forest String",
        "fct-source": "src/Test-SmartCheck-Types.html#gsf",
        "fct-type": "function",
        "title": "gsf"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "gsf",
        "normalized": "a b-\u003eForest String",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eForest String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:gst",
      "description": {
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e Forest SubT",
        "fct-source": "src/Test-SmartCheck-Types.html#gst",
        "fct-type": "function",
        "title": "gst"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "gst",
        "normalized": "a b-\u003eForest SubT",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eForest SubT"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:gsz",
      "description": {
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e Int",
        "fct-source": "src/Test-SmartCheck-Types.html#gsz",
        "fct-type": "function",
        "title": "gsz"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "gsz",
        "normalized": "a b-\u003eInt",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:gtc",
      "description": {
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "f a -\u003e String",
        "fct-source": "src/Test-SmartCheck-Types.html#gtc",
        "fct-type": "function",
        "title": "gtc"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "gtc",
        "normalized": "a b-\u003eString",
        "package": "smartcheck",
        "partial": "",
        "signature": "f a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:replaceChild",
      "description": {
        "fct-descr": "\u003cp\u003eGenerically replace child i in m with value s.  A total function: returns\n Nothing if you try to replace a child with an ill-typed child s.  (Returns\n Just (the original data) if your index is out of bounds).\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Forest Subst -\u003e b -\u003e Maybe a",
        "fct-source": "src/Test-SmartCheck-Types.html#replaceChild",
        "fct-type": "method",
        "title": "replaceChild"
      },
      "index": {
        "description": "Generically replace child in with value total function returns Nothing if you try to replace child with an ill-typed child Returns Just the original data if your index is out of bounds",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "replaceChild",
        "normalized": "a-\u003eForest Subst-\u003eb-\u003eMaybe a",
        "package": "smartcheck",
        "partial": "Child",
        "signature": "a-\u003eForest Subst-\u003eb-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:runQCInit",
      "description": {
        "fct-descr": "\u003cp\u003eRun QuickCheck initially, to get counterexamples for each argument,\n includding the one we want to focus on for SmartCheck, plus a \u003ccode\u003eProperty\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "Args -\u003e (a -\u003e prop) -\u003e IO (Maybe a, a -\u003e Property)",
        "fct-source": "src/Test-SmartCheck.html#runQCInit",
        "fct-type": "function",
        "title": "runQCInit"
      },
      "index": {
        "description": "Run QuickCheck initially to get counterexamples for each argument includding the one we want to focus on for SmartCheck plus Property",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "runQCInit",
        "normalized": "Args-\u003e(a-\u003eb)-\u003eIO(Maybe a,a-\u003eProperty)",
        "package": "smartcheck",
        "partial": "QCInit",
        "signature": "Args-\u003e(a-\u003eprop)-\u003eIO(Maybe a,a-\u003eProperty)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:showForest",
      "description": {
        "fct-descr": "\u003cp\u003eshowForest generically shows a value while preserving its structure (in a\n Tree).  You should always end up with either a singleton list containing\n the tree or an empty list for baseTypes.  Also, it must be the case that\n for a value v,\n\u003c/p\u003e\u003cp\u003enull (subTypes v) iff null (showForest v)\n and\n if not . null (subTypes v), then subForest . head (showForest v)\n has the same structure as subTypes v.\n\u003c/p\u003e\u003cp\u003eWe can't just return a Tree String or Maybe (Tree String).  The reason is\n that in generically constructing the value, we have to deal with product\n types.  There is no sane way to join them other than list-like\n concatenation (i.e., gsf (a :*: b) = gsf a ++ gsf b).\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Forest String",
        "fct-source": "src/Test-SmartCheck-Types.html#showForest",
        "fct-type": "method",
        "title": "showForest"
      },
      "index": {
        "description": "showForest generically shows value while preserving its structure in Tree You should always end up with either singleton list containing the tree or an empty list for baseTypes Also it must be the case that for value null subTypes iff null showForest and if not null subTypes then subForest head showForest has the same structure as subTypes We can just return Tree String or Maybe Tree String The reason is that in generically constructing the value we have to deal with product types There is no sane way to join them other than list-like concatenation i.e gsf gsf gsf",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "showForest",
        "normalized": "a-\u003eForest String",
        "package": "smartcheck",
        "partial": "Forest",
        "signature": "a-\u003eForest String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:smartCheck",
      "description": {
        "fct-descr": "\u003cp\u003eMain interface function.\n\u003c/p\u003e",
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "ScArgs -\u003e (a -\u003e prop) -\u003e IO ()",
        "fct-source": "src/Test-SmartCheck.html#smartCheck",
        "fct-type": "function",
        "title": "smartCheck"
      },
      "index": {
        "description": "Main interface function",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "smartCheck",
        "normalized": "ScArgs-\u003e(a-\u003eb)-\u003eIO()",
        "package": "smartcheck",
        "partial": "Check",
        "signature": "ScArgs-\u003e(a-\u003eprop)-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:subTypes",
      "description": {
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e Forest SubT",
        "fct-source": "src/Test-SmartCheck-Types.html#subTypes",
        "fct-type": "method",
        "title": "subTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "subTypes",
        "normalized": "a-\u003eForest SubT",
        "package": "smartcheck",
        "partial": "Types",
        "signature": "a-\u003eForest SubT"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/smartcheck/docs/Test-SmartCheck.html#v:toConstr",
      "description": {
        "fct-module": "Test.SmartCheck",
        "fct-package": "smartcheck",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Test-SmartCheck-Types.html#toConstr",
        "fct-type": "method",
        "title": "toConstr"
      },
      "index": {
        "description": "",
        "hierarchy": "Test SmartCheck",
        "module": "Test.SmartCheck",
        "name": "toConstr",
        "normalized": "a-\u003eString",
        "package": "smartcheck",
        "partial": "Constr",
        "signature": "a-\u003eString"
      }
    }
  }
]
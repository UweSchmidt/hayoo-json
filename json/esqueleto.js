[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is an internal module, anything exported by this module\n may change without a major version bump.  Please use only\n \u003ca\u003eDatabase.Esqueleto\u003c/a\u003e if possible.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "module",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html",
        "fct-type": "module",
        "title": "Language"
      },
      "index": {
        "description": "This is an internal module anything exported by this module may change without major version bump Please use only Database.Esqueleto if possible",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "Language",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Language",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:CrossJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents a \u003ccode\u003eCROSS JOIN\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e for an example).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#CrossJoin",
        "fct-type": "data",
        "title": "CrossJoin"
      },
      "index": {
        "description": "Data type that represents CROSS JOIN see LeftOuterJoin for an example",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "CrossJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Cross Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:Esqueleto",
      "description": {
        "fct-descr": "\u003cp\u003eFinally tagless representation of \u003ccode\u003eesqueleto\u003c/code\u003e's EDSL.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "class",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#Esqueleto",
        "fct-type": "class",
        "title": "Esqueleto"
      },
      "index": {
        "description": "Finally tagless representation of esqueleto EDSL",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "Esqueleto",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Esqueleto",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:From",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Class that implements the tuple \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e magic (see\n \u003ccode\u003e\u003ca\u003efromStart\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "class",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#From",
        "fct-type": "class",
        "title": "From"
      },
      "index": {
        "description": "Internal Class that implements the tuple from magic see fromStart",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "From",
        "normalized": "",
        "package": "esqueleto",
        "partial": "From",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:FromPreprocess",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Class that implements the \u003ccode\u003eJOIN\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e magic\n (see \u003ccode\u003e\u003ca\u003efromStart\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "class",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#FromPreprocess",
        "fct-type": "class",
        "title": "FromPreprocess"
      },
      "index": {
        "description": "Internal Class that implements the JOIN from magic see fromStart",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "FromPreprocess",
        "normalized": "",
        "package": "esqueleto",
        "partial": "From Preprocess",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:FullOuterJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents a \u003ccode\u003eFULL OUTER JOIN\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e for an example).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#FullOuterJoin",
        "fct-type": "data",
        "title": "FullOuterJoin"
      },
      "index": {
        "description": "Data type that represents FULL OUTER JOIN see LeftOuterJoin for an example",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "FullOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Full Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:InnerJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents an \u003ccode\u003eINNER JOIN\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e for an example).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#InnerJoin",
        "fct-type": "data",
        "title": "InnerJoin"
      },
      "index": {
        "description": "Data type that represents an INNER JOIN see LeftOuterJoin for an example",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "InnerJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Inner Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:Insertion",
      "description": {
        "fct-descr": "\u003cp\u003ePhantom type used by \u003ccode\u003einsertSelect\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#Insertion",
        "fct-type": "data",
        "title": "Insertion"
      },
      "index": {
        "description": "Phantom type used by insertSelect",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "Insertion",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Insertion",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:IsJoinKind",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Functions that operate on types (that should be)\n of kind \u003ccode\u003e\u003ca\u003eJoinKind\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "class",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#IsJoinKind",
        "fct-type": "class",
        "title": "IsJoinKind"
      },
      "index": {
        "description": "Internal Functions that operate on types that should be of kind JoinKind",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "IsJoinKind",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Is Join Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:JoinKind",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) A kind of \u003ccode\u003eJOIN\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#JoinKind",
        "fct-type": "data",
        "title": "JoinKind"
      },
      "index": {
        "description": "Internal kind of JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "JoinKind",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Join Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:LeftOuterJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents a \u003ccode\u003eLEFT OUTER JOIN\u003c/code\u003e. For example,\n\u003c/p\u003e\u003cpre\u003e\n select $\n from $ \\(person `\u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e` pet) -\u003e\n   ...\n\u003c/pre\u003e\u003cp\u003eis translated into\n\u003c/p\u003e\u003cpre\u003e\n SELECT ...\n FROM Person LEFT OUTER JOIN Pet\n ...\n\u003c/pre\u003e\u003cp\u003eSee also: \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#LeftOuterJoin",
        "fct-type": "data",
        "title": "LeftOuterJoin"
      },
      "index": {
        "description": "Data type that represents LEFT OUTER JOIN For example select from person LeftOuterJoin pet is translated into SELECT FROM Person LEFT OUTER JOIN Pet See also from",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "LeftOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Left Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:OnClauseWithoutMatchingJoinException",
      "description": {
        "fct-descr": "\u003cp\u003eException thrown whenever \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003e is used to create an \u003ccode\u003eON\u003c/code\u003e\n clause but no matching \u003ccode\u003eJOIN\u003c/code\u003e is found.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#OnClauseWithoutMatchingJoinException",
        "fct-type": "data",
        "title": "OnClauseWithoutMatchingJoinException"
      },
      "index": {
        "description": "Exception thrown whenever on is used to create an ON clause but no matching JOIN is found",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "OnClauseWithoutMatchingJoinException",
        "normalized": "",
        "package": "esqueleto",
        "partial": "On Clause Without Matching Join Exception",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:OrderBy",
      "description": {
        "fct-descr": "\u003cp\u003ePhantom type used by \u003ccode\u003e\u003ca\u003eorderBy\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003easc\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edesc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#OrderBy",
        "fct-type": "data",
        "title": "OrderBy"
      },
      "index": {
        "description": "Phantom type used by orderBy asc and desc",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "OrderBy",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Order By",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:PreprocessedFrom",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Phantom type used to process \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003efromStart\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#PreprocessedFrom",
        "fct-type": "data",
        "title": "PreprocessedFrom"
      },
      "index": {
        "description": "Internal Phantom type used to process from see fromStart",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "PreprocessedFrom",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Preprocessed From",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:RightOuterJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents a \u003ccode\u003eRIGHT OUTER JOIN\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e for an example).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#RightOuterJoin",
        "fct-type": "data",
        "title": "RightOuterJoin"
      },
      "index": {
        "description": "Data type that represents RIGHT OUTER JOIN see LeftOuterJoin for an example",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "RightOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Right Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:SomeValue",
      "description": {
        "fct-descr": "\u003cp\u003eA wrapper type for for any \u003ccode\u003eexpr (Value a)\u003c/code\u003e for all a.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#SomeValue",
        "fct-type": "data",
        "title": "SomeValue"
      },
      "index": {
        "description": "wrapper type for for any expr Value for all",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "SomeValue",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Some Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:ToSomeValues",
      "description": {
        "fct-descr": "\u003cp\u003eA class of things that can be converted into a list of SomeValue. It has\n instances for tuples and is the reason why groupBy can take tuples, like\n \u003ccode\u003egroupBy (foo ^. FooId, foo ^. FooName, foo ^. FooType)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "class",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#ToSomeValues",
        "fct-type": "class",
        "title": "ToSomeValues"
      },
      "index": {
        "description": "class of things that can be converted into list of SomeValue It has instances for tuples and is the reason why groupBy can take tuples like groupBy foo FooId foo FooName foo FooType",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "ToSomeValues",
        "normalized": "",
        "package": "esqueleto",
        "partial": "To Some Values",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:Update",
      "description": {
        "fct-descr": "\u003cp\u003ePhantom type for a \u003ccode\u003eSET\u003c/code\u003e operation on an entity of the given\n type (see \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e and '(=.)').\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#Update",
        "fct-type": "data",
        "title": "Update"
      },
      "index": {
        "description": "Phantom type for SET operation on an entity of the given type see set and",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "Update",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Update",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:Value",
      "description": {
        "fct-descr": "\u003cp\u003eA single value (as opposed to a whole entity).  You may use\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e or \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e?.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e to get a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e from an \u003ccode\u003e\u003ca\u003eEntity\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#Value",
        "fct-type": "data",
        "title": "Value"
      },
      "index": {
        "description": "single value as opposed to whole entity You may use or to get Value from an Entity",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "Value",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#t:ValueList",
      "description": {
        "fct-descr": "\u003cp\u003eA list of single values.  There's a limited set of funcitons\n able to work with this data type (such as \u003ccode\u003e\u003ca\u003esubList_select\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003evalList\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ein_\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eexists\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#ValueList",
        "fct-type": "data",
        "title": "ValueList"
      },
      "index": {
        "description": "list of single values There limited set of funcitons able to work with this data type such as subList select valList in and exists",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "ValueList",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Value List",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-124--124-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e expr (Value Bool) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%7C%7C.",
        "fct-type": "method",
        "title": "(||.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(||.) ||.",
        "normalized": "a(Value Bool)-\u003ea(Value Bool)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003eexpr(Value Bool)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-33--61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%21%3D.",
        "fct-type": "method",
        "title": "(!=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(!=.) !=.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-37-",
      "description": {
        "fct-descr": "\u003cp\u003eThe string \u003ccode\u003e\u003ccode\u003e\u003ca\u003e%\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  May be useful while using \u003ccode\u003e\u003ca\u003elike\u003c/a\u003e\u003c/code\u003e and\n concatenation (\u003ccode\u003e\u003ca\u003econcat_\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003e++.\u003c/a\u003e\u003c/code\u003e, depending on your\n database).  Note that you always to type the parenthesis,\n for example:\n\u003c/p\u003e\u003cpre\u003e\n name ``'like'`` (%) ++. val \u003ca\u003eJohn\u003c/a\u003e ++. (%)\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value s)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%25",
        "fct-type": "method",
        "title": "(%)"
      },
      "index": {
        "description": "The string May be useful while using like and concatenation concat or depending on your database Note that you always to type the parenthesis for example name like val John",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(%) %",
        "normalized": "",
        "package": "esqueleto",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-38--38-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e expr (Value Bool) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%26%26.",
        "fct-type": "method",
        "title": "(&&.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(&&.) &&.",
        "normalized": "a(Value Bool)-\u003ea(Value Bool)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003eexpr(Value Bool)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-42--61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val a -\u003e expr (Value a) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2A%3D.",
        "fct-type": "method",
        "title": "(*=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(*=.) *=.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val a-\u003eexpr(Value a)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-42-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value a) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2A.",
        "fct-type": "method",
        "title": "(*.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(*.) *.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value a)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-43--43-.",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e||\u003c/code\u003e string concatenation operator (named after\n Haskell's \u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003e in order to avoid naming clash with \u003ccode\u003e\u003ca\u003e||.\u003c/a\u003e\u003c/code\u003e).\n Supported by SQLite and PostgreSQL.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value s) -\u003e expr (Value s) -\u003e expr (Value s)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2B%2B.",
        "fct-type": "method",
        "title": "(++.)"
      },
      "index": {
        "description": "The string concatenation operator named after Haskell in order to avoid naming clash with Supported by SQLite and PostgreSQL",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(++.) ++.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value s)-\u003eexpr(Value s)-\u003eexpr(Value s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-43--61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val a -\u003e expr (Value a) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2B%3D.",
        "fct-type": "method",
        "title": "(+=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(+=.) +=.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val a-\u003eexpr(Value a)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-43-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value a) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2B.",
        "fct-type": "method",
        "title": "(+.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(+.) +.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value a)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-45--61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val a -\u003e expr (Value a) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#-%3D.",
        "fct-type": "method",
        "title": "(-=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(-=.) -=.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val a-\u003eexpr(Value a)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-45-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value a) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#-.",
        "fct-type": "method",
        "title": "(-.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(-.) -.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value a)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-47--61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val a -\u003e expr (Value a) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2F%3D.",
        "fct-type": "method",
        "title": "(/=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(/=.) /=.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val a-\u003eexpr(Value a)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-47-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value a) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2F.",
        "fct-type": "method",
        "title": "(/.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(/.) /.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value a)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-60--35-",
      "description": {
        "fct-descr": "\u003cp\u003eApply a \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e constructor to \u003ccode\u003eexpr Value\u003c/code\u003e arguments.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "(a -\u003e b) -\u003e expr (Value a) -\u003e expr (Insertion b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3C%23",
        "fct-type": "method",
        "title": "(\u003c#)"
      },
      "index": {
        "description": "Apply PersistField constructor to expr Value arguments",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(\u003c#) \u003c#",
        "normalized": "(a-\u003eb)-\u003ec(Value a)-\u003ec(Insertion b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eexpr(Value a)-\u003eexpr(Insertion b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-60--38--62-",
      "description": {
        "fct-descr": "\u003cp\u003eApply extra \u003ccode\u003eexpr Value\u003c/code\u003e arguments to a \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e constructor\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Insertion (a -\u003e b)) -\u003e expr (Value a) -\u003e expr (Insertion b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3C%26%3E",
        "fct-type": "method",
        "title": "(\u003c&\u003e)"
      },
      "index": {
        "description": "Apply extra expr Value arguments to PersistField constructor",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(\u003c&\u003e) \u003c&\u003e",
        "normalized": "a(Insertion(b-\u003ec))-\u003ea(Value b)-\u003ea(Insertion c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Insertion(a-\u003eb))-\u003eexpr(Value a)-\u003eexpr(Insertion b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-60--61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3C%3D.",
        "fct-type": "method",
        "title": "(\u003c=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(\u003c=.) \u003c=.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-60-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3C.",
        "fct-type": "method",
        "title": "(\u003c.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(\u003c.) \u003c.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-61--61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3D%3D.",
        "fct-type": "method",
        "title": "(==.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(==.) ==.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val typ -\u003e expr (Value typ) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3D.",
        "fct-type": "method",
        "title": "(=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(=.) =.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val typ-\u003eexpr(Value typ)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-62--61-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3E%3D.",
        "fct-type": "method",
        "title": "(\u003e=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(\u003e=.) \u003e=.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-62-.",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3E.",
        "fct-type": "method",
        "title": "(\u003e.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(\u003e.) \u003e.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-63-.",
      "description": {
        "fct-descr": "\u003cp\u003eProject a field of an entity that may be null.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Maybe (Entity val)) -\u003e EntityField val typ -\u003e expr (Value (Maybe typ))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3F.",
        "fct-type": "method",
        "title": "(?.)"
      },
      "index": {
        "description": "Project field of an entity that may be null",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(?.) ?.",
        "normalized": "a(Maybe(Entity b))-\u003eEntityField b c-\u003ea(Value(Maybe c))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Maybe(Entity val))-\u003eEntityField val typ-\u003eexpr(Value(Maybe typ))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:-94-.",
      "description": {
        "fct-descr": "\u003cp\u003eProject a field of an entity.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Entity val) -\u003e EntityField val typ -\u003e expr (Value typ)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%5E.",
        "fct-type": "method",
        "title": "(^.)"
      },
      "index": {
        "description": "Project field of an entity",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "(^.) ^.",
        "normalized": "a(Entity b)-\u003eEntityField b c-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Entity val)-\u003eEntityField val typ-\u003eexpr(Value typ)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:CrossJoin",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "a CrossJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#CrossJoin",
        "fct-type": "function",
        "title": "CrossJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "CrossJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Cross Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:CrossJoinKind",
      "description": {
        "fct-descr": "\u003cpre\u003eCROSS JOIN\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "CrossJoinKind",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#JoinKind",
        "fct-type": "function",
        "title": "CrossJoinKind"
      },
      "index": {
        "description": "CROSS JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "CrossJoinKind",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Cross Join Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:FullOuterJoin",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "a FullOuterJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#FullOuterJoin",
        "fct-type": "function",
        "title": "FullOuterJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "FullOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Full Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:FullOuterJoinKind",
      "description": {
        "fct-descr": "\u003cpre\u003eFULL OUTER JOIN\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "FullOuterJoinKind",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#JoinKind",
        "fct-type": "function",
        "title": "FullOuterJoinKind"
      },
      "index": {
        "description": "FULL OUTER JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "FullOuterJoinKind",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Full Outer Join Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:InnerJoin",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "a InnerJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#InnerJoin",
        "fct-type": "function",
        "title": "InnerJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "InnerJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Inner Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:InnerJoinKind",
      "description": {
        "fct-descr": "\u003cpre\u003eINNER JOIN\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "InnerJoinKind",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#JoinKind",
        "fct-type": "function",
        "title": "InnerJoinKind"
      },
      "index": {
        "description": "INNER JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "InnerJoinKind",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Inner Join Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:LeftOuterJoin",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "a LeftOuterJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#LeftOuterJoin",
        "fct-type": "function",
        "title": "LeftOuterJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "LeftOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Left Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:LeftOuterJoinKind",
      "description": {
        "fct-descr": "\u003cpre\u003eLEFT OUTER JOIN\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "LeftOuterJoinKind",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#JoinKind",
        "fct-type": "function",
        "title": "LeftOuterJoinKind"
      },
      "index": {
        "description": "LEFT OUTER JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "LeftOuterJoinKind",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Left Outer Join Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:OnClauseWithoutMatchingJoinException",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "OnClauseWithoutMatchingJoinException String",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#OnClauseWithoutMatchingJoinException",
        "fct-type": "function",
        "title": "OnClauseWithoutMatchingJoinException"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "OnClauseWithoutMatchingJoinException",
        "normalized": "",
        "package": "esqueleto",
        "partial": "On Clause Without Matching Join Exception",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:RightOuterJoin",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "a RightOuterJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#RightOuterJoin",
        "fct-type": "function",
        "title": "RightOuterJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "RightOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Right Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:RightOuterJoinKind",
      "description": {
        "fct-descr": "\u003cpre\u003eRIGHT OUTER JOIN\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "RightOuterJoinKind",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#JoinKind",
        "fct-type": "function",
        "title": "RightOuterJoinKind"
      },
      "index": {
        "description": "RIGHT OUTER JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "RightOuterJoinKind",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Right Outer Join Kind",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:SomeValue",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e SomeValue expr",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#SomeValue",
        "fct-type": "function",
        "title": "SomeValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "SomeValue",
        "normalized": "a(Value b)-\u003eSomeValue a",
        "package": "esqueleto",
        "partial": "Some Value",
        "signature": "expr(Value a)-\u003eSomeValue expr"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:Value",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "Value a",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#Value",
        "fct-type": "function",
        "title": "Value"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "Value",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:ValueList",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "ValueList a",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#ValueList",
        "fct-type": "function",
        "title": "ValueList"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "ValueList",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Value List",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:asc",
      "description": {
        "fct-descr": "\u003cp\u003eAscending order of this field or expression.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr OrderBy",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#asc",
        "fct-type": "method",
        "title": "asc"
      },
      "index": {
        "description": "Ascending order of this field or expression",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "asc",
        "normalized": "a(Value b)-\u003ea OrderBy",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr OrderBy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:avg_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value (Maybe b))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#avg_",
        "fct-type": "method",
        "title": "avg_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "avg_",
        "normalized": "a(Value b)-\u003ea(Value(Maybe c))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value(Maybe b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:ceiling_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#ceiling_",
        "fct-type": "method",
        "title": "ceiling_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "ceiling_",
        "normalized": "a(Value b)-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:concat_",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003eCONCAT\u003c/code\u003e function with a variable number of\n parameters.  Supported by MySQL and PostgreSQL.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "[expr (Value s)] -\u003e expr (Value s)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#concat_",
        "fct-type": "method",
        "title": "concat_"
      },
      "index": {
        "description": "The CONCAT function with variable number of parameters Supported by MySQL and PostgreSQL",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "concat_",
        "normalized": "[a(Value b)]-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "[expr(Value s)]-\u003eexpr(Value s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:count",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eCOUNT\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#count",
        "fct-type": "method",
        "title": "count"
      },
      "index": {
        "description": "COUNT",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "count",
        "normalized": "a(Value b)-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:countRows",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eCOUNT(*)\u003c/code\u003e value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#countRows",
        "fct-type": "method",
        "title": "countRows"
      },
      "index": {
        "description": "COUNT value",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "countRows",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Rows",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:desc",
      "description": {
        "fct-descr": "\u003cp\u003eDescending order of this field or expression.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr OrderBy",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#desc",
        "fct-type": "method",
        "title": "desc"
      },
      "index": {
        "description": "Descending order of this field or expression",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "desc",
        "normalized": "a(Value b)-\u003ea OrderBy",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr OrderBy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:exists",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eEXISTS\u003c/code\u003e operator.  For example:\n\u003c/p\u003e\u003cpre\u003e\n select $\n from $ \\person -\u003e do\n where_ $ exists $\n          from $ \\post -\u003e do\n          where_ (post ^. BlogPostAuthorId ==. person ^. PersonId)\n return person\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "query () -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#exists",
        "fct-type": "method",
        "title": "exists"
      },
      "index": {
        "description": "EXISTS operator For example select from person do where exists from post do where post BlogPostAuthorId person PersonId return person",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "exists",
        "normalized": "a()-\u003eb(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "query()-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:floor_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#floor_",
        "fct-type": "method",
        "title": "floor_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "floor_",
        "normalized": "a(Value b)-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:from",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eFROM\u003c/code\u003e clause: bring entities into scope.\n\u003c/p\u003e\u003cp\u003eThis function internally uses two type classes in order to\n provide some flexibility of how you may call it.  Internally\n we refer to these type classes as the two different magics.\n\u003c/p\u003e\u003cp\u003eThe innermost magic allows you to use \u003ccode\u003efrom\u003c/code\u003e with the\n following types:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eexpr (Entity val)\u003c/code\u003e, which brings a single entity into\n  scope.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eexpr (Maybe (Entity val))\u003c/code\u003e, which brings a single entity\n  that may be \u003ccode\u003eNULL\u003c/code\u003e into scope.  Used for \u003ccode\u003eOUTER JOIN\u003c/code\u003es.\n\u003c/li\u003e\u003cli\u003e A \u003ccode\u003eJOIN\u003c/code\u003e of any other two types allowed by the innermost\n  magic, where a \u003ccode\u003eJOIN\u003c/code\u003e may be an \u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e, a \u003ccode\u003e\u003ca\u003eCrossJoin\u003c/a\u003e\u003c/code\u003e, a\n  \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e, a \u003ccode\u003e\u003ca\u003eRightOuterJoin\u003c/a\u003e\u003c/code\u003e, or a \u003ccode\u003e\u003ca\u003eFullOuterJoin\u003c/a\u003e\u003c/code\u003e.\n  The \u003ccode\u003eJOINs\u003c/code\u003e have right fixity, the same as in SQL.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe outermost magic allows you to use \u003ccode\u003efrom\u003c/code\u003e on any tuples of\n types supported by innermost magic (and also tuples of tuples,\n and so on), up to 8-tuples.\n\u003c/p\u003e\u003cp\u003eNote that using \u003ccode\u003efrom\u003c/code\u003e for the same entity twice does work and\n corresponds to a self-join.  You don't even need to use two\n different calls to \u003ccode\u003efrom\u003c/code\u003e, you may use a \u003ccode\u003eJOIN\u003c/code\u003e or a tuple.\n\u003c/p\u003e\u003cp\u003eThe following are valid examples of uses of \u003ccode\u003efrom\u003c/code\u003e (the types\n of the arguments of the lambda are inside square brackets):\n\u003c/p\u003e\u003cpre\u003e\n from $ \\person -\u003e ...\n from $ \\(person, blogPost) -\u003e ...\n from $ \\(p `\u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e` mb) -\u003e ...\n from $ \\(p1 `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` f `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` p2) -\u003e ...\n from $ \\((p1 `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` f) `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` p2) -\u003e ...\n\u003c/pre\u003e\u003cp\u003eThe types of the arguments to the lambdas above are,\n respectively:\n\u003c/p\u003e\u003cpre\u003e\n person\n   :: ( Esqueleto query expr backend\n      , PersistEntity Person\n      , PersistEntityBackend Person ~ backend\n      ) =\u003e expr (Entity Person)\n (person, blogPost)\n   :: (...) =\u003e (expr (Entity Person), expr (Entity BlogPost))\n (p `\u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e` mb)\n   :: (...) =\u003e InnerJoin (expr (Entity Person)) (expr (Maybe (Entity BlogPost)))\n (p1 `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` f `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` p2)\n   :: (...) =\u003e InnerJoin\n                 (expr (Entity Person))\n                 (InnerJoin (expr (Entity Follow))\n                            (expr (Entity Person)))\n ((p1 `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` f) `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` p2) ::\n   :: (...) =\u003e InnerJoin\n                 (InnerJoin (expr (Entity Person))\n                            (expr (Entity Follow)))\n                 (expr (Entity Person))\n\u003c/pre\u003e\u003cp\u003eNote that some backends may not support all kinds of \u003ccode\u003eJOIN\u003c/code\u003es.\n For example, when using the SQL backend with SQLite, it will\n not accept the last example above (which is associated to the\n left, instead of being to the right) and will not accept\n \u003ccode\u003e\u003ca\u003eRightOuterJoin\u003c/a\u003e\u003c/code\u003es or \u003ccode\u003e\u003ca\u003eFullOuterJoin\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "(a -\u003e query b) -\u003e query b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#from",
        "fct-type": "function",
        "title": "from"
      },
      "index": {
        "description": "FROM clause bring entities into scope This function internally uses two type classes in order to provide some flexibility of how you may call it Internally we refer to these type classes as the two different magics The innermost magic allows you to use from with the following types expr Entity val which brings single entity into scope expr Maybe Entity val which brings single entity that may be NULL into scope Used for OUTER JOIN JOIN of any other two types allowed by the innermost magic where JOIN may be an InnerJoin CrossJoin LeftOuterJoin RightOuterJoin or FullOuterJoin The JOINs have right fixity the same as in SQL The outermost magic allows you to use from on any tuples of types supported by innermost magic and also tuples of tuples and so on up to tuples Note that using from for the same entity twice does work and corresponds to self-join You don even need to use two different calls to from you may use JOIN or tuple The following are valid examples of uses of from the types of the arguments of the lambda are inside square brackets from person from person blogPost from LeftOuterJoin mb from p1 InnerJoin InnerJoin p2 from p1 InnerJoin InnerJoin p2 The types of the arguments to the lambdas above are respectively person Esqueleto query expr backend PersistEntity Person PersistEntityBackend Person backend expr Entity Person person blogPost expr Entity Person expr Entity BlogPost LeftOuterJoin mb InnerJoin expr Entity Person expr Maybe Entity BlogPost p1 InnerJoin InnerJoin p2 InnerJoin expr Entity Person InnerJoin expr Entity Follow expr Entity Person p1 InnerJoin InnerJoin p2 InnerJoin InnerJoin expr Entity Person expr Entity Follow expr Entity Person Note that some backends may not support all kinds of JOIN For example when using the SQL backend with SQLite it will not accept the last example above which is associated to the left instead of being to the right and will not accept RightOuterJoin or FullOuterJoin",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "from",
        "normalized": "(a-\u003eb c)-\u003eb c",
        "package": "esqueleto",
        "partial": "",
        "signature": "(a-\u003equery b)-\u003equery b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:fromFinish",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Finish a \u003ccode\u003eJOIN\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (PreprocessedFrom a) -\u003e query a",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#fromFinish",
        "fct-type": "method",
        "title": "fromFinish"
      },
      "index": {
        "description": "Internal Finish JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "fromFinish",
        "normalized": "a(PreprocessedFrom b)-\u003ec b",
        "package": "esqueleto",
        "partial": "Finish",
        "signature": "expr(PreprocessedFrom a)-\u003equery a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:fromJoin",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Do a \u003ccode\u003eJOIN\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (PreprocessedFrom a) -\u003e expr (PreprocessedFrom b) -\u003e query (expr (PreprocessedFrom (join a b)))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#fromJoin",
        "fct-type": "method",
        "title": "fromJoin"
      },
      "index": {
        "description": "Internal Do JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "fromJoin",
        "normalized": "a(PreprocessedFrom b)-\u003ea(PreprocessedFrom c)-\u003ed(a(PreprocessedFrom(e b c)))",
        "package": "esqueleto",
        "partial": "Join",
        "signature": "expr(PreprocessedFrom a)-\u003eexpr(PreprocessedFrom b)-\u003equery(expr(PreprocessedFrom(join a b)))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:fromStart",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Start a \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e query with an entity. \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e\n does two kinds of magic using \u003ccode\u003e\u003ca\u003efromStart\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003efromJoin\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efromFinish\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e  The simple but tedious magic of allowing tuples to be\n   used.\n\u003c/li\u003e\u003cli\u003e  The more advanced magic of creating \u003ccode\u003eJOIN\u003c/code\u003es.  The\n   \u003ccode\u003eJOIN\u003c/code\u003e is processed from right to left.  The rightmost\n   entity of the \u003ccode\u003eJOIN\u003c/code\u003e is created with \u003ccode\u003e\u003ca\u003efromStart\u003c/a\u003e\u003c/code\u003e.  Each\n   \u003ccode\u003eJOIN\u003c/code\u003e step is then translated into a call to \u003ccode\u003e\u003ca\u003efromJoin\u003c/a\u003e\u003c/code\u003e.\n   In the end, \u003ccode\u003e\u003ca\u003efromFinish\u003c/a\u003e\u003c/code\u003e is called to materialize the\n   \u003ccode\u003eJOIN\u003c/code\u003e.\n\u003c/li\u003e\u003c/ol\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (PreprocessedFrom (expr (Entity a))))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#fromStart",
        "fct-type": "method",
        "title": "fromStart"
      },
      "index": {
        "description": "Internal Start from query with an entity from does two kinds of magic using fromStart fromJoin and fromFinish The simple but tedious magic of allowing tuples to be used The more advanced magic of creating JOIN The JOIN is processed from right to left The rightmost entity of the JOIN is created with fromStart Each JOIN step is then translated into call to fromJoin In the end fromFinish is called to materialize the JOIN",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "fromStart",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Start",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:fromStartMaybe",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Same as \u003ccode\u003e\u003ca\u003efromStart\u003c/a\u003e\u003c/code\u003e, but entity may be missing.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (PreprocessedFrom (expr (Maybe (Entity a)))))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#fromStartMaybe",
        "fct-type": "method",
        "title": "fromStartMaybe"
      },
      "index": {
        "description": "Internal Same as fromStart but entity may be missing",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "fromStartMaybe",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Start Maybe",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:groupBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eGROUP BY\u003c/code\u003e clause. You can enclose multiple columns\n in a tuple.\n\u003c/p\u003e\u003cpre\u003e\n select $ from \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar) -\u003e do\n   on (foo ^. FooBarId ==. bar ^. BarId)\n   groupBy (bar ^. BarId, bar ^. BarName)\n   return (bar ^. BarId, bar ^. BarName, countRows)\n\u003c/pre\u003e\u003cp\u003eWith groupBy you can sort by aggregate functions, like so (we\n used \u003ccode\u003elet\u003c/code\u003e to restrict the more general \u003ccode\u003e\u003ca\u003ecountRows\u003c/a\u003e\u003c/code\u003e to\n \u003ccode\u003eSqlExpr (Value Int)\u003c/code\u003e to avoid ambiguity):\n\u003c/p\u003e\u003cpre\u003e\n r \u003c- select $ from \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar) -\u003e do\n   on (foo ^. FooBarId ==. bar ^. BarId)\n   groupBy $ bar ^. BarName\n   let countRows' = countRows\n   orderBy [asc countRows']\n   return (bar ^. BarName, countRows')\n forM_ r $ \\((Value name), (Value count)) -\u003e do\n   print name\n   print (count :: Int)\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "a -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#groupBy",
        "fct-type": "method",
        "title": "groupBy"
      },
      "index": {
        "description": "GROUP BY clause You can enclose multiple columns in tuple select from foo InnerJoin bar do on foo FooBarId bar BarId groupBy bar BarId bar BarName return bar BarId bar BarName countRows With groupBy you can sort by aggregate functions like so we used let to restrict the more general countRows to SqlExpr Value Int to avoid ambiguity select from foo InnerJoin bar do on foo FooBarId bar BarId groupBy bar BarName let countRows countRows orderBy asc countRows return bar BarName countRows forM Value name Value count do print name print count Int",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "groupBy",
        "normalized": "a-\u003eb()",
        "package": "esqueleto",
        "partial": "By",
        "signature": "a-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:having",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eHAVING\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eSince: 1.2.2\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#having",
        "fct-type": "method",
        "title": "having"
      },
      "index": {
        "description": "HAVING Since",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "having",
        "normalized": "a(Value Bool)-\u003eb()",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:in_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eIN\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (ValueList typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#in_",
        "fct-type": "method",
        "title": "in_"
      },
      "index": {
        "description": "IN operator",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "in_",
        "normalized": "a(Value b)-\u003ea(ValueList b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(ValueList typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:isNothing",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eIS NULL\u003c/code\u003e comparison.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value (Maybe typ)) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#isNothing",
        "fct-type": "method",
        "title": "isNothing"
      },
      "index": {
        "description": "IS NULL comparison",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "isNothing",
        "normalized": "a(Value(Maybe b))-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "Nothing",
        "signature": "expr(Value(Maybe typ))-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:joinV",
      "description": {
        "fct-descr": "\u003cp\u003eJoin nested \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003es in a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e into one. This is useful when\n calling aggregate functions on nullable fields.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value (Maybe (Maybe typ))) -\u003e expr (Value (Maybe typ))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#joinV",
        "fct-type": "method",
        "title": "joinV"
      },
      "index": {
        "description": "Join nested Maybe in Value into one This is useful when calling aggregate functions on nullable fields",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "joinV",
        "normalized": "a(Value(Maybe(Maybe b)))-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value(Maybe(Maybe typ)))-\u003eexpr(Value(Maybe typ))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:just",
      "description": {
        "fct-descr": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e, promotes a value of type \u003ccode\u003etyp\u003c/code\u003e into\n one of type \u003ccode\u003eMaybe typ\u003c/code\u003e.  It should hold that \u003ccode\u003eval . Just\n === just . val\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value (Maybe typ))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#just",
        "fct-type": "method",
        "title": "just"
      },
      "index": {
        "description": "Analogous to Just promotes value of type typ into one of type Maybe typ It should hold that val Just just val",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "just",
        "normalized": "a(Value b)-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value(Maybe typ))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:like",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eLIKE\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value s) -\u003e expr (Value s) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#like",
        "fct-type": "method",
        "title": "like"
      },
      "index": {
        "description": "LIKE operator",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "like",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value s)-\u003eexpr(Value s)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:limit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eLIMIT\u003c/code\u003e.  Limit the number of returned rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "Int64 -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#limit",
        "fct-type": "method",
        "title": "limit"
      },
      "index": {
        "description": "LIMIT Limit the number of returned rows",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "limit",
        "normalized": "Int-\u003ea()",
        "package": "esqueleto",
        "partial": "",
        "signature": "Int-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:max_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value (Maybe a))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#max_",
        "fct-type": "method",
        "title": "max_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "max_",
        "normalized": "a(Value b)-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value(Maybe a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:min_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value (Maybe a))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#min_",
        "fct-type": "method",
        "title": "min_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "min_",
        "normalized": "a(Value b)-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value(Maybe a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:notExists",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eNOT EXISTS\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "query () -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#notExists",
        "fct-type": "method",
        "title": "notExists"
      },
      "index": {
        "description": "NOT EXISTS operator",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "notExists",
        "normalized": "a()-\u003eb(Value Bool)",
        "package": "esqueleto",
        "partial": "Exists",
        "signature": "query()-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:notIn",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eNOT IN\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (ValueList typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#notIn",
        "fct-type": "method",
        "title": "notIn"
      },
      "index": {
        "description": "NOT IN operator",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "notIn",
        "normalized": "a(Value b)-\u003ea(ValueList b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "In",
        "signature": "expr(Value typ)-\u003eexpr(ValueList typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:not_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#not_",
        "fct-type": "method",
        "title": "not_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "not_",
        "normalized": "a(Value Bool)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:nothing",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eNULL\u003c/code\u003e value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value (Maybe typ))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#nothing",
        "fct-type": "method",
        "title": "nothing"
      },
      "index": {
        "description": "NULL value",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "nothing",
        "normalized": "",
        "package": "esqueleto",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:offset",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eOFFSET\u003c/code\u003e.  Usually used with \u003ccode\u003e\u003ca\u003elimit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "Int64 -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#offset",
        "fct-type": "method",
        "title": "offset"
      },
      "index": {
        "description": "OFFSET Usually used with limit",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "offset",
        "normalized": "Int-\u003ea()",
        "package": "esqueleto",
        "partial": "",
        "signature": "Int-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:on",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eON\u003c/code\u003e clause: restrict the a \u003ccode\u003eJOIN\u003c/code\u003e's result.  The \u003ccode\u003eON\u003c/code\u003e\n clause will be applied to the \u003cem\u003elast\u003c/em\u003e \u003ccode\u003eJOIN\u003c/code\u003e that does not\n have an \u003ccode\u003eON\u003c/code\u003e clause yet.  If there are no \u003ccode\u003eJOIN\u003c/code\u003es without\n \u003ccode\u003eON\u003c/code\u003e clauses (either because you didn't do any \u003ccode\u003eJOIN\u003c/code\u003e, or\n because all \u003ccode\u003eJOIN\u003c/code\u003es already have their own \u003ccode\u003eON\u003c/code\u003e clauses), a\n runtime exception \u003ccode\u003e\u003ca\u003eOnClauseWithoutMatchingJoinException\u003c/a\u003e\u003c/code\u003e is\n thrown.  \u003ccode\u003eON\u003c/code\u003e clauses are optional when doing \u003ccode\u003eJOIN\u003c/code\u003es.\n\u003c/p\u003e\u003cp\u003eOn the simple case of doing just one \u003ccode\u003eJOIN\u003c/code\u003e, for example\n\u003c/p\u003e\u003cpre\u003e\n select $\n from $ \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar) -\u003e do\n   on (foo ^. FooId ==. bar ^. BarFooId)\n   ...\n\u003c/pre\u003e\u003cp\u003ethere's no ambiguity and the rules above just mean that\n you're allowed to call \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003e only once (as in SQL).  If you\n have many joins, then the \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003es are applied on the \u003cem\u003ereverse\u003c/em\u003e\n order that the \u003ccode\u003eJOIN\u003c/code\u003es appear.  For example:\n\u003c/p\u003e\u003cpre\u003e\n select $\n from $ \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` baz) -\u003e do\n   on (baz ^. BazId ==. bar ^. BarBazId)\n   on (foo ^. FooId ==. bar ^. BarFooId)\n   ...\n\u003c/pre\u003e\u003cp\u003eThe order is \u003cem\u003ereversed\u003c/em\u003e in order to improve composability.\n For example, consider \u003ccode\u003equery1\u003c/code\u003e and \u003ccode\u003equery2\u003c/code\u003e below:\n\u003c/p\u003e\u003cpre\u003e\n let query1 =\n       from $ \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar) -\u003e do\n         on (foo ^. FooId ==. bar ^. BarFooId)\n     query2 =\n       from $ \\(mbaz `\u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e` quux) -\u003e do\n         return (mbaz ?. BazName, quux)\n     test1 =      (,) \u003c$\u003e query1 \u003c*\u003e query2\n     test2 = flip (,) \u003c$\u003e query2 \u003c*\u003e query1\n\u003c/pre\u003e\u003cp\u003eIf the order was \u003cem\u003enot\u003c/em\u003e reversed, then \u003ccode\u003etest2\u003c/code\u003e would be\n broken: \u003ccode\u003equery1\u003c/code\u003e's \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003e would refer to \u003ccode\u003equery2\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#on",
        "fct-type": "method",
        "title": "on"
      },
      "index": {
        "description": "ON clause restrict the JOIN result The ON clause will be applied to the last JOIN that does not have an ON clause yet If there are no JOIN without ON clauses either because you didn do any JOIN or because all JOIN already have their own ON clauses runtime exception OnClauseWithoutMatchingJoinException is thrown ON clauses are optional when doing JOIN On the simple case of doing just one JOIN for example select from foo InnerJoin bar do on foo FooId bar BarFooId there no ambiguity and the rules above just mean that you re allowed to call on only once as in SQL If you have many joins then the on are applied on the reverse order that the JOIN appear For example select from foo InnerJoin bar InnerJoin baz do on baz BazId bar BarBazId on foo FooId bar BarFooId The order is reversed in order to improve composability For example consider query1 and query2 below let query1 from foo InnerJoin bar do on foo FooId bar BarFooId query2 from mbaz LeftOuterJoin quux do return mbaz BazName quux test1 query1 query2 test2 flip query2 query1 If the order was not reversed then test2 would be broken query1 on would refer to query2 LeftOuterJoin",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "on",
        "normalized": "a(Value Bool)-\u003eb()",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:orderBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eORDER BY\u003c/code\u003e clause. See also \u003ccode\u003e\u003ca\u003easc\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edesc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "[expr OrderBy] -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#orderBy",
        "fct-type": "method",
        "title": "orderBy"
      },
      "index": {
        "description": "ORDER BY clause See also asc and desc",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "orderBy",
        "normalized": "[a OrderBy]-\u003eb()",
        "package": "esqueleto",
        "partial": "By",
        "signature": "[expr OrderBy]-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:random_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#random_",
        "fct-type": "method",
        "title": "random_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "random_",
        "normalized": "",
        "package": "esqueleto",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:reifyJoinKind",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Reify a \u003ccode\u003eJoinKind\u003c/code\u003e from a \u003ccode\u003eJOIN\u003c/code\u003e.  This\n function is non-strict.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "join a b -\u003e JoinKind",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#reifyJoinKind",
        "fct-type": "method",
        "title": "reifyJoinKind"
      },
      "index": {
        "description": "Internal Reify JoinKind from JOIN This function is non-strict",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "reifyJoinKind",
        "normalized": "a b c-\u003eJoinKind",
        "package": "esqueleto",
        "partial": "Join Kind",
        "signature": "join a b-\u003eJoinKind"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:round_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#round_",
        "fct-type": "method",
        "title": "round_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "round_",
        "normalized": "a(Value b)-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eSET\u003c/code\u003e clause used on \u003ccode\u003eUPDATE\u003c/code\u003es.  Note that while it's not\n a type error to use this function on a \u003ccode\u003eSELECT\u003c/code\u003e, it will\n most certainly result in a runtime error.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Entity val) -\u003e [expr (Update val)] -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#set",
        "fct-type": "method",
        "title": "set"
      },
      "index": {
        "description": "SET clause used on UPDATE Note that while it not type error to use this function on SELECT it will most certainly result in runtime error",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "set",
        "normalized": "a(Entity b)-\u003e[a(Update b)]-\u003ec()",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Entity val)-\u003e[expr(Update val)]-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:smartJoin",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) \u003ccode\u003esmartJoin a b\u003c/code\u003e is a \u003ccode\u003eJOIN\u003c/code\u003e of the correct kind.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "a -\u003e b -\u003e join a b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#smartJoin",
        "fct-type": "method",
        "title": "smartJoin"
      },
      "index": {
        "description": "Internal smartJoin is JOIN of the correct kind",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "smartJoin",
        "normalized": "a-\u003eb-\u003ec a b",
        "package": "esqueleto",
        "partial": "Join",
        "signature": "a-\u003eb-\u003ejoin a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:subList_select",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a subquery \u003ccode\u003eSELECT\u003c/code\u003e in an expression.  Returns a\n list of values.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (Value a)) -\u003e expr (ValueList a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#subList_select",
        "fct-type": "method",
        "title": "subList_select"
      },
      "index": {
        "description": "Execute subquery SELECT in an expression Returns list of values",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "subList_select",
        "normalized": "a(b(Value c))-\u003eb(ValueList c)",
        "package": "esqueleto",
        "partial": "List",
        "signature": "query(expr(Value a))-\u003eexpr(ValueList a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:subList_selectDistinct",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003esublist_select\u003c/code\u003e but using \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (Value a)) -\u003e expr (ValueList a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#subList_selectDistinct",
        "fct-type": "method",
        "title": "subList_selectDistinct"
      },
      "index": {
        "description": "Same as sublist select but using SELECT DISTINCT",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "subList_selectDistinct",
        "normalized": "a(b(Value c))-\u003eb(ValueList c)",
        "package": "esqueleto",
        "partial": "List Distinct",
        "signature": "query(expr(Value a))-\u003eexpr(ValueList a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:sub_select",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a subquery \u003ccode\u003eSELECT\u003c/code\u003e in an expression.  Returns a\n simple value so should be used only when the \u003ccode\u003eSELECT\u003c/code\u003e query\n is guaranteed to return just one row.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (Value a)) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#sub_select",
        "fct-type": "method",
        "title": "sub_select"
      },
      "index": {
        "description": "Execute subquery SELECT in an expression Returns simple value so should be used only when the SELECT query is guaranteed to return just one row",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "sub_select",
        "normalized": "a(b(Value c))-\u003eb(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "query(expr(Value a))-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:sub_selectDistinct",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003esub_select\u003c/a\u003e\u003c/code\u003e but using \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (Value a)) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#sub_selectDistinct",
        "fct-type": "method",
        "title": "sub_selectDistinct"
      },
      "index": {
        "description": "Same as sub select but using SELECT DISTINCT",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "sub_selectDistinct",
        "normalized": "a(b(Value c))-\u003eb(Value c)",
        "package": "esqueleto",
        "partial": "Distinct",
        "signature": "query(expr(Value a))-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:sum_",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value (Maybe a))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#sum_",
        "fct-type": "method",
        "title": "sum_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "sum_",
        "normalized": "a(Value b)-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value(Maybe a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:toSomeValues",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "a -\u003e [SomeValue expr]",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#toSomeValues",
        "fct-type": "method",
        "title": "toSomeValues"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "toSomeValues",
        "normalized": "a-\u003e[SomeValue b]",
        "package": "esqueleto",
        "partial": "Some Values",
        "signature": "a-\u003e[SomeValue expr]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:val",
      "description": {
        "fct-descr": "\u003cp\u003eLift a constant value from Haskell-land to the query.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "typ -\u003e expr (Value typ)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#val",
        "fct-type": "method",
        "title": "val"
      },
      "index": {
        "description": "Lift constant value from Haskell-land to the query",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "val",
        "normalized": "a-\u003eb(Value a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "typ-\u003eexpr(Value typ)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:valList",
      "description": {
        "fct-descr": "\u003cp\u003eLift a list of constant value from Haskell-land to the query.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "[typ] -\u003e expr (ValueList typ)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#valList",
        "fct-type": "method",
        "title": "valList"
      },
      "index": {
        "description": "Lift list of constant value from Haskell-land to the query",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "valList",
        "normalized": "[a]-\u003eb(ValueList a)",
        "package": "esqueleto",
        "partial": "List",
        "signature": "[typ]-\u003eexpr(ValueList typ)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Language.html#v:where_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eWHERE\u003c/code\u003e clause: restrict the query's result.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Language",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#where_",
        "fct-type": "method",
        "title": "where_"
      },
      "index": {
        "description": "WHERE clause restrict the query result",
        "hierarchy": "Database Esqueleto Internal Language",
        "module": "Database.Esqueleto.Internal.Language",
        "name": "where_",
        "normalized": "a(Value Bool)-\u003eb()",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is an internal module, anything exported by this module\n may change without a major version bump.  Please use only\n \u003ca\u003eDatabase.Esqueleto\u003c/a\u003e if possible.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "module",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html",
        "fct-type": "module",
        "title": "Sql"
      },
      "index": {
        "description": "This is an internal module anything exported by this module may change without major version bump Please use only Database.Esqueleto if possible",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "Sql",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Sql",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#t:IdentInfo",
      "description": {
        "fct-descr": "\u003cp\u003eInformation needed to escape and use identifiers.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "type",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#IdentInfo",
        "fct-type": "type",
        "title": "IdentInfo"
      },
      "index": {
        "description": "Information needed to escape and use identifiers",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "IdentInfo",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Ident Info",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#t:IdentState",
      "description": {
        "fct-descr": "\u003cp\u003eList of identifiers already in use and supply of temporary\n identifiers.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#IdentState",
        "fct-type": "data",
        "title": "IdentState"
      },
      "index": {
        "description": "List of identifiers already in use and supply of temporary identifiers",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "IdentState",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Ident State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#t:Mode",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Mode of query being converted by \u003ccode\u003e\u003ca\u003etoRawSql\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#Mode",
        "fct-type": "data",
        "title": "Mode"
      },
      "index": {
        "description": "Internal Mode of query being converted by toRawSql",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "Mode",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Mode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#t:SqlEntity",
      "description": {
        "fct-descr": "\u003cp\u003eConstraint synonym for \u003ccode\u003epersistent\u003c/code\u003e entities whose backend\n is \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "type",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#SqlEntity",
        "fct-type": "type",
        "title": "SqlEntity"
      },
      "index": {
        "description": "Constraint synonym for persistent entities whose backend is SqlPersistT",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "SqlEntity",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Sql Entity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#t:SqlExpr",
      "description": {
        "fct-descr": "\u003cp\u003eAn expression on the SQL backend.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#SqlExpr",
        "fct-type": "data",
        "title": "SqlExpr"
      },
      "index": {
        "description": "An expression on the SQL backend",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "SqlExpr",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Sql Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#t:SqlQuery",
      "description": {
        "fct-descr": "\u003cp\u003eSQL backend for \u003ccode\u003eesqueleto\u003c/code\u003e using \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#SqlQuery",
        "fct-type": "data",
        "title": "SqlQuery"
      },
      "index": {
        "description": "SQL backend for esqueleto using SqlPersistT",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "SqlQuery",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Sql Query",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#t:SqlSelect",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Class for mapping results coming from \u003ccode\u003e\u003ca\u003eSqlQuery\u003c/a\u003e\u003c/code\u003e\n into actual results.\n\u003c/p\u003e\u003cp\u003eThis looks very similar to \u003ccode\u003eRawSql\u003c/code\u003e, and it is!  However,\n there are some crucial differences and ultimately they're\n different classes.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "class",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#SqlSelect",
        "fct-type": "class",
        "title": "SqlSelect"
      },
      "index": {
        "description": "Internal Class for mapping results coming from SqlQuery into actual results This looks very similar to RawSql and it is However there are some crucial differences and ultimately they re different classes",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "SqlSelect",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Sql Select",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#t:UnsafeSqlFunctionArgument",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "class",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#UnsafeSqlFunctionArgument",
        "fct-type": "class",
        "title": "UnsafeSqlFunctionArgument"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "UnsafeSqlFunctionArgument",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Unsafe Sql Function Argument",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:DELETE",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "DELETE",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#Mode",
        "fct-type": "function",
        "title": "DELETE"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "DELETE",
        "normalized": "",
        "package": "esqueleto",
        "partial": "DELETE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:SELECT",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SELECT",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#Mode",
        "fct-type": "function",
        "title": "SELECT"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "SELECT",
        "normalized": "",
        "package": "esqueleto",
        "partial": "SELECT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:SELECT_DISTINCT",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SELECT_DISTINCT",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#Mode",
        "fct-type": "function",
        "title": "SELECT_DISTINCT"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "SELECT_DISTINCT",
        "normalized": "",
        "package": "esqueleto",
        "partial": "SELECT DISTINCT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:UPDATE",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "UPDATE",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#Mode",
        "fct-type": "function",
        "title": "UPDATE"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "UPDATE",
        "normalized": "",
        "package": "esqueleto",
        "partial": "UPDATE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:delete",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eDELETE\u003c/code\u003e query inside \u003ccode\u003epersistent\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad.  Note that currently there are no type\n checks for statements that should not appear on a \u003ccode\u003eDELETE\u003c/code\u003e\n query.\n\u003c/p\u003e\u003cp\u003eExample of usage:\n\u003c/p\u003e\u003cpre\u003e\n delete $\n from $ \\appointment -\u003e\n where_ (appointment ^. AppointmentDate \u003c. val now)\n\u003c/pre\u003e\u003cp\u003eUnlike \u003ccode\u003e\u003ca\u003eselect\u003c/a\u003e\u003c/code\u003e, there is a useful way of using \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e that\n will lead to type ambiguities.  If you want to delete all rows\n (i.e., no \u003ccode\u003e\u003ca\u003ewhere_\u003c/a\u003e\u003c/code\u003e clause), you'll have to use a type signature:\n\u003c/p\u003e\u003cpre\u003e\n delete $\n from $ \\(appointment :: SqlExpr (Entity Appointment)) -\u003e\n return ()\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery () -\u003e SqlPersistT m ()",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#delete",
        "fct-type": "function",
        "title": "delete"
      },
      "index": {
        "description": "Execute an esqueleto DELETE query inside persistent SqlPersistT monad Note that currently there are no type checks for statements that should not appear on DELETE query Example of usage delete from appointment where appointment AppointmentDate val now Unlike select there is useful way of using delete that will lead to type ambiguities If you want to delete all rows i.e no where clause you ll have to use type signature delete from appointment SqlExpr Entity Appointment return",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "delete",
        "normalized": "SqlQuery()-\u003eSqlPersistT a()",
        "package": "esqueleto",
        "partial": "",
        "signature": "SqlQuery()-\u003eSqlPersistT m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:deleteCount",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e, but returns the number of rows affected.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery () -\u003e SqlPersistT m Int64",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#deleteCount",
        "fct-type": "function",
        "title": "deleteCount"
      },
      "index": {
        "description": "Same as delete but returns the number of rows affected",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "deleteCount",
        "normalized": "SqlQuery()-\u003eSqlPersistT a Int",
        "package": "esqueleto",
        "partial": "Count",
        "signature": "SqlQuery()-\u003eSqlPersistT m Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:initialIdentState",
      "description": {
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "IdentState",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#initialIdentState",
        "fct-type": "function",
        "title": "initialIdentState"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "initialIdentState",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Ident State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:insertSelect",
      "description": {
        "fct-descr": "\u003cp\u003eInsert a \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e for every selected value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery (SqlExpr (Insertion a)) -\u003e SqlPersistT m ()",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#insertSelect",
        "fct-type": "function",
        "title": "insertSelect"
      },
      "index": {
        "description": "Insert PersistField for every selected value",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "insertSelect",
        "normalized": "SqlQuery(SqlExpr(Insertion a))-\u003eSqlPersistT b()",
        "package": "esqueleto",
        "partial": "Select",
        "signature": "SqlQuery(SqlExpr(Insertion a))-\u003eSqlPersistT m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:insertSelectDistinct",
      "description": {
        "fct-descr": "\u003cp\u003eInsert a \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e for every unique selected value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery (SqlExpr (Insertion a)) -\u003e SqlPersistT m ()",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#insertSelectDistinct",
        "fct-type": "function",
        "title": "insertSelectDistinct"
      },
      "index": {
        "description": "Insert PersistField for every unique selected value",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "insertSelectDistinct",
        "normalized": "SqlQuery(SqlExpr(Insertion a))-\u003eSqlPersistT b()",
        "package": "esqueleto",
        "partial": "Select Distinct",
        "signature": "SqlQuery(SqlExpr(Insertion a))-\u003eSqlPersistT m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:rawEsqueleto",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Execute an \u003ccode\u003eesqueleto\u003c/code\u003e statement inside\n \u003ccode\u003epersistent\u003c/code\u003e's \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "Mode -\u003e SqlQuery () -\u003e SqlPersistT m Int64",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#rawEsqueleto",
        "fct-type": "function",
        "title": "rawEsqueleto"
      },
      "index": {
        "description": "Internal Execute an esqueleto statement inside persistent SqlPersistT monad",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "rawEsqueleto",
        "normalized": "Mode-\u003eSqlQuery()-\u003eSqlPersistT a Int",
        "package": "esqueleto",
        "partial": "Esqueleto",
        "signature": "Mode-\u003eSqlQuery()-\u003eSqlPersistT m Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:rawSelectSource",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Execute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSqlQuery\u003c/a\u003e\u003c/code\u003e inside\n \u003ccode\u003epersistent\u003c/code\u003e's \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "Mode -\u003e SqlQuery a -\u003e SqlPersistT m (Source (ResourceT (SqlPersistT m)) r)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#rawSelectSource",
        "fct-type": "function",
        "title": "rawSelectSource"
      },
      "index": {
        "description": "Internal Execute an esqueleto SELECT SqlQuery inside persistent SqlPersistT monad",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "rawSelectSource",
        "normalized": "Mode-\u003eSqlQuery a-\u003eSqlPersistT b(Source(ResourceT(SqlPersistT b))c)",
        "package": "esqueleto",
        "partial": "Select Source",
        "signature": "Mode-\u003eSqlQuery a-\u003eSqlPersistT m(Source(ResourceT(SqlPersistT m))r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:runSource",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Run a \u003ccode\u003e\u003ca\u003eSource\u003c/a\u003e\u003c/code\u003e of rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "Source (ResourceT (SqlPersistT m)) r -\u003e SqlPersistT m [r]",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#runSource",
        "fct-type": "function",
        "title": "runSource"
      },
      "index": {
        "description": "Internal Run Source of rows",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "runSource",
        "normalized": "Source(ResourceT(SqlPersistT a))b-\u003eSqlPersistT a[b]",
        "package": "esqueleto",
        "partial": "Source",
        "signature": "Source(ResourceT(SqlPersistT m))r-\u003eSqlPersistT m[r]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:select",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT\u003c/code\u003e query inside \u003ccode\u003epersistent\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad and return a list of rows.\n\u003c/p\u003e\u003cp\u003eWe've seen that \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e has some magic about which kinds of\n things you may bring into scope.  This \u003ccode\u003e\u003ca\u003eselect\u003c/a\u003e\u003c/code\u003e function also\n has some magic for which kinds of things you may bring back to\n Haskell-land by using \u003ccode\u003eSqlQuery\u003c/code\u003e's \u003ccode\u003ereturn\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e You may return a \u003ccode\u003eSqlExpr (\u003ccode\u003e\u003ca\u003eEntity\u003c/a\u003e\u003c/code\u003e v)\u003c/code\u003e for an entity \u003ccode\u003ev\u003c/code\u003e\n  (i.e., like the \u003ccode\u003e*\u003c/code\u003e in SQL), which is then returned to\n  Haskell-land as just \u003ccode\u003eEntity v\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e You may return a \u003ccode\u003eSqlExpr (Maybe (Entity v))\u003c/code\u003e for an entity\n  \u003ccode\u003ev\u003c/code\u003e that may be \u003ccode\u003eNULL\u003c/code\u003e, which is then returned to\n  Haskell-land as \u003ccode\u003eMaybe (Entity v)\u003c/code\u003e.  Used for \u003ccode\u003eOUTER JOIN\u003c/code\u003es.\n\u003c/li\u003e\u003cli\u003e You may return a \u003ccode\u003eSqlExpr (\u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e t)\u003c/code\u003e for a value \u003ccode\u003et\u003c/code\u003e\n  (i.e., a single column), where \u003ccode\u003et\u003c/code\u003e is any instance of\n  \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e, which is then returned to Haskell-land as\n  \u003ccode\u003eValue t\u003c/code\u003e.  You may use \u003ccode\u003eValue\u003c/code\u003e to return projections of an\n  \u003ccode\u003eEntity\u003c/code\u003e (see \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e and \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e?.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e) or to return any other\n  value calculated on the query (e.g., \u003ccode\u003e\u003ca\u003ecountRows\u003c/a\u003e\u003c/code\u003e or\n  \u003ccode\u003e\u003ca\u003esub_select\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe \u003ccode\u003eSqlSelect a r\u003c/code\u003e class has functional dependencies that\n allow type information to flow both from \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003er\u003c/code\u003e and\n vice-versa.  This means that you'll almost never have to give\n any type signatures for \u003ccode\u003eesqueleto\u003c/code\u003e queries.  For example, the\n query \u003ccode\u003eselect $ from $ \\p -\u003e return p\u003c/code\u003e alone is ambiguous, but\n in the context of\n\u003c/p\u003e\u003cpre\u003e\n do ps \u003c- select $\n          from $ \\p -\u003e\n          return p\n    liftIO $ mapM_ (putStrLn . personName . entityVal) ps\n\u003c/pre\u003e\u003cp\u003ewe are able to infer from that single \u003ccode\u003epersonName . entityVal\u003c/code\u003e\n function composition that the \u003ccode\u003ep\u003c/code\u003e inside the query is of type\n \u003ccode\u003eSqlExpr (Entity Person)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery a -\u003e SqlPersistT m [r]",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#select",
        "fct-type": "function",
        "title": "select"
      },
      "index": {
        "description": "Execute an esqueleto SELECT query inside persistent SqlPersistT monad and return list of rows We ve seen that from has some magic about which kinds of things you may bring into scope This select function also has some magic for which kinds of things you may bring back to Haskell-land by using SqlQuery return You may return SqlExpr Entity for an entity i.e like the in SQL which is then returned to Haskell-land as just Entity You may return SqlExpr Maybe Entity for an entity that may be NULL which is then returned to Haskell-land as Maybe Entity Used for OUTER JOIN You may return SqlExpr Value for value i.e single column where is any instance of PersistField which is then returned to Haskell-land as Value You may use Value to return projections of an Entity see and or to return any other value calculated on the query e.g countRows or sub select The SqlSelect class has functional dependencies that allow type information to flow both from to and vice-versa This means that you ll almost never have to give any type signatures for esqueleto queries For example the query select from return alone is ambiguous but in the context of do ps select from return liftIO mapM putStrLn personName entityVal ps we are able to infer from that single personName entityVal function composition that the inside the query is of type SqlExpr Entity Person",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "select",
        "normalized": "SqlQuery a-\u003eSqlPersistT b[c]",
        "package": "esqueleto",
        "partial": "",
        "signature": "SqlQuery a-\u003eSqlPersistT m[r]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:selectDistinct",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e query inside\n \u003ccode\u003epersistent\u003c/code\u003e's \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad and return a list of rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery a -\u003e SqlPersistT m [r]",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#selectDistinct",
        "fct-type": "function",
        "title": "selectDistinct"
      },
      "index": {
        "description": "Execute an esqueleto SELECT DISTINCT query inside persistent SqlPersistT monad and return list of rows",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "selectDistinct",
        "normalized": "SqlQuery a-\u003eSqlPersistT b[c]",
        "package": "esqueleto",
        "partial": "Distinct",
        "signature": "SqlQuery a-\u003eSqlPersistT m[r]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:selectDistinctSource",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e query inside\n \u003ccode\u003epersistent\u003c/code\u003e's \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad and return a \u003ccode\u003e\u003ca\u003eSource\u003c/a\u003e\u003c/code\u003e of\n rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery a -\u003e SqlPersistT m (Source (ResourceT (SqlPersistT m)) r)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#selectDistinctSource",
        "fct-type": "function",
        "title": "selectDistinctSource"
      },
      "index": {
        "description": "Execute an esqueleto SELECT DISTINCT query inside persistent SqlPersistT monad and return Source of rows",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "selectDistinctSource",
        "normalized": "SqlQuery a-\u003eSqlPersistT b(Source(ResourceT(SqlPersistT b))c)",
        "package": "esqueleto",
        "partial": "Distinct Source",
        "signature": "SqlQuery a-\u003eSqlPersistT m(Source(ResourceT(SqlPersistT m))r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:selectSource",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT\u003c/code\u003e query inside \u003ccode\u003epersistent\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad and return a \u003ccode\u003e\u003ca\u003eSource\u003c/a\u003e\u003c/code\u003e of rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery a -\u003e SqlPersistT m (Source (ResourceT (SqlPersistT m)) r)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#selectSource",
        "fct-type": "function",
        "title": "selectSource"
      },
      "index": {
        "description": "Execute an esqueleto SELECT query inside persistent SqlPersistT monad and return Source of rows",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "selectSource",
        "normalized": "SqlQuery a-\u003eSqlPersistT b(Source(ResourceT(SqlPersistT b))c)",
        "package": "esqueleto",
        "partial": "Source",
        "signature": "SqlQuery a-\u003eSqlPersistT m(Source(ResourceT(SqlPersistT m))r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:sqlSelectColCount",
      "description": {
        "fct-descr": "\u003cp\u003eNumber of columns that will be consumed.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "Proxy a -\u003e Int",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#sqlSelectColCount",
        "fct-type": "method",
        "title": "sqlSelectColCount"
      },
      "index": {
        "description": "Number of columns that will be consumed",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "sqlSelectColCount",
        "normalized": "Proxy a-\u003eInt",
        "package": "esqueleto",
        "partial": "Select Col Count",
        "signature": "Proxy a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:sqlSelectCols",
      "description": {
        "fct-descr": "\u003cp\u003eCreates the variable part of the \u003ccode\u003eSELECT\u003c/code\u003e query and\n returns the list of \u003ccode\u003e\u003ca\u003ePersistValue\u003c/a\u003e\u003c/code\u003es that will be given to\n \u003ccode\u003e\u003ca\u003erawQuery\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "IdentInfo -\u003e a -\u003e (Builder, [PersistValue])",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#sqlSelectCols",
        "fct-type": "method",
        "title": "sqlSelectCols"
      },
      "index": {
        "description": "Creates the variable part of the SELECT query and returns the list of PersistValue that will be given to rawQuery",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "sqlSelectCols",
        "normalized": "IdentInfo-\u003ea-\u003e(Builder,[PersistValue])",
        "package": "esqueleto",
        "partial": "Select Cols",
        "signature": "IdentInfo-\u003ea-\u003e(Builder,[PersistValue])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:sqlSelectProcessRow",
      "description": {
        "fct-descr": "\u003cp\u003eTransform a row of the result into the data type.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "[PersistValue] -\u003e Either Text r",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#sqlSelectProcessRow",
        "fct-type": "method",
        "title": "sqlSelectProcessRow"
      },
      "index": {
        "description": "Transform row of the result into the data type",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "sqlSelectProcessRow",
        "normalized": "[PersistValue]-\u003eEither Text a",
        "package": "esqueleto",
        "partial": "Select Process Row",
        "signature": "[PersistValue]-\u003eEither Text r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:toRawSql",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Pretty prints a \u003ccode\u003e\u003ca\u003eSqlQuery\u003c/a\u003e\u003c/code\u003e into a SQL query.\n\u003c/p\u003e\u003cp\u003eNote: if you're curious about the SQL query being generated by\n \u003ccode\u003eesqueleto\u003c/code\u003e, instead of manually using this function (which is\n possible but tedious), you may just turn on query logging of\n \u003ccode\u003epersistent\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "Mode -\u003e QueryType a -\u003e IdentInfo -\u003e SqlQuery a -\u003e (Builder, [PersistValue])",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#toRawSql",
        "fct-type": "function",
        "title": "toRawSql"
      },
      "index": {
        "description": "Internal Pretty prints SqlQuery into SQL query Note if you re curious about the SQL query being generated by esqueleto instead of manually using this function which is possible but tedious you may just turn on query logging of persistent",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "toRawSql",
        "normalized": "Mode-\u003eQueryType a-\u003eIdentInfo-\u003eSqlQuery a-\u003e(Builder,[PersistValue])",
        "package": "esqueleto",
        "partial": "Raw Sql",
        "signature": "Mode-\u003eQueryType a-\u003eIdentInfo-\u003eSqlQuery a-\u003e(Builder,[PersistValue])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:unsafeSqlBinOp",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Create a custom binary operator.  You \u003cem\u003eshould\u003c/em\u003e\n \u003cem\u003enot\u003c/em\u003e use this function directly since its type is very\n general, you should always use it with an explicit type\n signature.  For example:\n\u003c/p\u003e\u003cpre\u003e\n (==.) :: SqlExpr (Value a) -\u003e SqlExpr (Value a) -\u003e SqlExpr (Value Bool)\n (==.) = unsafeSqlBinOp \u003ca\u003e = \u003c/a\u003e\n\u003c/pre\u003e\u003cp\u003eIn the example above, we constraint the arguments to be of the\n same type and constraint the result to be a boolean value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "Builder -\u003e SqlExpr (Value a) -\u003e SqlExpr (Value b) -\u003e SqlExpr (Value c)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#unsafeSqlBinOp",
        "fct-type": "function",
        "title": "unsafeSqlBinOp"
      },
      "index": {
        "description": "Internal Create custom binary operator You should not use this function directly since its type is very general you should always use it with an explicit type signature For example SqlExpr Value SqlExpr Value SqlExpr Value Bool unsafeSqlBinOp In the example above we constraint the arguments to be of the same type and constraint the result to be boolean value",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "unsafeSqlBinOp",
        "normalized": "Builder-\u003eSqlExpr(Value a)-\u003eSqlExpr(Value b)-\u003eSqlExpr(Value c)",
        "package": "esqueleto",
        "partial": "Sql Bin Op",
        "signature": "Builder-\u003eSqlExpr(Value a)-\u003eSqlExpr(Value b)-\u003eSqlExpr(Value c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:unsafeSqlFunction",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) A raw SQL function.  Once again, the same warning\n from \u003ccode\u003e\u003ca\u003eunsafeSqlBinOp\u003c/a\u003e\u003c/code\u003e applies to this function as well.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "Builder -\u003e a -\u003e SqlExpr (Value b)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#unsafeSqlFunction",
        "fct-type": "function",
        "title": "unsafeSqlFunction"
      },
      "index": {
        "description": "Internal raw SQL function Once again the same warning from unsafeSqlBinOp applies to this function as well",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "unsafeSqlFunction",
        "normalized": "Builder-\u003ea-\u003eSqlExpr(Value b)",
        "package": "esqueleto",
        "partial": "Sql Function",
        "signature": "Builder-\u003ea-\u003eSqlExpr(Value b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:unsafeSqlValue",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) A raw SQL value.  The same warning from\n \u003ccode\u003e\u003ca\u003eunsafeSqlBinOp\u003c/a\u003e\u003c/code\u003e applies to this function as well.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "Builder -\u003e SqlExpr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#unsafeSqlValue",
        "fct-type": "function",
        "title": "unsafeSqlValue"
      },
      "index": {
        "description": "Internal raw SQL value The same warning from unsafeSqlBinOp applies to this function as well",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "unsafeSqlValue",
        "normalized": "Builder-\u003eSqlExpr(Value a)",
        "package": "esqueleto",
        "partial": "Sql Value",
        "signature": "Builder-\u003eSqlExpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:update",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eUPDATE\u003c/code\u003e query inside \u003ccode\u003epersistent\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad.  Note that currently there are no type\n checks for statements that should not appear on a \u003ccode\u003eUPDATE\u003c/code\u003e\n query.\n\u003c/p\u003e\u003cp\u003eExample of usage:\n\u003c/p\u003e\u003cpre\u003e\n update $ p -\u003e do\n set p [ PersonAge =. just (val thisYear) -. p ^. PersonBorn ]\n where_ $ isNull (p ^. PersonAge)\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "(SqlExpr (Entity val) -\u003e SqlQuery ()) -\u003e SqlPersistT m ()",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#update",
        "fct-type": "function",
        "title": "update"
      },
      "index": {
        "description": "Execute an esqueleto UPDATE query inside persistent SqlPersistT monad Note that currently there are no type checks for statements that should not appear on UPDATE query Example of usage update do set PersonAge just val thisYear PersonBorn where isNull PersonAge",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "update",
        "normalized": "(SqlExpr(Entity a)-\u003eSqlQuery())-\u003eSqlPersistT b()",
        "package": "esqueleto",
        "partial": "",
        "signature": "(SqlExpr(Entity val)-\u003eSqlQuery())-\u003eSqlPersistT m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:updateCount",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e, but returns the number of rows affected.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "(SqlExpr (Entity val) -\u003e SqlQuery ()) -\u003e SqlPersistT m Int64",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#updateCount",
        "fct-type": "function",
        "title": "updateCount"
      },
      "index": {
        "description": "Same as update but returns the number of rows affected",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "updateCount",
        "normalized": "(SqlExpr(Entity a)-\u003eSqlQuery())-\u003eSqlPersistT b Int",
        "package": "esqueleto",
        "partial": "Count",
        "signature": "(SqlExpr(Entity val)-\u003eSqlQuery())-\u003eSqlPersistT m Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto-Internal-Sql.html#v:veryUnsafeCoerceSqlExprValue",
      "description": {
        "fct-descr": "\u003cp\u003e(Internal) Coerce a value's type from 'SqlExpr (Value a)' to\n 'SqlExpr (Value b)'.  You should \u003cem\u003enot\u003c/em\u003e use this function\n unless you know what you're doing!\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto.Internal.Sql",
        "fct-package": "esqueleto",
        "fct-signature": "SqlExpr (Value a) -\u003e SqlExpr (Value b)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#veryUnsafeCoerceSqlExprValue",
        "fct-type": "function",
        "title": "veryUnsafeCoerceSqlExprValue"
      },
      "index": {
        "description": "Internal Coerce value type from SqlExpr Value to SqlExpr Value You should not use this function unless you know what you re doing",
        "hierarchy": "Database Esqueleto Internal Sql",
        "module": "Database.Esqueleto.Internal.Sql",
        "name": "veryUnsafeCoerceSqlExprValue",
        "normalized": "SqlExpr(Value a)-\u003eSqlExpr(Value b)",
        "package": "esqueleto",
        "partial": "Unsafe Coerce Sql Expr Value",
        "signature": "SqlExpr(Value a)-\u003eSqlExpr(Value b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003eesqueleto\u003c/code\u003e EDSL (embedded domain specific language).\n This module replaces \u003ccode\u003eDatabase.Persist\u003c/code\u003e, so instead of\n importing that module you should just import this one:\n\u003c/p\u003e\u003cpre\u003e\n -- For a module using just esqueleto.\n import Database.Esqueleto\n\u003c/pre\u003e\u003cp\u003eIf you need to use \u003ccode\u003epersistent\u003c/code\u003e's default support for queries\n as well, either import it qualified:\n\u003c/p\u003e\u003cpre\u003e\n -- For a module that mostly uses esqueleto.\n import Database.Esqueleto\n import qualified Database.Persistent as P\n\u003c/pre\u003e\u003cp\u003eor import \u003ccode\u003eesqueleto\u003c/code\u003e itself qualified:\n\u003c/p\u003e\u003cpre\u003e\n -- For a module uses esqueleto just on some queries.\n import Database.Persistent\n import qualified Database.Esqueleto as E\n\u003c/pre\u003e\u003cp\u003eOther than identifier name clashes, \u003ccode\u003eesqueleto\u003c/code\u003e does not\n conflict with \u003ccode\u003epersistent\u003c/code\u003e in any way.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "module",
        "fct-source": "src/Database-Esqueleto.html",
        "fct-type": "module",
        "title": "Esqueleto"
      },
      "index": {
        "description": "The esqueleto EDSL embedded domain specific language This module replaces Database.Persist so instead of importing that module you should just import this one For module using just esqueleto import Database.Esqueleto If you need to use persistent default support for queries as well either import it qualified For module that mostly uses esqueleto import Database.Esqueleto import qualified Database.Persistent as or import esqueleto itself qualified For module uses esqueleto just on some queries import Database.Persistent import qualified Database.Esqueleto as Other than identifier name clashes esqueleto does not conflict with persistent in any way",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "Esqueleto",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Esqueleto",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:CrossJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents a \u003ccode\u003eCROSS JOIN\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e for an example).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#CrossJoin",
        "fct-type": "data",
        "title": "CrossJoin"
      },
      "index": {
        "description": "Data type that represents CROSS JOIN see LeftOuterJoin for an example",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "CrossJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Cross Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:Esqueleto",
      "description": {
        "fct-descr": "\u003cp\u003eFinally tagless representation of \u003ccode\u003eesqueleto\u003c/code\u003e's EDSL.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "class",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#Esqueleto",
        "fct-type": "class",
        "title": "Esqueleto"
      },
      "index": {
        "description": "Finally tagless representation of esqueleto EDSL",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "Esqueleto",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Esqueleto",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:FullOuterJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents a \u003ccode\u003eFULL OUTER JOIN\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e for an example).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#FullOuterJoin",
        "fct-type": "data",
        "title": "FullOuterJoin"
      },
      "index": {
        "description": "Data type that represents FULL OUTER JOIN see LeftOuterJoin for an example",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "FullOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Full Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:InnerJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents an \u003ccode\u003eINNER JOIN\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e for an example).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#InnerJoin",
        "fct-type": "data",
        "title": "InnerJoin"
      },
      "index": {
        "description": "Data type that represents an INNER JOIN see LeftOuterJoin for an example",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "InnerJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Inner Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:LeftOuterJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents a \u003ccode\u003eLEFT OUTER JOIN\u003c/code\u003e. For example,\n\u003c/p\u003e\u003cpre\u003e\n select $\n from $ \\(person `\u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e` pet) -\u003e\n   ...\n\u003c/pre\u003e\u003cp\u003eis translated into\n\u003c/p\u003e\u003cpre\u003e\n SELECT ...\n FROM Person LEFT OUTER JOIN Pet\n ...\n\u003c/pre\u003e\u003cp\u003eSee also: \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#LeftOuterJoin",
        "fct-type": "data",
        "title": "LeftOuterJoin"
      },
      "index": {
        "description": "Data type that represents LEFT OUTER JOIN For example select from person LeftOuterJoin pet is translated into SELECT FROM Person LEFT OUTER JOIN Pet See also from",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "LeftOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Left Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:OnClauseWithoutMatchingJoinException",
      "description": {
        "fct-descr": "\u003cp\u003eException thrown whenever \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003e is used to create an \u003ccode\u003eON\u003c/code\u003e\n clause but no matching \u003ccode\u003eJOIN\u003c/code\u003e is found.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#OnClauseWithoutMatchingJoinException",
        "fct-type": "data",
        "title": "OnClauseWithoutMatchingJoinException"
      },
      "index": {
        "description": "Exception thrown whenever on is used to create an ON clause but no matching JOIN is found",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "OnClauseWithoutMatchingJoinException",
        "normalized": "",
        "package": "esqueleto",
        "partial": "On Clause Without Matching Join Exception",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:OrderBy",
      "description": {
        "fct-descr": "\u003cp\u003ePhantom type used by \u003ccode\u003e\u003ca\u003eorderBy\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003easc\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edesc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#OrderBy",
        "fct-type": "data",
        "title": "OrderBy"
      },
      "index": {
        "description": "Phantom type used by orderBy asc and desc",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "OrderBy",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Order By",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:RightOuterJoin",
      "description": {
        "fct-descr": "\u003cp\u003eData type that represents a \u003ccode\u003eRIGHT OUTER JOIN\u003c/code\u003e (see \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e for an example).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#RightOuterJoin",
        "fct-type": "data",
        "title": "RightOuterJoin"
      },
      "index": {
        "description": "Data type that represents RIGHT OUTER JOIN see LeftOuterJoin for an example",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "RightOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Right Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:SqlEntity",
      "description": {
        "fct-descr": "\u003cp\u003eConstraint synonym for \u003ccode\u003epersistent\u003c/code\u003e entities whose backend\n is \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "type",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#SqlEntity",
        "fct-type": "type",
        "title": "SqlEntity"
      },
      "index": {
        "description": "Constraint synonym for persistent entities whose backend is SqlPersistT",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "SqlEntity",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Sql Entity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:SqlExpr",
      "description": {
        "fct-descr": "\u003cp\u003eAn expression on the SQL backend.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#SqlExpr",
        "fct-type": "data",
        "title": "SqlExpr"
      },
      "index": {
        "description": "An expression on the SQL backend",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "SqlExpr",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Sql Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:SqlQuery",
      "description": {
        "fct-descr": "\u003cp\u003eSQL backend for \u003ccode\u003eesqueleto\u003c/code\u003e using \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#SqlQuery",
        "fct-type": "data",
        "title": "SqlQuery"
      },
      "index": {
        "description": "SQL backend for esqueleto using SqlPersistT",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "SqlQuery",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Sql Query",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:Value",
      "description": {
        "fct-descr": "\u003cp\u003eA single value (as opposed to a whole entity).  You may use\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e or \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e?.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e to get a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e from an \u003ccode\u003e\u003ca\u003eEntity\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#Value",
        "fct-type": "data",
        "title": "Value"
      },
      "index": {
        "description": "single value as opposed to whole entity You may use or to get Value from an Entity",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "Value",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#t:ValueList",
      "description": {
        "fct-descr": "\u003cp\u003eA list of single values.  There's a limited set of funcitons\n able to work with this data type (such as \u003ccode\u003e\u003ca\u003esubList_select\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003evalList\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ein_\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eexists\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "data",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#ValueList",
        "fct-type": "data",
        "title": "ValueList"
      },
      "index": {
        "description": "list of single values There limited set of funcitons able to work with this data type such as subList select valList in and exists",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "ValueList",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Value List",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-124--124-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e expr (Value Bool) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%7C%7C.",
        "fct-type": "method",
        "title": "(||.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(||.) ||.",
        "normalized": "a(Value Bool)-\u003ea(Value Bool)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003eexpr(Value Bool)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-33--61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%21%3D.",
        "fct-type": "method",
        "title": "(!=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(!=.) !=.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-37-",
      "description": {
        "fct-descr": "\u003cp\u003eThe string \u003ccode\u003e\u003ccode\u003e\u003ca\u003e%\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.  May be useful while using \u003ccode\u003e\u003ca\u003elike\u003c/a\u003e\u003c/code\u003e and\n concatenation (\u003ccode\u003e\u003ca\u003econcat_\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003e++.\u003c/a\u003e\u003c/code\u003e, depending on your\n database).  Note that you always to type the parenthesis,\n for example:\n\u003c/p\u003e\u003cpre\u003e\n name ``'like'`` (%) ++. val \u003ca\u003eJohn\u003c/a\u003e ++. (%)\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value s)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%25",
        "fct-type": "method",
        "title": "(%)"
      },
      "index": {
        "description": "The string May be useful while using like and concatenation concat or depending on your database Note that you always to type the parenthesis for example name like val John",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(%) %",
        "normalized": "",
        "package": "esqueleto",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-38--38-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e expr (Value Bool) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%26%26.",
        "fct-type": "method",
        "title": "(&&.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(&&.) &&.",
        "normalized": "a(Value Bool)-\u003ea(Value Bool)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003eexpr(Value Bool)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-42--61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val a -\u003e expr (Value a) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2A%3D.",
        "fct-type": "method",
        "title": "(*=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(*=.) *=.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val a-\u003eexpr(Value a)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-42-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value a) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2A.",
        "fct-type": "method",
        "title": "(*.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(*.) *.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value a)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-43--43-.",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e||\u003c/code\u003e string concatenation operator (named after\n Haskell's \u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003e in order to avoid naming clash with \u003ccode\u003e\u003ca\u003e||.\u003c/a\u003e\u003c/code\u003e).\n Supported by SQLite and PostgreSQL.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value s) -\u003e expr (Value s) -\u003e expr (Value s)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2B%2B.",
        "fct-type": "method",
        "title": "(++.)"
      },
      "index": {
        "description": "The string concatenation operator named after Haskell in order to avoid naming clash with Supported by SQLite and PostgreSQL",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(++.) ++.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value s)-\u003eexpr(Value s)-\u003eexpr(Value s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-43--61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val a -\u003e expr (Value a) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2B%3D.",
        "fct-type": "method",
        "title": "(+=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(+=.) +=.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val a-\u003eexpr(Value a)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-43-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value a) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2B.",
        "fct-type": "method",
        "title": "(+.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(+.) +.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value a)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-45--61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val a -\u003e expr (Value a) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#-%3D.",
        "fct-type": "method",
        "title": "(-=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(-=.) -=.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val a-\u003eexpr(Value a)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-45-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value a) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#-.",
        "fct-type": "method",
        "title": "(-.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(-.) -.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value a)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-47--61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val a -\u003e expr (Value a) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2F%3D.",
        "fct-type": "method",
        "title": "(/=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(/=.) /=.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val a-\u003eexpr(Value a)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-47-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value a) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%2F.",
        "fct-type": "method",
        "title": "(/.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(/.) /.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value a)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-60--35-",
      "description": {
        "fct-descr": "\u003cp\u003eApply a \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e constructor to \u003ccode\u003eexpr Value\u003c/code\u003e arguments.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "(a -\u003e b) -\u003e expr (Value a) -\u003e expr (Insertion b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3C%23",
        "fct-type": "method",
        "title": "(\u003c#)"
      },
      "index": {
        "description": "Apply PersistField constructor to expr Value arguments",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(\u003c#) \u003c#",
        "normalized": "(a-\u003eb)-\u003ec(Value a)-\u003ec(Insertion b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eexpr(Value a)-\u003eexpr(Insertion b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-60--38--62-",
      "description": {
        "fct-descr": "\u003cp\u003eApply extra \u003ccode\u003eexpr Value\u003c/code\u003e arguments to a \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e constructor\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Insertion (a -\u003e b)) -\u003e expr (Value a) -\u003e expr (Insertion b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3C%26%3E",
        "fct-type": "method",
        "title": "(\u003c&\u003e)"
      },
      "index": {
        "description": "Apply extra expr Value arguments to PersistField constructor",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(\u003c&\u003e) \u003c&\u003e",
        "normalized": "a(Insertion(b-\u003ec))-\u003ea(Value b)-\u003ea(Insertion c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Insertion(a-\u003eb))-\u003eexpr(Value a)-\u003eexpr(Insertion b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-60--61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3C%3D.",
        "fct-type": "method",
        "title": "(\u003c=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(\u003c=.) \u003c=.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-60-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3C.",
        "fct-type": "method",
        "title": "(\u003c.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(\u003c.) \u003c.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-61--61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3D%3D.",
        "fct-type": "method",
        "title": "(==.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(==.) ==.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "EntityField val typ -\u003e expr (Value typ) -\u003e expr (Update val)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3D.",
        "fct-type": "method",
        "title": "(=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(=.) =.",
        "normalized": "EntityField a b-\u003ec(Value b)-\u003ec(Update a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "EntityField val typ-\u003eexpr(Value typ)-\u003eexpr(Update val)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-62--61-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3E%3D.",
        "fct-type": "method",
        "title": "(\u003e=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(\u003e=.) \u003e=.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-62-.",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3E.",
        "fct-type": "method",
        "title": "(\u003e.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(\u003e.) \u003e.",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-63-.",
      "description": {
        "fct-descr": "\u003cp\u003eProject a field of an entity that may be null.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Maybe (Entity val)) -\u003e EntityField val typ -\u003e expr (Value (Maybe typ))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%3F.",
        "fct-type": "method",
        "title": "(?.)"
      },
      "index": {
        "description": "Project field of an entity that may be null",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(?.) ?.",
        "normalized": "a(Maybe(Entity b))-\u003eEntityField b c-\u003ea(Value(Maybe c))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Maybe(Entity val))-\u003eEntityField val typ-\u003eexpr(Value(Maybe typ))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:-94-.",
      "description": {
        "fct-descr": "\u003cp\u003eProject a field of an entity.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Entity val) -\u003e EntityField val typ -\u003e expr (Value typ)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#%5E.",
        "fct-type": "method",
        "title": "(^.)"
      },
      "index": {
        "description": "Project field of an entity",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "(^.) ^.",
        "normalized": "a(Entity b)-\u003eEntityField b c-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Entity val)-\u003eEntityField val typ-\u003eexpr(Value typ)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:CrossJoin",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "a CrossJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#CrossJoin",
        "fct-type": "function",
        "title": "CrossJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "CrossJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Cross Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:FullOuterJoin",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "a FullOuterJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#FullOuterJoin",
        "fct-type": "function",
        "title": "FullOuterJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "FullOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Full Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:InnerJoin",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "a InnerJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#InnerJoin",
        "fct-type": "function",
        "title": "InnerJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "InnerJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Inner Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:LeftOuterJoin",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "a LeftOuterJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#LeftOuterJoin",
        "fct-type": "function",
        "title": "LeftOuterJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "LeftOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Left Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:OnClauseWithoutMatchingJoinException",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "OnClauseWithoutMatchingJoinException String",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#OnClauseWithoutMatchingJoinException",
        "fct-type": "function",
        "title": "OnClauseWithoutMatchingJoinException"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "OnClauseWithoutMatchingJoinException",
        "normalized": "",
        "package": "esqueleto",
        "partial": "On Clause Without Matching Join Exception",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:RightOuterJoin",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "a RightOuterJoin b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#RightOuterJoin",
        "fct-type": "function",
        "title": "RightOuterJoin"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "RightOuterJoin",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Right Outer Join",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:Value",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "Value a",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#Value",
        "fct-type": "function",
        "title": "Value"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "Value",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:ValueList",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "ValueList a",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#ValueList",
        "fct-type": "function",
        "title": "ValueList"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "ValueList",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Value List",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:asc",
      "description": {
        "fct-descr": "\u003cp\u003eAscending order of this field or expression.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr OrderBy",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#asc",
        "fct-type": "method",
        "title": "asc"
      },
      "index": {
        "description": "Ascending order of this field or expression",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "asc",
        "normalized": "a(Value b)-\u003ea OrderBy",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr OrderBy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:avg_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value (Maybe b))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#avg_",
        "fct-type": "method",
        "title": "avg_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "avg_",
        "normalized": "a(Value b)-\u003ea(Value(Maybe c))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value(Maybe b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:ceiling_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#ceiling_",
        "fct-type": "method",
        "title": "ceiling_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "ceiling_",
        "normalized": "a(Value b)-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:concat_",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003eCONCAT\u003c/code\u003e function with a variable number of\n parameters.  Supported by MySQL and PostgreSQL.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "[expr (Value s)] -\u003e expr (Value s)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#concat_",
        "fct-type": "method",
        "title": "concat_"
      },
      "index": {
        "description": "The CONCAT function with variable number of parameters Supported by MySQL and PostgreSQL",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "concat_",
        "normalized": "[a(Value b)]-\u003ea(Value b)",
        "package": "esqueleto",
        "partial": "",
        "signature": "[expr(Value s)]-\u003eexpr(Value s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:count",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eCOUNT\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#count",
        "fct-type": "method",
        "title": "count"
      },
      "index": {
        "description": "COUNT",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "count",
        "normalized": "a(Value b)-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:countRows",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eCOUNT(*)\u003c/code\u003e value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#countRows",
        "fct-type": "method",
        "title": "countRows"
      },
      "index": {
        "description": "COUNT value",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "countRows",
        "normalized": "",
        "package": "esqueleto",
        "partial": "Rows",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:delete",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eDELETE\u003c/code\u003e query inside \u003ccode\u003epersistent\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad.  Note that currently there are no type\n checks for statements that should not appear on a \u003ccode\u003eDELETE\u003c/code\u003e\n query.\n\u003c/p\u003e\u003cp\u003eExample of usage:\n\u003c/p\u003e\u003cpre\u003e\n delete $\n from $ \\appointment -\u003e\n where_ (appointment ^. AppointmentDate \u003c. val now)\n\u003c/pre\u003e\u003cp\u003eUnlike \u003ccode\u003e\u003ca\u003eselect\u003c/a\u003e\u003c/code\u003e, there is a useful way of using \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e that\n will lead to type ambiguities.  If you want to delete all rows\n (i.e., no \u003ccode\u003e\u003ca\u003ewhere_\u003c/a\u003e\u003c/code\u003e clause), you'll have to use a type signature:\n\u003c/p\u003e\u003cpre\u003e\n delete $\n from $ \\(appointment :: SqlExpr (Entity Appointment)) -\u003e\n return ()\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery () -\u003e SqlPersistT m ()",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#delete",
        "fct-type": "function",
        "title": "delete"
      },
      "index": {
        "description": "Execute an esqueleto DELETE query inside persistent SqlPersistT monad Note that currently there are no type checks for statements that should not appear on DELETE query Example of usage delete from appointment where appointment AppointmentDate val now Unlike select there is useful way of using delete that will lead to type ambiguities If you want to delete all rows i.e no where clause you ll have to use type signature delete from appointment SqlExpr Entity Appointment return",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "delete",
        "normalized": "SqlQuery()-\u003eSqlPersistT a()",
        "package": "esqueleto",
        "partial": "",
        "signature": "SqlQuery()-\u003eSqlPersistT m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:deleteCount",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e, but returns the number of rows affected.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery () -\u003e SqlPersistT m Int64",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#deleteCount",
        "fct-type": "function",
        "title": "deleteCount"
      },
      "index": {
        "description": "Same as delete but returns the number of rows affected",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "deleteCount",
        "normalized": "SqlQuery()-\u003eSqlPersistT a Int",
        "package": "esqueleto",
        "partial": "Count",
        "signature": "SqlQuery()-\u003eSqlPersistT m Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:deleteKey",
      "description": {
        "fct-descr": "\u003cp\u003eSynonym for \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e that does not\n clash with \u003ccode\u003eesqueleto\u003c/code\u003e's \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "Key val -\u003e m ()",
        "fct-source": "src/Database-Esqueleto.html#deleteKey",
        "fct-type": "function",
        "title": "deleteKey"
      },
      "index": {
        "description": "Synonym for delete that does not clash with esqueleto delete",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "deleteKey",
        "normalized": "Key a-\u003eb()",
        "package": "esqueleto",
        "partial": "Key",
        "signature": "Key val-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:desc",
      "description": {
        "fct-descr": "\u003cp\u003eDescending order of this field or expression.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr OrderBy",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#desc",
        "fct-type": "method",
        "title": "desc"
      },
      "index": {
        "description": "Descending order of this field or expression",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "desc",
        "normalized": "a(Value b)-\u003ea OrderBy",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr OrderBy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:exists",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eEXISTS\u003c/code\u003e operator.  For example:\n\u003c/p\u003e\u003cpre\u003e\n select $\n from $ \\person -\u003e do\n where_ $ exists $\n          from $ \\post -\u003e do\n          where_ (post ^. BlogPostAuthorId ==. person ^. PersonId)\n return person\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "query () -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#exists",
        "fct-type": "method",
        "title": "exists"
      },
      "index": {
        "description": "EXISTS operator For example select from person do where exists from post do where post BlogPostAuthorId person PersonId return person",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "exists",
        "normalized": "a()-\u003eb(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "query()-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:floor_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#floor_",
        "fct-type": "method",
        "title": "floor_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "floor_",
        "normalized": "a(Value b)-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:from",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eFROM\u003c/code\u003e clause: bring entities into scope.\n\u003c/p\u003e\u003cp\u003eThis function internally uses two type classes in order to\n provide some flexibility of how you may call it.  Internally\n we refer to these type classes as the two different magics.\n\u003c/p\u003e\u003cp\u003eThe innermost magic allows you to use \u003ccode\u003efrom\u003c/code\u003e with the\n following types:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eexpr (Entity val)\u003c/code\u003e, which brings a single entity into\n  scope.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eexpr (Maybe (Entity val))\u003c/code\u003e, which brings a single entity\n  that may be \u003ccode\u003eNULL\u003c/code\u003e into scope.  Used for \u003ccode\u003eOUTER JOIN\u003c/code\u003es.\n\u003c/li\u003e\u003cli\u003e A \u003ccode\u003eJOIN\u003c/code\u003e of any other two types allowed by the innermost\n  magic, where a \u003ccode\u003eJOIN\u003c/code\u003e may be an \u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e, a \u003ccode\u003e\u003ca\u003eCrossJoin\u003c/a\u003e\u003c/code\u003e, a\n  \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e, a \u003ccode\u003e\u003ca\u003eRightOuterJoin\u003c/a\u003e\u003c/code\u003e, or a \u003ccode\u003e\u003ca\u003eFullOuterJoin\u003c/a\u003e\u003c/code\u003e.\n  The \u003ccode\u003eJOINs\u003c/code\u003e have right fixity, the same as in SQL.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe outermost magic allows you to use \u003ccode\u003efrom\u003c/code\u003e on any tuples of\n types supported by innermost magic (and also tuples of tuples,\n and so on), up to 8-tuples.\n\u003c/p\u003e\u003cp\u003eNote that using \u003ccode\u003efrom\u003c/code\u003e for the same entity twice does work and\n corresponds to a self-join.  You don't even need to use two\n different calls to \u003ccode\u003efrom\u003c/code\u003e, you may use a \u003ccode\u003eJOIN\u003c/code\u003e or a tuple.\n\u003c/p\u003e\u003cp\u003eThe following are valid examples of uses of \u003ccode\u003efrom\u003c/code\u003e (the types\n of the arguments of the lambda are inside square brackets):\n\u003c/p\u003e\u003cpre\u003e\n from $ \\person -\u003e ...\n from $ \\(person, blogPost) -\u003e ...\n from $ \\(p `\u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e` mb) -\u003e ...\n from $ \\(p1 `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` f `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` p2) -\u003e ...\n from $ \\((p1 `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` f) `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` p2) -\u003e ...\n\u003c/pre\u003e\u003cp\u003eThe types of the arguments to the lambdas above are,\n respectively:\n\u003c/p\u003e\u003cpre\u003e\n person\n   :: ( Esqueleto query expr backend\n      , PersistEntity Person\n      , PersistEntityBackend Person ~ backend\n      ) =\u003e expr (Entity Person)\n (person, blogPost)\n   :: (...) =\u003e (expr (Entity Person), expr (Entity BlogPost))\n (p `\u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e` mb)\n   :: (...) =\u003e InnerJoin (expr (Entity Person)) (expr (Maybe (Entity BlogPost)))\n (p1 `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` f `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` p2)\n   :: (...) =\u003e InnerJoin\n                 (expr (Entity Person))\n                 (InnerJoin (expr (Entity Follow))\n                            (expr (Entity Person)))\n ((p1 `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` f) `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` p2) ::\n   :: (...) =\u003e InnerJoin\n                 (InnerJoin (expr (Entity Person))\n                            (expr (Entity Follow)))\n                 (expr (Entity Person))\n\u003c/pre\u003e\u003cp\u003eNote that some backends may not support all kinds of \u003ccode\u003eJOIN\u003c/code\u003es.\n For example, when using the SQL backend with SQLite, it will\n not accept the last example above (which is associated to the\n left, instead of being to the right) and will not accept\n \u003ccode\u003e\u003ca\u003eRightOuterJoin\u003c/a\u003e\u003c/code\u003es or \u003ccode\u003e\u003ca\u003eFullOuterJoin\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "(a -\u003e query b) -\u003e query b",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#from",
        "fct-type": "function",
        "title": "from"
      },
      "index": {
        "description": "FROM clause bring entities into scope This function internally uses two type classes in order to provide some flexibility of how you may call it Internally we refer to these type classes as the two different magics The innermost magic allows you to use from with the following types expr Entity val which brings single entity into scope expr Maybe Entity val which brings single entity that may be NULL into scope Used for OUTER JOIN JOIN of any other two types allowed by the innermost magic where JOIN may be an InnerJoin CrossJoin LeftOuterJoin RightOuterJoin or FullOuterJoin The JOINs have right fixity the same as in SQL The outermost magic allows you to use from on any tuples of types supported by innermost magic and also tuples of tuples and so on up to tuples Note that using from for the same entity twice does work and corresponds to self-join You don even need to use two different calls to from you may use JOIN or tuple The following are valid examples of uses of from the types of the arguments of the lambda are inside square brackets from person from person blogPost from LeftOuterJoin mb from p1 InnerJoin InnerJoin p2 from p1 InnerJoin InnerJoin p2 The types of the arguments to the lambdas above are respectively person Esqueleto query expr backend PersistEntity Person PersistEntityBackend Person backend expr Entity Person person blogPost expr Entity Person expr Entity BlogPost LeftOuterJoin mb InnerJoin expr Entity Person expr Maybe Entity BlogPost p1 InnerJoin InnerJoin p2 InnerJoin expr Entity Person InnerJoin expr Entity Follow expr Entity Person p1 InnerJoin InnerJoin p2 InnerJoin InnerJoin expr Entity Person expr Entity Follow expr Entity Person Note that some backends may not support all kinds of JOIN For example when using the SQL backend with SQLite it will not accept the last example above which is associated to the left instead of being to the right and will not accept RightOuterJoin or FullOuterJoin",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "from",
        "normalized": "(a-\u003eb c)-\u003eb c",
        "package": "esqueleto",
        "partial": "",
        "signature": "(a-\u003equery b)-\u003equery b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:groupBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eGROUP BY\u003c/code\u003e clause. You can enclose multiple columns\n in a tuple.\n\u003c/p\u003e\u003cpre\u003e\n select $ from \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar) -\u003e do\n   on (foo ^. FooBarId ==. bar ^. BarId)\n   groupBy (bar ^. BarId, bar ^. BarName)\n   return (bar ^. BarId, bar ^. BarName, countRows)\n\u003c/pre\u003e\u003cp\u003eWith groupBy you can sort by aggregate functions, like so (we\n used \u003ccode\u003elet\u003c/code\u003e to restrict the more general \u003ccode\u003e\u003ca\u003ecountRows\u003c/a\u003e\u003c/code\u003e to\n \u003ccode\u003eSqlExpr (Value Int)\u003c/code\u003e to avoid ambiguity):\n\u003c/p\u003e\u003cpre\u003e\n r \u003c- select $ from \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar) -\u003e do\n   on (foo ^. FooBarId ==. bar ^. BarId)\n   groupBy $ bar ^. BarName\n   let countRows' = countRows\n   orderBy [asc countRows']\n   return (bar ^. BarName, countRows')\n forM_ r $ \\((Value name), (Value count)) -\u003e do\n   print name\n   print (count :: Int)\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "a -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#groupBy",
        "fct-type": "method",
        "title": "groupBy"
      },
      "index": {
        "description": "GROUP BY clause You can enclose multiple columns in tuple select from foo InnerJoin bar do on foo FooBarId bar BarId groupBy bar BarId bar BarName return bar BarId bar BarName countRows With groupBy you can sort by aggregate functions like so we used let to restrict the more general countRows to SqlExpr Value Int to avoid ambiguity select from foo InnerJoin bar do on foo FooBarId bar BarId groupBy bar BarName let countRows countRows orderBy asc countRows return bar BarName countRows forM Value name Value count do print name print count Int",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "groupBy",
        "normalized": "a-\u003eb()",
        "package": "esqueleto",
        "partial": "By",
        "signature": "a-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:having",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eHAVING\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eSince: 1.2.2\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#having",
        "fct-type": "method",
        "title": "having"
      },
      "index": {
        "description": "HAVING Since",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "having",
        "normalized": "a(Value Bool)-\u003eb()",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:in_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eIN\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (ValueList typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#in_",
        "fct-type": "method",
        "title": "in_"
      },
      "index": {
        "description": "IN operator",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "in_",
        "normalized": "a(Value b)-\u003ea(ValueList b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(ValueList typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:insertSelect",
      "description": {
        "fct-descr": "\u003cp\u003eInsert a \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e for every selected value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery (SqlExpr (Insertion a)) -\u003e SqlPersistT m ()",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#insertSelect",
        "fct-type": "function",
        "title": "insertSelect"
      },
      "index": {
        "description": "Insert PersistField for every selected value",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "insertSelect",
        "normalized": "SqlQuery(SqlExpr(Insertion a))-\u003eSqlPersistT b()",
        "package": "esqueleto",
        "partial": "Select",
        "signature": "SqlQuery(SqlExpr(Insertion a))-\u003eSqlPersistT m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:insertSelectDistinct",
      "description": {
        "fct-descr": "\u003cp\u003eInsert a \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e for every unique selected value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery (SqlExpr (Insertion a)) -\u003e SqlPersistT m ()",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#insertSelectDistinct",
        "fct-type": "function",
        "title": "insertSelectDistinct"
      },
      "index": {
        "description": "Insert PersistField for every unique selected value",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "insertSelectDistinct",
        "normalized": "SqlQuery(SqlExpr(Insertion a))-\u003eSqlPersistT b()",
        "package": "esqueleto",
        "partial": "Select Distinct",
        "signature": "SqlQuery(SqlExpr(Insertion a))-\u003eSqlPersistT m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:isNothing",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eIS NULL\u003c/code\u003e comparison.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value (Maybe typ)) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#isNothing",
        "fct-type": "method",
        "title": "isNothing"
      },
      "index": {
        "description": "IS NULL comparison",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "isNothing",
        "normalized": "a(Value(Maybe b))-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "Nothing",
        "signature": "expr(Value(Maybe typ))-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:joinV",
      "description": {
        "fct-descr": "\u003cp\u003eJoin nested \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003es in a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e into one. This is useful when\n calling aggregate functions on nullable fields.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value (Maybe (Maybe typ))) -\u003e expr (Value (Maybe typ))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#joinV",
        "fct-type": "method",
        "title": "joinV"
      },
      "index": {
        "description": "Join nested Maybe in Value into one This is useful when calling aggregate functions on nullable fields",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "joinV",
        "normalized": "a(Value(Maybe(Maybe b)))-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value(Maybe(Maybe typ)))-\u003eexpr(Value(Maybe typ))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:just",
      "description": {
        "fct-descr": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e, promotes a value of type \u003ccode\u003etyp\u003c/code\u003e into\n one of type \u003ccode\u003eMaybe typ\u003c/code\u003e.  It should hold that \u003ccode\u003eval . Just\n === just . val\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (Value (Maybe typ))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#just",
        "fct-type": "method",
        "title": "just"
      },
      "index": {
        "description": "Analogous to Just promotes value of type typ into one of type Maybe typ It should hold that val Just just val",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "just",
        "normalized": "a(Value b)-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value typ)-\u003eexpr(Value(Maybe typ))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:like",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eLIKE\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value s) -\u003e expr (Value s) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#like",
        "fct-type": "method",
        "title": "like"
      },
      "index": {
        "description": "LIKE operator",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "like",
        "normalized": "a(Value b)-\u003ea(Value b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value s)-\u003eexpr(Value s)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:limit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eLIMIT\u003c/code\u003e.  Limit the number of returned rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "Int64 -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#limit",
        "fct-type": "method",
        "title": "limit"
      },
      "index": {
        "description": "LIMIT Limit the number of returned rows",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "limit",
        "normalized": "Int-\u003ea()",
        "package": "esqueleto",
        "partial": "",
        "signature": "Int-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:max_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value (Maybe a))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#max_",
        "fct-type": "method",
        "title": "max_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "max_",
        "normalized": "a(Value b)-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value(Maybe a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:min_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value (Maybe a))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#min_",
        "fct-type": "method",
        "title": "min_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "min_",
        "normalized": "a(Value b)-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value(Maybe a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:notExists",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eNOT EXISTS\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "query () -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#notExists",
        "fct-type": "method",
        "title": "notExists"
      },
      "index": {
        "description": "NOT EXISTS operator",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "notExists",
        "normalized": "a()-\u003eb(Value Bool)",
        "package": "esqueleto",
        "partial": "Exists",
        "signature": "query()-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:notIn",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eNOT IN\u003c/code\u003e operator.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value typ) -\u003e expr (ValueList typ) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#notIn",
        "fct-type": "method",
        "title": "notIn"
      },
      "index": {
        "description": "NOT IN operator",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "notIn",
        "normalized": "a(Value b)-\u003ea(ValueList b)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "In",
        "signature": "expr(Value typ)-\u003eexpr(ValueList typ)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:not_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e expr (Value Bool)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#not_",
        "fct-type": "method",
        "title": "not_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "not_",
        "normalized": "a(Value Bool)-\u003ea(Value Bool)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003eexpr(Value Bool)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:nothing",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eNULL\u003c/code\u003e value.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value (Maybe typ))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#nothing",
        "fct-type": "method",
        "title": "nothing"
      },
      "index": {
        "description": "NULL value",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "nothing",
        "normalized": "",
        "package": "esqueleto",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:offset",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eOFFSET\u003c/code\u003e.  Usually used with \u003ccode\u003e\u003ca\u003elimit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "Int64 -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#offset",
        "fct-type": "method",
        "title": "offset"
      },
      "index": {
        "description": "OFFSET Usually used with limit",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "offset",
        "normalized": "Int-\u003ea()",
        "package": "esqueleto",
        "partial": "",
        "signature": "Int-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:on",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eON\u003c/code\u003e clause: restrict the a \u003ccode\u003eJOIN\u003c/code\u003e's result.  The \u003ccode\u003eON\u003c/code\u003e\n clause will be applied to the \u003cem\u003elast\u003c/em\u003e \u003ccode\u003eJOIN\u003c/code\u003e that does not\n have an \u003ccode\u003eON\u003c/code\u003e clause yet.  If there are no \u003ccode\u003eJOIN\u003c/code\u003es without\n \u003ccode\u003eON\u003c/code\u003e clauses (either because you didn't do any \u003ccode\u003eJOIN\u003c/code\u003e, or\n because all \u003ccode\u003eJOIN\u003c/code\u003es already have their own \u003ccode\u003eON\u003c/code\u003e clauses), a\n runtime exception \u003ccode\u003e\u003ca\u003eOnClauseWithoutMatchingJoinException\u003c/a\u003e\u003c/code\u003e is\n thrown.  \u003ccode\u003eON\u003c/code\u003e clauses are optional when doing \u003ccode\u003eJOIN\u003c/code\u003es.\n\u003c/p\u003e\u003cp\u003eOn the simple case of doing just one \u003ccode\u003eJOIN\u003c/code\u003e, for example\n\u003c/p\u003e\u003cpre\u003e\n select $\n from $ \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar) -\u003e do\n   on (foo ^. FooId ==. bar ^. BarFooId)\n   ...\n\u003c/pre\u003e\u003cp\u003ethere's no ambiguity and the rules above just mean that\n you're allowed to call \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003e only once (as in SQL).  If you\n have many joins, then the \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003es are applied on the \u003cem\u003ereverse\u003c/em\u003e\n order that the \u003ccode\u003eJOIN\u003c/code\u003es appear.  For example:\n\u003c/p\u003e\u003cpre\u003e\n select $\n from $ \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` baz) -\u003e do\n   on (baz ^. BazId ==. bar ^. BarBazId)\n   on (foo ^. FooId ==. bar ^. BarFooId)\n   ...\n\u003c/pre\u003e\u003cp\u003eThe order is \u003cem\u003ereversed\u003c/em\u003e in order to improve composability.\n For example, consider \u003ccode\u003equery1\u003c/code\u003e and \u003ccode\u003equery2\u003c/code\u003e below:\n\u003c/p\u003e\u003cpre\u003e\n let query1 =\n       from $ \\(foo `\u003ccode\u003e\u003ca\u003eInnerJoin\u003c/a\u003e\u003c/code\u003e` bar) -\u003e do\n         on (foo ^. FooId ==. bar ^. BarFooId)\n     query2 =\n       from $ \\(mbaz `\u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e` quux) -\u003e do\n         return (mbaz ?. BazName, quux)\n     test1 =      (,) \u003c$\u003e query1 \u003c*\u003e query2\n     test2 = flip (,) \u003c$\u003e query2 \u003c*\u003e query1\n\u003c/pre\u003e\u003cp\u003eIf the order was \u003cem\u003enot\u003c/em\u003e reversed, then \u003ccode\u003etest2\u003c/code\u003e would be\n broken: \u003ccode\u003equery1\u003c/code\u003e's \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003e would refer to \u003ccode\u003equery2\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eLeftOuterJoin\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#on",
        "fct-type": "method",
        "title": "on"
      },
      "index": {
        "description": "ON clause restrict the JOIN result The ON clause will be applied to the last JOIN that does not have an ON clause yet If there are no JOIN without ON clauses either because you didn do any JOIN or because all JOIN already have their own ON clauses runtime exception OnClauseWithoutMatchingJoinException is thrown ON clauses are optional when doing JOIN On the simple case of doing just one JOIN for example select from foo InnerJoin bar do on foo FooId bar BarFooId there no ambiguity and the rules above just mean that you re allowed to call on only once as in SQL If you have many joins then the on are applied on the reverse order that the JOIN appear For example select from foo InnerJoin bar InnerJoin baz do on baz BazId bar BarBazId on foo FooId bar BarFooId The order is reversed in order to improve composability For example consider query1 and query2 below let query1 from foo InnerJoin bar do on foo FooId bar BarFooId query2 from mbaz LeftOuterJoin quux do return mbaz BazName quux test1 query1 query2 test2 flip query2 query1 If the order was not reversed then test2 would be broken query1 on would refer to query2 LeftOuterJoin",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "on",
        "normalized": "a(Value Bool)-\u003eb()",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:orderBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eORDER BY\u003c/code\u003e clause. See also \u003ccode\u003e\u003ca\u003easc\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edesc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "[expr OrderBy] -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#orderBy",
        "fct-type": "method",
        "title": "orderBy"
      },
      "index": {
        "description": "ORDER BY clause See also asc and desc",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "orderBy",
        "normalized": "[a OrderBy]-\u003eb()",
        "package": "esqueleto",
        "partial": "By",
        "signature": "[expr OrderBy]-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:random_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#random_",
        "fct-type": "method",
        "title": "random_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "random_",
        "normalized": "",
        "package": "esqueleto",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:round_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value b)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#round_",
        "fct-type": "method",
        "title": "round_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "round_",
        "normalized": "a(Value b)-\u003ea(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:select",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT\u003c/code\u003e query inside \u003ccode\u003epersistent\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad and return a list of rows.\n\u003c/p\u003e\u003cp\u003eWe've seen that \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e has some magic about which kinds of\n things you may bring into scope.  This \u003ccode\u003e\u003ca\u003eselect\u003c/a\u003e\u003c/code\u003e function also\n has some magic for which kinds of things you may bring back to\n Haskell-land by using \u003ccode\u003eSqlQuery\u003c/code\u003e's \u003ccode\u003ereturn\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e You may return a \u003ccode\u003eSqlExpr (\u003ccode\u003e\u003ca\u003eEntity\u003c/a\u003e\u003c/code\u003e v)\u003c/code\u003e for an entity \u003ccode\u003ev\u003c/code\u003e\n  (i.e., like the \u003ccode\u003e*\u003c/code\u003e in SQL), which is then returned to\n  Haskell-land as just \u003ccode\u003eEntity v\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e You may return a \u003ccode\u003eSqlExpr (Maybe (Entity v))\u003c/code\u003e for an entity\n  \u003ccode\u003ev\u003c/code\u003e that may be \u003ccode\u003eNULL\u003c/code\u003e, which is then returned to\n  Haskell-land as \u003ccode\u003eMaybe (Entity v)\u003c/code\u003e.  Used for \u003ccode\u003eOUTER JOIN\u003c/code\u003es.\n\u003c/li\u003e\u003cli\u003e You may return a \u003ccode\u003eSqlExpr (\u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e t)\u003c/code\u003e for a value \u003ccode\u003et\u003c/code\u003e\n  (i.e., a single column), where \u003ccode\u003et\u003c/code\u003e is any instance of\n  \u003ccode\u003e\u003ca\u003ePersistField\u003c/a\u003e\u003c/code\u003e, which is then returned to Haskell-land as\n  \u003ccode\u003eValue t\u003c/code\u003e.  You may use \u003ccode\u003eValue\u003c/code\u003e to return projections of an\n  \u003ccode\u003eEntity\u003c/code\u003e (see \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e and \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e?.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e) or to return any other\n  value calculated on the query (e.g., \u003ccode\u003e\u003ca\u003ecountRows\u003c/a\u003e\u003c/code\u003e or\n  \u003ccode\u003e\u003ca\u003esub_select\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe \u003ccode\u003eSqlSelect a r\u003c/code\u003e class has functional dependencies that\n allow type information to flow both from \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003er\u003c/code\u003e and\n vice-versa.  This means that you'll almost never have to give\n any type signatures for \u003ccode\u003eesqueleto\u003c/code\u003e queries.  For example, the\n query \u003ccode\u003eselect $ from $ \\p -\u003e return p\u003c/code\u003e alone is ambiguous, but\n in the context of\n\u003c/p\u003e\u003cpre\u003e\n do ps \u003c- select $\n          from $ \\p -\u003e\n          return p\n    liftIO $ mapM_ (putStrLn . personName . entityVal) ps\n\u003c/pre\u003e\u003cp\u003ewe are able to infer from that single \u003ccode\u003epersonName . entityVal\u003c/code\u003e\n function composition that the \u003ccode\u003ep\u003c/code\u003e inside the query is of type\n \u003ccode\u003eSqlExpr (Entity Person)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery a -\u003e SqlPersistT m [r]",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#select",
        "fct-type": "function",
        "title": "select"
      },
      "index": {
        "description": "Execute an esqueleto SELECT query inside persistent SqlPersistT monad and return list of rows We ve seen that from has some magic about which kinds of things you may bring into scope This select function also has some magic for which kinds of things you may bring back to Haskell-land by using SqlQuery return You may return SqlExpr Entity for an entity i.e like the in SQL which is then returned to Haskell-land as just Entity You may return SqlExpr Maybe Entity for an entity that may be NULL which is then returned to Haskell-land as Maybe Entity Used for OUTER JOIN You may return SqlExpr Value for value i.e single column where is any instance of PersistField which is then returned to Haskell-land as Value You may use Value to return projections of an Entity see and or to return any other value calculated on the query e.g countRows or sub select The SqlSelect class has functional dependencies that allow type information to flow both from to and vice-versa This means that you ll almost never have to give any type signatures for esqueleto queries For example the query select from return alone is ambiguous but in the context of do ps select from return liftIO mapM putStrLn personName entityVal ps we are able to infer from that single personName entityVal function composition that the inside the query is of type SqlExpr Entity Person",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "select",
        "normalized": "SqlQuery a-\u003eSqlPersistT b[c]",
        "package": "esqueleto",
        "partial": "",
        "signature": "SqlQuery a-\u003eSqlPersistT m[r]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:selectDistinct",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e query inside\n \u003ccode\u003epersistent\u003c/code\u003e's \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad and return a list of rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery a -\u003e SqlPersistT m [r]",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#selectDistinct",
        "fct-type": "function",
        "title": "selectDistinct"
      },
      "index": {
        "description": "Execute an esqueleto SELECT DISTINCT query inside persistent SqlPersistT monad and return list of rows",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "selectDistinct",
        "normalized": "SqlQuery a-\u003eSqlPersistT b[c]",
        "package": "esqueleto",
        "partial": "Distinct",
        "signature": "SqlQuery a-\u003eSqlPersistT m[r]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:selectDistinctSource",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e query inside\n \u003ccode\u003epersistent\u003c/code\u003e's \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad and return a \u003ccode\u003e\u003ca\u003eSource\u003c/a\u003e\u003c/code\u003e of\n rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery a -\u003e SqlPersistT m (Source (ResourceT (SqlPersistT m)) r)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#selectDistinctSource",
        "fct-type": "function",
        "title": "selectDistinctSource"
      },
      "index": {
        "description": "Execute an esqueleto SELECT DISTINCT query inside persistent SqlPersistT monad and return Source of rows",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "selectDistinctSource",
        "normalized": "SqlQuery a-\u003eSqlPersistT b(Source(ResourceT(SqlPersistT b))c)",
        "package": "esqueleto",
        "partial": "Distinct Source",
        "signature": "SqlQuery a-\u003eSqlPersistT m(Source(ResourceT(SqlPersistT m))r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:selectSource",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eSELECT\u003c/code\u003e query inside \u003ccode\u003epersistent\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad and return a \u003ccode\u003e\u003ca\u003eSource\u003c/a\u003e\u003c/code\u003e of rows.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "SqlQuery a -\u003e SqlPersistT m (Source (ResourceT (SqlPersistT m)) r)",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#selectSource",
        "fct-type": "function",
        "title": "selectSource"
      },
      "index": {
        "description": "Execute an esqueleto SELECT query inside persistent SqlPersistT monad and return Source of rows",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "selectSource",
        "normalized": "SqlQuery a-\u003eSqlPersistT b(Source(ResourceT(SqlPersistT b))c)",
        "package": "esqueleto",
        "partial": "Source",
        "signature": "SqlQuery a-\u003eSqlPersistT m(Source(ResourceT(SqlPersistT m))r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eSET\u003c/code\u003e clause used on \u003ccode\u003eUPDATE\u003c/code\u003es.  Note that while it's not\n a type error to use this function on a \u003ccode\u003eSELECT\u003c/code\u003e, it will\n most certainly result in a runtime error.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Entity val) -\u003e [expr (Update val)] -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#set",
        "fct-type": "method",
        "title": "set"
      },
      "index": {
        "description": "SET clause used on UPDATE Note that while it not type error to use this function on SELECT it will most certainly result in runtime error",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "set",
        "normalized": "a(Entity b)-\u003e[a(Update b)]-\u003ec()",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Entity val)-\u003e[expr(Update val)]-\u003equery()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:subList_select",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a subquery \u003ccode\u003eSELECT\u003c/code\u003e in an expression.  Returns a\n list of values.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (Value a)) -\u003e expr (ValueList a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#subList_select",
        "fct-type": "method",
        "title": "subList_select"
      },
      "index": {
        "description": "Execute subquery SELECT in an expression Returns list of values",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "subList_select",
        "normalized": "a(b(Value c))-\u003eb(ValueList c)",
        "package": "esqueleto",
        "partial": "List",
        "signature": "query(expr(Value a))-\u003eexpr(ValueList a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:subList_selectDistinct",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003esublist_select\u003c/code\u003e but using \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (Value a)) -\u003e expr (ValueList a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#subList_selectDistinct",
        "fct-type": "method",
        "title": "subList_selectDistinct"
      },
      "index": {
        "description": "Same as sublist select but using SELECT DISTINCT",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "subList_selectDistinct",
        "normalized": "a(b(Value c))-\u003eb(ValueList c)",
        "package": "esqueleto",
        "partial": "List Distinct",
        "signature": "query(expr(Value a))-\u003eexpr(ValueList a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:sub_select",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a subquery \u003ccode\u003eSELECT\u003c/code\u003e in an expression.  Returns a\n simple value so should be used only when the \u003ccode\u003eSELECT\u003c/code\u003e query\n is guaranteed to return just one row.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (Value a)) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#sub_select",
        "fct-type": "method",
        "title": "sub_select"
      },
      "index": {
        "description": "Execute subquery SELECT in an expression Returns simple value so should be used only when the SELECT query is guaranteed to return just one row",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "sub_select",
        "normalized": "a(b(Value c))-\u003eb(Value c)",
        "package": "esqueleto",
        "partial": "",
        "signature": "query(expr(Value a))-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:sub_selectDistinct",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003esub_select\u003c/a\u003e\u003c/code\u003e but using \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "query (expr (Value a)) -\u003e expr (Value a)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#sub_selectDistinct",
        "fct-type": "method",
        "title": "sub_selectDistinct"
      },
      "index": {
        "description": "Same as sub select but using SELECT DISTINCT",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "sub_selectDistinct",
        "normalized": "a(b(Value c))-\u003eb(Value c)",
        "package": "esqueleto",
        "partial": "Distinct",
        "signature": "query(expr(Value a))-\u003eexpr(Value a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:sum_",
      "description": {
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value a) -\u003e expr (Value (Maybe a))",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#sum_",
        "fct-type": "method",
        "title": "sum_"
      },
      "index": {
        "description": "",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "sum_",
        "normalized": "a(Value b)-\u003ea(Value(Maybe b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value a)-\u003eexpr(Value(Maybe a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:update",
      "description": {
        "fct-descr": "\u003cp\u003eExecute an \u003ccode\u003eesqueleto\u003c/code\u003e \u003ccode\u003eUPDATE\u003c/code\u003e query inside \u003ccode\u003epersistent\u003c/code\u003e's\n \u003ccode\u003e\u003ca\u003eSqlPersistT\u003c/a\u003e\u003c/code\u003e monad.  Note that currently there are no type\n checks for statements that should not appear on a \u003ccode\u003eUPDATE\u003c/code\u003e\n query.\n\u003c/p\u003e\u003cp\u003eExample of usage:\n\u003c/p\u003e\u003cpre\u003e\n update $ p -\u003e do\n set p [ PersonAge =. just (val thisYear) -. p ^. PersonBorn ]\n where_ $ isNull (p ^. PersonAge)\n\u003c/pre\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "(SqlExpr (Entity val) -\u003e SqlQuery ()) -\u003e SqlPersistT m ()",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#update",
        "fct-type": "function",
        "title": "update"
      },
      "index": {
        "description": "Execute an esqueleto UPDATE query inside persistent SqlPersistT monad Note that currently there are no type checks for statements that should not appear on UPDATE query Example of usage update do set PersonAge just val thisYear PersonBorn where isNull PersonAge",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "update",
        "normalized": "(SqlExpr(Entity a)-\u003eSqlQuery())-\u003eSqlPersistT b()",
        "package": "esqueleto",
        "partial": "",
        "signature": "(SqlExpr(Entity val)-\u003eSqlQuery())-\u003eSqlPersistT m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:updateCount",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e, but returns the number of rows affected.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "(SqlExpr (Entity val) -\u003e SqlQuery ()) -\u003e SqlPersistT m Int64",
        "fct-source": "src/Database-Esqueleto-Internal-Sql.html#updateCount",
        "fct-type": "function",
        "title": "updateCount"
      },
      "index": {
        "description": "Same as update but returns the number of rows affected",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "updateCount",
        "normalized": "(SqlExpr(Entity a)-\u003eSqlQuery())-\u003eSqlPersistT b Int",
        "package": "esqueleto",
        "partial": "Count",
        "signature": "(SqlExpr(Entity val)-\u003eSqlQuery())-\u003eSqlPersistT m Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:val",
      "description": {
        "fct-descr": "\u003cp\u003eLift a constant value from Haskell-land to the query.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "typ -\u003e expr (Value typ)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#val",
        "fct-type": "method",
        "title": "val"
      },
      "index": {
        "description": "Lift constant value from Haskell-land to the query",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "val",
        "normalized": "a-\u003eb(Value a)",
        "package": "esqueleto",
        "partial": "",
        "signature": "typ-\u003eexpr(Value typ)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:valList",
      "description": {
        "fct-descr": "\u003cp\u003eLift a list of constant value from Haskell-land to the query.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "[typ] -\u003e expr (ValueList typ)",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#valList",
        "fct-type": "method",
        "title": "valList"
      },
      "index": {
        "description": "Lift list of constant value from Haskell-land to the query",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "valList",
        "normalized": "[a]-\u003eb(ValueList a)",
        "package": "esqueleto",
        "partial": "List",
        "signature": "[typ]-\u003eexpr(ValueList typ)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:valkey",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003evalkey i = val (Key (PersistInt64 i))\u003c/code\u003e\n (\u003ca\u003ehttps://github.com/meteficha/esqueleto/issues/9\u003c/a\u003e).\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "Int64 -\u003e expr (Value (Key entity))",
        "fct-source": "src/Database-Esqueleto.html#valkey",
        "fct-type": "function",
        "title": "valkey"
      },
      "index": {
        "description": "valkey val Key PersistInt64 https github.com meteficha esqueleto issues",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "valkey",
        "normalized": "Int-\u003ea(Value(Key b))",
        "package": "esqueleto",
        "partial": "",
        "signature": "Int-\u003eexpr(Value(Key entity))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/esqueleto/docs/Database-Esqueleto.html#v:where_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eWHERE\u003c/code\u003e clause: restrict the query's result.\n\u003c/p\u003e",
        "fct-module": "Database.Esqueleto",
        "fct-package": "esqueleto",
        "fct-signature": "expr (Value Bool) -\u003e query ()",
        "fct-source": "src/Database-Esqueleto-Internal-Language.html#where_",
        "fct-type": "method",
        "title": "where_"
      },
      "index": {
        "description": "WHERE clause restrict the query result",
        "hierarchy": "Database Esqueleto",
        "module": "Database.Esqueleto",
        "name": "where_",
        "normalized": "a(Value Bool)-\u003eb()",
        "package": "esqueleto",
        "partial": "",
        "signature": "expr(Value Bool)-\u003equery()"
      }
    }
  }
]
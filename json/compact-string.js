[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompactString specialized to ASCII.         Note that not all characters can be encoded in ASCII,         if encoding is not possible the function will raise an error..\n\u003c/p\u003e\u003cp\u003eThis module can be used to reduce the need for type signatures,\n since in most cases only a single encoding is used.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "module",
        "fct-source": "src/Data-CompactString-ASCII.html",
        "fct-type": "module",
        "title": "ASCII"
      },
      "index": {
        "description": "CompactString specialized to ASCII Note that not all characters can be encoded in ASCII if encoding is not possible the function will raise an error This module can be used to reduce the need for type signatures since in most cases only single encoding is used",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "ASCII",
        "normalized": "",
        "package": "compact-string",
        "partial": "ASCII",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#t:CompactString",
      "description": {
        "fct-descr": "\u003cp\u003eCompactString specialized to ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-ASCII.html#CompactString",
        "fct-type": "type",
        "title": "CompactString"
      },
      "index": {
        "description": "CompactString specialized to ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "CompactString",
        "normalized": "",
        "package": "compact-string",
        "partial": "Compact String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Applied to a predicate and a CompactString, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if\n all elements of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-ASCII.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Applied to predicate and CompactString any determines if all elements of the CompactString satisfy the predicate",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "all",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Applied to a predicate and a CompactString, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if\n any element of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-ASCII.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Applied to predicate and CompactString any determines if any element of the CompactString satisfies the predicate",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "any",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:append",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append two CompactStrings\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#append",
        "fct-type": "function",
        "title": "append"
      },
      "index": {
        "description": "Append two CompactStrings",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "append",
        "normalized": "CompactString-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:appendFile",
      "description": {
        "fct-descr": "\u003cp\u003eAppend a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#appendFile",
        "fct-type": "function",
        "title": "appendFile"
      },
      "index": {
        "description": "Append CompactString to file Files are written using ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "appendFile",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:appendFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eAppend a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eThe encoding of the file is determined based on a Byte Order Mark.\n   If the file is empty, it is written using ASCII with a Byte Order Mark.\n   If the encoding can not be determined the file is assumed to be UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#appendFile%27",
        "fct-type": "function",
        "title": "appendFile'"
      },
      "index": {
        "description": "Append CompactString to file The encoding of the file is determined based on Byte Order Mark If the file is empty it is written using ASCII with Byte Order Mark If the encoding can not be determined the file is assumed to be UTF-8",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "appendFile'",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . p)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "break is equivalent to span not",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "break",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:breakEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreakEnd\u003c/a\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e but from the end of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e breakEnd p == spanEnd (not.p)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#breakEnd",
        "fct-type": "function",
        "title": "breakEnd"
      },
      "index": {
        "description": "breakEnd behaves like break but from the end of the CompactString breakEnd spanEnd not.p",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "breakEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate a list of \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate list of CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "concat",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and concatenate the results\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e CompactString) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over CompactString and concatenate the results",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "concatMap",
        "normalized": "(Char-\u003eCompactString)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Map",
        "signature": "(Char-\u003eCompactString)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003econs\u003c/a\u003e\u003c/code\u003e is analogous to (:) for lists, but of different\n complexity, as it requires a memcpy.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "cons is analogous to for lists but of different complexity as it requires memcpy",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "cons",
        "normalized": "Char-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:count",
      "description": {
        "fct-descr": "\u003cp\u003ecount returns the number of times its argument appears in the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e count c = length . elemIndices c\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Int",
        "fct-source": "src/Data-CompactString-ASCII.html#count",
        "fct-type": "function",
        "title": "count"
      },
      "index": {
        "description": "count returns the number of times its argument appears in the CompactString count length elemIndices",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "count",
        "normalized": "Char-\u003eCompactString-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a ByteString to a CompactString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e decode e = recode =\u003c\u003c fromByteString\n\u003c/pre\u003e\u003cp\u003ebut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eFails if the ByteString is not a valid encoded string\n   or if the string can not be represented in ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "Decode ByteString to CompactString using the given encoding decode recode fromByteString but it might be faster for some combinations of encodings Fails if the ByteString is not valid encoded string or if the string can not be represented in ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "decode",
        "normalized": "a-\u003eByteString-\u003eb CompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:decodeBOM",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, by investigating the Byte Order Mark.\n   If there is no BOM assumes UTF-8.\n   Fails if the input is not a valid encoded string\n   or if the string can not be represented in ASCII.\n\u003c/p\u003e\u003cp\u003eFor portability, this function should be prefered over \u003ccode\u003edecode UTF8\u003c/code\u003e when reading files.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#decodeBOM",
        "fct-type": "function",
        "title": "decodeBOM"
      },
      "index": {
        "description": "Decode ByteString into CompactString by investigating the Byte Order Mark If there is no BOM assumes UTF-8 Fails if the input is not valid encoded string or if the string can not be represented in ASCII For portability this function should be prefered over decode UTF8 when reading files",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "decodeBOM",
        "normalized": "ByteString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "ByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:decodeBOM_",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, by investigating the Byte Order Mark.\n   If there is no BOM assumes UTF-8.\n   Raises an error if the input is not a valid encoded string\n   or if the string can not be represented in ASCII.\n\u003c/p\u003e\u003cp\u003eFor portability, this function should be prefered over \u003ccode\u003edecode UTF8\u003c/code\u003e when reading files.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#decodeBOM_",
        "fct-type": "function",
        "title": "decodeBOM_"
      },
      "index": {
        "description": "Decode ByteString into CompactString by investigating the Byte Order Mark If there is no BOM assumes UTF-8 Raises an error if the input is not valid encoded string or if the string can not be represented in ASCII For portability this function should be prefered over decode UTF8 when reading files",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "decodeBOM_",
        "normalized": "ByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "ByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:decode_",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a ByteString to a CompactString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e decode_ e = recode_ . fromByteString_\n\u003c/pre\u003e\u003cp\u003ebut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eRaises an error if the ByteString is not a valid encoded string\n   or if the string can not be represented in ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#decode_",
        "fct-type": "function",
        "title": "decode_"
      },
      "index": {
        "description": "Decode ByteString to CompactString using the given encoding decode recode fromByteString but it might be faster for some combinations of encodings Raises an error if the ByteString is not valid encoded string or if the string can not be represented in ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "decode_",
        "normalized": "a-\u003eByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e returns the suffix of \u003ccode\u003exs\u003c/code\u003e after the first \u003ccode\u003en\u003c/code\u003e\n elements, or \u003ccode\u003eempty\u003c/code\u003e if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "drop xs returns the suffix of xs after the first elements or empty if length xs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "drop",
        "normalized": "Int-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e returns the suffix remaining after \u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "dropWhile xs returns the suffix remaining after takeWhile xs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "dropWhile",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "While",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e is the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e membership predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-ASCII.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "elem is the CompactString membership predicate",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "elem",
        "normalized": "Char-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e function returns the index of the first\n element in the given \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e which is equal to the query\n element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-ASCII.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "The elemIndex function returns the index of the first element in the given ByteString which is equal to the query element or Nothing if there is no such element",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "elemIndex",
        "normalized": "Char-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index",
        "signature": "Char-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:elemIndexEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndexEnd\u003c/a\u003e\u003c/code\u003e function returns the last index of the\n element in the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e which is equal to the query\n element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. The following\n holds:\n\u003c/p\u003e\u003cpre\u003e elemIndexEnd c xs == \n (-) (length xs - 1) `fmap` elemIndex c (reverse xs)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-ASCII.html#elemIndexEnd",
        "fct-type": "function",
        "title": "elemIndexEnd"
      },
      "index": {
        "description": "The elemIndexEnd function returns the last index of the element in the given CompactString which is equal to the query element or Nothing if there is no such element The following holds elemIndexEnd xs length xs fmap elemIndex reverse xs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "elemIndexEnd",
        "normalized": "Char-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index End",
        "signature": "Char-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e, by returning\n the indices of all elements equal to the query element, in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e [Int]",
        "fct-source": "src/Data-CompactString-ASCII.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "The elemIndices function extends elemIndex by returning the indices of all elements equal to the query element in ascending order",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "elemIndices",
        "normalized": "Char-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Indices",
        "signature": "Char-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e The empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "The empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "empty",
        "normalized": "",
        "package": "compact-string",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a CompactString to a ByteString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e encode e = liftM toByteString . recode\n\u003c/pre\u003e\u003cp\u003eBut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eFails if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e m ByteString",
        "fct-source": "src/Data-CompactString-ASCII.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Encode CompactString to ByteString using the given encoding encode liftM toByteString recode But it might be faster for some combinations of encodings Fails if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "encode",
        "normalized": "a-\u003eCompactString-\u003eb ByteString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eCompactString-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:encodeBOM",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e using the given encoding, and add a Byte Order Mark.\n   Byte Order Marks are common on Windows, but not on other platforms.\n\u003c/p\u003e\u003cp\u003eFails if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e m ByteString",
        "fct-source": "src/Data-CompactString-ASCII.html#encodeBOM",
        "fct-type": "function",
        "title": "encodeBOM"
      },
      "index": {
        "description": "Encode CompactString using the given encoding and add Byte Order Mark Byte Order Marks are common on Windows but not on other platforms Fails if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "encodeBOM",
        "normalized": "a-\u003eCompactString-\u003eb ByteString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "e-\u003eCompactString-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:encodeBOM_",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e using the given encoding, and add a Byte Order Mark.\n   Byte Order Marks are common on Windows, but not on other platforms.\n\u003c/p\u003e\u003cp\u003eRaises an error if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-ASCII.html#encodeBOM_",
        "fct-type": "function",
        "title": "encodeBOM_"
      },
      "index": {
        "description": "Encode CompactString using the given encoding and add Byte Order Mark Byte Order Marks are common on Windows but not on other platforms Raises an error if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "encodeBOM_",
        "normalized": "a-\u003eCompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "e-\u003eCompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:encode_",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a CompactString to a ByteString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e encode_ e = toByteString . recode\n\u003c/pre\u003e\u003cp\u003eBut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eRaises an error if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-ASCII.html#encode_",
        "fct-type": "function",
        "title": "encode_"
      },
      "index": {
        "description": "Encode CompactString to ByteString using the given encoding encode toByteString recode But it might be faster for some combinations of encodings Raises an error if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "encode_",
        "normalized": "a-\u003eCompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eCompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n returns a CompactString containing those characters that satisfy the\n predicate. This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "filter applied to predicate and CompactString returns CompactString containing those characters that satisfy the predicate This function is subject to array fusion",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "filter",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e function takes a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n and returns the first element in matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if there is no such element.\n\u003c/p\u003e\u003cpre\u003e find f p = case findIndex f p of Just n -\u003e Just (p `index` n) ; _ -\u003e Nothing\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Char",
        "fct-source": "src/Data-CompactString-ASCII.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "The find function takes predicate and CompactString and returns the first element in matching the predicate or Nothing if there is no such element find case findIndex of Just Just index Nothing",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "find",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Char",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e function takes a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and\n returns the index of the first element in the CompactString\n satisfying the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-ASCII.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "The findIndex function takes predicate and CompactString and returns the index of the first element in the CompactString satisfying the predicate",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "findIndex",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:findIndexEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003efindIndexEnd\u003c/a\u003e\u003c/code\u003e function returns the last index of the\n element in the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e which satisfies the predicate,\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. The following holds:\n\u003c/p\u003e\u003cpre\u003e findIndexEnd c xs == \n (-) (length xs - 1) `fmap` findIndex c (reverse xs)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-ASCII.html#findIndexEnd",
        "fct-type": "function",
        "title": "findIndexEnd"
      },
      "index": {
        "description": "The findIndexEnd function returns the last index of the element in the given CompactString which satisfies the predicate or Nothing if there is no such element The following holds findIndexEnd xs length xs fmap findIndex reverse xs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "findIndexEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e, by returning the\n indices of all elements satisfying the predicate, in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e [Int]",
        "fct-source": "src/Data-CompactString-ASCII.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "The findIndices function extends findIndex by returning the indices of all elements satisfying the predicate in ascending order",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "findIndices",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Indices",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:findSubstring",
      "description": {
        "fct-descr": "\u003cp\u003eGet the first index of a substring in another string,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not found.\n   \u003ccode\u003efindSubstring p s\u003c/code\u003e is equivalent to \u003ccode\u003elistToMaybe (findSubstrings p s)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e Maybe Int",
        "fct-type": "function",
        "title": "findSubstring"
      },
      "index": {
        "description": "Get the first index of substring in another string or Nothing if the string is not found findSubstring is equivalent to listToMaybe findSubstrings",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "findSubstring",
        "normalized": "CompactString-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Substring",
        "signature": "CompactString-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:findSubstrings",
      "description": {
        "fct-descr": "\u003cp\u003eFind the indexes of all (possibly overlapping) occurances of a\n substring in a string.  This function uses the Knuth-Morris-Pratt\n string matching algorithm.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e [Int]",
        "fct-type": "function",
        "title": "findSubstrings"
      },
      "index": {
        "description": "Find the indexes of all possibly overlapping occurances of substring in string This function uses the Knuth-Morris-Pratt string matching algorithm",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "findSubstrings",
        "normalized": "CompactString-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Substrings",
        "signature": "CompactString-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value (typically\n the left-identity of the operator), and a CompactString, reduces the\n CompactString using the binary operator, from left to right.\n This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-ASCII.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "foldl applied to binary operator starting value typically the left-identity of the operator and CompactString reduces the CompactString using the binary operator from left to right This function is subject to array fusion",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "foldl",
        "normalized": "(a-\u003eChar-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldl\\'' is like \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but strict in the accumulator.\n Though actually foldl is also strict in the accumulator.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-ASCII.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "foldl is like foldl but strict in the accumulator Though actually foldl is also strict in the accumulator",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "foldl'",
        "normalized": "(a-\u003eChar-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e that has no starting value\n argument, and thus must be applied to non-empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n This function is subject to array fusion. \n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "foldl1 is variant of foldl that has no starting value argument and thus must be applied to non-empty CompactString This function is subject to array fusion An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "foldl1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldl1\\'' is like \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e, but strict in the accumulator.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "foldl1 is like foldl1 but strict in the accumulator An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "foldl1'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value\n (typically the right-identity of the operator), and a CompactString,\n reduces the CompactString using the binary operator, from right to left.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e acc -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-ASCII.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "foldr applied to binary operator starting value typically the right-identity of the operator and CompactString reduces the CompactString using the binary operator from right to left",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "foldr",
        "normalized": "(Char-\u003ea-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eacc-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value\n (typically the right-identity of the operator), and a CompactString,\n reduces the CompactString using the binary operator, from right to left.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e acc -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-ASCII.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "foldr applied to binary operator starting value typically the right-identity of the operator and CompactString reduces the CompactString using the binary operator from right to left",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "foldr'",
        "normalized": "(Char-\u003ea-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eacc-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e that has no starting value argument,\n and thus must be applied to non-empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "foldr1 is variant of foldr that has no starting value argument and thus must be applied to non-empty CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "foldr1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldr1\\'' is a variant of \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e, but is strict in the\n accumulator.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "foldr1 is variant of foldr1 but is strict in the accumulator An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "foldr1'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:fromByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString.\n   Fails if the ByteString is not a valid encoded string.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#fromByteString",
        "fct-type": "function",
        "title": "fromByteString"
      },
      "index": {
        "description": "Convert ByteString to CompactString Fails if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "fromByteString",
        "normalized": "ByteString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "ByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:fromByteString_",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString.\n   Raises an error if the ByteString is not a valid encoded string.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#fromByteString_",
        "fct-type": "function",
        "title": "fromByteString_"
      },
      "index": {
        "description": "Convert ByteString to CompactString Raises an error if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "fromByteString_",
        "normalized": "ByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "ByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:getContents",
      "description": {
        "fct-descr": "\u003cp\u003egetContents. Equivalent to \u003ccode\u003ehGetContents stdin\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eInput is assumed to be in ASCII, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#getContents",
        "fct-type": "function",
        "title": "getContents"
      },
      "index": {
        "description": "getContents Equivalent to hGetContents stdin Input is assumed to be in ASCII this may not be appropriate",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "getContents",
        "normalized": "",
        "package": "compact-string",
        "partial": "Contents",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:getLine",
      "description": {
        "fct-descr": "\u003cp\u003eRead a line from stdin.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#getLine",
        "fct-type": "function",
        "title": "getLine"
      },
      "index": {
        "description": "Read line from stdin",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "getLine",
        "normalized": "",
        "package": "compact-string",
        "partial": "Line",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:group",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and returns a list of\n CompactStrings such that the concatenation of the result is equal to the\n argument.  Moreover, each sublist in the result contains only equal\n elements.  For example,\n\u003c/p\u003e\u003cpre\u003e group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own equality test.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#group",
        "fct-type": "function",
        "title": "group"
      },
      "index": {
        "description": "The group function takes CompactString and returns list of CompactStrings such that the concatenation of the result is equal to the argument Moreover each sublist in the result contains only equal elements For example group Mississippi ss ss pp It is special case of groupBy which allows the programmer to supply their own equality test",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "group",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:groupBy",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Bool) -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#groupBy",
        "fct-type": "function",
        "title": "groupBy"
      },
      "index": {
        "description": "The groupBy function is the non-overloaded version of group",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "groupBy",
        "normalized": "(Char-\u003eChar-\u003eBool)-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "By",
        "signature": "(Char-\u003eChar-\u003eBool)-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:hGet",
      "description": {
        "fct-descr": "\u003cp\u003eRead a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e directly from the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e Int -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#hGet",
        "fct-type": "function",
        "title": "hGet"
      },
      "index": {
        "description": "Read CompactString directly from the specified Handle The handle is interpreted as ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "hGet",
        "normalized": "Handle-\u003eInt-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get",
        "signature": "Handle-\u003eInt-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:hGetContents",
      "description": {
        "fct-descr": "\u003cp\u003eRead entire handle contents into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#hGetContents",
        "fct-type": "function",
        "title": "hGetContents"
      },
      "index": {
        "description": "Read entire handle contents into CompactString The handle is interpreted as ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "hGetContents",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Contents",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:hGetContents-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRead entire handle contents into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe encoding is determined based on a Byte Order Mark, see \u003ccode\u003e\u003ca\u003edecodeBOM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#hGetContents%27",
        "fct-type": "function",
        "title": "hGetContents'"
      },
      "index": {
        "description": "Read entire handle contents into CompactString The encoding is determined based on Byte Order Mark see decodeBOM",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "hGetContents'",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Contents'",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:hGetLine",
      "description": {
        "fct-descr": "\u003cp\u003eRead a line from a handle\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#hGetLine",
        "fct-type": "function",
        "title": "hGetLine"
      },
      "index": {
        "description": "Read line from handle",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "hGetLine",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Line",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:hGetNonBlocking",
      "description": {
        "fct-descr": "\u003cp\u003ehGetNonBlocking is identical to \u003ccode\u003e\u003ca\u003ehGet\u003c/a\u003e\u003c/code\u003e, except that it will never block\n waiting for data to become available, instead it returns only whatever data\n is available.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e Int -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#hGetNonBlocking",
        "fct-type": "function",
        "title": "hGetNonBlocking"
      },
      "index": {
        "description": "hGetNonBlocking is identical to hGet except that it will never block waiting for data to become available instead it returns only whatever data is available The handle is interpreted as ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "hGetNonBlocking",
        "normalized": "Handle-\u003eInt-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Non Blocking",
        "signature": "Handle-\u003eInt-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:hPut",
      "description": {
        "fct-descr": "\u003cp\u003eOutputs a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eOutput is written in ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#hPut",
        "fct-type": "function",
        "title": "hPut"
      },
      "index": {
        "description": "Outputs CompactString to the specified Handle Output is written in ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "hPut",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:hPutStr",
      "description": {
        "fct-descr": "\u003cp\u003eA synonym for \u003ccode\u003ehPut\u003c/code\u003e, for compatibility \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#hPutStr",
        "fct-type": "function",
        "title": "hPutStr"
      },
      "index": {
        "description": "synonym for hPut for compatibility",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "hPutStr",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put Str",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:hPutStrLn",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a handle, appending a newline byte\n\u003c/p\u003e\u003cp\u003eOutput is written in ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#hPutStrLn",
        "fct-type": "function",
        "title": "hPutStrLn"
      },
      "index": {
        "description": "Write CompactString to handle appending newline byte Output is written in ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "hPutStrLn",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put Str Ln",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the first element of a CompactString, which must be non-empty.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "Extract the first element of CompactString which must be non-empty An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "head",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:headView",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e A view of the front of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e headView s = if null s then Nothing else Just (head s, tail s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Maybe (Char, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#headView",
        "fct-type": "function",
        "title": "headView"
      },
      "index": {
        "description": "view of the front of CompactString headView if null then Nothing else Just head tail",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "headView",
        "normalized": "CompactString-\u003eMaybe(Char,CompactString)",
        "package": "compact-string",
        "partial": "View",
        "signature": "CompactString-\u003eMaybe(Char,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:index",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e index (subscript) operator, starting from 0.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Int -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#index",
        "fct-type": "function",
        "title": "index"
      },
      "index": {
        "description": "CompactString index subscript operator starting from",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "index",
        "normalized": "CompactString-\u003eInt-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eInt-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Return all the elements of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e except the last one.\n An exception will be thrown in the case of an empty ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Return all the elements of CompactString except the last one An exception will be thrown in the case of an empty ByteString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "init",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:inits",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Return all initial segments of the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, shortest first.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#inits",
        "fct-type": "function",
        "title": "inits"
      },
      "index": {
        "description": "Return all initial segments of the given CompactString shortest first",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "inits",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:interact",
      "description": {
        "fct-descr": "\u003cp\u003eThe interact function takes a function of type \u003ccode\u003eCompactString -\u003e CompactString\u003c/code\u003e\n as its argument. The entire input from the standard input device is passed\n to this function as its argument, and the resulting string is output on the\n standard output device. It's great for writing one line programs!\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(CompactString -\u003e CompactString) -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#interact",
        "fct-type": "function",
        "title": "interact"
      },
      "index": {
        "description": "The interact function takes function of type CompactString CompactString as its argument The entire input from the standard input device is passed to this function as its argument and the resulting string is output on the standard output device It great for writing one line programs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "interact",
        "normalized": "(CompactString-\u003eCompactString)-\u003eIO()",
        "package": "compact-string",
        "partial": "",
        "signature": "(CompactString-\u003eCompactString)-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:intercalate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and a list of\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es and concatenates the list after interspersing the first\n argument between each element of the list.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#intercalate",
        "fct-type": "function",
        "title": "intercalate"
      },
      "index": {
        "description": "The intercalate function takes CompactString and list of CompactString and concatenates the list after interspersing the first argument between each element of the list",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "intercalate",
        "normalized": "CompactString-\u003e[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:intersperse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eintersperse\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e and a\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and `intersperses' that character between the elements of\n the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  It is analogous to the intersperse function on\n Lists.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#intersperse",
        "fct-type": "function",
        "title": "intersperse"
      },
      "index": {
        "description": "The intersperse function takes Char and CompactString and intersperses that character between the elements of the CompactString It is analogous to the intersperse function on Lists",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "intersperse",
        "normalized": "Char-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:isInfixOf",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether one string is a substring of another. \u003ccode\u003eisInfixOf\n p s\u003c/code\u003e is equivalent to \u003ccode\u003enot (null (findSubstrings p s))\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e Bool",
        "fct-type": "function",
        "title": "isInfixOf"
      },
      "index": {
        "description": "Check whether one string is substring of another isInfixOf is equivalent to not null findSubstrings",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "isInfixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Infix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:isPrefixOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eisPrefixOf\u003c/a\u003e\u003c/code\u003e function takes two CompactString and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first is a prefix of the second.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-ASCII.html#isPrefixOf",
        "fct-type": "function",
        "title": "isPrefixOf"
      },
      "index": {
        "description": "The isPrefixOf function takes two CompactString and returns True iff the first is prefix of the second",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "isPrefixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Prefix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:isSuffixOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eisSuffixOf\u003c/a\u003e\u003c/code\u003e function takes two CompactString and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first is a suffix of the second.\n\u003c/p\u003e\u003cp\u003eThe following holds:\n\u003c/p\u003e\u003cpre\u003e isSuffixOf x y == reverse x `isPrefixOf` reverse y\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-ASCII.html#isSuffixOf",
        "fct-type": "function",
        "title": "isSuffixOf"
      },
      "index": {
        "description": "The isSuffixOf function takes two CompactString and returns True iff the first is suffix of the second The following holds isSuffixOf reverse isPrefixOf reverse",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "isSuffixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Suffix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the last element of a ByteString, which must be finite and non-empty.\n An exception will be thrown in the case of an empty ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Extract the last element of ByteString which must be finite and non-empty An exception will be thrown in the case of an empty ByteString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "last",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:lastView",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e A view of the back of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e lastView s = if null s then Nothing else Just (init s, last s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Maybe (CompactString, Char)",
        "fct-source": "src/Data-CompactString-ASCII.html#lastView",
        "fct-type": "function",
        "title": "lastView"
      },
      "index": {
        "description": "view of the back of CompactString lastView if null then Nothing else Just init last",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "lastView",
        "normalized": "CompactString-\u003eMaybe(CompactString,Char)",
        "package": "compact-string",
        "partial": "View",
        "signature": "CompactString-\u003eMaybe(CompactString,Char)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e returns the length of a CompactString as an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Int",
        "fct-source": "src/Data-CompactString-ASCII.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "length returns the length of CompactString as an Int",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "length",
        "normalized": "CompactString-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:lines",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e breaks a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e up into a list of CompactStrings at\n newline Chars. The resulting strings do not contain newlines.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#lines",
        "fct-type": "function",
        "title": "lines"
      },
      "index": {
        "description": "lines breaks CompactString up into list of CompactStrings at newline Chars The resulting strings do not contain newlines",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "lines",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef xs\u003c/code\u003e is the CompactString obtained by applying \u003ccode\u003ef\u003c/code\u003e to each\n element of \u003ccode\u003exs\u003c/code\u003e. This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "map xs is the CompactString obtained by applying to each element of xs This function is subject to array fusion",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "map",
        "normalized": "(Char-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:mapAccumL",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a CompactString,\n passing an accumulating parameter from left to right, and returning a\n final value of this accumulator together with the new CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e acc -\u003e CompactString -\u003e (acc, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#mapAccumL",
        "fct-type": "function",
        "title": "mapAccumL"
      },
      "index": {
        "description": "The mapAccumL function behaves like combination of map and foldl it applies function to each element of CompactString passing an accumulating parameter from left to right and returning final value of this accumulator together with the new CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "mapAccumL",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003ea-\u003eCompactString-\u003e(a,CompactString)",
        "package": "compact-string",
        "partial": "Accum",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eacc-\u003eCompactString-\u003e(acc,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:mapAccumR",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a CompactString,\n passing an accumulating parameter from right to left, and returning a\n final value of this accumulator together with the new CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e acc -\u003e CompactString -\u003e (acc, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#mapAccumR",
        "fct-type": "function",
        "title": "mapAccumR"
      },
      "index": {
        "description": "The mapAccumR function behaves like combination of map and foldr it applies function to each element of CompactString passing an accumulating parameter from right to left and returning final value of this accumulator together with the new CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "mapAccumR",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003ea-\u003eCompactString-\u003e(a,CompactString)",
        "package": "compact-string",
        "partial": "Accum",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eacc-\u003eCompactString-\u003e(acc,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:mapIndexed",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e map Char functions, provided with the index at each position.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Int -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#mapIndexed",
        "fct-type": "function",
        "title": "mapIndexed"
      },
      "index": {
        "description": "map Char functions provided with the index at each position",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "mapIndexed",
        "normalized": "(Int-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Indexed",
        "signature": "(Int-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003emaximum\u003c/a\u003e\u003c/code\u003e returns the maximum value from a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "maximum returns the maximum value from CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "maximum",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eminimum\u003c/a\u003e\u003c/code\u003e returns the minimum value from a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-ASCII.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "minimum returns the minimum value from CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "minimum",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003enotElem\u003c/a\u003e\u003c/code\u003e is the inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-ASCII.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "notElem is the inverse of elem",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "notElem",
        "normalized": "Char-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Elem",
        "signature": "Char-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a CompactString is empty.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-ASCII.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether CompactString is empty",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "null",
        "normalized": "CompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:pack",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "String -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#pack",
        "fct-type": "function",
        "title": "pack"
      },
      "index": {
        "description": "Convert String into CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "pack",
        "normalized": "String-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "String-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n returns a pair of CompactStrings.\n The first containing those characters that satisfy the predicate,\n the second containg those that don't.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "partition applied to predicate and CompactString returns pair of CompactStrings The first containing those characters that satisfy the predicate the second containg those that don",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "partition",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:putStr",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to stdout.\n\u003c/p\u003e\u003cp\u003eOutput is written in ASCII, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#putStr",
        "fct-type": "function",
        "title": "putStr"
      },
      "index": {
        "description": "Write CompactString to stdout Output is written in ASCII this may not be appropriate",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "putStr",
        "normalized": "CompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Str",
        "signature": "CompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:putStrLn",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to stdout, appending a newline character.\n\u003c/p\u003e\u003cp\u003eOutput is written in ASCII, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#putStrLn",
        "fct-type": "function",
        "title": "putStrLn"
      },
      "index": {
        "description": "Write CompactString to stdout appending newline character Output is written in ASCII this may not be appropriate",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "putStrLn",
        "normalized": "CompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Str Ln",
        "signature": "CompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:readFile",
      "description": {
        "fct-descr": "\u003cp\u003eRead an entire file strictly into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  This is far more\n   efficient than reading the characters into a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and then using\n   \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e. Files are read using 'text mode' on Windows.\n\u003c/p\u003e\u003cp\u003eFiles are assumed to be in ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#readFile",
        "fct-type": "function",
        "title": "readFile"
      },
      "index": {
        "description": "Read an entire file strictly into CompactString This is far more efficient than reading the characters into String and then using pack Files are read using text mode on Windows Files are assumed to be in ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "readFile",
        "normalized": "FilePath-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:readFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRead an entire file strictly into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  This is far more\n   efficient than reading the characters into a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and then using\n   \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e. Files are read using 'text mode' on Windows.\n\u003c/p\u003e\u003cp\u003eThe encoding of the file is determined based on a Byte Order Mark, see \u003ccode\u003e\u003ca\u003edecodeBOM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#readFile%27",
        "fct-type": "function",
        "title": "readFile'"
      },
      "index": {
        "description": "Read an entire file strictly into CompactString This is far more efficient than reading the characters into String and then using pack Files are read using text mode on Windows The encoding of the file is determined based on Byte Order Mark see decodeBOM",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "readFile'",
        "normalized": "FilePath-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en x\u003c/code\u003e is a CompactString of length \u003ccode\u003en\u003c/code\u003e with \u003ccode\u003ex\u003c/code\u003e\n the value of every element. The following holds:\n\u003c/p\u003e\u003cpre\u003e replicate w c = unfoldr w (\\u -\u003e Just (u,u)) c\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "replicate is CompactString of length with the value of every element The following holds replicate unfoldr Just",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "replicate",
        "normalized": "Int-\u003eChar-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eChar-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003eReverse a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "reverse",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e is similar to \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but returns a list of successive\n reduced values from the left. This function will fuse.\n\u003c/p\u003e\u003cpre\u003e scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\n\u003c/pre\u003e\u003cp\u003eNote that\n\u003c/p\u003e\u003cpre\u003e last (scanl f z xs) == foldl f z xs.\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "scanl is similar to foldl but returns list of successive reduced values from the left This function will fuse scanl x1 x2 x1 x1 x2 Note that last scanl xs foldl xs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "scanl",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n This function will fuse.\n\u003c/p\u003e\u003cpre\u003e scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "scanl1 is variant of scanl that has no starting value argument This function will fuse scanl1 x1 x2 x1 x1 x2",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "scanl1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003escanr is the right-to-left dual of scanl.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "scanr is the right-to-left dual of scanl",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "scanr",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "scanr1 is variant of scanr that has no starting value argument",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "scanr1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Convert Char into CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "singleton",
        "normalized": "Char-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append a byte to the end of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append byte to the end of CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "snoc",
        "normalized": "CompactString-\u003eChar-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:sort",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e Sort a CompactString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#sort",
        "fct-type": "function",
        "title": "sort"
      },
      "index": {
        "description": "log Sort CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "sort",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e breaks the ByteString into two segments. It is\n equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e p xs, \u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e p xs)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "span xs breaks the ByteString into two segments It is equivalent to takeWhile xs dropWhile xs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "span",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:spanEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espanEnd\u003c/a\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e but from the end of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWe have\n\u003c/p\u003e\u003cpre\u003e spanEnd (not.isSpace) \"x y z\" == (\"x y \",\"z\")\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e spanEnd (not . isSpace) cs\n    == \n let (x,y) = span (not.isSpace) (reverse cs) in (reverse y, reverse x)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#spanEnd",
        "fct-type": "function",
        "title": "spanEnd"
      },
      "index": {
        "description": "spanEnd behaves like span but from the end of the CompactString We have spanEnd not.isSpace and spanEnd not isSpace cs let span not.isSpace reverse cs in reverse reverse",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "spanEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:split",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Break a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into pieces separated by the byte\n argument, consuming the delimiter. I.e.\n\u003c/p\u003e\u003cpre\u003e split '\\n' \"a\\nb\\nd\\ne\" == [\"a\",\"b\",\"d\",\"e\"]\n split 'a'  \"aXaXaXa\"    == [\"\",\"X\",\"X\",\"X\",\"\"]\n split 'x'  \"x\"          == [\"\",\"\"]\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e intercalate [c] . split c == id\n split == splitWith . (==)\n\u003c/pre\u003e\u003cp\u003eAs for all splitting functions in this library, this function does\n not copy the substrings, it just constructs new \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e that\n are slices of the original.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#split",
        "fct-type": "function",
        "title": "split"
      },
      "index": {
        "description": "Break ByteString into pieces separated by the byte argument consuming the delimiter I.e split nb nd ne split aXaXaXa split and intercalate split id split splitWith As for all splitting functions in this library this function does not copy the substrings it just constructs new CompactString that are slices of the original",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "split",
        "normalized": "Char-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n xs)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "splitAt xs is equivalent to take xs drop xs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "splitAt",
        "normalized": "Int-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "At",
        "signature": "Int-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:splitWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Splits a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e into components delimited by\n separators, where the predicate returns True for a separator element.\n The resulting components do not contain the separators.  Two adjacent\n separators result in an empty component in the output.  eg.\n\u003c/p\u003e\u003cpre\u003e splitWith (=='a') \"aabbaca\" == [\"\",\"\",\"bb\",\"c\",\"\"]\n splitWith (=='a') []        == []\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#splitWith",
        "fct-type": "function",
        "title": "splitWith"
      },
      "index": {
        "description": "Splits CompactString into components delimited by separators where the predicate returns True for separator element The resulting components do not contain the separators Two adjacent separators result in an empty component in the output eg splitWith aabbaca bb splitWith",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "splitWith",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "With",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the elements after the head of a CompactString, which must be non-empty.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Extract the elements after the head of CompactString which must be non-empty An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "tail",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:tails",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Return all final segments of the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, longest first.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#tails",
        "fct-type": "function",
        "title": "tails"
      },
      "index": {
        "description": "Return all final segments of the given CompactString longest first",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "tails",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en\u003c/code\u003e, applied to a CompactString \u003ccode\u003exs\u003c/code\u003e, returns the prefix\n of \u003ccode\u003exs\u003c/code\u003e of length \u003ccode\u003en\u003c/code\u003e, or \u003ccode\u003exs\u003c/code\u003e itself if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "take applied to CompactString xs returns the prefix of xs of length or xs itself if length xs",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "take",
        "normalized": "Int-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e, applied to a predicate \u003ccode\u003ep\u003c/code\u003e and a CompactString \u003ccode\u003exs\u003c/code\u003e,\n returns the longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n satisfy \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "takeWhile applied to predicate and CompactString xs returns the longest prefix possibly empty of xs of elements that satisfy",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "takeWhile",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "While",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:toByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a CompactString to a ByteString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-ASCII.html#toByteString",
        "fct-type": "function",
        "title": "toByteString"
      },
      "index": {
        "description": "Convert CompactString to ByteString",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "toByteString",
        "normalized": "CompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "CompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:transpose",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e function transposes the rows and columns of its\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e argument.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#transpose",
        "fct-type": "function",
        "title": "transpose"
      },
      "index": {
        "description": "The transpose function transposes the rows and columns of its CompactString argument",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "transpose",
        "normalized": "[CompactString]-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e, where \u003cem\u003en\u003c/em\u003e is the length of the result.  The \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e \n function is analogous to the List 'unfoldr'.  \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e builds a \n ByteString from a seed value.  The function takes the element and \n returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it is done producing the CompactString or returns \n \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(a,b)\u003c/code\u003e, in which case, \u003ccode\u003ea\u003c/code\u003e is the next byte in the string, \n and \u003ccode\u003eb\u003c/code\u003e is the seed value for further production.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e    unfoldr (\\x -\u003e if x \u003c= 5 then Just (x, x + 1) else Nothing) 0\n == pack [0, 1, 2, 3, 4, 5]\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Maybe (Char, acc)) -\u003e acc -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "where is the length of the result The unfoldr function is analogous to the List unfoldr unfoldr builds ByteString from seed value The function takes the element and returns Nothing if it is done producing the CompactString or returns Just in which case is the next byte in the string and is the seed value for further production Examples unfoldr if then Just else Nothing pack",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(Char,a))-\u003ea-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eMaybe(Char,acc))-\u003eacc-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Like \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e builds a ByteString from a seed\n value.  However, the length of the result is limited by the first\n argument to \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e.  This function is more efficient than \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e\n when the maximum length of the result is known.\n\u003c/p\u003e\u003cp\u003eThe following equation relates \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e fst (unfoldrN n f s) == take n (unfoldr f s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e (acc -\u003e Maybe (Char, acc)) -\u003e acc -\u003e (CompactString, Maybe acc)",
        "fct-source": "src/Data-CompactString-ASCII.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Like unfoldr unfoldrN builds ByteString from seed value However the length of the result is limited by the first argument to unfoldrN This function is more efficient than unfoldr when the maximum length of the result is known The following equation relates unfoldrN and unfoldr fst unfoldrN take unfoldr",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(Char,a))-\u003ea-\u003e(CompactString,Maybe a)",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003e(acc-\u003eMaybe(Char,acc))-\u003eacc-\u003e(CompactString,Maybe acc)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:unlines",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e is an inverse operation to \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e.  It joins lines,\n after appending a terminating newline to each.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#unlines",
        "fct-type": "function",
        "title": "unlines"
      },
      "index": {
        "description": "unlines is an inverse operation to lines It joins lines after appending terminating newline to each",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "unlines",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:unpack",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Converts a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e String",
        "fct-source": "src/Data-CompactString-ASCII.html#unpack",
        "fct-type": "function",
        "title": "unpack"
      },
      "index": {
        "description": "Converts CompactString to String",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "unpack",
        "normalized": "CompactString-\u003eString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:unwords",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunwords\u003c/a\u003e\u003c/code\u003e function is analogous to the \u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e function, on words.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#unwords",
        "fct-type": "function",
        "title": "unwords"
      },
      "index": {
        "description": "The unwords function is analogous to the unlines function on words",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "unwords",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e transforms a list of pairs of bytes into a pair of\n CompactStrings. Note that this performs two \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "[(Char, Char)] -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-ASCII.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "unzip transforms list of pairs of bytes into pair of CompactStrings Note that this performs two pack operations",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "unzip",
        "normalized": "[(Char,Char)]-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "[(Char,Char)]-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:validate",
      "description": {
        "fct-descr": "\u003cp\u003eValidates a CompactString.\n   If the string is invalid, fails, otherwise returns the input.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#validate",
        "fct-type": "function",
        "title": "validate"
      },
      "index": {
        "description": "Validates CompactString If the string is invalid fails otherwise returns the input",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "validate",
        "normalized": "CompactString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:validate_",
      "description": {
        "fct-descr": "\u003cp\u003eValidates a CompactString.\n   If the string is invalid, throws an error, otherwise returns the input.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#validate_",
        "fct-type": "function",
        "title": "validate_"
      },
      "index": {
        "description": "Validates CompactString If the string is invalid throws an error otherwise returns the input",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "validate_",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:words",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e breaks a ByteString up into a list of words, which\n were delimited by Chars representing white space. And\n\u003c/p\u003e\u003cpre\u003e words = filter (not . null) . splitWith isSpace\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-ASCII.html#words",
        "fct-type": "function",
        "title": "words"
      },
      "index": {
        "description": "words breaks ByteString up into list of words which were delimited by Chars representing white space And words filter not null splitWith isSpace",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "words",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:writeFile",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using ASCII.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#writeFile",
        "fct-type": "function",
        "title": "writeFile"
      },
      "index": {
        "description": "Write CompactString to file Files are written using ASCII",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "writeFile",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:writeFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using ASCII.\n   A Byte Order Mark is also written.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-ASCII.html#writeFile%27",
        "fct-type": "function",
        "title": "writeFile'"
      },
      "index": {
        "description": "Write CompactString to file Files are written using ASCII Byte Order Mark is also written",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "writeFile'",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e takes two ByteStrings and returns a list of\n corresponding pairs of bytes. If one input ByteString is short,\n excess elements of the longer ByteString are discarded. This is\n equivalent to a pair of \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e [(Char, Char)]",
        "fct-source": "src/Data-CompactString-ASCII.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "zip takes two ByteStrings and returns list of corresponding pairs of bytes If one input ByteString is short excess elements of the longer ByteString are discarded This is equivalent to pair of unpack operations",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "zip",
        "normalized": "CompactString-\u003eCompactString-\u003e[(Char,Char)]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString-\u003e[(Char,Char)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e generalises \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e by zipping with the function given as\n the first argument, instead of a tupling function.  For example,\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e (+)\u003c/code\u003e is applied to two ByteStrings to produce the list of\n corresponding sums. \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e b) -\u003e CompactString -\u003e CompactString -\u003e [b]",
        "fct-source": "src/Data-CompactString-ASCII.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "zipWith generalises zip by zipping with the function given as the first argument instead of tupling function For example zipWith is applied to two ByteStrings to produce the list of corresponding sums",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "zipWith",
        "normalized": "(Char-\u003eChar-\u003ea)-\u003eCompactString-\u003eCompactString-\u003e[a]",
        "package": "compact-string",
        "partial": "With",
        "signature": "(Char-\u003eChar-\u003eb)-\u003eCompactString-\u003eCompactString-\u003e[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-ASCII.html#v:zipWith-39-",
      "description": {
        "fct-descr": "\u003cp\u003eA specialised version of \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e for the common case of a\n simultaneous map over two \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es, to build a 3rd. Rewrite rules\n are used to automatically covert zipWith into zipWith' when a pack is\n performed on the result of zipWith, but we also export it for\n convenience.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.ASCII",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-ASCII.html#zipWith%27",
        "fct-type": "function",
        "title": "zipWith'"
      },
      "index": {
        "description": "specialised version of zipWith for the common case of simultaneous map over two CompactString to build rd Rewrite rules are used to automatically covert zipWith into zipWith when pack is performed on the result of zipWith but we also export it for convenience",
        "hierarchy": "Data CompactString ASCII",
        "module": "Data.CompactString.ASCII",
        "name": "zipWith'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "With'",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDifferent encodings of characters into bytes.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "module",
        "fct-source": "src/Data-CompactString-Encodings.html",
        "fct-type": "module",
        "title": "Encodings"
      },
      "index": {
        "description": "Different encodings of characters into bytes",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "Encodings",
        "normalized": "",
        "package": "compact-string",
        "partial": "Encodings",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:ASCII",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the ASCII encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Encodings.html#ASCII",
        "fct-type": "data",
        "title": "ASCII"
      },
      "index": {
        "description": "Tag representing the ASCII encoding",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "ASCII",
        "normalized": "",
        "package": "compact-string",
        "partial": "ASCII",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:BE",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing big endian encoding\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Encodings.html#BE",
        "fct-type": "data",
        "title": "BE"
      },
      "index": {
        "description": "Tag representing big endian encoding",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "BE",
        "normalized": "",
        "package": "compact-string",
        "partial": "BE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:Compact",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing a custom encoding optimized for memory usage.\n\u003c/p\u003e\u003cp\u003eThis encoding looks like UTF-8, but is slightly more efficient.\n It requires at most 3 byes per character, as opposed to 4 for UTF-8.\n\u003c/p\u003e\u003cp\u003eEncoding looks like:\n\u003c/p\u003e\u003cpre\u003e                   0zzzzzzz -\u003e 0zzzzzzz\n          00yyyyyy yzzzzzzz -\u003e 1xxxxxxx 1yyyyyyy\n 000xxxxx xxyyyyyy yzzzzzzz -\u003e 1xxxxxxx 0yyyyyyy 1zzzzzzz\n\u003c/pre\u003e\u003cp\u003eThe reasoning behind the tag bits is that this allows the char to be read both forwards\n and backwards.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Encodings.html#Compact",
        "fct-type": "data",
        "title": "Compact"
      },
      "index": {
        "description": "Tag representing custom encoding optimized for memory usage This encoding looks like UTF-8 but is slightly more efficient It requires at most byes per character as opposed to for UTF-8 Encoding looks like zzzzzzz zzzzzzz yyyyyy yzzzzzzz xxxxxxx yyyyyyy xxxxx xxyyyyyy yzzzzzzz xxxxxxx yyyyyyy zzzzzzz The reasoning behind the tag bits is that this allows the char to be read both forwards and backwards",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "Compact",
        "normalized": "",
        "package": "compact-string",
        "partial": "Compact",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:LE",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing little endian encoding\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Encodings.html#LE",
        "fct-type": "data",
        "title": "LE"
      },
      "index": {
        "description": "Tag representing little endian encoding",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "LE",
        "normalized": "",
        "package": "compact-string",
        "partial": "LE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:Latin1",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the ISO 8859-1 encoding (latin 1).\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Encodings.html#Latin1",
        "fct-type": "data",
        "title": "Latin1"
      },
      "index": {
        "description": "Tag representing the ISO encoding latin",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "Latin1",
        "normalized": "",
        "package": "compact-string",
        "partial": "Latin",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:Native",
      "description": {
        "fct-descr": "\u003cp\u003eThe platform native endianness\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Encodings.html#Native",
        "fct-type": "type",
        "title": "Native"
      },
      "index": {
        "description": "The platform native endianness",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "Native",
        "normalized": "",
        "package": "compact-string",
        "partial": "Native",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF16",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the UTF-16 encoding\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF16",
        "fct-type": "data",
        "title": "UTF16"
      },
      "index": {
        "description": "Tag representing the UTF-16 encoding",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF16",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF16BE",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the big endian UTF-16 encoding, aka. UTF-16BE.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF16BE",
        "fct-type": "type",
        "title": "UTF16BE"
      },
      "index": {
        "description": "Tag representing the big endian UTF-16 encoding aka UTF-16BE",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF16BE",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF BE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF16LE",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the little endian UTF-16 encoding, aka. UTF-16LE.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF16LE",
        "fct-type": "type",
        "title": "UTF16LE"
      },
      "index": {
        "description": "Tag representing the little endian UTF-16 encoding aka UTF-16LE",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF16LE",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF LE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF16Native",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the platform native UTF-16 encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF16Native",
        "fct-type": "type",
        "title": "UTF16Native"
      },
      "index": {
        "description": "Tag representing the platform native UTF-16 encoding",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF16Native",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF Native",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF32",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the UTF-32 encoding\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF32",
        "fct-type": "data",
        "title": "UTF32"
      },
      "index": {
        "description": "Tag representing the UTF-32 encoding",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF32",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF32BE",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the big endian UTF-32 encoding, aka. UTF-32BE.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF32BE",
        "fct-type": "type",
        "title": "UTF32BE"
      },
      "index": {
        "description": "Tag representing the big endian UTF-32 encoding aka UTF-32BE",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF32BE",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF BE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF32LE",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the little endian UTF-32 encoding, aka. UTF-32LE.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF32LE",
        "fct-type": "type",
        "title": "UTF32LE"
      },
      "index": {
        "description": "Tag representing the little endian UTF-32 encoding aka UTF-32LE",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF32LE",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF LE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF32Native",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the platform native UTF-32 encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF32Native",
        "fct-type": "type",
        "title": "UTF32Native"
      },
      "index": {
        "description": "Tag representing the platform native UTF-32 encoding",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF32Native",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF Native",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#t:UTF8",
      "description": {
        "fct-descr": "\u003cp\u003eTag representing the UTF-8 encoding.\n   Use \u003ccode\u003e\u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e UTF8\u003c/code\u003e for UTF-8 encoded strings.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF8",
        "fct-type": "data",
        "title": "UTF8"
      },
      "index": {
        "description": "Tag representing the UTF-8 encoding Use CompactString UTF8 for UTF-8 encoded strings",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF8",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#v:ASCII",
      "description": {
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "ASCII",
        "fct-source": "src/Data-CompactString-Encodings.html#ASCII",
        "fct-type": "function",
        "title": "ASCII"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "ASCII",
        "normalized": "",
        "package": "compact-string",
        "partial": "ASCII",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#v:BE",
      "description": {
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "BE",
        "fct-source": "src/Data-CompactString-Encodings.html#BE",
        "fct-type": "function",
        "title": "BE"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "BE",
        "normalized": "",
        "package": "compact-string",
        "partial": "BE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#v:Compact",
      "description": {
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "Compact",
        "fct-source": "src/Data-CompactString-Encodings.html#Compact",
        "fct-type": "function",
        "title": "Compact"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "Compact",
        "normalized": "",
        "package": "compact-string",
        "partial": "Compact",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#v:LE",
      "description": {
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "LE",
        "fct-source": "src/Data-CompactString-Encodings.html#LE",
        "fct-type": "function",
        "title": "LE"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "LE",
        "normalized": "",
        "package": "compact-string",
        "partial": "LE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#v:Latin1",
      "description": {
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "Latin1",
        "fct-source": "src/Data-CompactString-Encodings.html#Latin1",
        "fct-type": "function",
        "title": "Latin1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "Latin1",
        "normalized": "",
        "package": "compact-string",
        "partial": "Latin",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#v:UTF16",
      "description": {
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "UTF16 endianness",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF16",
        "fct-type": "function",
        "title": "UTF16"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF16",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#v:UTF32",
      "description": {
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "UTF32 endianness",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF32",
        "fct-type": "function",
        "title": "UTF32"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF32",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Encodings.html#v:UTF8",
      "description": {
        "fct-module": "Data.CompactString.Encodings",
        "fct-package": "compact-string",
        "fct-signature": "UTF8",
        "fct-source": "src/Data-CompactString-Encodings.html#UTF8",
        "fct-type": "function",
        "title": "UTF8"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Encodings",
        "module": "Data.CompactString.Encodings",
        "name": "UTF8",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFusable loop functions, mirrors \u003ca\u003eData.ByteString.Fusion\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "module",
        "fct-source": "src/Data-CompactString-Fusion.html",
        "fct-type": "module",
        "title": "Fusion"
      },
      "index": {
        "description": "Fusable loop functions mirrors Data.ByteString.Fusion",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "Fusion",
        "normalized": "",
        "package": "compact-string",
        "partial": "Fusion",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#t:NoAcc",
      "description": {
        "fct-descr": "\u003cp\u003eData type for accumulators which can be ignored. The rewrite rules rely on\n the fact that no bottoms of this type are ever constructed; hence, we can\n assume \u003ccode\u003e(_ :: NoAcc) \u003ccode\u003e\u003ca\u003eseq\u003c/a\u003e\u003c/code\u003e x = x\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Fusion.html#NoAcc",
        "fct-type": "data",
        "title": "NoAcc"
      },
      "index": {
        "description": "Data type for accumulators which can be ignored The rewrite rules rely on the fact that no bottoms of this type are ever constructed hence we can assume NoAcc seq",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "NoAcc",
        "normalized": "",
        "package": "compact-string",
        "partial": "No Acc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:NoAcc",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "NoAcc",
        "fct-source": "src/Data-CompactString-Fusion.html#NoAcc",
        "fct-type": "function",
        "title": "NoAcc"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "NoAcc",
        "normalized": "",
        "package": "compact-string",
        "partial": "No Acc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:filterEFL",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e AccEFL NoAcc",
        "fct-source": "src/Data-CompactString-Fusion.html#filterEFL",
        "fct-type": "function",
        "title": "filterEFL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "filterEFL",
        "normalized": "(Char-\u003eBool)-\u003eAccEFL NoAcc",
        "package": "compact-string",
        "partial": "EFL",
        "signature": "(Char-\u003eBool)-\u003eAccEFL NoAcc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:foldEFL",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e AccEFL acc",
        "fct-source": "src/Data-CompactString-Fusion.html#foldEFL",
        "fct-type": "function",
        "title": "foldEFL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "foldEFL",
        "normalized": "(a-\u003eChar-\u003ea)-\u003eAccEFL a",
        "package": "compact-string",
        "partial": "EFL",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eAccEFL acc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:loopAcc",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "PairS acc arr -\u003e acc",
        "fct-source": "src/Data-CompactString-Fusion.html#loopAcc",
        "fct-type": "function",
        "title": "loopAcc"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "loopAcc",
        "normalized": "PairS a b-\u003ea",
        "package": "compact-string",
        "partial": "Acc",
        "signature": "PairS acc arr-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:loopArr",
      "description": {
        "fct-descr": "\u003cp\u003eProjection functions that are fusion friendly (as in, we determine when\n they are inlined)\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "PairS acc arr -\u003e arr",
        "fct-source": "src/Data-CompactString-Fusion.html#loopArr",
        "fct-type": "function",
        "title": "loopArr"
      },
      "index": {
        "description": "Projection functions that are fusion friendly as in we determine when they are inlined",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "loopArr",
        "normalized": "PairS a b-\u003eb",
        "package": "compact-string",
        "partial": "Arr",
        "signature": "PairS acc arr-\u003earr"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:loopDown",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "AccEFL acc -\u003e acc -\u003e CompactString a -\u003e PairS acc (CompactString a)",
        "fct-source": "src/Data-CompactString-Fusion.html#loopDown",
        "fct-type": "function",
        "title": "loopDown"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "loopDown",
        "normalized": "AccEFL a-\u003ea-\u003eCompactString b-\u003ePairS a(CompactString b)",
        "package": "compact-string",
        "partial": "Down",
        "signature": "AccEFL acc-\u003eacc-\u003eCompactString a-\u003ePairS acc(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:loopDownFold",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "FoldEFL acc -\u003e acc -\u003e CompactString a -\u003e acc",
        "fct-source": "src/Data-CompactString-Fusion.html#loopDownFold",
        "fct-type": "function",
        "title": "loopDownFold"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "loopDownFold",
        "normalized": "FoldEFL a-\u003ea-\u003eCompactString b-\u003ea",
        "package": "compact-string",
        "partial": "Down Fold",
        "signature": "FoldEFL acc-\u003eacc-\u003eCompactString a-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:loopUp",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "AccEFL acc -\u003e acc -\u003e CompactString a -\u003e PairS acc (CompactString a)",
        "fct-source": "src/Data-CompactString-Fusion.html#loopUp",
        "fct-type": "function",
        "title": "loopUp"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "loopUp",
        "normalized": "AccEFL a-\u003ea-\u003eCompactString b-\u003ePairS a(CompactString b)",
        "package": "compact-string",
        "partial": "Up",
        "signature": "AccEFL acc-\u003eacc-\u003eCompactString a-\u003ePairS acc(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:loopUpC",
      "description": {
        "fct-descr": "\u003cp\u003elike loopUp, but the size of the buffer can only become smaller\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "AccEFL acc -\u003e acc -\u003e CompactString a -\u003e PairS acc (CompactString a)",
        "fct-source": "src/Data-CompactString-Fusion.html#loopUpC",
        "fct-type": "function",
        "title": "loopUpC"
      },
      "index": {
        "description": "like loopUp but the size of the buffer can only become smaller",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "loopUpC",
        "normalized": "AccEFL a-\u003ea-\u003eCompactString b-\u003ePairS a(CompactString b)",
        "package": "compact-string",
        "partial": "Up",
        "signature": "AccEFL acc-\u003eacc-\u003eCompactString a-\u003ePairS acc(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:loopUpFold",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "FoldEFL acc -\u003e acc -\u003e CompactString a -\u003e acc",
        "fct-source": "src/Data-CompactString-Fusion.html#loopUpFold",
        "fct-type": "function",
        "title": "loopUpFold"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "loopUpFold",
        "normalized": "FoldEFL a-\u003ea-\u003eCompactString b-\u003ea",
        "package": "compact-string",
        "partial": "Up Fold",
        "signature": "FoldEFL acc-\u003eacc-\u003eCompactString a-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:mapAccumEFL",
      "description": {
        "fct-descr": "\u003cp\u003eElement function implementing a map and fold\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e AccEFL acc",
        "fct-source": "src/Data-CompactString-Fusion.html#mapAccumEFL",
        "fct-type": "function",
        "title": "mapAccumEFL"
      },
      "index": {
        "description": "Element function implementing map and fold",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "mapAccumEFL",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003eAccEFL a",
        "package": "compact-string",
        "partial": "Accum EFL",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eAccEFL acc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:mapEFL",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char) -\u003e AccEFL NoAcc",
        "fct-source": "src/Data-CompactString-Fusion.html#mapEFL",
        "fct-type": "function",
        "title": "mapEFL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "mapEFL",
        "normalized": "(Char-\u003eChar)-\u003eAccEFL NoAcc",
        "package": "compact-string",
        "partial": "EFL",
        "signature": "(Char-\u003eChar)-\u003eAccEFL NoAcc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:mapIndexEFL",
      "description": {
        "fct-descr": "\u003cp\u003eElement function implementing a map with index\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "(Int -\u003e Char -\u003e Char) -\u003e AccEFL Int",
        "fct-source": "src/Data-CompactString-Fusion.html#mapIndexEFL",
        "fct-type": "function",
        "title": "mapIndexEFL"
      },
      "index": {
        "description": "Element function implementing map with index",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "mapIndexEFL",
        "normalized": "(Int-\u003eChar-\u003eChar)-\u003eAccEFL Int",
        "package": "compact-string",
        "partial": "Index EFL",
        "signature": "(Int-\u003eChar-\u003eChar)-\u003eAccEFL Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Fusion.html#v:scanEFL",
      "description": {
        "fct-module": "Data.CompactString.Fusion",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e AccEFL Char",
        "fct-source": "src/Data-CompactString-Fusion.html#scanEFL",
        "fct-type": "function",
        "title": "scanEFL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Fusion",
        "module": "Data.CompactString.Fusion",
        "name": "scanEFL",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eAccEFL Char",
        "package": "compact-string",
        "partial": "EFL",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eAccEFL Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInternal functions for the CompactString type.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "module",
        "fct-source": "src/Data-CompactString-Internal.html",
        "fct-type": "module",
        "title": "Internal"
      },
      "index": {
        "description": "Internal functions for the CompactString type",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "Internal",
        "normalized": "",
        "package": "compact-string",
        "partial": "Internal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:AccEFL",
      "description": {
        "fct-descr": "\u003cp\u003eType of loop functions\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Internal.html#AccEFL",
        "fct-type": "type",
        "title": "AccEFL"
      },
      "index": {
        "description": "Type of loop functions",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "AccEFL",
        "normalized": "",
        "package": "compact-string",
        "partial": "Acc EFL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:ByteString",
      "description": {
        "fct-descr": "\u003cp\u003eA space-efficient representation of a Word8 vector, supporting many\n efficient operations.  A \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e contains 8-bit characters only.\n\u003c/p\u003e\u003cp\u003eInstances of Eq, Ord, Read, Show, Data, Typeable\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "ByteString"
      },
      "index": {
        "description": "space-efficient representation of Word8 vector supporting many efficient operations ByteString contains bit characters only Instances of Eq Ord Read Show Data Typeable",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "ByteString",
        "normalized": "",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:CompactString",
      "description": {
        "fct-descr": "\u003cp\u003eA String using a compact, strict representation.\n   A \u003ccode\u003eCompactString a\u003c/code\u003e is encoded using encoding \u003ccode\u003ea\u003c/code\u003e, for example \u003ccode\u003eCompactString \u003ccode\u003eUTF8\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "newtype",
        "fct-source": "src/Data-CompactString-Internal.html#CompactString",
        "fct-type": "newtype",
        "title": "CompactString"
      },
      "index": {
        "description": "String using compact strict representation CompactString is encoded using encoding for example CompactString UTF8",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "CompactString",
        "normalized": "",
        "package": "compact-string",
        "partial": "Compact String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:Encoding",
      "description": {
        "fct-descr": "\u003cp\u003eA way to encode characters into bytes\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "class",
        "fct-source": "src/Data-CompactString-Internal.html#Encoding",
        "fct-type": "class",
        "title": "Encoding"
      },
      "index": {
        "description": "way to encode characters into bytes",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "Encoding",
        "normalized": "",
        "package": "compact-string",
        "partial": "Encoding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:FoldEFL",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Internal.html#FoldEFL",
        "fct-type": "type",
        "title": "FoldEFL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "FoldEFL",
        "normalized": "",
        "package": "compact-string",
        "partial": "Fold EFL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:ImperativeLoop",
      "description": {
        "fct-descr": "\u003cp\u003eAn imperative loop transforming a string, using an accumulating parameter.\n   See Data.ByteString.Fusion\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Internal.html#ImperativeLoop",
        "fct-type": "type",
        "title": "ImperativeLoop"
      },
      "index": {
        "description": "An imperative loop transforming string using an accumulating parameter See Data.ByteString.Fusion",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "ImperativeLoop",
        "normalized": "",
        "package": "compact-string",
        "partial": "Imperative Loop",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:ImperativeLoop_",
      "description": {
        "fct-descr": "\u003cp\u003eImperativeLoop with no output\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-Internal.html#ImperativeLoop_",
        "fct-type": "type",
        "title": "ImperativeLoop_"
      },
      "index": {
        "description": "ImperativeLoop with no output",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "ImperativeLoop_",
        "normalized": "",
        "package": "compact-string",
        "partial": "Imperative Loop",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:MaybeS",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Internal.html#MaybeS",
        "fct-type": "data",
        "title": "MaybeS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "MaybeS",
        "normalized": "",
        "package": "compact-string",
        "partial": "Maybe",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:PairS",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Internal.html#PairS",
        "fct-type": "data",
        "title": "PairS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "PairS",
        "normalized": "",
        "package": "compact-string",
        "partial": "Pair",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#t:Proxy",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Internal.html#Proxy",
        "fct-type": "data",
        "title": "Proxy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "Proxy",
        "normalized": "",
        "package": "compact-string",
        "partial": "Proxy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v::-42-:",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "!a :*: !b",
        "fct-source": "src/Data-CompactString-Internal.html#PairS",
        "fct-type": "function",
        "title": ":*:"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": ":*:",
        "normalized": "",
        "package": "compact-string",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:CS",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "CS",
        "fct-source": "src/Data-CompactString-Internal.html#CompactString",
        "fct-type": "function",
        "title": "CS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "CS",
        "normalized": "",
        "package": "compact-string",
        "partial": "CS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:JustS",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "JustS !a",
        "fct-source": "src/Data-CompactString-Internal.html#MaybeS",
        "fct-type": "function",
        "title": "JustS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "JustS",
        "normalized": "",
        "package": "compact-string",
        "partial": "Just",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:NothingS",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "NothingS",
        "fct-source": "src/Data-CompactString-Internal.html#MaybeS",
        "fct-type": "function",
        "title": "NothingS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "NothingS",
        "normalized": "",
        "package": "compact-string",
        "partial": "Nothing",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:PS",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "PS !(ForeignPtr Word8) !Int !Int",
        "fct-type": "function",
        "title": "PS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "PS",
        "normalized": "",
        "package": "compact-string",
        "partial": "PS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:byteCount",
      "description": {
        "fct-descr": "\u003cp\u003eWhat is the maximum number of bytes a string with the given number of characters contains?\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Int -\u003e Int",
        "fct-source": "src/Data-CompactString-Internal.html#byteCount",
        "fct-type": "method",
        "title": "byteCount"
      },
      "index": {
        "description": "What is the maximum number of bytes string with the given number of characters contains",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "byteCount",
        "normalized": "Proxy a-\u003eInt-\u003eInt",
        "package": "compact-string",
        "partial": "Count",
        "signature": "Proxy a-\u003eInt-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:charCount",
      "description": {
        "fct-descr": "\u003cp\u003eWhat is the maximum number of character a string with the given number of bytes contains?\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Int -\u003e Int",
        "fct-source": "src/Data-CompactString-Internal.html#charCount",
        "fct-type": "method",
        "title": "charCount"
      },
      "index": {
        "description": "What is the maximum number of character string with the given number of bytes contains",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "charCount",
        "normalized": "Proxy a-\u003eInt-\u003eInt",
        "package": "compact-string",
        "partial": "Count",
        "signature": "Proxy a-\u003eInt-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:containsASCII",
      "description": {
        "fct-descr": "\u003cp\u003eIs ASCII a valid subset of the encoding?\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Bool",
        "fct-source": "src/Data-CompactString-Internal.html#containsASCII",
        "fct-type": "method",
        "title": "containsASCII"
      },
      "index": {
        "description": "Is ASCII valid subset of the encoding",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "containsASCII",
        "normalized": "Proxy a-\u003eBool",
        "package": "compact-string",
        "partial": "ASCII",
        "signature": "Proxy a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:copyChar",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a character from one buffer to another, return the length of the character\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Ptr Word8 -\u003e Ptr Word8 -\u003e IO Int",
        "fct-source": "src/Data-CompactString-Internal.html#copyChar",
        "fct-type": "method",
        "title": "copyChar"
      },
      "index": {
        "description": "Copy character from one buffer to another return the length of the character",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "copyChar",
        "normalized": "Proxy a-\u003ePtr Word-\u003ePtr Word-\u003eIO Int",
        "package": "compact-string",
        "partial": "Char",
        "signature": "Proxy a-\u003ePtr Word-\u003ePtr Word-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:copyCharRev",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a character from one buffer to another, where the source pointer\n   points to the last byte of the character.\n   return the length of the character.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Ptr Word8 -\u003e Ptr Word8 -\u003e IO Int",
        "fct-source": "src/Data-CompactString-Internal.html#copyCharRev",
        "fct-type": "method",
        "title": "copyCharRev"
      },
      "index": {
        "description": "Copy character from one buffer to another where the source pointer points to the last byte of the character return the length of the character",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "copyCharRev",
        "normalized": "Proxy a-\u003ePtr Word-\u003ePtr Word-\u003eIO Int",
        "package": "compact-string",
        "partial": "Char Rev",
        "signature": "Proxy a-\u003ePtr Word-\u003ePtr Word-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:create",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e (Ptr Word8 -\u003e IO ()) -\u003e IO (CompactString a)",
        "fct-source": "src/Data-CompactString-Internal.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "create",
        "normalized": "Int-\u003e(Ptr Word-\u003eIO())-\u003eIO(CompactString a)",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003e(Ptr Word-\u003eIO())-\u003eIO(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:doDownLoop",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e AccEFL acc -\u003e acc -\u003e ImperativeLoop acc",
        "fct-source": "src/Data-CompactString-Internal.html#doDownLoop",
        "fct-type": "method",
        "title": "doDownLoop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "doDownLoop",
        "normalized": "Proxy a-\u003eAccEFL b-\u003eb-\u003eImperativeLoop b",
        "package": "compact-string",
        "partial": "Down Loop",
        "signature": "Proxy a-\u003eAccEFL acc-\u003eacc-\u003eImperativeLoop acc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:doDownLoopFold",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e FoldEFL acc -\u003e acc -\u003e ImperativeLoop_ acc",
        "fct-source": "src/Data-CompactString-Internal.html#doDownLoopFold",
        "fct-type": "method",
        "title": "doDownLoopFold"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "doDownLoopFold",
        "normalized": "Proxy a-\u003eFoldEFL b-\u003eb-\u003eImperativeLoop_ b",
        "package": "compact-string",
        "partial": "Down Loop Fold",
        "signature": "Proxy a-\u003eFoldEFL acc-\u003eacc-\u003eImperativeLoop_ acc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:doUpLoop",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e AccEFL acc -\u003e acc -\u003e ImperativeLoop acc",
        "fct-source": "src/Data-CompactString-Internal.html#doUpLoop",
        "fct-type": "method",
        "title": "doUpLoop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "doUpLoop",
        "normalized": "Proxy a-\u003eAccEFL b-\u003eb-\u003eImperativeLoop b",
        "package": "compact-string",
        "partial": "Up Loop",
        "signature": "Proxy a-\u003eAccEFL acc-\u003eacc-\u003eImperativeLoop acc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:doUpLoopFold",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e FoldEFL acc -\u003e acc -\u003e ImperativeLoop_ acc",
        "fct-source": "src/Data-CompactString-Internal.html#doUpLoopFold",
        "fct-type": "method",
        "title": "doUpLoopFold"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "doUpLoopFold",
        "normalized": "Proxy a-\u003eFoldEFL b-\u003eb-\u003eImperativeLoop_ b",
        "package": "compact-string",
        "partial": "Up Loop Fold",
        "signature": "Proxy a-\u003eFoldEFL acc-\u003eacc-\u003eImperativeLoop_ acc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:encoding",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Proxy a",
        "fct-source": "src/Data-CompactString-Internal.html#encoding",
        "fct-type": "function",
        "title": "encoding"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "encoding",
        "normalized": "CompactString a-\u003eProxy a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eProxy a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:errorEmptyList",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "String -\u003e a",
        "fct-source": "src/Data-CompactString-Internal.html#errorEmptyList",
        "fct-type": "function",
        "title": "errorEmptyList"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "errorEmptyList",
        "normalized": "String-\u003ea",
        "package": "compact-string",
        "partial": "Empty List",
        "signature": "String-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:failMessage",
      "description": {
        "fct-descr": "\u003cp\u003eFail with an error message including the module name and function\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "String -\u003e String -\u003e IO a",
        "fct-source": "src/Data-CompactString-Internal.html#failMessage",
        "fct-type": "function",
        "title": "failMessage"
      },
      "index": {
        "description": "Fail with an error message including the module name and function",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "failMessage",
        "normalized": "String-\u003eString-\u003eIO a",
        "package": "compact-string",
        "partial": "Message",
        "signature": "String-\u003eString-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:inlinePerformIO",
      "description": {
        "fct-descr": "\u003cp\u003eJust like unsafePerformIO, but we inline it. Big performance gains as\n it exposes lots of things to further inlining. \u003cem\u003eVery unsafe\u003c/em\u003e. In\n particular, you should do no memory allocation inside an\n \u003ccode\u003e\u003ca\u003einlinePerformIO\u003c/a\u003e\u003c/code\u003e block. On Hugs this is just \u003ccode\u003eunsafePerformIO\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "IO a -\u003e a",
        "fct-type": "function",
        "title": "inlinePerformIO"
      },
      "index": {
        "description": "Just like unsafePerformIO but we inline it Big performance gains as it exposes lots of things to further inlining Very unsafe In particular you should do no memory allocation inside an inlinePerformIO block On Hugs this is just unsafePerformIO",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "inlinePerformIO",
        "normalized": "IO a-\u003ea",
        "package": "compact-string",
        "partial": "Perform IO",
        "signature": "IO a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:memcpy",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Ptr Word8 -\u003e Ptr Word8 -\u003e CSize -\u003e IO ()",
        "fct-type": "function",
        "title": "memcpy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "memcpy",
        "normalized": "Ptr Word-\u003ePtr Word-\u003eCSize-\u003eIO()",
        "package": "compact-string",
        "partial": "",
        "signature": "Ptr Word-\u003ePtr Word-\u003eCSize-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:moduleError",
      "description": {
        "fct-descr": "\u003cp\u003eRaise an errorr, with the message including the module name and function\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "String -\u003e String -\u003e a",
        "fct-source": "src/Data-CompactString-Internal.html#moduleError",
        "fct-type": "function",
        "title": "moduleError"
      },
      "index": {
        "description": "Raise an errorr with the message including the module name and function",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "moduleError",
        "normalized": "String-\u003eString-\u003ea",
        "package": "compact-string",
        "partial": "Error",
        "signature": "String-\u003eString-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:newSize",
      "description": {
        "fct-descr": "\u003cp\u003eWhat is the maximum size in bytes after transforming (using map) a string?\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Int -\u003e Int",
        "fct-source": "src/Data-CompactString-Internal.html#newSize",
        "fct-type": "method",
        "title": "newSize"
      },
      "index": {
        "description": "What is the maximum size in bytes after transforming using map string",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "newSize",
        "normalized": "Proxy a-\u003eInt-\u003eInt",
        "package": "compact-string",
        "partial": "Size",
        "signature": "Proxy a-\u003eInt-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:ord",
      "description": {
        "fct-descr": "\u003cp\u003eThe Prelude.fromEnum method restricted to the type Data.Char.Char.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e Int",
        "fct-type": "function",
        "title": "ord"
      },
      "index": {
        "description": "The Prelude.fromEnum method restricted to the type Data.Char.Char",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "ord",
        "normalized": "Char-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:peek",
      "description": {
        "fct-descr": "\u003cp\u003eRead a value from the given memory location.\n\u003c/p\u003e\u003cp\u003eNote that the peek and poke functions might require properly\n  aligned addresses to function correctly.  This is architecture\n  dependent; thus, portable code should ensure that when peeking or\n  poking values of some type \u003ccode\u003ea\u003c/code\u003e, the alignment\n  constraint for \u003ccode\u003ea\u003c/code\u003e, as given by the function\n  \u003ccode\u003e\u003ca\u003ealignment\u003c/a\u003e\u003c/code\u003e is fulfilled.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Ptr a -\u003e IO a",
        "fct-type": "function",
        "title": "peek"
      },
      "index": {
        "description": "Read value from the given memory location Note that the peek and poke functions might require properly aligned addresses to function correctly This is architecture dependent thus portable code should ensure that when peeking or poking values of some type the alignment constraint for as given by the function alignment is fulfilled",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "peek",
        "normalized": "Ptr a-\u003eIO a",
        "package": "compact-string",
        "partial": "",
        "signature": "Ptr a-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:peekByteOff",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Ptr a -\u003e Int -\u003e IO a",
        "fct-source": "src/Data-CompactString-Internal.html#peekByteOff",
        "fct-type": "function",
        "title": "peekByteOff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "peekByteOff",
        "normalized": "Ptr a-\u003eInt-\u003eIO a",
        "package": "compact-string",
        "partial": "Byte Off",
        "signature": "Ptr a-\u003eInt-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:peekChar",
      "description": {
        "fct-descr": "\u003cp\u003eRead a character from a memory buffer, return it and its length.\n   The buffer is guaranteed to contain a valid character.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Ptr Word8 -\u003e IO (Int, Char)",
        "fct-source": "src/Data-CompactString-Internal.html#peekChar",
        "fct-type": "method",
        "title": "peekChar"
      },
      "index": {
        "description": "Read character from memory buffer return it and its length The buffer is guaranteed to contain valid character",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "peekChar",
        "normalized": "Proxy a-\u003ePtr Word-\u003eIO(Int,Char)",
        "package": "compact-string",
        "partial": "Char",
        "signature": "Proxy a-\u003ePtr Word-\u003eIO(Int,Char)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:peekCharLen",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the length of the character in a memory buffer\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Ptr Word8 -\u003e IO Int",
        "fct-source": "src/Data-CompactString-Internal.html#peekCharLen",
        "fct-type": "method",
        "title": "peekCharLen"
      },
      "index": {
        "description": "Return the length of the character in memory buffer",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "peekCharLen",
        "normalized": "Proxy a-\u003ePtr Word-\u003eIO Int",
        "package": "compact-string",
        "partial": "Char Len",
        "signature": "Proxy a-\u003ePtr Word-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:peekCharLenRev",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the length of the character in a memory buffer,\n   given a pointer to the \u003cem\u003elast\u003c/em\u003e byte.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Ptr Word8 -\u003e IO Int",
        "fct-source": "src/Data-CompactString-Internal.html#peekCharLenRev",
        "fct-type": "method",
        "title": "peekCharLenRev"
      },
      "index": {
        "description": "Return the length of the character in memory buffer given pointer to the last byte",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "peekCharLenRev",
        "normalized": "Proxy a-\u003ePtr Word-\u003eIO Int",
        "package": "compact-string",
        "partial": "Char Len Rev",
        "signature": "Proxy a-\u003ePtr Word-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:peekCharRev",
      "description": {
        "fct-descr": "\u003cp\u003eRead a character from a memory buffer, return it and its length,\n   given a pointer to the \u003cem\u003elast\u003c/em\u003e byte.\n   The buffer is guaranteed to contain a valid character.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Ptr Word8 -\u003e IO (Int, Char)",
        "fct-source": "src/Data-CompactString-Internal.html#peekCharRev",
        "fct-type": "method",
        "title": "peekCharRev"
      },
      "index": {
        "description": "Read character from memory buffer return it and its length given pointer to the last byte The buffer is guaranteed to contain valid character",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "peekCharRev",
        "normalized": "Proxy a-\u003ePtr Word-\u003eIO(Int,Char)",
        "package": "compact-string",
        "partial": "Char Rev",
        "signature": "Proxy a-\u003ePtr Word-\u003eIO(Int,Char)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:peekCharSafe",
      "description": {
        "fct-descr": "\u003cp\u003eRead a character from a memory buffer, return it and its length.\n   The buffer is not guaranteed to contain a valid character, so that should\n   be verified. There is also no guarantee that the length of the buffer (also given)\n   is sufficient to contain a whole character.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Int -\u003e Ptr Word8 -\u003e IO (Int, Char)",
        "fct-source": "src/Data-CompactString-Internal.html#peekCharSafe",
        "fct-type": "method",
        "title": "peekCharSafe"
      },
      "index": {
        "description": "Read character from memory buffer return it and its length The buffer is not guaranteed to contain valid character so that should be verified There is also no guarantee that the length of the buffer also given is sufficient to contain whole character",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "peekCharSafe",
        "normalized": "Proxy a-\u003eInt-\u003ePtr Word-\u003eIO(Int,Char)",
        "package": "compact-string",
        "partial": "Char Safe",
        "signature": "Proxy a-\u003eInt-\u003ePtr Word-\u003eIO(Int,Char)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:plusPtr",
      "description": {
        "fct-descr": "\u003cp\u003eplusPtr that preserves the pointer type\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Ptr a -\u003e Int -\u003e Ptr a",
        "fct-source": "src/Data-CompactString-Internal.html#plusPtr",
        "fct-type": "function",
        "title": "plusPtr"
      },
      "index": {
        "description": "plusPtr that preserves the pointer type",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "plusPtr",
        "normalized": "Ptr a-\u003eInt-\u003ePtr a",
        "package": "compact-string",
        "partial": "Ptr",
        "signature": "Ptr a-\u003eInt-\u003ePtr a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:poke",
      "description": {
        "fct-descr": "\u003cp\u003eWrite the given value to the given memory location.  Alignment\n restrictions might apply; see \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Ptr a -\u003e a -\u003e IO ()",
        "fct-type": "function",
        "title": "poke"
      },
      "index": {
        "description": "Write the given value to the given memory location Alignment restrictions might apply see peek",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "poke",
        "normalized": "Ptr a-\u003ea-\u003eIO()",
        "package": "compact-string",
        "partial": "",
        "signature": "Ptr a-\u003ea-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:pokeByteOff",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Ptr a -\u003e Int -\u003e a -\u003e IO ()",
        "fct-source": "src/Data-CompactString-Internal.html#pokeByteOff",
        "fct-type": "function",
        "title": "pokeByteOff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "pokeByteOff",
        "normalized": "Ptr a-\u003eInt-\u003ea-\u003eIO()",
        "package": "compact-string",
        "partial": "Byte Off",
        "signature": "Ptr a-\u003eInt-\u003ea-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:pokeChar",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a character and return the size used\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Ptr Word8 -\u003e Char -\u003e IO Int",
        "fct-source": "src/Data-CompactString-Internal.html#pokeChar",
        "fct-type": "method",
        "title": "pokeChar"
      },
      "index": {
        "description": "Write character and return the size used",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "pokeChar",
        "normalized": "Proxy a-\u003ePtr Word-\u003eChar-\u003eIO Int",
        "package": "compact-string",
        "partial": "Char",
        "signature": "Proxy a-\u003ePtr Word-\u003eChar-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:pokeCharFun",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a character returns the length of that character,\n   and a function to write it to a memory buffer.\n   if the encoding can not represent the character, the io function should \u003ccode\u003efail\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Char -\u003e (Int, Ptr Word8 -\u003e IO ())",
        "fct-source": "src/Data-CompactString-Internal.html#pokeCharFun",
        "fct-type": "method",
        "title": "pokeCharFun"
      },
      "index": {
        "description": "Given character returns the length of that character and function to write it to memory buffer if the encoding can not represent the character the io function should fail",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "pokeCharFun",
        "normalized": "Proxy a-\u003eChar-\u003e(Int,Ptr Word-\u003eIO())",
        "package": "compact-string",
        "partial": "Char Fun",
        "signature": "Proxy a-\u003eChar-\u003e(Int,Ptr Word-\u003eIO())"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:pokeCharLen",
      "description": {
        "fct-descr": "\u003cp\u003eThe size needed to store a character\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Char -\u003e Int",
        "fct-source": "src/Data-CompactString-Internal.html#pokeCharLen",
        "fct-type": "method",
        "title": "pokeCharLen"
      },
      "index": {
        "description": "The size needed to store character",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "pokeCharLen",
        "normalized": "Proxy a-\u003eChar-\u003eInt",
        "package": "compact-string",
        "partial": "Char Len",
        "signature": "Proxy a-\u003eChar-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:pokeCharRev",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a character given a pointer to its last byte, and return the size used\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Ptr Word8 -\u003e Char -\u003e IO Int",
        "fct-source": "src/Data-CompactString-Internal.html#pokeCharRev",
        "fct-type": "method",
        "title": "pokeCharRev"
      },
      "index": {
        "description": "Write character given pointer to its last byte and return the size used",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "pokeCharRev",
        "normalized": "Proxy a-\u003ePtr Word-\u003eChar-\u003eIO Int",
        "package": "compact-string",
        "partial": "Char Rev",
        "signature": "Proxy a-\u003ePtr Word-\u003eChar-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:returnChr",
      "description": {
        "fct-descr": "\u003cp\u003eSafe variant of chr, combined with return; does more checks.\n   At least GHC does not check for surrogate pairs\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e Word32 -\u003e IO (Int, Char)",
        "fct-source": "src/Data-CompactString-Internal.html#returnChr",
        "fct-type": "function",
        "title": "returnChr"
      },
      "index": {
        "description": "Safe variant of chr combined with return does more checks At least GHC does not check for surrogate pairs",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "returnChr",
        "normalized": "Int-\u003eWord-\u003eIO(Int,Char)",
        "package": "compact-string",
        "partial": "Chr",
        "signature": "Int-\u003eWord-\u003eIO(Int,Char)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:unCS",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "ByteString",
        "fct-source": "src/Data-CompactString-Internal.html#CompactString",
        "fct-type": "function",
        "title": "unCS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "unCS",
        "normalized": "",
        "package": "compact-string",
        "partial": "CS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:unSP",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "PairS a b -\u003e (a, b)",
        "fct-source": "src/Data-CompactString-Internal.html#unSP",
        "fct-type": "function",
        "title": "unSP"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "unSP",
        "normalized": "PairS a b-\u003e(a,b)",
        "package": "compact-string",
        "partial": "SP",
        "signature": "PairS a b-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:unsafeChr",
      "description": {
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e Char",
        "fct-type": "function",
        "title": "unsafeChr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "unsafeChr",
        "normalized": "Int-\u003eChar",
        "package": "compact-string",
        "partial": "Chr",
        "signature": "Int-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:unsafeTry",
      "description": {
        "fct-descr": "\u003cp\u003eCatch exceptions from fail in the IO monad, and wrap them in another monad\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "IO a -\u003e m a",
        "fct-source": "src/Data-CompactString-Internal.html#unsafeTry",
        "fct-type": "function",
        "title": "unsafeTry"
      },
      "index": {
        "description": "Catch exceptions from fail in the IO monad and wrap them in another monad",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "unsafeTry",
        "normalized": "IO a-\u003eb a",
        "package": "compact-string",
        "partial": "Try",
        "signature": "IO a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:unsafeTryIO",
      "description": {
        "fct-descr": "\u003cp\u003eCatch exceptions from fail in the IO monad, and wrap them in another monad\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "IO a -\u003e IO (m a)",
        "fct-source": "src/Data-CompactString-Internal.html#unsafeTryIO",
        "fct-type": "function",
        "title": "unsafeTryIO"
      },
      "index": {
        "description": "Catch exceptions from fail in the IO monad and wrap them in another monad",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "unsafeTryIO",
        "normalized": "IO a-\u003eIO(b a)",
        "package": "compact-string",
        "partial": "Try IO",
        "signature": "IO a-\u003eIO(m a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:unsafeWithBuffer",
      "description": {
        "fct-descr": "\u003cp\u003ePerform a function given a pointer to the buffer of a CompactString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e (Ptr Word8 -\u003e IO b) -\u003e b",
        "fct-source": "src/Data-CompactString-Internal.html#unsafeWithBuffer",
        "fct-type": "function",
        "title": "unsafeWithBuffer"
      },
      "index": {
        "description": "Perform function given pointer to the buffer of CompactString",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "unsafeWithBuffer",
        "normalized": "CompactString a-\u003e(Ptr Word-\u003eIO b)-\u003eb",
        "package": "compact-string",
        "partial": "With Buffer",
        "signature": "CompactString a-\u003e(Ptr Word-\u003eIO b)-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:unsafeWithBufferEnd",
      "description": {
        "fct-descr": "\u003cp\u003ePerform a function given a pointer to the last byte in the buffer of a CompactString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e (Ptr Word8 -\u003e IO b) -\u003e b",
        "fct-source": "src/Data-CompactString-Internal.html#unsafeWithBufferEnd",
        "fct-type": "function",
        "title": "unsafeWithBufferEnd"
      },
      "index": {
        "description": "Perform function given pointer to the last byte in the buffer of CompactString",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "unsafeWithBufferEnd",
        "normalized": "CompactString a-\u003e(Ptr Word-\u003eIO b)-\u003eb",
        "package": "compact-string",
        "partial": "With Buffer End",
        "signature": "CompactString a-\u003e(Ptr Word-\u003eIO b)-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:validEquality",
      "description": {
        "fct-descr": "\u003cp\u003eIs \u003ccode\u003e(a == b) == (toBS a == toBS b)\u003c/code\u003e?\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Bool",
        "fct-source": "src/Data-CompactString-Internal.html#validEquality",
        "fct-type": "method",
        "title": "validEquality"
      },
      "index": {
        "description": "Is toBS toBS",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "validEquality",
        "normalized": "Proxy a-\u003eBool",
        "package": "compact-string",
        "partial": "Equality",
        "signature": "Proxy a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:validOrdering",
      "description": {
        "fct-descr": "\u003cp\u003eIs \u003ccode\u003e(a \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e b) == (toBS a \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e toBS b)\u003c/code\u003e?\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Bool",
        "fct-source": "src/Data-CompactString-Internal.html#validOrdering",
        "fct-type": "method",
        "title": "validOrdering"
      },
      "index": {
        "description": "Is compare toBS compare toBS",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "validOrdering",
        "normalized": "Proxy a-\u003eBool",
        "package": "compact-string",
        "partial": "Ordering",
        "signature": "Proxy a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:validSubstring",
      "description": {
        "fct-descr": "\u003cp\u003eIs \u003ccode\u003e(a \u003ccode\u003eisSubstringOf\u003c/code\u003e b) == (toBS a \u003ccode\u003eisSubstringOf\u003c/code\u003e toBS b)\u003c/code\u003e?\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Bool",
        "fct-source": "src/Data-CompactString-Internal.html#validSubstring",
        "fct-type": "method",
        "title": "validSubstring"
      },
      "index": {
        "description": "Is isSubstringOf toBS isSubstringOf toBS",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "validSubstring",
        "normalized": "Proxy a-\u003eBool",
        "package": "compact-string",
        "partial": "Substring",
        "signature": "Proxy a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:validateLength",
      "description": {
        "fct-descr": "\u003cp\u003eValidate the length, should be used before peekCharSafe is called.\n   Can be used to remove the number of checks used by peekCharSafe.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "Proxy a -\u003e Int -\u003e IO ()",
        "fct-source": "src/Data-CompactString-Internal.html#validateLength",
        "fct-type": "method",
        "title": "validateLength"
      },
      "index": {
        "description": "Validate the length should be used before peekCharSafe is called Can be used to remove the number of checks used by peekCharSafe",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "validateLength",
        "normalized": "Proxy a-\u003eInt-\u003eIO()",
        "package": "compact-string",
        "partial": "Length",
        "signature": "Proxy a-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:withBuffer",
      "description": {
        "fct-descr": "\u003cp\u003ePerform a function given a pointer to the buffer of a CompactString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e (Ptr Word8 -\u003e IO b) -\u003e IO b",
        "fct-source": "src/Data-CompactString-Internal.html#withBuffer",
        "fct-type": "function",
        "title": "withBuffer"
      },
      "index": {
        "description": "Perform function given pointer to the buffer of CompactString",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "withBuffer",
        "normalized": "CompactString a-\u003e(Ptr Word-\u003eIO b)-\u003eIO b",
        "package": "compact-string",
        "partial": "Buffer",
        "signature": "CompactString a-\u003e(Ptr Word-\u003eIO b)-\u003eIO b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Internal.html#v:withBufferEnd",
      "description": {
        "fct-descr": "\u003cp\u003ePerform a function given a pointer to the last byte in the buffer of a CompactString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Internal",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e (Ptr Word8 -\u003e IO b) -\u003e IO b",
        "fct-source": "src/Data-CompactString-Internal.html#withBufferEnd",
        "fct-type": "function",
        "title": "withBufferEnd"
      },
      "index": {
        "description": "Perform function given pointer to the last byte in the buffer of CompactString",
        "hierarchy": "Data CompactString Internal",
        "module": "Data.CompactString.Internal",
        "name": "withBufferEnd",
        "normalized": "CompactString a-\u003e(Ptr Word-\u003eIO b)-\u003eIO b",
        "package": "compact-string",
        "partial": "Buffer End",
        "signature": "CompactString a-\u003e(Ptr Word-\u003eIO b)-\u003eIO b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompactString specialized to platform native UTF-16.\n\u003c/p\u003e\u003cp\u003eThis module can be used to reduce the need for type signatures,\n since in most cases only a single encoding is used.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "module",
        "fct-source": "src/Data-CompactString-UTF16.html",
        "fct-type": "module",
        "title": "UTF16"
      },
      "index": {
        "description": "CompactString specialized to platform native UTF-16 This module can be used to reduce the need for type signatures since in most cases only single encoding is used",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "UTF16",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#t:CompactString",
      "description": {
        "fct-descr": "\u003cp\u003eCompactString specialized to UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-UTF16.html#CompactString",
        "fct-type": "type",
        "title": "CompactString"
      },
      "index": {
        "description": "CompactString specialized to UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "CompactString",
        "normalized": "",
        "package": "compact-string",
        "partial": "Compact String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Applied to a predicate and a CompactString, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if\n all elements of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF16.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Applied to predicate and CompactString any determines if all elements of the CompactString satisfy the predicate",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "all",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Applied to a predicate and a CompactString, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if\n any element of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF16.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Applied to predicate and CompactString any determines if any element of the CompactString satisfies the predicate",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "any",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:append",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append two CompactStrings\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#append",
        "fct-type": "function",
        "title": "append"
      },
      "index": {
        "description": "Append two CompactStrings",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "append",
        "normalized": "CompactString-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:appendFile",
      "description": {
        "fct-descr": "\u003cp\u003eAppend a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#appendFile",
        "fct-type": "function",
        "title": "appendFile"
      },
      "index": {
        "description": "Append CompactString to file Files are written using UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "appendFile",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:appendFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eAppend a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eThe encoding of the file is determined based on a Byte Order Mark.\n   If the file is empty, it is written using UTF-16 with a Byte Order Mark.\n   If the encoding can not be determined the file is assumed to be UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#appendFile%27",
        "fct-type": "function",
        "title": "appendFile'"
      },
      "index": {
        "description": "Append CompactString to file The encoding of the file is determined based on Byte Order Mark If the file is empty it is written using UTF-16 with Byte Order Mark If the encoding can not be determined the file is assumed to be UTF-8",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "appendFile'",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . p)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "break is equivalent to span not",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "break",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:breakEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreakEnd\u003c/a\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e but from the end of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e breakEnd p == spanEnd (not.p)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#breakEnd",
        "fct-type": "function",
        "title": "breakEnd"
      },
      "index": {
        "description": "breakEnd behaves like break but from the end of the CompactString breakEnd spanEnd not.p",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "breakEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate a list of \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate list of CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "concat",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and concatenate the results\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e CompactString) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over CompactString and concatenate the results",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "concatMap",
        "normalized": "(Char-\u003eCompactString)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Map",
        "signature": "(Char-\u003eCompactString)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003econs\u003c/a\u003e\u003c/code\u003e is analogous to (:) for lists, but of different\n complexity, as it requires a memcpy.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "cons is analogous to for lists but of different complexity as it requires memcpy",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "cons",
        "normalized": "Char-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:count",
      "description": {
        "fct-descr": "\u003cp\u003ecount returns the number of times its argument appears in the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e count c = length . elemIndices c\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Int",
        "fct-source": "src/Data-CompactString-UTF16.html#count",
        "fct-type": "function",
        "title": "count"
      },
      "index": {
        "description": "count returns the number of times its argument appears in the CompactString count length elemIndices",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "count",
        "normalized": "Char-\u003eCompactString-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a ByteString to a CompactString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e decode e = recode =\u003c\u003c fromByteString\n\u003c/pre\u003e\u003cp\u003ebut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eFails if the ByteString is not a valid encoded string\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "Decode ByteString to CompactString using the given encoding decode recode fromByteString but it might be faster for some combinations of encodings Fails if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "decode",
        "normalized": "a-\u003eByteString-\u003eb CompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:decodeBOM",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, by investigating the Byte Order Mark.\n   If there is no BOM assumes UTF-8.\n   Fails if the input is not a valid encoded string\n\u003c/p\u003e\u003cp\u003eFor portability, this function should be prefered over \u003ccode\u003edecode UTF8\u003c/code\u003e when reading files.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#decodeBOM",
        "fct-type": "function",
        "title": "decodeBOM"
      },
      "index": {
        "description": "Decode ByteString into CompactString by investigating the Byte Order Mark If there is no BOM assumes UTF-8 Fails if the input is not valid encoded string For portability this function should be prefered over decode UTF8 when reading files",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "decodeBOM",
        "normalized": "ByteString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "ByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:decodeBOM_",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, by investigating the Byte Order Mark.\n   If there is no BOM assumes UTF-8.\n   Raises an error if the input is not a valid encoded string\n\u003c/p\u003e\u003cp\u003eFor portability, this function should be prefered over \u003ccode\u003edecode UTF8\u003c/code\u003e when reading files.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#decodeBOM_",
        "fct-type": "function",
        "title": "decodeBOM_"
      },
      "index": {
        "description": "Decode ByteString into CompactString by investigating the Byte Order Mark If there is no BOM assumes UTF-8 Raises an error if the input is not valid encoded string For portability this function should be prefered over decode UTF8 when reading files",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "decodeBOM_",
        "normalized": "ByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "ByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:decode_",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a ByteString to a CompactString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e decode_ e = recode_ . fromByteString_\n\u003c/pre\u003e\u003cp\u003ebut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eRaises an error if the ByteString is not a valid encoded string\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#decode_",
        "fct-type": "function",
        "title": "decode_"
      },
      "index": {
        "description": "Decode ByteString to CompactString using the given encoding decode recode fromByteString but it might be faster for some combinations of encodings Raises an error if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "decode_",
        "normalized": "a-\u003eByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e returns the suffix of \u003ccode\u003exs\u003c/code\u003e after the first \u003ccode\u003en\u003c/code\u003e\n elements, or \u003ccode\u003eempty\u003c/code\u003e if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "drop xs returns the suffix of xs after the first elements or empty if length xs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "drop",
        "normalized": "Int-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e returns the suffix remaining after \u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "dropWhile xs returns the suffix remaining after takeWhile xs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "dropWhile",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "While",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e is the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e membership predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF16.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "elem is the CompactString membership predicate",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "elem",
        "normalized": "Char-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e function returns the index of the first\n element in the given \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e which is equal to the query\n element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-UTF16.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "The elemIndex function returns the index of the first element in the given ByteString which is equal to the query element or Nothing if there is no such element",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "elemIndex",
        "normalized": "Char-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index",
        "signature": "Char-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:elemIndexEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndexEnd\u003c/a\u003e\u003c/code\u003e function returns the last index of the\n element in the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e which is equal to the query\n element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. The following\n holds:\n\u003c/p\u003e\u003cpre\u003e elemIndexEnd c xs == \n (-) (length xs - 1) `fmap` elemIndex c (reverse xs)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-UTF16.html#elemIndexEnd",
        "fct-type": "function",
        "title": "elemIndexEnd"
      },
      "index": {
        "description": "The elemIndexEnd function returns the last index of the element in the given CompactString which is equal to the query element or Nothing if there is no such element The following holds elemIndexEnd xs length xs fmap elemIndex reverse xs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "elemIndexEnd",
        "normalized": "Char-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index End",
        "signature": "Char-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e, by returning\n the indices of all elements equal to the query element, in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e [Int]",
        "fct-source": "src/Data-CompactString-UTF16.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "The elemIndices function extends elemIndex by returning the indices of all elements equal to the query element in ascending order",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "elemIndices",
        "normalized": "Char-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Indices",
        "signature": "Char-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e The empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "The empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "empty",
        "normalized": "",
        "package": "compact-string",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a CompactString to a ByteString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e encode e = liftM toByteString . recode\n\u003c/pre\u003e\u003cp\u003eBut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eFails if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e m ByteString",
        "fct-source": "src/Data-CompactString-UTF16.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Encode CompactString to ByteString using the given encoding encode liftM toByteString recode But it might be faster for some combinations of encodings Fails if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "encode",
        "normalized": "a-\u003eCompactString-\u003eb ByteString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eCompactString-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:encodeBOM",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e using the given encoding, and add a Byte Order Mark.\n   Byte Order Marks are common on Windows, but not on other platforms.\n\u003c/p\u003e\u003cp\u003eFails if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e m ByteString",
        "fct-source": "src/Data-CompactString-UTF16.html#encodeBOM",
        "fct-type": "function",
        "title": "encodeBOM"
      },
      "index": {
        "description": "Encode CompactString using the given encoding and add Byte Order Mark Byte Order Marks are common on Windows but not on other platforms Fails if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "encodeBOM",
        "normalized": "a-\u003eCompactString-\u003eb ByteString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "e-\u003eCompactString-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:encodeBOM_",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e using the given encoding, and add a Byte Order Mark.\n   Byte Order Marks are common on Windows, but not on other platforms.\n\u003c/p\u003e\u003cp\u003eRaises an error if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-UTF16.html#encodeBOM_",
        "fct-type": "function",
        "title": "encodeBOM_"
      },
      "index": {
        "description": "Encode CompactString using the given encoding and add Byte Order Mark Byte Order Marks are common on Windows but not on other platforms Raises an error if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "encodeBOM_",
        "normalized": "a-\u003eCompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "e-\u003eCompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:encode_",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a CompactString to a ByteString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e encode_ e = toByteString . recode\n\u003c/pre\u003e\u003cp\u003eBut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eRaises an error if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-UTF16.html#encode_",
        "fct-type": "function",
        "title": "encode_"
      },
      "index": {
        "description": "Encode CompactString to ByteString using the given encoding encode toByteString recode But it might be faster for some combinations of encodings Raises an error if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "encode_",
        "normalized": "a-\u003eCompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eCompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n returns a CompactString containing those characters that satisfy the\n predicate. This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "filter applied to predicate and CompactString returns CompactString containing those characters that satisfy the predicate This function is subject to array fusion",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "filter",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e function takes a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n and returns the first element in matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if there is no such element.\n\u003c/p\u003e\u003cpre\u003e find f p = case findIndex f p of Just n -\u003e Just (p `index` n) ; _ -\u003e Nothing\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Char",
        "fct-source": "src/Data-CompactString-UTF16.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "The find function takes predicate and CompactString and returns the first element in matching the predicate or Nothing if there is no such element find case findIndex of Just Just index Nothing",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "find",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Char",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e function takes a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and\n returns the index of the first element in the CompactString\n satisfying the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-UTF16.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "The findIndex function takes predicate and CompactString and returns the index of the first element in the CompactString satisfying the predicate",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "findIndex",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:findIndexEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003efindIndexEnd\u003c/a\u003e\u003c/code\u003e function returns the last index of the\n element in the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e which satisfies the predicate,\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. The following holds:\n\u003c/p\u003e\u003cpre\u003e findIndexEnd c xs == \n (-) (length xs - 1) `fmap` findIndex c (reverse xs)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-UTF16.html#findIndexEnd",
        "fct-type": "function",
        "title": "findIndexEnd"
      },
      "index": {
        "description": "The findIndexEnd function returns the last index of the element in the given CompactString which satisfies the predicate or Nothing if there is no such element The following holds findIndexEnd xs length xs fmap findIndex reverse xs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "findIndexEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e, by returning the\n indices of all elements satisfying the predicate, in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e [Int]",
        "fct-source": "src/Data-CompactString-UTF16.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "The findIndices function extends findIndex by returning the indices of all elements satisfying the predicate in ascending order",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "findIndices",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Indices",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:findSubstring",
      "description": {
        "fct-descr": "\u003cp\u003eGet the first index of a substring in another string,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not found.\n   \u003ccode\u003efindSubstring p s\u003c/code\u003e is equivalent to \u003ccode\u003elistToMaybe (findSubstrings p s)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e Maybe Int",
        "fct-type": "function",
        "title": "findSubstring"
      },
      "index": {
        "description": "Get the first index of substring in another string or Nothing if the string is not found findSubstring is equivalent to listToMaybe findSubstrings",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "findSubstring",
        "normalized": "CompactString-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Substring",
        "signature": "CompactString-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:findSubstrings",
      "description": {
        "fct-descr": "\u003cp\u003eFind the indexes of all (possibly overlapping) occurances of a\n substring in a string.  This function uses the Knuth-Morris-Pratt\n string matching algorithm.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e [Int]",
        "fct-type": "function",
        "title": "findSubstrings"
      },
      "index": {
        "description": "Find the indexes of all possibly overlapping occurances of substring in string This function uses the Knuth-Morris-Pratt string matching algorithm",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "findSubstrings",
        "normalized": "CompactString-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Substrings",
        "signature": "CompactString-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value (typically\n the left-identity of the operator), and a CompactString, reduces the\n CompactString using the binary operator, from left to right.\n This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-UTF16.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "foldl applied to binary operator starting value typically the left-identity of the operator and CompactString reduces the CompactString using the binary operator from left to right This function is subject to array fusion",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "foldl",
        "normalized": "(a-\u003eChar-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldl\\'' is like \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but strict in the accumulator.\n Though actually foldl is also strict in the accumulator.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-UTF16.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "foldl is like foldl but strict in the accumulator Though actually foldl is also strict in the accumulator",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "foldl'",
        "normalized": "(a-\u003eChar-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e that has no starting value\n argument, and thus must be applied to non-empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n This function is subject to array fusion. \n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "foldl1 is variant of foldl that has no starting value argument and thus must be applied to non-empty CompactString This function is subject to array fusion An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "foldl1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldl1\\'' is like \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e, but strict in the accumulator.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "foldl1 is like foldl1 but strict in the accumulator An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "foldl1'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value\n (typically the right-identity of the operator), and a CompactString,\n reduces the CompactString using the binary operator, from right to left.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e acc -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-UTF16.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "foldr applied to binary operator starting value typically the right-identity of the operator and CompactString reduces the CompactString using the binary operator from right to left",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "foldr",
        "normalized": "(Char-\u003ea-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eacc-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value\n (typically the right-identity of the operator), and a CompactString,\n reduces the CompactString using the binary operator, from right to left.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e acc -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-UTF16.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "foldr applied to binary operator starting value typically the right-identity of the operator and CompactString reduces the CompactString using the binary operator from right to left",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "foldr'",
        "normalized": "(Char-\u003ea-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eacc-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e that has no starting value argument,\n and thus must be applied to non-empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "foldr1 is variant of foldr that has no starting value argument and thus must be applied to non-empty CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "foldr1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldr1\\'' is a variant of \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e, but is strict in the\n accumulator.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "foldr1 is variant of foldr1 but is strict in the accumulator An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "foldr1'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:fromByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString.\n   Fails if the ByteString is not a valid encoded string.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#fromByteString",
        "fct-type": "function",
        "title": "fromByteString"
      },
      "index": {
        "description": "Convert ByteString to CompactString Fails if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "fromByteString",
        "normalized": "ByteString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "ByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:fromByteString_",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString.\n   Raises an error if the ByteString is not a valid encoded string.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#fromByteString_",
        "fct-type": "function",
        "title": "fromByteString_"
      },
      "index": {
        "description": "Convert ByteString to CompactString Raises an error if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "fromByteString_",
        "normalized": "ByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "ByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:getContents",
      "description": {
        "fct-descr": "\u003cp\u003egetContents. Equivalent to \u003ccode\u003ehGetContents stdin\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eInput is assumed to be in UTF-16, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#getContents",
        "fct-type": "function",
        "title": "getContents"
      },
      "index": {
        "description": "getContents Equivalent to hGetContents stdin Input is assumed to be in UTF-16 this may not be appropriate",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "getContents",
        "normalized": "",
        "package": "compact-string",
        "partial": "Contents",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:getLine",
      "description": {
        "fct-descr": "\u003cp\u003eRead a line from stdin.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#getLine",
        "fct-type": "function",
        "title": "getLine"
      },
      "index": {
        "description": "Read line from stdin",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "getLine",
        "normalized": "",
        "package": "compact-string",
        "partial": "Line",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:group",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and returns a list of\n CompactStrings such that the concatenation of the result is equal to the\n argument.  Moreover, each sublist in the result contains only equal\n elements.  For example,\n\u003c/p\u003e\u003cpre\u003e group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own equality test.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#group",
        "fct-type": "function",
        "title": "group"
      },
      "index": {
        "description": "The group function takes CompactString and returns list of CompactStrings such that the concatenation of the result is equal to the argument Moreover each sublist in the result contains only equal elements For example group Mississippi ss ss pp It is special case of groupBy which allows the programmer to supply their own equality test",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "group",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:groupBy",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Bool) -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#groupBy",
        "fct-type": "function",
        "title": "groupBy"
      },
      "index": {
        "description": "The groupBy function is the non-overloaded version of group",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "groupBy",
        "normalized": "(Char-\u003eChar-\u003eBool)-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "By",
        "signature": "(Char-\u003eChar-\u003eBool)-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:hGet",
      "description": {
        "fct-descr": "\u003cp\u003eRead a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e directly from the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e Int -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#hGet",
        "fct-type": "function",
        "title": "hGet"
      },
      "index": {
        "description": "Read CompactString directly from the specified Handle The handle is interpreted as UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "hGet",
        "normalized": "Handle-\u003eInt-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get",
        "signature": "Handle-\u003eInt-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:hGetContents",
      "description": {
        "fct-descr": "\u003cp\u003eRead entire handle contents into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#hGetContents",
        "fct-type": "function",
        "title": "hGetContents"
      },
      "index": {
        "description": "Read entire handle contents into CompactString The handle is interpreted as UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "hGetContents",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Contents",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:hGetContents-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRead entire handle contents into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe encoding is determined based on a Byte Order Mark, see \u003ccode\u003e\u003ca\u003edecodeBOM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#hGetContents%27",
        "fct-type": "function",
        "title": "hGetContents'"
      },
      "index": {
        "description": "Read entire handle contents into CompactString The encoding is determined based on Byte Order Mark see decodeBOM",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "hGetContents'",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Contents'",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:hGetLine",
      "description": {
        "fct-descr": "\u003cp\u003eRead a line from a handle\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#hGetLine",
        "fct-type": "function",
        "title": "hGetLine"
      },
      "index": {
        "description": "Read line from handle",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "hGetLine",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Line",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:hGetNonBlocking",
      "description": {
        "fct-descr": "\u003cp\u003ehGetNonBlocking is identical to \u003ccode\u003e\u003ca\u003ehGet\u003c/a\u003e\u003c/code\u003e, except that it will never block\n waiting for data to become available, instead it returns only whatever data\n is available.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e Int -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#hGetNonBlocking",
        "fct-type": "function",
        "title": "hGetNonBlocking"
      },
      "index": {
        "description": "hGetNonBlocking is identical to hGet except that it will never block waiting for data to become available instead it returns only whatever data is available The handle is interpreted as UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "hGetNonBlocking",
        "normalized": "Handle-\u003eInt-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Non Blocking",
        "signature": "Handle-\u003eInt-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:hPut",
      "description": {
        "fct-descr": "\u003cp\u003eOutputs a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eOutput is written in UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#hPut",
        "fct-type": "function",
        "title": "hPut"
      },
      "index": {
        "description": "Outputs CompactString to the specified Handle Output is written in UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "hPut",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:hPutStr",
      "description": {
        "fct-descr": "\u003cp\u003eA synonym for \u003ccode\u003ehPut\u003c/code\u003e, for compatibility \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#hPutStr",
        "fct-type": "function",
        "title": "hPutStr"
      },
      "index": {
        "description": "synonym for hPut for compatibility",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "hPutStr",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put Str",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:hPutStrLn",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a handle, appending a newline byte\n\u003c/p\u003e\u003cp\u003eOutput is written in UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#hPutStrLn",
        "fct-type": "function",
        "title": "hPutStrLn"
      },
      "index": {
        "description": "Write CompactString to handle appending newline byte Output is written in UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "hPutStrLn",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put Str Ln",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the first element of a CompactString, which must be non-empty.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "Extract the first element of CompactString which must be non-empty An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "head",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:headView",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e A view of the front of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e headView s = if null s then Nothing else Just (head s, tail s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Maybe (Char, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#headView",
        "fct-type": "function",
        "title": "headView"
      },
      "index": {
        "description": "view of the front of CompactString headView if null then Nothing else Just head tail",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "headView",
        "normalized": "CompactString-\u003eMaybe(Char,CompactString)",
        "package": "compact-string",
        "partial": "View",
        "signature": "CompactString-\u003eMaybe(Char,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:index",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e index (subscript) operator, starting from 0.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Int -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#index",
        "fct-type": "function",
        "title": "index"
      },
      "index": {
        "description": "CompactString index subscript operator starting from",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "index",
        "normalized": "CompactString-\u003eInt-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eInt-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Return all the elements of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e except the last one.\n An exception will be thrown in the case of an empty ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Return all the elements of CompactString except the last one An exception will be thrown in the case of an empty ByteString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "init",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:inits",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Return all initial segments of the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, shortest first.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#inits",
        "fct-type": "function",
        "title": "inits"
      },
      "index": {
        "description": "Return all initial segments of the given CompactString shortest first",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "inits",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:interact",
      "description": {
        "fct-descr": "\u003cp\u003eThe interact function takes a function of type \u003ccode\u003eCompactString -\u003e CompactString\u003c/code\u003e\n as its argument. The entire input from the standard input device is passed\n to this function as its argument, and the resulting string is output on the\n standard output device. It's great for writing one line programs!\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(CompactString -\u003e CompactString) -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#interact",
        "fct-type": "function",
        "title": "interact"
      },
      "index": {
        "description": "The interact function takes function of type CompactString CompactString as its argument The entire input from the standard input device is passed to this function as its argument and the resulting string is output on the standard output device It great for writing one line programs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "interact",
        "normalized": "(CompactString-\u003eCompactString)-\u003eIO()",
        "package": "compact-string",
        "partial": "",
        "signature": "(CompactString-\u003eCompactString)-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:intercalate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and a list of\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es and concatenates the list after interspersing the first\n argument between each element of the list.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#intercalate",
        "fct-type": "function",
        "title": "intercalate"
      },
      "index": {
        "description": "The intercalate function takes CompactString and list of CompactString and concatenates the list after interspersing the first argument between each element of the list",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "intercalate",
        "normalized": "CompactString-\u003e[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:intersperse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eintersperse\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e and a\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and `intersperses' that character between the elements of\n the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  It is analogous to the intersperse function on\n Lists.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#intersperse",
        "fct-type": "function",
        "title": "intersperse"
      },
      "index": {
        "description": "The intersperse function takes Char and CompactString and intersperses that character between the elements of the CompactString It is analogous to the intersperse function on Lists",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "intersperse",
        "normalized": "Char-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:isInfixOf",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether one string is a substring of another. \u003ccode\u003eisInfixOf\n p s\u003c/code\u003e is equivalent to \u003ccode\u003enot (null (findSubstrings p s))\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e Bool",
        "fct-type": "function",
        "title": "isInfixOf"
      },
      "index": {
        "description": "Check whether one string is substring of another isInfixOf is equivalent to not null findSubstrings",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "isInfixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Infix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:isPrefixOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eisPrefixOf\u003c/a\u003e\u003c/code\u003e function takes two CompactString and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first is a prefix of the second.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF16.html#isPrefixOf",
        "fct-type": "function",
        "title": "isPrefixOf"
      },
      "index": {
        "description": "The isPrefixOf function takes two CompactString and returns True iff the first is prefix of the second",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "isPrefixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Prefix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:isSuffixOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eisSuffixOf\u003c/a\u003e\u003c/code\u003e function takes two CompactString and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first is a suffix of the second.\n\u003c/p\u003e\u003cp\u003eThe following holds:\n\u003c/p\u003e\u003cpre\u003e isSuffixOf x y == reverse x `isPrefixOf` reverse y\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF16.html#isSuffixOf",
        "fct-type": "function",
        "title": "isSuffixOf"
      },
      "index": {
        "description": "The isSuffixOf function takes two CompactString and returns True iff the first is suffix of the second The following holds isSuffixOf reverse isPrefixOf reverse",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "isSuffixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Suffix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the last element of a ByteString, which must be finite and non-empty.\n An exception will be thrown in the case of an empty ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Extract the last element of ByteString which must be finite and non-empty An exception will be thrown in the case of an empty ByteString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "last",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:lastView",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e A view of the back of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e lastView s = if null s then Nothing else Just (init s, last s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Maybe (CompactString, Char)",
        "fct-source": "src/Data-CompactString-UTF16.html#lastView",
        "fct-type": "function",
        "title": "lastView"
      },
      "index": {
        "description": "view of the back of CompactString lastView if null then Nothing else Just init last",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "lastView",
        "normalized": "CompactString-\u003eMaybe(CompactString,Char)",
        "package": "compact-string",
        "partial": "View",
        "signature": "CompactString-\u003eMaybe(CompactString,Char)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e returns the length of a CompactString as an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Int",
        "fct-source": "src/Data-CompactString-UTF16.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "length returns the length of CompactString as an Int",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "length",
        "normalized": "CompactString-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:lines",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e breaks a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e up into a list of CompactStrings at\n newline Chars. The resulting strings do not contain newlines.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#lines",
        "fct-type": "function",
        "title": "lines"
      },
      "index": {
        "description": "lines breaks CompactString up into list of CompactStrings at newline Chars The resulting strings do not contain newlines",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "lines",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef xs\u003c/code\u003e is the CompactString obtained by applying \u003ccode\u003ef\u003c/code\u003e to each\n element of \u003ccode\u003exs\u003c/code\u003e. This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "map xs is the CompactString obtained by applying to each element of xs This function is subject to array fusion",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "map",
        "normalized": "(Char-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:mapAccumL",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a CompactString,\n passing an accumulating parameter from left to right, and returning a\n final value of this accumulator together with the new CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e acc -\u003e CompactString -\u003e (acc, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#mapAccumL",
        "fct-type": "function",
        "title": "mapAccumL"
      },
      "index": {
        "description": "The mapAccumL function behaves like combination of map and foldl it applies function to each element of CompactString passing an accumulating parameter from left to right and returning final value of this accumulator together with the new CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "mapAccumL",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003ea-\u003eCompactString-\u003e(a,CompactString)",
        "package": "compact-string",
        "partial": "Accum",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eacc-\u003eCompactString-\u003e(acc,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:mapAccumR",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a CompactString,\n passing an accumulating parameter from right to left, and returning a\n final value of this accumulator together with the new CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e acc -\u003e CompactString -\u003e (acc, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#mapAccumR",
        "fct-type": "function",
        "title": "mapAccumR"
      },
      "index": {
        "description": "The mapAccumR function behaves like combination of map and foldr it applies function to each element of CompactString passing an accumulating parameter from right to left and returning final value of this accumulator together with the new CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "mapAccumR",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003ea-\u003eCompactString-\u003e(a,CompactString)",
        "package": "compact-string",
        "partial": "Accum",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eacc-\u003eCompactString-\u003e(acc,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:mapIndexed",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e map Char functions, provided with the index at each position.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Int -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#mapIndexed",
        "fct-type": "function",
        "title": "mapIndexed"
      },
      "index": {
        "description": "map Char functions provided with the index at each position",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "mapIndexed",
        "normalized": "(Int-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Indexed",
        "signature": "(Int-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003emaximum\u003c/a\u003e\u003c/code\u003e returns the maximum value from a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "maximum returns the maximum value from CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "maximum",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eminimum\u003c/a\u003e\u003c/code\u003e returns the minimum value from a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF16.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "minimum returns the minimum value from CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "minimum",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003enotElem\u003c/a\u003e\u003c/code\u003e is the inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF16.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "notElem is the inverse of elem",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "notElem",
        "normalized": "Char-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Elem",
        "signature": "Char-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a CompactString is empty.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF16.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether CompactString is empty",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "null",
        "normalized": "CompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:pack",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "String -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#pack",
        "fct-type": "function",
        "title": "pack"
      },
      "index": {
        "description": "Convert String into CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "pack",
        "normalized": "String-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "String-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n returns a pair of CompactStrings.\n The first containing those characters that satisfy the predicate,\n the second containg those that don't.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "partition applied to predicate and CompactString returns pair of CompactStrings The first containing those characters that satisfy the predicate the second containg those that don",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "partition",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:putStr",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to stdout.\n\u003c/p\u003e\u003cp\u003eOutput is written in UTF-16, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#putStr",
        "fct-type": "function",
        "title": "putStr"
      },
      "index": {
        "description": "Write CompactString to stdout Output is written in UTF-16 this may not be appropriate",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "putStr",
        "normalized": "CompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Str",
        "signature": "CompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:putStrLn",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to stdout, appending a newline character.\n\u003c/p\u003e\u003cp\u003eOutput is written in UTF-16, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#putStrLn",
        "fct-type": "function",
        "title": "putStrLn"
      },
      "index": {
        "description": "Write CompactString to stdout appending newline character Output is written in UTF-16 this may not be appropriate",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "putStrLn",
        "normalized": "CompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Str Ln",
        "signature": "CompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:readFile",
      "description": {
        "fct-descr": "\u003cp\u003eRead an entire file strictly into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  This is far more\n   efficient than reading the characters into a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and then using\n   \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e. Files are read using 'text mode' on Windows.\n\u003c/p\u003e\u003cp\u003eFiles are assumed to be in UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#readFile",
        "fct-type": "function",
        "title": "readFile"
      },
      "index": {
        "description": "Read an entire file strictly into CompactString This is far more efficient than reading the characters into String and then using pack Files are read using text mode on Windows Files are assumed to be in UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "readFile",
        "normalized": "FilePath-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:readFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRead an entire file strictly into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  This is far more\n   efficient than reading the characters into a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and then using\n   \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e. Files are read using 'text mode' on Windows.\n\u003c/p\u003e\u003cp\u003eThe encoding of the file is determined based on a Byte Order Mark, see \u003ccode\u003e\u003ca\u003edecodeBOM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#readFile%27",
        "fct-type": "function",
        "title": "readFile'"
      },
      "index": {
        "description": "Read an entire file strictly into CompactString This is far more efficient than reading the characters into String and then using pack Files are read using text mode on Windows The encoding of the file is determined based on Byte Order Mark see decodeBOM",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "readFile'",
        "normalized": "FilePath-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en x\u003c/code\u003e is a CompactString of length \u003ccode\u003en\u003c/code\u003e with \u003ccode\u003ex\u003c/code\u003e\n the value of every element. The following holds:\n\u003c/p\u003e\u003cpre\u003e replicate w c = unfoldr w (\\u -\u003e Just (u,u)) c\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "replicate is CompactString of length with the value of every element The following holds replicate unfoldr Just",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "replicate",
        "normalized": "Int-\u003eChar-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eChar-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003eReverse a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "reverse",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e is similar to \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but returns a list of successive\n reduced values from the left. This function will fuse.\n\u003c/p\u003e\u003cpre\u003e scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\n\u003c/pre\u003e\u003cp\u003eNote that\n\u003c/p\u003e\u003cpre\u003e last (scanl f z xs) == foldl f z xs.\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "scanl is similar to foldl but returns list of successive reduced values from the left This function will fuse scanl x1 x2 x1 x1 x2 Note that last scanl xs foldl xs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "scanl",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n This function will fuse.\n\u003c/p\u003e\u003cpre\u003e scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "scanl1 is variant of scanl that has no starting value argument This function will fuse scanl1 x1 x2 x1 x1 x2",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "scanl1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003escanr is the right-to-left dual of scanl.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "scanr is the right-to-left dual of scanl",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "scanr",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "scanr1 is variant of scanr that has no starting value argument",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "scanr1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Convert Char into CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "singleton",
        "normalized": "Char-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append a byte to the end of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append byte to the end of CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "snoc",
        "normalized": "CompactString-\u003eChar-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:sort",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e Sort a CompactString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#sort",
        "fct-type": "function",
        "title": "sort"
      },
      "index": {
        "description": "log Sort CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "sort",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e breaks the ByteString into two segments. It is\n equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e p xs, \u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e p xs)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "span xs breaks the ByteString into two segments It is equivalent to takeWhile xs dropWhile xs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "span",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:spanEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espanEnd\u003c/a\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e but from the end of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWe have\n\u003c/p\u003e\u003cpre\u003e spanEnd (not.isSpace) \"x y z\" == (\"x y \",\"z\")\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e spanEnd (not . isSpace) cs\n    == \n let (x,y) = span (not.isSpace) (reverse cs) in (reverse y, reverse x)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#spanEnd",
        "fct-type": "function",
        "title": "spanEnd"
      },
      "index": {
        "description": "spanEnd behaves like span but from the end of the CompactString We have spanEnd not.isSpace and spanEnd not isSpace cs let span not.isSpace reverse cs in reverse reverse",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "spanEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:split",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Break a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into pieces separated by the byte\n argument, consuming the delimiter. I.e.\n\u003c/p\u003e\u003cpre\u003e split '\\n' \"a\\nb\\nd\\ne\" == [\"a\",\"b\",\"d\",\"e\"]\n split 'a'  \"aXaXaXa\"    == [\"\",\"X\",\"X\",\"X\",\"\"]\n split 'x'  \"x\"          == [\"\",\"\"]\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e intercalate [c] . split c == id\n split == splitWith . (==)\n\u003c/pre\u003e\u003cp\u003eAs for all splitting functions in this library, this function does\n not copy the substrings, it just constructs new \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e that\n are slices of the original.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#split",
        "fct-type": "function",
        "title": "split"
      },
      "index": {
        "description": "Break ByteString into pieces separated by the byte argument consuming the delimiter I.e split nb nd ne split aXaXaXa split and intercalate split id split splitWith As for all splitting functions in this library this function does not copy the substrings it just constructs new CompactString that are slices of the original",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "split",
        "normalized": "Char-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n xs)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "splitAt xs is equivalent to take xs drop xs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "splitAt",
        "normalized": "Int-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "At",
        "signature": "Int-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:splitWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Splits a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e into components delimited by\n separators, where the predicate returns True for a separator element.\n The resulting components do not contain the separators.  Two adjacent\n separators result in an empty component in the output.  eg.\n\u003c/p\u003e\u003cpre\u003e splitWith (=='a') \"aabbaca\" == [\"\",\"\",\"bb\",\"c\",\"\"]\n splitWith (=='a') []        == []\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#splitWith",
        "fct-type": "function",
        "title": "splitWith"
      },
      "index": {
        "description": "Splits CompactString into components delimited by separators where the predicate returns True for separator element The resulting components do not contain the separators Two adjacent separators result in an empty component in the output eg splitWith aabbaca bb splitWith",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "splitWith",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "With",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the elements after the head of a CompactString, which must be non-empty.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Extract the elements after the head of CompactString which must be non-empty An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "tail",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:tails",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Return all final segments of the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, longest first.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#tails",
        "fct-type": "function",
        "title": "tails"
      },
      "index": {
        "description": "Return all final segments of the given CompactString longest first",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "tails",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en\u003c/code\u003e, applied to a CompactString \u003ccode\u003exs\u003c/code\u003e, returns the prefix\n of \u003ccode\u003exs\u003c/code\u003e of length \u003ccode\u003en\u003c/code\u003e, or \u003ccode\u003exs\u003c/code\u003e itself if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "take applied to CompactString xs returns the prefix of xs of length or xs itself if length xs",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "take",
        "normalized": "Int-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e, applied to a predicate \u003ccode\u003ep\u003c/code\u003e and a CompactString \u003ccode\u003exs\u003c/code\u003e,\n returns the longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n satisfy \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "takeWhile applied to predicate and CompactString xs returns the longest prefix possibly empty of xs of elements that satisfy",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "takeWhile",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "While",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:toByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a CompactString to a ByteString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-UTF16.html#toByteString",
        "fct-type": "function",
        "title": "toByteString"
      },
      "index": {
        "description": "Convert CompactString to ByteString",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "toByteString",
        "normalized": "CompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "CompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:transpose",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e function transposes the rows and columns of its\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e argument.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#transpose",
        "fct-type": "function",
        "title": "transpose"
      },
      "index": {
        "description": "The transpose function transposes the rows and columns of its CompactString argument",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "transpose",
        "normalized": "[CompactString]-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e, where \u003cem\u003en\u003c/em\u003e is the length of the result.  The \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e \n function is analogous to the List 'unfoldr'.  \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e builds a \n ByteString from a seed value.  The function takes the element and \n returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it is done producing the CompactString or returns \n \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(a,b)\u003c/code\u003e, in which case, \u003ccode\u003ea\u003c/code\u003e is the next byte in the string, \n and \u003ccode\u003eb\u003c/code\u003e is the seed value for further production.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e    unfoldr (\\x -\u003e if x \u003c= 5 then Just (x, x + 1) else Nothing) 0\n == pack [0, 1, 2, 3, 4, 5]\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Maybe (Char, acc)) -\u003e acc -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "where is the length of the result The unfoldr function is analogous to the List unfoldr unfoldr builds ByteString from seed value The function takes the element and returns Nothing if it is done producing the CompactString or returns Just in which case is the next byte in the string and is the seed value for further production Examples unfoldr if then Just else Nothing pack",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(Char,a))-\u003ea-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eMaybe(Char,acc))-\u003eacc-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Like \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e builds a ByteString from a seed\n value.  However, the length of the result is limited by the first\n argument to \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e.  This function is more efficient than \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e\n when the maximum length of the result is known.\n\u003c/p\u003e\u003cp\u003eThe following equation relates \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e fst (unfoldrN n f s) == take n (unfoldr f s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e (acc -\u003e Maybe (Char, acc)) -\u003e acc -\u003e (CompactString, Maybe acc)",
        "fct-source": "src/Data-CompactString-UTF16.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Like unfoldr unfoldrN builds ByteString from seed value However the length of the result is limited by the first argument to unfoldrN This function is more efficient than unfoldr when the maximum length of the result is known The following equation relates unfoldrN and unfoldr fst unfoldrN take unfoldr",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(Char,a))-\u003ea-\u003e(CompactString,Maybe a)",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003e(acc-\u003eMaybe(Char,acc))-\u003eacc-\u003e(CompactString,Maybe acc)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:unlines",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e is an inverse operation to \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e.  It joins lines,\n after appending a terminating newline to each.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#unlines",
        "fct-type": "function",
        "title": "unlines"
      },
      "index": {
        "description": "unlines is an inverse operation to lines It joins lines after appending terminating newline to each",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "unlines",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:unpack",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Converts a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e String",
        "fct-source": "src/Data-CompactString-UTF16.html#unpack",
        "fct-type": "function",
        "title": "unpack"
      },
      "index": {
        "description": "Converts CompactString to String",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "unpack",
        "normalized": "CompactString-\u003eString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:unwords",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunwords\u003c/a\u003e\u003c/code\u003e function is analogous to the \u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e function, on words.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#unwords",
        "fct-type": "function",
        "title": "unwords"
      },
      "index": {
        "description": "The unwords function is analogous to the unlines function on words",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "unwords",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e transforms a list of pairs of bytes into a pair of\n CompactStrings. Note that this performs two \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "[(Char, Char)] -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF16.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "unzip transforms list of pairs of bytes into pair of CompactStrings Note that this performs two pack operations",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "unzip",
        "normalized": "[(Char,Char)]-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "[(Char,Char)]-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:validate",
      "description": {
        "fct-descr": "\u003cp\u003eValidates a CompactString.\n   If the string is invalid, fails, otherwise returns the input.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#validate",
        "fct-type": "function",
        "title": "validate"
      },
      "index": {
        "description": "Validates CompactString If the string is invalid fails otherwise returns the input",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "validate",
        "normalized": "CompactString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:validate_",
      "description": {
        "fct-descr": "\u003cp\u003eValidates a CompactString.\n   If the string is invalid, throws an error, otherwise returns the input.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#validate_",
        "fct-type": "function",
        "title": "validate_"
      },
      "index": {
        "description": "Validates CompactString If the string is invalid throws an error otherwise returns the input",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "validate_",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:words",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e breaks a ByteString up into a list of words, which\n were delimited by Chars representing white space. And\n\u003c/p\u003e\u003cpre\u003e words = filter (not . null) . splitWith isSpace\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF16.html#words",
        "fct-type": "function",
        "title": "words"
      },
      "index": {
        "description": "words breaks ByteString up into list of words which were delimited by Chars representing white space And words filter not null splitWith isSpace",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "words",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:writeFile",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using UTF-16.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#writeFile",
        "fct-type": "function",
        "title": "writeFile"
      },
      "index": {
        "description": "Write CompactString to file Files are written using UTF-16",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "writeFile",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:writeFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using UTF-16.\n   A Byte Order Mark is also written.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF16.html#writeFile%27",
        "fct-type": "function",
        "title": "writeFile'"
      },
      "index": {
        "description": "Write CompactString to file Files are written using UTF-16 Byte Order Mark is also written",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "writeFile'",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e takes two ByteStrings and returns a list of\n corresponding pairs of bytes. If one input ByteString is short,\n excess elements of the longer ByteString are discarded. This is\n equivalent to a pair of \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e [(Char, Char)]",
        "fct-source": "src/Data-CompactString-UTF16.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "zip takes two ByteStrings and returns list of corresponding pairs of bytes If one input ByteString is short excess elements of the longer ByteString are discarded This is equivalent to pair of unpack operations",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "zip",
        "normalized": "CompactString-\u003eCompactString-\u003e[(Char,Char)]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString-\u003e[(Char,Char)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e generalises \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e by zipping with the function given as\n the first argument, instead of a tupling function.  For example,\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e (+)\u003c/code\u003e is applied to two ByteStrings to produce the list of\n corresponding sums. \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e b) -\u003e CompactString -\u003e CompactString -\u003e [b]",
        "fct-source": "src/Data-CompactString-UTF16.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "zipWith generalises zip by zipping with the function given as the first argument instead of tupling function For example zipWith is applied to two ByteStrings to produce the list of corresponding sums",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "zipWith",
        "normalized": "(Char-\u003eChar-\u003ea)-\u003eCompactString-\u003eCompactString-\u003e[a]",
        "package": "compact-string",
        "partial": "With",
        "signature": "(Char-\u003eChar-\u003eb)-\u003eCompactString-\u003eCompactString-\u003e[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF16.html#v:zipWith-39-",
      "description": {
        "fct-descr": "\u003cp\u003eA specialised version of \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e for the common case of a\n simultaneous map over two \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es, to build a 3rd. Rewrite rules\n are used to automatically covert zipWith into zipWith' when a pack is\n performed on the result of zipWith, but we also export it for\n convenience.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF16",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF16.html#zipWith%27",
        "fct-type": "function",
        "title": "zipWith'"
      },
      "index": {
        "description": "specialised version of zipWith for the common case of simultaneous map over two CompactString to build rd Rewrite rules are used to automatically covert zipWith into zipWith when pack is performed on the result of zipWith but we also export it for convenience",
        "hierarchy": "Data CompactString UTF16",
        "module": "Data.CompactString.UTF16",
        "name": "zipWith'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "With'",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompactString specialized to UTF-8.\n\u003c/p\u003e\u003cp\u003eThis module can be used to reduce the need for type signatures,\n since in most cases only a single encoding is used.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "module",
        "fct-source": "src/Data-CompactString-UTF8.html",
        "fct-type": "module",
        "title": "UTF8"
      },
      "index": {
        "description": "CompactString specialized to UTF-8 This module can be used to reduce the need for type signatures since in most cases only single encoding is used",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "UTF8",
        "normalized": "",
        "package": "compact-string",
        "partial": "UTF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#t:CompactString",
      "description": {
        "fct-descr": "\u003cp\u003eCompactString specialized to UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "type",
        "fct-source": "src/Data-CompactString-UTF8.html#CompactString",
        "fct-type": "type",
        "title": "CompactString"
      },
      "index": {
        "description": "CompactString specialized to UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "CompactString",
        "normalized": "",
        "package": "compact-string",
        "partial": "Compact String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Applied to a predicate and a CompactString, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if\n all elements of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF8.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Applied to predicate and CompactString any determines if all elements of the CompactString satisfy the predicate",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "all",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Applied to a predicate and a CompactString, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if\n any element of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF8.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Applied to predicate and CompactString any determines if any element of the CompactString satisfies the predicate",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "any",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:append",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append two CompactStrings\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#append",
        "fct-type": "function",
        "title": "append"
      },
      "index": {
        "description": "Append two CompactStrings",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "append",
        "normalized": "CompactString-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:appendFile",
      "description": {
        "fct-descr": "\u003cp\u003eAppend a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#appendFile",
        "fct-type": "function",
        "title": "appendFile"
      },
      "index": {
        "description": "Append CompactString to file Files are written using UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "appendFile",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:appendFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eAppend a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eThe encoding of the file is determined based on a Byte Order Mark.\n   If the file is empty, it is written using UTF-8 with a Byte Order Mark.\n   If the encoding can not be determined the file is assumed to be UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#appendFile%27",
        "fct-type": "function",
        "title": "appendFile'"
      },
      "index": {
        "description": "Append CompactString to file The encoding of the file is determined based on Byte Order Mark If the file is empty it is written using UTF-8 with Byte Order Mark If the encoding can not be determined the file is assumed to be UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "appendFile'",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . p)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "break is equivalent to span not",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "break",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:breakEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreakEnd\u003c/a\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e but from the end of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e breakEnd p == spanEnd (not.p)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#breakEnd",
        "fct-type": "function",
        "title": "breakEnd"
      },
      "index": {
        "description": "breakEnd behaves like break but from the end of the CompactString breakEnd spanEnd not.p",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "breakEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate a list of \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate list of CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "concat",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and concatenate the results\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e CompactString) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over CompactString and concatenate the results",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "concatMap",
        "normalized": "(Char-\u003eCompactString)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Map",
        "signature": "(Char-\u003eCompactString)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003econs\u003c/a\u003e\u003c/code\u003e is analogous to (:) for lists, but of different\n complexity, as it requires a memcpy.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "cons is analogous to for lists but of different complexity as it requires memcpy",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "cons",
        "normalized": "Char-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:count",
      "description": {
        "fct-descr": "\u003cp\u003ecount returns the number of times its argument appears in the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e count c = length . elemIndices c\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Int",
        "fct-source": "src/Data-CompactString-UTF8.html#count",
        "fct-type": "function",
        "title": "count"
      },
      "index": {
        "description": "count returns the number of times its argument appears in the CompactString count length elemIndices",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "count",
        "normalized": "Char-\u003eCompactString-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a ByteString to a CompactString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e decode e = recode =\u003c\u003c fromByteString\n\u003c/pre\u003e\u003cp\u003ebut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eFails if the ByteString is not a valid encoded string\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "Decode ByteString to CompactString using the given encoding decode recode fromByteString but it might be faster for some combinations of encodings Fails if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "decode",
        "normalized": "a-\u003eByteString-\u003eb CompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:decodeBOM",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, by investigating the Byte Order Mark.\n   If there is no BOM assumes UTF-8.\n   Fails if the input is not a valid encoded string\n\u003c/p\u003e\u003cp\u003eFor portability, this function should be prefered over \u003ccode\u003edecode UTF8\u003c/code\u003e when reading files.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#decodeBOM",
        "fct-type": "function",
        "title": "decodeBOM"
      },
      "index": {
        "description": "Decode ByteString into CompactString by investigating the Byte Order Mark If there is no BOM assumes UTF-8 Fails if the input is not valid encoded string For portability this function should be prefered over decode UTF8 when reading files",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "decodeBOM",
        "normalized": "ByteString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "ByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:decodeBOM_",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, by investigating the Byte Order Mark.\n   If there is no BOM assumes UTF-8.\n   Raises an error if the input is not a valid encoded string\n\u003c/p\u003e\u003cp\u003eFor portability, this function should be prefered over \u003ccode\u003edecode UTF8\u003c/code\u003e when reading files.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#decodeBOM_",
        "fct-type": "function",
        "title": "decodeBOM_"
      },
      "index": {
        "description": "Decode ByteString into CompactString by investigating the Byte Order Mark If there is no BOM assumes UTF-8 Raises an error if the input is not valid encoded string For portability this function should be prefered over decode UTF8 when reading files",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "decodeBOM_",
        "normalized": "ByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "ByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:decode_",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a ByteString to a CompactString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e decode_ e = recode_ . fromByteString_\n\u003c/pre\u003e\u003cp\u003ebut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eRaises an error if the ByteString is not a valid encoded string\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#decode_",
        "fct-type": "function",
        "title": "decode_"
      },
      "index": {
        "description": "Decode ByteString to CompactString using the given encoding decode recode fromByteString but it might be faster for some combinations of encodings Raises an error if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "decode_",
        "normalized": "a-\u003eByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e returns the suffix of \u003ccode\u003exs\u003c/code\u003e after the first \u003ccode\u003en\u003c/code\u003e\n elements, or \u003ccode\u003eempty\u003c/code\u003e if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "drop xs returns the suffix of xs after the first elements or empty if length xs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "drop",
        "normalized": "Int-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e returns the suffix remaining after \u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "dropWhile xs returns the suffix remaining after takeWhile xs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "dropWhile",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "While",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e is the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e membership predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF8.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "elem is the CompactString membership predicate",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "elem",
        "normalized": "Char-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e function returns the index of the first\n element in the given \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e which is equal to the query\n element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-UTF8.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "The elemIndex function returns the index of the first element in the given ByteString which is equal to the query element or Nothing if there is no such element",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "elemIndex",
        "normalized": "Char-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index",
        "signature": "Char-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:elemIndexEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndexEnd\u003c/a\u003e\u003c/code\u003e function returns the last index of the\n element in the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e which is equal to the query\n element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. The following\n holds:\n\u003c/p\u003e\u003cpre\u003e elemIndexEnd c xs == \n (-) (length xs - 1) `fmap` elemIndex c (reverse xs)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-UTF8.html#elemIndexEnd",
        "fct-type": "function",
        "title": "elemIndexEnd"
      },
      "index": {
        "description": "The elemIndexEnd function returns the last index of the element in the given CompactString which is equal to the query element or Nothing if there is no such element The following holds elemIndexEnd xs length xs fmap elemIndex reverse xs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "elemIndexEnd",
        "normalized": "Char-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index End",
        "signature": "Char-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e, by returning\n the indices of all elements equal to the query element, in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e [Int]",
        "fct-source": "src/Data-CompactString-UTF8.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "The elemIndices function extends elemIndex by returning the indices of all elements equal to the query element in ascending order",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "elemIndices",
        "normalized": "Char-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Indices",
        "signature": "Char-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e The empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "The empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "empty",
        "normalized": "",
        "package": "compact-string",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a CompactString to a ByteString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e encode e = liftM toByteString . recode\n\u003c/pre\u003e\u003cp\u003eBut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eFails if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e m ByteString",
        "fct-source": "src/Data-CompactString-UTF8.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Encode CompactString to ByteString using the given encoding encode liftM toByteString recode But it might be faster for some combinations of encodings Fails if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "encode",
        "normalized": "a-\u003eCompactString-\u003eb ByteString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eCompactString-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:encodeBOM",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e using the given encoding, and add a Byte Order Mark.\n   Byte Order Marks are common on Windows, but not on other platforms.\n\u003c/p\u003e\u003cp\u003eFails if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e m ByteString",
        "fct-source": "src/Data-CompactString-UTF8.html#encodeBOM",
        "fct-type": "function",
        "title": "encodeBOM"
      },
      "index": {
        "description": "Encode CompactString using the given encoding and add Byte Order Mark Byte Order Marks are common on Windows but not on other platforms Fails if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "encodeBOM",
        "normalized": "a-\u003eCompactString-\u003eb ByteString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "e-\u003eCompactString-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:encodeBOM_",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e using the given encoding, and add a Byte Order Mark.\n   Byte Order Marks are common on Windows, but not on other platforms.\n\u003c/p\u003e\u003cp\u003eRaises an error if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-UTF8.html#encodeBOM_",
        "fct-type": "function",
        "title": "encodeBOM_"
      },
      "index": {
        "description": "Encode CompactString using the given encoding and add Byte Order Mark Byte Order Marks are common on Windows but not on other platforms Raises an error if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "encodeBOM_",
        "normalized": "a-\u003eCompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "e-\u003eCompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:encode_",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a CompactString to a ByteString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e encode_ e = toByteString . recode\n\u003c/pre\u003e\u003cp\u003eBut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eRaises an error if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-UTF8.html#encode_",
        "fct-type": "function",
        "title": "encode_"
      },
      "index": {
        "description": "Encode CompactString to ByteString using the given encoding encode toByteString recode But it might be faster for some combinations of encodings Raises an error if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "encode_",
        "normalized": "a-\u003eCompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eCompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n returns a CompactString containing those characters that satisfy the\n predicate. This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "filter applied to predicate and CompactString returns CompactString containing those characters that satisfy the predicate This function is subject to array fusion",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "filter",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e function takes a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n and returns the first element in matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if there is no such element.\n\u003c/p\u003e\u003cpre\u003e find f p = case findIndex f p of Just n -\u003e Just (p `index` n) ; _ -\u003e Nothing\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Char",
        "fct-source": "src/Data-CompactString-UTF8.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "The find function takes predicate and CompactString and returns the first element in matching the predicate or Nothing if there is no such element find case findIndex of Just Just index Nothing",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "find",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Char",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e function takes a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and\n returns the index of the first element in the CompactString\n satisfying the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-UTF8.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "The findIndex function takes predicate and CompactString and returns the index of the first element in the CompactString satisfying the predicate",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "findIndex",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:findIndexEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003efindIndexEnd\u003c/a\u003e\u003c/code\u003e function returns the last index of the\n element in the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e which satisfies the predicate,\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. The following holds:\n\u003c/p\u003e\u003cpre\u003e findIndexEnd c xs == \n (-) (length xs - 1) `fmap` findIndex c (reverse xs)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString-UTF8.html#findIndexEnd",
        "fct-type": "function",
        "title": "findIndexEnd"
      },
      "index": {
        "description": "The findIndexEnd function returns the last index of the element in the given CompactString which satisfies the predicate or Nothing if there is no such element The following holds findIndexEnd xs length xs fmap findIndex reverse xs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "findIndexEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e, by returning the\n indices of all elements satisfying the predicate, in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e [Int]",
        "fct-source": "src/Data-CompactString-UTF8.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "The findIndices function extends findIndex by returning the indices of all elements satisfying the predicate in ascending order",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "findIndices",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Indices",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:findSubstring",
      "description": {
        "fct-descr": "\u003cp\u003eGet the first index of a substring in another string,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not found.\n   \u003ccode\u003efindSubstring p s\u003c/code\u003e is equivalent to \u003ccode\u003elistToMaybe (findSubstrings p s)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e Maybe Int",
        "fct-type": "function",
        "title": "findSubstring"
      },
      "index": {
        "description": "Get the first index of substring in another string or Nothing if the string is not found findSubstring is equivalent to listToMaybe findSubstrings",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "findSubstring",
        "normalized": "CompactString-\u003eCompactString-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Substring",
        "signature": "CompactString-\u003eCompactString-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:findSubstrings",
      "description": {
        "fct-descr": "\u003cp\u003eFind the indexes of all (possibly overlapping) occurances of a\n substring in a string.  This function uses the Knuth-Morris-Pratt\n string matching algorithm.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e [Int]",
        "fct-type": "function",
        "title": "findSubstrings"
      },
      "index": {
        "description": "Find the indexes of all possibly overlapping occurances of substring in string This function uses the Knuth-Morris-Pratt string matching algorithm",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "findSubstrings",
        "normalized": "CompactString-\u003eCompactString-\u003e[Int]",
        "package": "compact-string",
        "partial": "Substrings",
        "signature": "CompactString-\u003eCompactString-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value (typically\n the left-identity of the operator), and a CompactString, reduces the\n CompactString using the binary operator, from left to right.\n This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-UTF8.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "foldl applied to binary operator starting value typically the left-identity of the operator and CompactString reduces the CompactString using the binary operator from left to right This function is subject to array fusion",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "foldl",
        "normalized": "(a-\u003eChar-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldl\\'' is like \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but strict in the accumulator.\n Though actually foldl is also strict in the accumulator.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-UTF8.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "foldl is like foldl but strict in the accumulator Though actually foldl is also strict in the accumulator",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "foldl'",
        "normalized": "(a-\u003eChar-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e that has no starting value\n argument, and thus must be applied to non-empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n This function is subject to array fusion. \n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "foldl1 is variant of foldl that has no starting value argument and thus must be applied to non-empty CompactString This function is subject to array fusion An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "foldl1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldl1\\'' is like \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e, but strict in the accumulator.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "foldl1 is like foldl1 but strict in the accumulator An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "foldl1'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value\n (typically the right-identity of the operator), and a CompactString,\n reduces the CompactString using the binary operator, from right to left.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e acc -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-UTF8.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "foldr applied to binary operator starting value typically the right-identity of the operator and CompactString reduces the CompactString using the binary operator from right to left",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "foldr",
        "normalized": "(Char-\u003ea-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eacc-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value\n (typically the right-identity of the operator), and a CompactString,\n reduces the CompactString using the binary operator, from right to left.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e acc -\u003e acc) -\u003e acc -\u003e CompactString -\u003e acc",
        "fct-source": "src/Data-CompactString-UTF8.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "foldr applied to binary operator starting value typically the right-identity of the operator and CompactString reduces the CompactString using the binary operator from right to left",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "foldr'",
        "normalized": "(Char-\u003ea-\u003ea)-\u003ea-\u003eCompactString-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eacc-\u003eacc)-\u003eacc-\u003eCompactString-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e that has no starting value argument,\n and thus must be applied to non-empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "foldr1 is variant of foldr that has no starting value argument and thus must be applied to non-empty CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "foldr1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldr1\\'' is a variant of \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e, but is strict in the\n accumulator.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "foldr1 is variant of foldr1 but is strict in the accumulator An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "foldr1'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:fromByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString.\n   Fails if the ByteString is not a valid encoded string.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#fromByteString",
        "fct-type": "function",
        "title": "fromByteString"
      },
      "index": {
        "description": "Convert ByteString to CompactString Fails if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "fromByteString",
        "normalized": "ByteString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "ByteString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:fromByteString_",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString.\n   Raises an error if the ByteString is not a valid encoded string.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#fromByteString_",
        "fct-type": "function",
        "title": "fromByteString_"
      },
      "index": {
        "description": "Convert ByteString to CompactString Raises an error if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "fromByteString_",
        "normalized": "ByteString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "ByteString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:getContents",
      "description": {
        "fct-descr": "\u003cp\u003egetContents. Equivalent to \u003ccode\u003ehGetContents stdin\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eInput is assumed to be in UTF-8, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#getContents",
        "fct-type": "function",
        "title": "getContents"
      },
      "index": {
        "description": "getContents Equivalent to hGetContents stdin Input is assumed to be in UTF-8 this may not be appropriate",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "getContents",
        "normalized": "",
        "package": "compact-string",
        "partial": "Contents",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:getLine",
      "description": {
        "fct-descr": "\u003cp\u003eRead a line from stdin.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#getLine",
        "fct-type": "function",
        "title": "getLine"
      },
      "index": {
        "description": "Read line from stdin",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "getLine",
        "normalized": "",
        "package": "compact-string",
        "partial": "Line",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:group",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and returns a list of\n CompactStrings such that the concatenation of the result is equal to the\n argument.  Moreover, each sublist in the result contains only equal\n elements.  For example,\n\u003c/p\u003e\u003cpre\u003e group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own equality test.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#group",
        "fct-type": "function",
        "title": "group"
      },
      "index": {
        "description": "The group function takes CompactString and returns list of CompactStrings such that the concatenation of the result is equal to the argument Moreover each sublist in the result contains only equal elements For example group Mississippi ss ss pp It is special case of groupBy which allows the programmer to supply their own equality test",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "group",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:groupBy",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Bool) -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#groupBy",
        "fct-type": "function",
        "title": "groupBy"
      },
      "index": {
        "description": "The groupBy function is the non-overloaded version of group",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "groupBy",
        "normalized": "(Char-\u003eChar-\u003eBool)-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "By",
        "signature": "(Char-\u003eChar-\u003eBool)-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:hGet",
      "description": {
        "fct-descr": "\u003cp\u003eRead a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e directly from the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e Int -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#hGet",
        "fct-type": "function",
        "title": "hGet"
      },
      "index": {
        "description": "Read CompactString directly from the specified Handle The handle is interpreted as UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "hGet",
        "normalized": "Handle-\u003eInt-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get",
        "signature": "Handle-\u003eInt-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:hGetContents",
      "description": {
        "fct-descr": "\u003cp\u003eRead entire handle contents into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#hGetContents",
        "fct-type": "function",
        "title": "hGetContents"
      },
      "index": {
        "description": "Read entire handle contents into CompactString The handle is interpreted as UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "hGetContents",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Contents",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:hGetContents-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRead entire handle contents into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe encoding is determined based on a Byte Order Mark, see \u003ccode\u003e\u003ca\u003edecodeBOM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#hGetContents%27",
        "fct-type": "function",
        "title": "hGetContents'"
      },
      "index": {
        "description": "Read entire handle contents into CompactString The encoding is determined based on Byte Order Mark see decodeBOM",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "hGetContents'",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Contents'",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:hGetLine",
      "description": {
        "fct-descr": "\u003cp\u003eRead a line from a handle\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#hGetLine",
        "fct-type": "function",
        "title": "hGetLine"
      },
      "index": {
        "description": "Read line from handle",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "hGetLine",
        "normalized": "Handle-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Line",
        "signature": "Handle-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:hGetNonBlocking",
      "description": {
        "fct-descr": "\u003cp\u003ehGetNonBlocking is identical to \u003ccode\u003e\u003ca\u003ehGet\u003c/a\u003e\u003c/code\u003e, except that it will never block\n waiting for data to become available, instead it returns only whatever data\n is available.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e Int -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#hGetNonBlocking",
        "fct-type": "function",
        "title": "hGetNonBlocking"
      },
      "index": {
        "description": "hGetNonBlocking is identical to hGet except that it will never block waiting for data to become available instead it returns only whatever data is available The handle is interpreted as UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "hGetNonBlocking",
        "normalized": "Handle-\u003eInt-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "Get Non Blocking",
        "signature": "Handle-\u003eInt-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:hPut",
      "description": {
        "fct-descr": "\u003cp\u003eOutputs a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eOutput is written in UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#hPut",
        "fct-type": "function",
        "title": "hPut"
      },
      "index": {
        "description": "Outputs CompactString to the specified Handle Output is written in UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "hPut",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:hPutStr",
      "description": {
        "fct-descr": "\u003cp\u003eA synonym for \u003ccode\u003ehPut\u003c/code\u003e, for compatibility \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#hPutStr",
        "fct-type": "function",
        "title": "hPutStr"
      },
      "index": {
        "description": "synonym for hPut for compatibility",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "hPutStr",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put Str",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:hPutStrLn",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a handle, appending a newline byte\n\u003c/p\u003e\u003cp\u003eOutput is written in UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#hPutStrLn",
        "fct-type": "function",
        "title": "hPutStrLn"
      },
      "index": {
        "description": "Write CompactString to handle appending newline byte Output is written in UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "hPutStrLn",
        "normalized": "Handle-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Put Str Ln",
        "signature": "Handle-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the first element of a CompactString, which must be non-empty.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "Extract the first element of CompactString which must be non-empty An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "head",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:headView",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e A view of the front of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e headView s = if null s then Nothing else Just (head s, tail s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Maybe (Char, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#headView",
        "fct-type": "function",
        "title": "headView"
      },
      "index": {
        "description": "view of the front of CompactString headView if null then Nothing else Just head tail",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "headView",
        "normalized": "CompactString-\u003eMaybe(Char,CompactString)",
        "package": "compact-string",
        "partial": "View",
        "signature": "CompactString-\u003eMaybe(Char,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:index",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e index (subscript) operator, starting from 0.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Int -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#index",
        "fct-type": "function",
        "title": "index"
      },
      "index": {
        "description": "CompactString index subscript operator starting from",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "index",
        "normalized": "CompactString-\u003eInt-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eInt-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Return all the elements of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e except the last one.\n An exception will be thrown in the case of an empty ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Return all the elements of CompactString except the last one An exception will be thrown in the case of an empty ByteString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "init",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:inits",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Return all initial segments of the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, shortest first.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#inits",
        "fct-type": "function",
        "title": "inits"
      },
      "index": {
        "description": "Return all initial segments of the given CompactString shortest first",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "inits",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:interact",
      "description": {
        "fct-descr": "\u003cp\u003eThe interact function takes a function of type \u003ccode\u003eCompactString -\u003e CompactString\u003c/code\u003e\n as its argument. The entire input from the standard input device is passed\n to this function as its argument, and the resulting string is output on the\n standard output device. It's great for writing one line programs!\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(CompactString -\u003e CompactString) -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#interact",
        "fct-type": "function",
        "title": "interact"
      },
      "index": {
        "description": "The interact function takes function of type CompactString CompactString as its argument The entire input from the standard input device is passed to this function as its argument and the resulting string is output on the standard output device It great for writing one line programs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "interact",
        "normalized": "(CompactString-\u003eCompactString)-\u003eIO()",
        "package": "compact-string",
        "partial": "",
        "signature": "(CompactString-\u003eCompactString)-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:intercalate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and a list of\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es and concatenates the list after interspersing the first\n argument between each element of the list.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#intercalate",
        "fct-type": "function",
        "title": "intercalate"
      },
      "index": {
        "description": "The intercalate function takes CompactString and list of CompactString and concatenates the list after interspersing the first argument between each element of the list",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "intercalate",
        "normalized": "CompactString-\u003e[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:intersperse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eintersperse\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e and a\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and `intersperses' that character between the elements of\n the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  It is analogous to the intersperse function on\n Lists.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#intersperse",
        "fct-type": "function",
        "title": "intersperse"
      },
      "index": {
        "description": "The intersperse function takes Char and CompactString and intersperses that character between the elements of the CompactString It is analogous to the intersperse function on Lists",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "intersperse",
        "normalized": "Char-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:isInfixOf",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether one string is a substring of another. \u003ccode\u003eisInfixOf\n p s\u003c/code\u003e is equivalent to \u003ccode\u003enot (null (findSubstrings p s))\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString-\u003e CompactString-\u003e Bool",
        "fct-type": "function",
        "title": "isInfixOf"
      },
      "index": {
        "description": "Check whether one string is substring of another isInfixOf is equivalent to not null findSubstrings",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "isInfixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Infix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:isPrefixOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eisPrefixOf\u003c/a\u003e\u003c/code\u003e function takes two CompactString and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first is a prefix of the second.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF8.html#isPrefixOf",
        "fct-type": "function",
        "title": "isPrefixOf"
      },
      "index": {
        "description": "The isPrefixOf function takes two CompactString and returns True iff the first is prefix of the second",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "isPrefixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Prefix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:isSuffixOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eisSuffixOf\u003c/a\u003e\u003c/code\u003e function takes two CompactString and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first is a suffix of the second.\n\u003c/p\u003e\u003cp\u003eThe following holds:\n\u003c/p\u003e\u003cpre\u003e isSuffixOf x y == reverse x `isPrefixOf` reverse y\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF8.html#isSuffixOf",
        "fct-type": "function",
        "title": "isSuffixOf"
      },
      "index": {
        "description": "The isSuffixOf function takes two CompactString and returns True iff the first is suffix of the second The following holds isSuffixOf reverse isPrefixOf reverse",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "isSuffixOf",
        "normalized": "CompactString-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Suffix Of",
        "signature": "CompactString-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the last element of a ByteString, which must be finite and non-empty.\n An exception will be thrown in the case of an empty ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Extract the last element of ByteString which must be finite and non-empty An exception will be thrown in the case of an empty ByteString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "last",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:lastView",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e A view of the back of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e lastView s = if null s then Nothing else Just (init s, last s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Maybe (CompactString, Char)",
        "fct-source": "src/Data-CompactString-UTF8.html#lastView",
        "fct-type": "function",
        "title": "lastView"
      },
      "index": {
        "description": "view of the back of CompactString lastView if null then Nothing else Just init last",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "lastView",
        "normalized": "CompactString-\u003eMaybe(CompactString,Char)",
        "package": "compact-string",
        "partial": "View",
        "signature": "CompactString-\u003eMaybe(CompactString,Char)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e returns the length of a CompactString as an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Int",
        "fct-source": "src/Data-CompactString-UTF8.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "length returns the length of CompactString as an Int",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "length",
        "normalized": "CompactString-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:lines",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e breaks a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e up into a list of CompactStrings at\n newline Chars. The resulting strings do not contain newlines.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#lines",
        "fct-type": "function",
        "title": "lines"
      },
      "index": {
        "description": "lines breaks CompactString up into list of CompactStrings at newline Chars The resulting strings do not contain newlines",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "lines",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef xs\u003c/code\u003e is the CompactString obtained by applying \u003ccode\u003ef\u003c/code\u003e to each\n element of \u003ccode\u003exs\u003c/code\u003e. This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "map xs is the CompactString obtained by applying to each element of xs This function is subject to array fusion",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "map",
        "normalized": "(Char-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:mapAccumL",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a CompactString,\n passing an accumulating parameter from left to right, and returning a\n final value of this accumulator together with the new CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e acc -\u003e CompactString -\u003e (acc, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#mapAccumL",
        "fct-type": "function",
        "title": "mapAccumL"
      },
      "index": {
        "description": "The mapAccumL function behaves like combination of map and foldl it applies function to each element of CompactString passing an accumulating parameter from left to right and returning final value of this accumulator together with the new CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "mapAccumL",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003ea-\u003eCompactString-\u003e(a,CompactString)",
        "package": "compact-string",
        "partial": "Accum",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eacc-\u003eCompactString-\u003e(acc,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:mapAccumR",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a CompactString,\n passing an accumulating parameter from right to left, and returning a\n final value of this accumulator together with the new CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e acc -\u003e CompactString -\u003e (acc, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#mapAccumR",
        "fct-type": "function",
        "title": "mapAccumR"
      },
      "index": {
        "description": "The mapAccumR function behaves like combination of map and foldr it applies function to each element of CompactString passing an accumulating parameter from right to left and returning final value of this accumulator together with the new CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "mapAccumR",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003ea-\u003eCompactString-\u003e(a,CompactString)",
        "package": "compact-string",
        "partial": "Accum",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eacc-\u003eCompactString-\u003e(acc,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:mapIndexed",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e map Char functions, provided with the index at each position.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Int -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#mapIndexed",
        "fct-type": "function",
        "title": "mapIndexed"
      },
      "index": {
        "description": "map Char functions provided with the index at each position",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "mapIndexed",
        "normalized": "(Int-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "Indexed",
        "signature": "(Int-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003emaximum\u003c/a\u003e\u003c/code\u003e returns the maximum value from a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "maximum returns the maximum value from CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "maximum",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eminimum\u003c/a\u003e\u003c/code\u003e returns the minimum value from a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char",
        "fct-source": "src/Data-CompactString-UTF8.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "minimum returns the minimum value from CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "minimum",
        "normalized": "CompactString-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003enotElem\u003c/a\u003e\u003c/code\u003e is the inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF8.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "notElem is the inverse of elem",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "notElem",
        "normalized": "Char-\u003eCompactString-\u003eBool",
        "package": "compact-string",
        "partial": "Elem",
        "signature": "Char-\u003eCompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a CompactString is empty.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Bool",
        "fct-source": "src/Data-CompactString-UTF8.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether CompactString is empty",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "null",
        "normalized": "CompactString-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:pack",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "String -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#pack",
        "fct-type": "function",
        "title": "pack"
      },
      "index": {
        "description": "Convert String into CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "pack",
        "normalized": "String-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "String-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n returns a pair of CompactStrings.\n The first containing those characters that satisfy the predicate,\n the second containg those that don't.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "partition applied to predicate and CompactString returns pair of CompactStrings The first containing those characters that satisfy the predicate the second containg those that don",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "partition",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:putStr",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to stdout.\n\u003c/p\u003e\u003cp\u003eOutput is written in UTF-8, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#putStr",
        "fct-type": "function",
        "title": "putStr"
      },
      "index": {
        "description": "Write CompactString to stdout Output is written in UTF-8 this may not be appropriate",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "putStr",
        "normalized": "CompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Str",
        "signature": "CompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:putStrLn",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to stdout, appending a newline character.\n\u003c/p\u003e\u003cp\u003eOutput is written in UTF-8, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#putStrLn",
        "fct-type": "function",
        "title": "putStrLn"
      },
      "index": {
        "description": "Write CompactString to stdout appending newline character Output is written in UTF-8 this may not be appropriate",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "putStrLn",
        "normalized": "CompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "Str Ln",
        "signature": "CompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:readFile",
      "description": {
        "fct-descr": "\u003cp\u003eRead an entire file strictly into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  This is far more\n   efficient than reading the characters into a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and then using\n   \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e. Files are read using 'text mode' on Windows.\n\u003c/p\u003e\u003cp\u003eFiles are assumed to be in UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#readFile",
        "fct-type": "function",
        "title": "readFile"
      },
      "index": {
        "description": "Read an entire file strictly into CompactString This is far more efficient than reading the characters into String and then using pack Files are read using text mode on Windows Files are assumed to be in UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "readFile",
        "normalized": "FilePath-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:readFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRead an entire file strictly into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  This is far more\n   efficient than reading the characters into a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and then using\n   \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e. Files are read using 'text mode' on Windows.\n\u003c/p\u003e\u003cp\u003eThe encoding of the file is determined based on a Byte Order Mark, see \u003ccode\u003e\u003ca\u003edecodeBOM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e IO CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#readFile%27",
        "fct-type": "function",
        "title": "readFile'"
      },
      "index": {
        "description": "Read an entire file strictly into CompactString This is far more efficient than reading the characters into String and then using pack Files are read using text mode on Windows The encoding of the file is determined based on Byte Order Mark see decodeBOM",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "readFile'",
        "normalized": "FilePath-\u003eIO CompactString",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eIO CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en x\u003c/code\u003e is a CompactString of length \u003ccode\u003en\u003c/code\u003e with \u003ccode\u003ex\u003c/code\u003e\n the value of every element. The following holds:\n\u003c/p\u003e\u003cpre\u003e replicate w c = unfoldr w (\\u -\u003e Just (u,u)) c\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "replicate is CompactString of length with the value of every element The following holds replicate unfoldr Just",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "replicate",
        "normalized": "Int-\u003eChar-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eChar-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003eReverse a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "reverse",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e is similar to \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but returns a list of successive\n reduced values from the left. This function will fuse.\n\u003c/p\u003e\u003cpre\u003e scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\n\u003c/pre\u003e\u003cp\u003eNote that\n\u003c/p\u003e\u003cpre\u003e last (scanl f z xs) == foldl f z xs.\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "scanl is similar to foldl but returns list of successive reduced values from the left This function will fuse scanl x1 x2 x1 x1 x2 Note that last scanl xs foldl xs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "scanl",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n This function will fuse.\n\u003c/p\u003e\u003cpre\u003e scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "scanl1 is variant of scanl that has no starting value argument This function will fuse scanl1 x1 x2 x1 x1 x2",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "scanl1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003escanr is the right-to-left dual of scanl.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e Char -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "scanr is the right-to-left dual of scanl",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "scanr",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "scanr1 is variant of scanr that has no starting value argument",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "scanr1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Convert Char into CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "singleton",
        "normalized": "Char-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append a byte to the end of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e Char -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append byte to the end of CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "snoc",
        "normalized": "CompactString-\u003eChar-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eChar-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:sort",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e Sort a CompactString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#sort",
        "fct-type": "function",
        "title": "sort"
      },
      "index": {
        "description": "log Sort CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "sort",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e breaks the ByteString into two segments. It is\n equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e p xs, \u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e p xs)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "span xs breaks the ByteString into two segments It is equivalent to takeWhile xs dropWhile xs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "span",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:spanEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espanEnd\u003c/a\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e but from the end of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWe have\n\u003c/p\u003e\u003cpre\u003e spanEnd (not.isSpace) \"x y z\" == (\"x y \",\"z\")\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e spanEnd (not . isSpace) cs\n    == \n let (x,y) = span (not.isSpace) (reverse cs) in (reverse y, reverse x)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#spanEnd",
        "fct-type": "function",
        "title": "spanEnd"
      },
      "index": {
        "description": "spanEnd behaves like span but from the end of the CompactString We have spanEnd not.isSpace and spanEnd not isSpace cs let span not.isSpace reverse cs in reverse reverse",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "spanEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "End",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:split",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Break a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into pieces separated by the byte\n argument, consuming the delimiter. I.e.\n\u003c/p\u003e\u003cpre\u003e split '\\n' \"a\\nb\\nd\\ne\" == [\"a\",\"b\",\"d\",\"e\"]\n split 'a'  \"aXaXaXa\"    == [\"\",\"X\",\"X\",\"X\",\"\"]\n split 'x'  \"x\"          == [\"\",\"\"]\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e intercalate [c] . split c == id\n split == splitWith . (==)\n\u003c/pre\u003e\u003cp\u003eAs for all splitting functions in this library, this function does\n not copy the substrings, it just constructs new \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e that\n are slices of the original.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#split",
        "fct-type": "function",
        "title": "split"
      },
      "index": {
        "description": "Break ByteString into pieces separated by the byte argument consuming the delimiter I.e split nb nd ne split aXaXaXa split and intercalate split id split splitWith As for all splitting functions in this library this function does not copy the substrings it just constructs new CompactString that are slices of the original",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "split",
        "normalized": "Char-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n xs)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "splitAt xs is equivalent to take xs drop xs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "splitAt",
        "normalized": "Int-\u003eCompactString-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "At",
        "signature": "Int-\u003eCompactString-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:splitWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Splits a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e into components delimited by\n separators, where the predicate returns True for a separator element.\n The resulting components do not contain the separators.  Two adjacent\n separators result in an empty component in the output.  eg.\n\u003c/p\u003e\u003cpre\u003e splitWith (=='a') \"aabbaca\" == [\"\",\"\",\"bb\",\"c\",\"\"]\n splitWith (=='a') []        == []\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#splitWith",
        "fct-type": "function",
        "title": "splitWith"
      },
      "index": {
        "description": "Splits CompactString into components delimited by separators where the predicate returns True for separator element The resulting components do not contain the separators Two adjacent separators result in an empty component in the output eg splitWith aabbaca bb splitWith",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "splitWith",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "With",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the elements after the head of a CompactString, which must be non-empty.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Extract the elements after the head of CompactString which must be non-empty An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "tail",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:tails",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Return all final segments of the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, longest first.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#tails",
        "fct-type": "function",
        "title": "tails"
      },
      "index": {
        "description": "Return all final segments of the given CompactString longest first",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "tails",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en\u003c/code\u003e, applied to a CompactString \u003ccode\u003exs\u003c/code\u003e, returns the prefix\n of \u003ccode\u003exs\u003c/code\u003e of length \u003ccode\u003en\u003c/code\u003e, or \u003ccode\u003exs\u003c/code\u003e itself if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "take applied to CompactString xs returns the prefix of xs of length or xs itself if length xs",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "take",
        "normalized": "Int-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e, applied to a predicate \u003ccode\u003ep\u003c/code\u003e and a CompactString \u003ccode\u003exs\u003c/code\u003e,\n returns the longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n satisfy \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "takeWhile applied to predicate and CompactString xs returns the longest prefix possibly empty of xs of elements that satisfy",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "takeWhile",
        "normalized": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "While",
        "signature": "(Char-\u003eBool)-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:toByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a CompactString to a ByteString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e ByteString",
        "fct-source": "src/Data-CompactString-UTF8.html#toByteString",
        "fct-type": "function",
        "title": "toByteString"
      },
      "index": {
        "description": "Convert CompactString to ByteString",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "toByteString",
        "normalized": "CompactString-\u003eByteString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "CompactString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:transpose",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e function transposes the rows and columns of its\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e argument.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#transpose",
        "fct-type": "function",
        "title": "transpose"
      },
      "index": {
        "description": "The transpose function transposes the rows and columns of its CompactString argument",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "transpose",
        "normalized": "[CompactString]-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e, where \u003cem\u003en\u003c/em\u003e is the length of the result.  The \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e \n function is analogous to the List 'unfoldr'.  \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e builds a \n ByteString from a seed value.  The function takes the element and \n returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it is done producing the CompactString or returns \n \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(a,b)\u003c/code\u003e, in which case, \u003ccode\u003ea\u003c/code\u003e is the next byte in the string, \n and \u003ccode\u003eb\u003c/code\u003e is the seed value for further production.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e    unfoldr (\\x -\u003e if x \u003c= 5 then Just (x, x + 1) else Nothing) 0\n == pack [0, 1, 2, 3, 4, 5]\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Maybe (Char, acc)) -\u003e acc -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "where is the length of the result The unfoldr function is analogous to the List unfoldr unfoldr builds ByteString from seed value The function takes the element and returns Nothing if it is done producing the CompactString or returns Just in which case is the next byte in the string and is the seed value for further production Examples unfoldr if then Just else Nothing pack",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(Char,a))-\u003ea-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eMaybe(Char,acc))-\u003eacc-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Like \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e builds a ByteString from a seed\n value.  However, the length of the result is limited by the first\n argument to \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e.  This function is more efficient than \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e\n when the maximum length of the result is known.\n\u003c/p\u003e\u003cp\u003eThe following equation relates \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e fst (unfoldrN n f s) == take n (unfoldr f s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e (acc -\u003e Maybe (Char, acc)) -\u003e acc -\u003e (CompactString, Maybe acc)",
        "fct-source": "src/Data-CompactString-UTF8.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Like unfoldr unfoldrN builds ByteString from seed value However the length of the result is limited by the first argument to unfoldrN This function is more efficient than unfoldr when the maximum length of the result is known The following equation relates unfoldrN and unfoldr fst unfoldrN take unfoldr",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(Char,a))-\u003ea-\u003e(CompactString,Maybe a)",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003e(acc-\u003eMaybe(Char,acc))-\u003eacc-\u003e(CompactString,Maybe acc)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:unlines",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e is an inverse operation to \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e.  It joins lines,\n after appending a terminating newline to each.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#unlines",
        "fct-type": "function",
        "title": "unlines"
      },
      "index": {
        "description": "unlines is an inverse operation to lines It joins lines after appending terminating newline to each",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "unlines",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:unpack",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Converts a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e String",
        "fct-source": "src/Data-CompactString-UTF8.html#unpack",
        "fct-type": "function",
        "title": "unpack"
      },
      "index": {
        "description": "Converts CompactString to String",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "unpack",
        "normalized": "CompactString-\u003eString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:unwords",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunwords\u003c/a\u003e\u003c/code\u003e function is analogous to the \u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e function, on words.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString] -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#unwords",
        "fct-type": "function",
        "title": "unwords"
      },
      "index": {
        "description": "The unwords function is analogous to the unlines function on words",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "unwords",
        "normalized": "[CompactString]-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString]-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e transforms a list of pairs of bytes into a pair of\n CompactStrings. Note that this performs two \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "[(Char, Char)] -\u003e (CompactString, CompactString)",
        "fct-source": "src/Data-CompactString-UTF8.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "unzip transforms list of pairs of bytes into pair of CompactStrings Note that this performs two pack operations",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "unzip",
        "normalized": "[(Char,Char)]-\u003e(CompactString,CompactString)",
        "package": "compact-string",
        "partial": "",
        "signature": "[(Char,Char)]-\u003e(CompactString,CompactString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:validate",
      "description": {
        "fct-descr": "\u003cp\u003eValidates a CompactString.\n   If the string is invalid, fails, otherwise returns the input.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e m CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#validate",
        "fct-type": "function",
        "title": "validate"
      },
      "index": {
        "description": "Validates CompactString If the string is invalid fails otherwise returns the input",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "validate",
        "normalized": "CompactString-\u003ea CompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003em CompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:validate_",
      "description": {
        "fct-descr": "\u003cp\u003eValidates a CompactString.\n   If the string is invalid, throws an error, otherwise returns the input.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#validate_",
        "fct-type": "function",
        "title": "validate_"
      },
      "index": {
        "description": "Validates CompactString If the string is invalid throws an error otherwise returns the input",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "validate_",
        "normalized": "CompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:words",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e breaks a ByteString up into a list of words, which\n were delimited by Chars representing white space. And\n\u003c/p\u003e\u003cpre\u003e words = filter (not . null) . splitWith isSpace\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e [CompactString]",
        "fct-source": "src/Data-CompactString-UTF8.html#words",
        "fct-type": "function",
        "title": "words"
      },
      "index": {
        "description": "words breaks ByteString up into list of words which were delimited by Chars representing white space And words filter not null splitWith isSpace",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "words",
        "normalized": "CompactString-\u003e[CompactString]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003e[CompactString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:writeFile",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#writeFile",
        "fct-type": "function",
        "title": "writeFile"
      },
      "index": {
        "description": "Write CompactString to file Files are written using UTF-8",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "writeFile",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:writeFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using UTF-8.\n   A Byte Order Mark is also written.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString -\u003e IO ()",
        "fct-source": "src/Data-CompactString-UTF8.html#writeFile%27",
        "fct-type": "function",
        "title": "writeFile'"
      },
      "index": {
        "description": "Write CompactString to file Files are written using UTF-8 Byte Order Mark is also written",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "writeFile'",
        "normalized": "FilePath-\u003eCompactString-\u003eIO()",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eCompactString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e takes two ByteStrings and returns a list of\n corresponding pairs of bytes. If one input ByteString is short,\n excess elements of the longer ByteString are discarded. This is\n equivalent to a pair of \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "CompactString -\u003e CompactString -\u003e [(Char, Char)]",
        "fct-source": "src/Data-CompactString-UTF8.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "zip takes two ByteStrings and returns list of corresponding pairs of bytes If one input ByteString is short excess elements of the longer ByteString are discarded This is equivalent to pair of unpack operations",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "zip",
        "normalized": "CompactString-\u003eCompactString-\u003e[(Char,Char)]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString-\u003eCompactString-\u003e[(Char,Char)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e generalises \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e by zipping with the function given as\n the first argument, instead of a tupling function.  For example,\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e (+)\u003c/code\u003e is applied to two ByteStrings to produce the list of\n corresponding sums. \n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e b) -\u003e CompactString -\u003e CompactString -\u003e [b]",
        "fct-source": "src/Data-CompactString-UTF8.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "zipWith generalises zip by zipping with the function given as the first argument instead of tupling function For example zipWith is applied to two ByteStrings to produce the list of corresponding sums",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "zipWith",
        "normalized": "(Char-\u003eChar-\u003ea)-\u003eCompactString-\u003eCompactString-\u003e[a]",
        "package": "compact-string",
        "partial": "With",
        "signature": "(Char-\u003eChar-\u003eb)-\u003eCompactString-\u003eCompactString-\u003e[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-UTF8.html#v:zipWith-39-",
      "description": {
        "fct-descr": "\u003cp\u003eA specialised version of \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e for the common case of a\n simultaneous map over two \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es, to build a 3rd. Rewrite rules\n are used to automatically covert zipWith into zipWith' when a pack is\n performed on the result of zipWith, but we also export it for\n convenience.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.UTF8",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString -\u003e CompactString -\u003e CompactString",
        "fct-source": "src/Data-CompactString-UTF8.html#zipWith%27",
        "fct-type": "function",
        "title": "zipWith'"
      },
      "index": {
        "description": "specialised version of zipWith for the common case of simultaneous map over two CompactString to build rd Rewrite rules are used to automatically covert zipWith into zipWith when pack is performed on the result of zipWith but we also export it for convenience",
        "hierarchy": "Data CompactString UTF8",
        "module": "Data.CompactString.UTF8",
        "name": "zipWith'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString-\u003eCompactString",
        "package": "compact-string",
        "partial": "With'",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString-\u003eCompactString-\u003eCompactString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Unsafe.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnsafe functions on \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es.\n All these functions can lead to crashes if not used properly.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CompactString.Unsafe",
        "fct-package": "compact-string",
        "fct-signature": "module",
        "fct-source": "src/Data-CompactString-Unsafe.html",
        "fct-type": "module",
        "title": "Unsafe"
      },
      "index": {
        "description": "Unsafe functions on CompactString All these functions can lead to crashes if not used properly",
        "hierarchy": "Data CompactString Unsafe",
        "module": "Data.CompactString.Unsafe",
        "name": "Unsafe",
        "normalized": "",
        "package": "compact-string",
        "partial": "Unsafe",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Unsafe.html#v:unsafeFromByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString,\n   does not check whether the ByteString represents a valid string in the encoding a.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Unsafe",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString a",
        "fct-source": "src/Data-CompactString-Unsafe.html#unsafeFromByteString",
        "fct-type": "function",
        "title": "unsafeFromByteString"
      },
      "index": {
        "description": "Convert ByteString to CompactString does not check whether the ByteString represents valid string in the encoding",
        "hierarchy": "Data CompactString Unsafe",
        "module": "Data.CompactString.Unsafe",
        "name": "unsafeFromByteString",
        "normalized": "ByteString-\u003eCompactString a",
        "package": "compact-string",
        "partial": "From Byte String",
        "signature": "ByteString-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Unsafe.html#v:unsafeHead",
      "description": {
        "fct-descr": "\u003cp\u003eA variety of \u003ccode\u003e\u003ca\u003ehead\u003c/a\u003e\u003c/code\u003e for non-empty CompactString. \u003ccode\u003e\u003ca\u003eunsafeHead\u003c/a\u003e\u003c/code\u003e omits the\n check for the empty case, so there is an obligation on the programmer\n to provide a proof that the CompactString is non-empty.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Unsafe",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString-Unsafe.html#unsafeHead",
        "fct-type": "function",
        "title": "unsafeHead"
      },
      "index": {
        "description": "variety of head for non-empty CompactString unsafeHead omits the check for the empty case so there is an obligation on the programmer to provide proof that the CompactString is non-empty",
        "hierarchy": "Data CompactString Unsafe",
        "module": "Data.CompactString.Unsafe",
        "name": "unsafeHead",
        "normalized": "CompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "Head",
        "signature": "CompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Unsafe.html#v:unsafeInit",
      "description": {
        "fct-descr": "\u003cp\u003eA variety of \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e for non-empty CompactString. \u003ccode\u003e\u003ca\u003eunsafeInit\u003c/a\u003e\u003c/code\u003e omits the\n check for the empty case, so there is an obligation on the programmer\n to provide a proof that the CompactString is non-empty.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Unsafe",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString-Unsafe.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "variety of init for non-empty CompactString unsafeInit omits the check for the empty case so there is an obligation on the programmer to provide proof that the CompactString is non-empty",
        "hierarchy": "Data CompactString Unsafe",
        "module": "Data.CompactString.Unsafe",
        "name": "unsafeInit",
        "normalized": "CompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "Init",
        "signature": "CompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Unsafe.html#v:unsafeLast",
      "description": {
        "fct-descr": "\u003cp\u003eA variety of \u003ccode\u003e\u003ca\u003elast\u003c/a\u003e\u003c/code\u003e for non-empty CompactString. \u003ccode\u003e\u003ca\u003eunsafeLast\u003c/a\u003e\u003c/code\u003e omits the\n check for the empty case, so there is an obligation on the programmer\n to provide a proof that the CompactString is non-empty.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Unsafe",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString-Unsafe.html#unsafeLast",
        "fct-type": "function",
        "title": "unsafeLast"
      },
      "index": {
        "description": "variety of last for non-empty CompactString unsafeLast omits the check for the empty case so there is an obligation on the programmer to provide proof that the CompactString is non-empty",
        "hierarchy": "Data CompactString Unsafe",
        "module": "Data.CompactString.Unsafe",
        "name": "unsafeLast",
        "normalized": "CompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "Last",
        "signature": "CompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString-Unsafe.html#v:unsafeTail",
      "description": {
        "fct-descr": "\u003cp\u003eA variety of \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e for non-empty CompactString. \u003ccode\u003e\u003ca\u003eunsafeTail\u003c/a\u003e\u003c/code\u003e omits the\n check for the empty case, so there is an obligation on the programmer\n to provide a proof that the CompactString is non-empty.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString.Unsafe",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString-Unsafe.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "variety of tail for non-empty CompactString unsafeTail omits the check for the empty case so there is an obligation on the programmer to provide proof that the CompactString is non-empty",
        "hierarchy": "Data CompactString Unsafe",
        "module": "Data.CompactString.Unsafe",
        "name": "unsafeTail",
        "normalized": "CompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "Tail",
        "signature": "CompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA time and space-efficient implementation of strings using\n packed Word8 arrays, suitable for high performance use, both in terms\n of large data quantities, or high speed requirements.\n\u003c/p\u003e\u003cp\u003eThis module is intended to be imported \u003ccode\u003equalified\u003c/code\u003e, to avoid name\n clashes with \u003ca\u003ePrelude\u003c/a\u003e functions.  eg.\n\u003c/p\u003e\u003cpre\u003e import qualified Data.CompactString as C\n\u003c/pre\u003e\u003cp\u003eInternally, CompactStrings are encoded \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "module",
        "fct-source": "src/Data-CompactString.html",
        "fct-type": "module",
        "title": "CompactString"
      },
      "index": {
        "description": "time and space-efficient implementation of strings using packed Word8 arrays suitable for high performance use both in terms of large data quantities or high speed requirements This module is intended to be imported qualified to avoid name clashes with Prelude functions eg import qualified Data.CompactString as Internally CompactStrings are encoded ByteString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "CompactString",
        "normalized": "",
        "package": "compact-string",
        "partial": "Compact String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#t:CompactString",
      "description": {
        "fct-descr": "\u003cp\u003eA String using a compact, strict representation.\n   A \u003ccode\u003eCompactString a\u003c/code\u003e is encoded using encoding \u003ccode\u003ea\u003c/code\u003e, for example \u003ccode\u003eCompactString \u003ccode\u003eUTF8\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "data",
        "fct-source": "src/Data-CompactString-Internal.html#CompactString",
        "fct-type": "data",
        "title": "CompactString"
      },
      "index": {
        "description": "String using compact strict representation CompactString is encoded using encoding for example CompactString UTF8",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "CompactString",
        "normalized": "",
        "package": "compact-string",
        "partial": "Compact String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#t:Encoding",
      "description": {
        "fct-descr": "\u003cp\u003eA way to encode characters into bytes\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "class",
        "fct-source": "src/Data-CompactString-Internal.html#Encoding",
        "fct-type": "class",
        "title": "Encoding"
      },
      "index": {
        "description": "way to encode characters into bytes",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "Encoding",
        "normalized": "",
        "package": "compact-string",
        "partial": "Encoding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Applied to a predicate and a CompactString, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if\n all elements of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e Bool",
        "fct-source": "src/Data-CompactString.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Applied to predicate and CompactString any determines if all elements of the CompactString satisfy the predicate",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "all",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Applied to a predicate and a CompactString, \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e determines if\n any element of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e Bool",
        "fct-source": "src/Data-CompactString.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Applied to predicate and CompactString any determines if any element of the CompactString satisfies the predicate",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "any",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:append",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append two CompactStrings\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#append",
        "fct-type": "function",
        "title": "append"
      },
      "index": {
        "description": "Append two CompactStrings",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "append",
        "normalized": "CompactString a-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:appendFile",
      "description": {
        "fct-descr": "\u003cp\u003eAppend a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#appendFile",
        "fct-type": "function",
        "title": "appendFile"
      },
      "index": {
        "description": "Append CompactString to file Files are written using the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "appendFile",
        "normalized": "FilePath-\u003eCompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eCompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:appendFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eAppend a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eThe encoding of the file is determined based on a Byte Order Mark.\n   If the file is empty, it is written using the encoding \u003ccode\u003ea\u003c/code\u003e with a Byte Order Mark.\n   If the encoding can not be determined the file is assumed to be UTF-8.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#appendFile%27",
        "fct-type": "function",
        "title": "appendFile'"
      },
      "index": {
        "description": "Append CompactString to file The encoding of the file is determined based on Byte Order Mark If the file is empty it is written using the encoding with Byte Order Mark If the encoding can not be determined the file is assumed to be UTF-8",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "appendFile'",
        "normalized": "FilePath-\u003eCompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eCompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . p)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e (CompactString a, CompactString a)",
        "fct-source": "src/Data-CompactString.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "break is equivalent to span not",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "break",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:breakEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebreakEnd\u003c/a\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e but from the end of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e breakEnd p == spanEnd (not.p)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e (CompactString a, CompactString a)",
        "fct-source": "src/Data-CompactString.html#breakEnd",
        "fct-type": "function",
        "title": "breakEnd"
      },
      "index": {
        "description": "breakEnd behaves like break but from the end of the CompactString breakEnd spanEnd not.p",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "breakEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)",
        "package": "compact-string",
        "partial": "End",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:compare-39-",
      "description": {
        "fct-descr": "\u003cp\u003eCompare two bytestrings, possibly with a different encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString b -\u003e Ordering",
        "fct-source": "src/Data-CompactString.html#compare%27",
        "fct-type": "function",
        "title": "compare'"
      },
      "index": {
        "description": "Compare two bytestrings possibly with different encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "compare'",
        "normalized": "CompactString a-\u003eCompactString b-\u003eOrdering",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString b-\u003eOrdering"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate a list of \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString a] -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate list of CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "concat",
        "normalized": "[CompactString a]-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString a]-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and concatenate the results\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e CompactString a) -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over CompactString and concatenate the results",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "concatMap",
        "normalized": "(Char-\u003eCompactString a)-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "Map",
        "signature": "(Char-\u003eCompactString a)-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003econs\u003c/a\u003e\u003c/code\u003e is analogous to (:) for lists, but of different\n complexity, as it requires a memcpy.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "cons is analogous to for lists but of different complexity as it requires memcpy",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "cons",
        "normalized": "Char-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:count",
      "description": {
        "fct-descr": "\u003cp\u003ecount returns the number of times its argument appears in the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e count c = length . elemIndices c\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e Int",
        "fct-source": "src/Data-CompactString.html#count",
        "fct-type": "function",
        "title": "count"
      },
      "index": {
        "description": "count returns the number of times its argument appears in the CompactString count length elemIndices",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "count",
        "normalized": "Char-\u003eCompactString a-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a ByteString to a CompactString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e decode e = recode =\u003c\u003c fromByteString\n\u003c/pre\u003e\u003cp\u003ebut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eFails if the ByteString is not a valid encoded string\n   or if the string can not be represented in the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e ByteString -\u003e m (CompactString a)",
        "fct-source": "src/Data-CompactString.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "Decode ByteString to CompactString using the given encoding decode recode fromByteString but it might be faster for some combinations of encodings Fails if the ByteString is not valid encoded string or if the string can not be represented in the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "decode",
        "normalized": "a-\u003eByteString-\u003eb(CompactString c)",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eByteString-\u003em(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:decodeBOM",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, by investigating the Byte Order Mark.\n   If there is no BOM assumes UTF-8.\n   Fails if the input is not a valid encoded string\n   or if the string can not be represented in the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor portability, this function should be prefered over \u003ccode\u003edecode UTF8\u003c/code\u003e when reading files.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e m (CompactString a)",
        "fct-source": "src/Data-CompactString.html#decodeBOM",
        "fct-type": "function",
        "title": "decodeBOM"
      },
      "index": {
        "description": "Decode ByteString into CompactString by investigating the Byte Order Mark If there is no BOM assumes UTF-8 Fails if the input is not valid encoded string or if the string can not be represented in the encoding For portability this function should be prefered over decode UTF8 when reading files",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "decodeBOM",
        "normalized": "ByteString-\u003ea(CompactString b)",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "ByteString-\u003em(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:decodeBOM_",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, by investigating the Byte Order Mark.\n   If there is no BOM assumes UTF-8.\n   Raises an error if the input is not a valid encoded string\n   or if the string can not be represented in the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor portability, this function should be prefered over \u003ccode\u003edecode UTF8\u003c/code\u003e when reading files.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#decodeBOM_",
        "fct-type": "function",
        "title": "decodeBOM_"
      },
      "index": {
        "description": "Decode ByteString into CompactString by investigating the Byte Order Mark If there is no BOM assumes UTF-8 Raises an error if the input is not valid encoded string or if the string can not be represented in the encoding For portability this function should be prefered over decode UTF8 when reading files",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "decodeBOM_",
        "normalized": "ByteString-\u003eCompactString a",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "ByteString-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:decode_",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a ByteString to a CompactString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e decode_ e = recode_ . fromByteString_\n\u003c/pre\u003e\u003cp\u003ebut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eRaises an error if the ByteString is not a valid encoded string\n   or if the string can not be represented in the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e ByteString -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#decode_",
        "fct-type": "function",
        "title": "decode_"
      },
      "index": {
        "description": "Decode ByteString to CompactString using the given encoding decode recode fromByteString but it might be faster for some combinations of encodings Raises an error if the ByteString is not valid encoded string or if the string can not be represented in the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "decode_",
        "normalized": "a-\u003eByteString-\u003eCompactString b",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eByteString-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e returns the suffix of \u003ccode\u003exs\u003c/code\u003e after the first \u003ccode\u003en\u003c/code\u003e\n elements, or \u003ccode\u003eempty\u003c/code\u003e if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "drop xs returns the suffix of xs after the first elements or empty if length xs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "drop",
        "normalized": "Int-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e returns the suffix remaining after \u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "dropWhile xs returns the suffix remaining after takeWhile xs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "dropWhile",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "While",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e is the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e membership predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e Bool",
        "fct-source": "src/Data-CompactString.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "elem is the CompactString membership predicate",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "elem",
        "normalized": "Char-\u003eCompactString a-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e function returns the index of the first\n element in the given \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e which is equal to the query\n element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. \n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "The elemIndex function returns the index of the first element in the given ByteString which is equal to the query element or Nothing if there is no such element",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "elemIndex",
        "normalized": "Char-\u003eCompactString a-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index",
        "signature": "Char-\u003eCompactString a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:elemIndexEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndexEnd\u003c/a\u003e\u003c/code\u003e function returns the last index of the\n element in the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e which is equal to the query\n element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. The following\n holds:\n\u003c/p\u003e\u003cpre\u003e elemIndexEnd c xs == \n (-) (length xs - 1) `fmap` elemIndex c (reverse xs)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString.html#elemIndexEnd",
        "fct-type": "function",
        "title": "elemIndexEnd"
      },
      "index": {
        "description": "The elemIndexEnd function returns the last index of the element in the given CompactString which is equal to the query element or Nothing if there is no such element The following holds elemIndexEnd xs length xs fmap elemIndex reverse xs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "elemIndexEnd",
        "normalized": "Char-\u003eCompactString a-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index End",
        "signature": "Char-\u003eCompactString a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eelemIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003eelemIndex\u003c/a\u003e\u003c/code\u003e, by returning\n the indices of all elements equal to the query element, in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e [Int]",
        "fct-source": "src/Data-CompactString.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "The elemIndices function extends elemIndex by returning the indices of all elements equal to the query element in ascending order",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "elemIndices",
        "normalized": "Char-\u003eCompactString a-\u003e[Int]",
        "package": "compact-string",
        "partial": "Indices",
        "signature": "Char-\u003eCompactString a-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e The empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a",
        "fct-source": "src/Data-CompactString.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "The empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "empty",
        "normalized": "",
        "package": "compact-string",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a CompactString to a ByteString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e encode e = liftM toByteString . recode\n\u003c/pre\u003e\u003cp\u003eBut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eFails if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString a -\u003e m ByteString",
        "fct-source": "src/Data-CompactString.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Encode CompactString to ByteString using the given encoding encode liftM toByteString recode But it might be faster for some combinations of encodings Fails if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "encode",
        "normalized": "a-\u003eCompactString b-\u003ec ByteString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eCompactString a-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:encodeBOM",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e using the given encoding, and add a Byte Order Mark.\n   Byte Order Marks are common on Windows, but not on other platforms.\n\u003c/p\u003e\u003cp\u003eFails if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString a -\u003e m ByteString",
        "fct-source": "src/Data-CompactString.html#encodeBOM",
        "fct-type": "function",
        "title": "encodeBOM"
      },
      "index": {
        "description": "Encode CompactString using the given encoding and add Byte Order Mark Byte Order Marks are common on Windows but not on other platforms Fails if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "encodeBOM",
        "normalized": "a-\u003eCompactString b-\u003ec ByteString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "e-\u003eCompactString a-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:encodeBOM_",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e using the given encoding, and add a Byte Order Mark.\n   Byte Order Marks are common on Windows, but not on other platforms.\n\u003c/p\u003e\u003cp\u003eRaises an error if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString a -\u003e ByteString",
        "fct-source": "src/Data-CompactString.html#encodeBOM_",
        "fct-type": "function",
        "title": "encodeBOM_"
      },
      "index": {
        "description": "Encode CompactString using the given encoding and add Byte Order Mark Byte Order Marks are common on Windows but not on other platforms Raises an error if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "encodeBOM_",
        "normalized": "a-\u003eCompactString b-\u003eByteString",
        "package": "compact-string",
        "partial": "BOM",
        "signature": "e-\u003eCompactString a-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:encode_",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a CompactString to a ByteString using the given encoding.\n\u003c/p\u003e\u003cpre\u003e encode_ e = toByteString . recode\n\u003c/pre\u003e\u003cp\u003eBut it might be faster for some combinations of encodings.\n\u003c/p\u003e\u003cp\u003eRaises an error if the string is cannot be encoded in the target encoding.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "e -\u003e CompactString a -\u003e ByteString",
        "fct-source": "src/Data-CompactString.html#encode_",
        "fct-type": "function",
        "title": "encode_"
      },
      "index": {
        "description": "Encode CompactString to ByteString using the given encoding encode toByteString recode But it might be faster for some combinations of encodings Raises an error if the string is cannot be encoded in the target encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "encode_",
        "normalized": "a-\u003eCompactString b-\u003eByteString",
        "package": "compact-string",
        "partial": "",
        "signature": "e-\u003eCompactString a-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n returns a CompactString containing those characters that satisfy the\n predicate. This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "filter applied to predicate and CompactString returns CompactString containing those characters that satisfy the predicate This function is subject to array fusion",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "filter",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e function takes a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n and returns the first element in matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if there is no such element.\n\u003c/p\u003e\u003cpre\u003e find f p = case findIndex f p of Just n -\u003e Just (p `index` n) ; _ -\u003e Nothing\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e Maybe Char",
        "fct-source": "src/Data-CompactString.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "The find function takes predicate and CompactString and returns the first element in matching the predicate or Nothing if there is no such element find case findIndex of Just Just index Nothing",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "find",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003eMaybe Char",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003eMaybe Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e function takes a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and\n returns the index of the first element in the CompactString\n satisfying the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "The findIndex function takes predicate and CompactString and returns the index of the first element in the CompactString satisfying the predicate",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "findIndex",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:findIndexEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003efindIndexEnd\u003c/a\u003e\u003c/code\u003e function returns the last index of the\n element in the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e which satisfies the predicate,\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element. The following holds:\n\u003c/p\u003e\u003cpre\u003e findIndexEnd c xs == \n (-) (length xs - 1) `fmap` findIndex c (reverse xs)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e Maybe Int",
        "fct-source": "src/Data-CompactString.html#findIndexEnd",
        "fct-type": "function",
        "title": "findIndexEnd"
      },
      "index": {
        "description": "The findIndexEnd function returns the last index of the element in the given CompactString which satisfies the predicate or Nothing if there is no such element The following holds findIndexEnd xs length xs fmap findIndex reverse xs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "findIndexEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Index End",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e function extends \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e, by returning the\n indices of all elements satisfying the predicate, in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e [Int]",
        "fct-source": "src/Data-CompactString.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "The findIndices function extends findIndex by returning the indices of all elements satisfying the predicate in ascending order",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "findIndices",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003e[Int]",
        "package": "compact-string",
        "partial": "Indices",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:findSubstring",
      "description": {
        "fct-descr": "\u003cp\u003eGet the first index of a substring in another string,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not found.\n   \u003ccode\u003efindSubstring p s\u003c/code\u003e is equivalent to \u003ccode\u003elistToMaybe (findSubstrings p s)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a-\u003e CompactString a-\u003e Maybe Int",
        "fct-type": "function",
        "title": "findSubstring"
      },
      "index": {
        "description": "Get the first index of substring in another string or Nothing if the string is not found findSubstring is equivalent to listToMaybe findSubstrings",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "findSubstring",
        "normalized": "CompactString a-\u003eCompactString a-\u003eMaybe Int",
        "package": "compact-string",
        "partial": "Substring",
        "signature": "CompactString a-\u003eCompactString a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:findSubstrings",
      "description": {
        "fct-descr": "\u003cp\u003eFind the indexes of all (possibly overlapping) occurances of a\n substring in a string.  This function uses the Knuth-Morris-Pratt\n string matching algorithm.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a-\u003e CompactString a-\u003e [Int]",
        "fct-type": "function",
        "title": "findSubstrings"
      },
      "index": {
        "description": "Find the indexes of all possibly overlapping occurances of substring in string This function uses the Knuth-Morris-Pratt string matching algorithm",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "findSubstrings",
        "normalized": "CompactString a-\u003eCompactString a-\u003e[Int]",
        "package": "compact-string",
        "partial": "Substrings",
        "signature": "CompactString a-\u003eCompactString a-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value (typically\n the left-identity of the operator), and a CompactString, reduces the\n CompactString using the binary operator, from left to right.\n This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e acc -\u003e CompactString a -\u003e acc",
        "fct-source": "src/Data-CompactString.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "foldl applied to binary operator starting value typically the left-identity of the operator and CompactString reduces the CompactString using the binary operator from left to right This function is subject to array fusion",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "foldl",
        "normalized": "(a-\u003eChar-\u003ea)-\u003ea-\u003eCompactString b-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eacc-\u003eCompactString a-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldl\\'' is like \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but strict in the accumulator.\n Though actually foldl is also strict in the accumulator.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e acc) -\u003e acc -\u003e CompactString a -\u003e acc",
        "fct-source": "src/Data-CompactString.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "foldl is like foldl but strict in the accumulator Though actually foldl is also strict in the accumulator",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "foldl'",
        "normalized": "(a-\u003eChar-\u003ea)-\u003ea-\u003eCompactString b-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eChar-\u003eacc)-\u003eacc-\u003eCompactString a-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e that has no starting value\n argument, and thus must be applied to non-empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n This function is subject to array fusion. \n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "foldl1 is variant of foldl that has no starting value argument and thus must be applied to non-empty CompactString This function is subject to array fusion An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "foldl1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldl1\\'' is like \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e, but strict in the accumulator.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "foldl1 is like foldl1 but strict in the accumulator An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "foldl1'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value\n (typically the right-identity of the operator), and a CompactString,\n reduces the CompactString using the binary operator, from right to left.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e acc -\u003e acc) -\u003e acc -\u003e CompactString a -\u003e acc",
        "fct-source": "src/Data-CompactString.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "foldr applied to binary operator starting value typically the right-identity of the operator and CompactString reduces the CompactString using the binary operator from right to left",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "foldr",
        "normalized": "(Char-\u003ea-\u003ea)-\u003ea-\u003eCompactString b-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eacc-\u003eacc)-\u003eacc-\u003eCompactString a-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, applied to a binary operator, a starting value\n (typically the right-identity of the operator), and a CompactString,\n reduces the CompactString using the binary operator, from right to left.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e acc -\u003e acc) -\u003e acc -\u003e CompactString a -\u003e acc",
        "fct-source": "src/Data-CompactString.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "foldr applied to binary operator starting value typically the right-identity of the operator and CompactString reduces the CompactString using the binary operator from right to left",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "foldr'",
        "normalized": "(Char-\u003ea-\u003ea)-\u003ea-\u003eCompactString b-\u003ea",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eacc-\u003eacc)-\u003eacc-\u003eCompactString a-\u003eacc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e that has no starting value argument,\n and thus must be applied to non-empty \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "foldr1 is variant of foldr that has no starting value argument and thus must be applied to non-empty CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "foldr1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e'foldr1\\'' is a variant of \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e, but is strict in the\n accumulator.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "foldr1 is variant of foldr1 but is strict in the accumulator An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "foldr1'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:fromByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString.\n   Fails if the ByteString is not a valid encoded string.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e m (CompactString a)",
        "fct-source": "src/Data-CompactString.html#fromByteString",
        "fct-type": "function",
        "title": "fromByteString"
      },
      "index": {
        "description": "Convert ByteString to CompactString Fails if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "fromByteString",
        "normalized": "ByteString-\u003ea(CompactString b)",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "ByteString-\u003em(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:fromByteString_",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a ByteString to a CompactString.\n   Raises an error if the ByteString is not a valid encoded string.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "ByteString -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#fromByteString_",
        "fct-type": "function",
        "title": "fromByteString_"
      },
      "index": {
        "description": "Convert ByteString to CompactString Raises an error if the ByteString is not valid encoded string",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "fromByteString_",
        "normalized": "ByteString-\u003eCompactString a",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "ByteString-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:getContents",
      "description": {
        "fct-descr": "\u003cp\u003egetContents. Equivalent to \u003ccode\u003ehGetContents stdin\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eInput is assumed to be in the encoding \u003ccode\u003ea\u003c/code\u003e, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#getContents",
        "fct-type": "function",
        "title": "getContents"
      },
      "index": {
        "description": "getContents Equivalent to hGetContents stdin Input is assumed to be in the encoding this may not be appropriate",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "getContents",
        "normalized": "",
        "package": "compact-string",
        "partial": "Contents",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:getLine",
      "description": {
        "fct-descr": "\u003cp\u003eRead a line from stdin.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#getLine",
        "fct-type": "function",
        "title": "getLine"
      },
      "index": {
        "description": "Read line from stdin",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "getLine",
        "normalized": "",
        "package": "compact-string",
        "partial": "Line",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:group",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and returns a list of\n CompactStrings such that the concatenation of the result is equal to the\n argument.  Moreover, each sublist in the result contains only equal\n elements.  For example,\n\u003c/p\u003e\u003cpre\u003e group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own equality test.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#group",
        "fct-type": "function",
        "title": "group"
      },
      "index": {
        "description": "The group function takes CompactString and returns list of CompactStrings such that the concatenation of the result is equal to the argument Moreover each sublist in the result contains only equal elements For example group Mississippi ss ss pp It is special case of groupBy which allows the programmer to supply their own equality test",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "group",
        "normalized": "CompactString a-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:groupBy",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Bool) -\u003e CompactString a -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#groupBy",
        "fct-type": "function",
        "title": "groupBy"
      },
      "index": {
        "description": "The groupBy function is the non-overloaded version of group",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "groupBy",
        "normalized": "(Char-\u003eChar-\u003eBool)-\u003eCompactString a-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "By",
        "signature": "(Char-\u003eChar-\u003eBool)-\u003eCompactString a-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:hGet",
      "description": {
        "fct-descr": "\u003cp\u003eRead a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e directly from the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e Int -\u003e IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#hGet",
        "fct-type": "function",
        "title": "hGet"
      },
      "index": {
        "description": "Read CompactString directly from the specified Handle The handle is interpreted as the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "hGet",
        "normalized": "Handle-\u003eInt-\u003eIO(CompactString a)",
        "package": "compact-string",
        "partial": "Get",
        "signature": "Handle-\u003eInt-\u003eIO(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:hGetContents",
      "description": {
        "fct-descr": "\u003cp\u003eRead entire handle contents into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#hGetContents",
        "fct-type": "function",
        "title": "hGetContents"
      },
      "index": {
        "description": "Read entire handle contents into CompactString The handle is interpreted as the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "hGetContents",
        "normalized": "Handle-\u003eIO(CompactString a)",
        "package": "compact-string",
        "partial": "Get Contents",
        "signature": "Handle-\u003eIO(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:hGetContents-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRead entire handle contents into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe encoding is determined based on a Byte Order Mark, see \u003ccode\u003e\u003ca\u003edecodeBOM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#hGetContents%27",
        "fct-type": "function",
        "title": "hGetContents'"
      },
      "index": {
        "description": "Read entire handle contents into CompactString The encoding is determined based on Byte Order Mark see decodeBOM",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "hGetContents'",
        "normalized": "Handle-\u003eIO(CompactString a)",
        "package": "compact-string",
        "partial": "Get Contents'",
        "signature": "Handle-\u003eIO(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:hGetLine",
      "description": {
        "fct-descr": "\u003cp\u003eRead a line from a handle\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#hGetLine",
        "fct-type": "function",
        "title": "hGetLine"
      },
      "index": {
        "description": "Read line from handle",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "hGetLine",
        "normalized": "Handle-\u003eIO(CompactString a)",
        "package": "compact-string",
        "partial": "Get Line",
        "signature": "Handle-\u003eIO(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:hGetNonBlocking",
      "description": {
        "fct-descr": "\u003cp\u003ehGetNonBlocking is identical to \u003ccode\u003e\u003ca\u003ehGet\u003c/a\u003e\u003c/code\u003e, except that it will never block\n waiting for data to become available, instead it returns only whatever data\n is available.\n\u003c/p\u003e\u003cp\u003eThe handle is interpreted as the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e Int -\u003e IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#hGetNonBlocking",
        "fct-type": "function",
        "title": "hGetNonBlocking"
      },
      "index": {
        "description": "hGetNonBlocking is identical to hGet except that it will never block waiting for data to become available instead it returns only whatever data is available The handle is interpreted as the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "hGetNonBlocking",
        "normalized": "Handle-\u003eInt-\u003eIO(CompactString a)",
        "package": "compact-string",
        "partial": "Get Non Blocking",
        "signature": "Handle-\u003eInt-\u003eIO(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:hPut",
      "description": {
        "fct-descr": "\u003cp\u003eOutputs a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eOutput is written in the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#hPut",
        "fct-type": "function",
        "title": "hPut"
      },
      "index": {
        "description": "Outputs CompactString to the specified Handle Output is written in the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "hPut",
        "normalized": "Handle-\u003eCompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "Put",
        "signature": "Handle-\u003eCompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:hPutStr",
      "description": {
        "fct-descr": "\u003cp\u003eA synonym for \u003ccode\u003ehPut\u003c/code\u003e, for compatibility \n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#hPutStr",
        "fct-type": "function",
        "title": "hPutStr"
      },
      "index": {
        "description": "synonym for hPut for compatibility",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "hPutStr",
        "normalized": "Handle-\u003eCompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "Put Str",
        "signature": "Handle-\u003eCompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:hPutStrLn",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a handle, appending a newline byte\n\u003c/p\u003e\u003cp\u003eOutput is written in the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Handle -\u003e CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#hPutStrLn",
        "fct-type": "function",
        "title": "hPutStrLn"
      },
      "index": {
        "description": "Write CompactString to handle appending newline byte Output is written in the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "hPutStrLn",
        "normalized": "Handle-\u003eCompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "Put Str Ln",
        "signature": "Handle-\u003eCompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the first element of a CompactString, which must be non-empty.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "Extract the first element of CompactString which must be non-empty An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "head",
        "normalized": "CompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:headView",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e A view of the front of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e headView s = if null s then Nothing else Just (head s, tail s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Maybe (Char, CompactString a)",
        "fct-source": "src/Data-CompactString.html#headView",
        "fct-type": "function",
        "title": "headView"
      },
      "index": {
        "description": "view of the front of CompactString headView if null then Nothing else Just head tail",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "headView",
        "normalized": "CompactString a-\u003eMaybe(Char,CompactString a)",
        "package": "compact-string",
        "partial": "View",
        "signature": "CompactString a-\u003eMaybe(Char,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:index",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e index (subscript) operator, starting from 0.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Int -\u003e Char",
        "fct-source": "src/Data-CompactString.html#index",
        "fct-type": "function",
        "title": "index"
      },
      "index": {
        "description": "CompactString index subscript operator starting from",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "index",
        "normalized": "CompactString a-\u003eInt-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eInt-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Return all the elements of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e except the last one.\n An exception will be thrown in the case of an empty ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Return all the elements of CompactString except the last one An exception will be thrown in the case of an empty ByteString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "init",
        "normalized": "CompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:inits",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Return all initial segments of the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, shortest first.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#inits",
        "fct-type": "function",
        "title": "inits"
      },
      "index": {
        "description": "Return all initial segments of the given CompactString shortest first",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "inits",
        "normalized": "CompactString a-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:interact",
      "description": {
        "fct-descr": "\u003cp\u003eThe interact function takes a function of type \u003ccode\u003eCompactString -\u003e CompactString\u003c/code\u003e\n as its argument. The entire input from the standard input device is passed\n to this function as its argument, and the resulting string is output on the\n standard output device. It's great for writing one line programs!\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(CompactString a -\u003e CompactString a) -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#interact",
        "fct-type": "function",
        "title": "interact"
      },
      "index": {
        "description": "The interact function takes function of type CompactString CompactString as its argument The entire input from the standard input device is passed to this function as its argument and the resulting string is output on the standard output device It great for writing one line programs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "interact",
        "normalized": "(CompactString a-\u003eCompactString a)-\u003eIO()",
        "package": "compact-string",
        "partial": "",
        "signature": "(CompactString a-\u003eCompactString a)-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:intercalate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eintercalate\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and a list of\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es and concatenates the list after interspersing the first\n argument between each element of the list.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e [CompactString a] -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#intercalate",
        "fct-type": "function",
        "title": "intercalate"
      },
      "index": {
        "description": "The intercalate function takes CompactString and list of CompactString and concatenates the list after interspersing the first argument between each element of the list",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "intercalate",
        "normalized": "CompactString a-\u003e[CompactString a]-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003e[CompactString a]-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:intersperse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eintersperse\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e and a\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e and `intersperses' that character between the elements of\n the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  It is analogous to the intersperse function on\n Lists.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#intersperse",
        "fct-type": "function",
        "title": "intersperse"
      },
      "index": {
        "description": "The intersperse function takes Char and CompactString and intersperses that character between the elements of the CompactString It is analogous to the intersperse function on Lists",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "intersperse",
        "normalized": "Char-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:isInfixOf",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether one string is a substring of another. \u003ccode\u003eisInfixOf\n p s\u003c/code\u003e is equivalent to \u003ccode\u003enot (null (findSubstrings p s))\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a-\u003e CompactString a-\u003e Bool",
        "fct-type": "function",
        "title": "isInfixOf"
      },
      "index": {
        "description": "Check whether one string is substring of another isInfixOf is equivalent to not null findSubstrings",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "isInfixOf",
        "normalized": "CompactString a-\u003eCompactString a-\u003eBool",
        "package": "compact-string",
        "partial": "Infix Of",
        "signature": "CompactString a-\u003eCompactString a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:isPrefixOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eisPrefixOf\u003c/a\u003e\u003c/code\u003e function takes two CompactString and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first is a prefix of the second.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a -\u003e Bool",
        "fct-source": "src/Data-CompactString.html#isPrefixOf",
        "fct-type": "function",
        "title": "isPrefixOf"
      },
      "index": {
        "description": "The isPrefixOf function takes two CompactString and returns True iff the first is prefix of the second",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "isPrefixOf",
        "normalized": "CompactString a-\u003eCompactString a-\u003eBool",
        "package": "compact-string",
        "partial": "Prefix Of",
        "signature": "CompactString a-\u003eCompactString a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:isSuffixOf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e The \u003ccode\u003e\u003ca\u003eisSuffixOf\u003c/a\u003e\u003c/code\u003e function takes two CompactString and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first is a suffix of the second.\n\u003c/p\u003e\u003cp\u003eThe following holds:\n\u003c/p\u003e\u003cpre\u003e isSuffixOf x y == reverse x `isPrefixOf` reverse y\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a -\u003e Bool",
        "fct-source": "src/Data-CompactString.html#isSuffixOf",
        "fct-type": "function",
        "title": "isSuffixOf"
      },
      "index": {
        "description": "The isSuffixOf function takes two CompactString and returns True iff the first is suffix of the second The following holds isSuffixOf reverse isPrefixOf reverse",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "isSuffixOf",
        "normalized": "CompactString a-\u003eCompactString a-\u003eBool",
        "package": "compact-string",
        "partial": "Suffix Of",
        "signature": "CompactString a-\u003eCompactString a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the last element of a ByteString, which must be finite and non-empty.\n An exception will be thrown in the case of an empty ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Extract the last element of ByteString which must be finite and non-empty An exception will be thrown in the case of an empty ByteString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "last",
        "normalized": "CompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:lastView",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e A view of the back of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e lastView s = if null s then Nothing else Just (init s, last s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Maybe (CompactString a, Char)",
        "fct-source": "src/Data-CompactString.html#lastView",
        "fct-type": "function",
        "title": "lastView"
      },
      "index": {
        "description": "view of the back of CompactString lastView if null then Nothing else Just init last",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "lastView",
        "normalized": "CompactString a-\u003eMaybe(CompactString a,Char)",
        "package": "compact-string",
        "partial": "View",
        "signature": "CompactString a-\u003eMaybe(CompactString a,Char)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e returns the length of a CompactString as an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Int",
        "fct-source": "src/Data-CompactString.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "length returns the length of CompactString as an Int",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "length",
        "normalized": "CompactString a-\u003eInt",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:lines",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e breaks a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e up into a list of CompactStrings at\n newline Chars. The resulting strings do not contain newlines.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#lines",
        "fct-type": "function",
        "title": "lines"
      },
      "index": {
        "description": "lines breaks CompactString up into list of CompactStrings at newline Chars The resulting strings do not contain newlines",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "lines",
        "normalized": "CompactString a-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef xs\u003c/code\u003e is the CompactString obtained by applying \u003ccode\u003ef\u003c/code\u003e to each\n element of \u003ccode\u003exs\u003c/code\u003e. This function is subject to array fusion.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char) -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "map xs is the CompactString obtained by applying to each element of xs This function is subject to array fusion",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "map",
        "normalized": "(Char-\u003eChar)-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar)-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:mapAccumL",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a CompactString,\n passing an accumulating parameter from left to right, and returning a\n final value of this accumulator together with the new CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e acc -\u003e CompactString a -\u003e (acc, CompactString a)",
        "fct-source": "src/Data-CompactString.html#mapAccumL",
        "fct-type": "function",
        "title": "mapAccumL"
      },
      "index": {
        "description": "The mapAccumL function behaves like combination of map and foldl it applies function to each element of CompactString passing an accumulating parameter from left to right and returning final value of this accumulator together with the new CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "mapAccumL",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003ea-\u003eCompactString b-\u003e(a,CompactString b)",
        "package": "compact-string",
        "partial": "Accum",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eacc-\u003eCompactString a-\u003e(acc,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:mapAccumR",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e function behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e; it applies a function to each element of a CompactString,\n passing an accumulating parameter from right to left, and returning a\n final value of this accumulator together with the new CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Char -\u003e (acc, Char)) -\u003e acc -\u003e CompactString a -\u003e (acc, CompactString a)",
        "fct-source": "src/Data-CompactString.html#mapAccumR",
        "fct-type": "function",
        "title": "mapAccumR"
      },
      "index": {
        "description": "The mapAccumR function behaves like combination of map and foldr it applies function to each element of CompactString passing an accumulating parameter from right to left and returning final value of this accumulator together with the new CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "mapAccumR",
        "normalized": "(a-\u003eChar-\u003e(a,Char))-\u003ea-\u003eCompactString b-\u003e(a,CompactString b)",
        "package": "compact-string",
        "partial": "Accum",
        "signature": "(acc-\u003eChar-\u003e(acc,Char))-\u003eacc-\u003eCompactString a-\u003e(acc,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:mapIndexed",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e map Char functions, provided with the index at each position.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Int -\u003e Char -\u003e Char) -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#mapIndexed",
        "fct-type": "function",
        "title": "mapIndexed"
      },
      "index": {
        "description": "map Char functions provided with the index at each position",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "mapIndexed",
        "normalized": "(Int-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "Indexed",
        "signature": "(Int-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003emaximum\u003c/a\u003e\u003c/code\u003e returns the maximum value from a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "maximum returns the maximum value from CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "maximum",
        "normalized": "CompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eminimum\u003c/a\u003e\u003c/code\u003e returns the minimum value from a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Char",
        "fct-source": "src/Data-CompactString.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "minimum returns the minimum value from CompactString An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "minimum",
        "normalized": "CompactString a-\u003eChar",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eChar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003enotElem\u003c/a\u003e\u003c/code\u003e is the inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e Bool",
        "fct-source": "src/Data-CompactString.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "notElem is the inverse of elem",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "notElem",
        "normalized": "Char-\u003eCompactString a-\u003eBool",
        "package": "compact-string",
        "partial": "Elem",
        "signature": "Char-\u003eCompactString a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a CompactString is empty.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Bool",
        "fct-source": "src/Data-CompactString.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether CompactString is empty",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "null",
        "normalized": "CompactString a-\u003eBool",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:pack",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "String -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#pack",
        "fct-type": "function",
        "title": "pack"
      },
      "index": {
        "description": "Convert String into CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "pack",
        "normalized": "String-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "String-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e, applied to a predicate and a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e,\n returns a pair of CompactStrings.\n The first containing those characters that satisfy the predicate,\n the second containg those that don't.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e (CompactString a, CompactString a)",
        "fct-source": "src/Data-CompactString.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "partition applied to predicate and CompactString returns pair of CompactStrings The first containing those characters that satisfy the predicate the second containg those that don",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "partition",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:putStr",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to stdout.\n\u003c/p\u003e\u003cp\u003eOutput is written in the encoding \u003ccode\u003ea\u003c/code\u003e, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#putStr",
        "fct-type": "function",
        "title": "putStr"
      },
      "index": {
        "description": "Write CompactString to stdout Output is written in the encoding this may not be appropriate",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "putStr",
        "normalized": "CompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "Str",
        "signature": "CompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:putStrLn",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to stdout, appending a newline character.\n\u003c/p\u003e\u003cp\u003eOutput is written in the encoding \u003ccode\u003ea\u003c/code\u003e, this may not be appropriate.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#putStrLn",
        "fct-type": "function",
        "title": "putStrLn"
      },
      "index": {
        "description": "Write CompactString to stdout appending newline character Output is written in the encoding this may not be appropriate",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "putStrLn",
        "normalized": "CompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "Str Ln",
        "signature": "CompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:readFile",
      "description": {
        "fct-descr": "\u003cp\u003eRead an entire file strictly into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  This is far more\n   efficient than reading the characters into a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and then using\n   \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e. Files are read using 'text mode' on Windows.\n\u003c/p\u003e\u003cp\u003eFiles are assumed to be in the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#readFile",
        "fct-type": "function",
        "title": "readFile"
      },
      "index": {
        "description": "Read an entire file strictly into CompactString This is far more efficient than reading the characters into String and then using pack Files are read using text mode on Windows Files are assumed to be in the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "readFile",
        "normalized": "FilePath-\u003eIO(CompactString a)",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eIO(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:readFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRead an entire file strictly into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e.  This is far more\n   efficient than reading the characters into a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and then using\n   \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e. Files are read using 'text mode' on Windows.\n\u003c/p\u003e\u003cp\u003eThe encoding of the file is determined based on a Byte Order Mark, see \u003ccode\u003e\u003ca\u003edecodeBOM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e IO (CompactString a)",
        "fct-source": "src/Data-CompactString.html#readFile%27",
        "fct-type": "function",
        "title": "readFile'"
      },
      "index": {
        "description": "Read an entire file strictly into CompactString This is far more efficient than reading the characters into String and then using pack Files are read using text mode on Windows The encoding of the file is determined based on Byte Order Mark see decodeBOM",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "readFile'",
        "normalized": "FilePath-\u003eIO(CompactString a)",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eIO(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:recode",
      "description": {
        "fct-descr": "\u003cp\u003eConvert between two different encodings, fails if conversion is not possible.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e m (CompactString b)",
        "fct-source": "src/Data-CompactString.html#recode",
        "fct-type": "function",
        "title": "recode"
      },
      "index": {
        "description": "Convert between two different encodings fails if conversion is not possible",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "recode",
        "normalized": "CompactString a-\u003eb(CompactString c)",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003em(CompactString b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:recode_",
      "description": {
        "fct-descr": "\u003cp\u003eConvert between two different encodings, raises an error if conversion is not possible.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString b",
        "fct-source": "src/Data-CompactString.html#recode_",
        "fct-type": "function",
        "title": "recode_"
      },
      "index": {
        "description": "Convert between two different encodings raises an error if conversion is not possible",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "recode_",
        "normalized": "CompactString a-\u003eCompactString b",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en x\u003c/code\u003e is a CompactString of length \u003ccode\u003en\u003c/code\u003e with \u003ccode\u003ex\u003c/code\u003e\n the value of every element. The following holds:\n\u003c/p\u003e\u003cpre\u003e replicate w c = unfoldr w (\\u -\u003e Just (u,u)) c\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e Char -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "replicate is CompactString of length with the value of every element The following holds replicate unfoldr Just",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "replicate",
        "normalized": "Int-\u003eChar-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eChar-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003eReverse a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "reverse",
        "normalized": "CompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e is similar to \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but returns a list of successive\n reduced values from the left. This function will fuse.\n\u003c/p\u003e\u003cpre\u003e scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\n\u003c/pre\u003e\u003cp\u003eNote that\n\u003c/p\u003e\u003cpre\u003e last (scanl f z xs) == foldl f z xs.\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e Char -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "scanl is similar to foldl but returns list of successive reduced values from the left This function will fuse scanl x1 x2 x1 x1 x2 Note that last scanl xs foldl xs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "scanl",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n This function will fuse.\n\u003c/p\u003e\u003cpre\u003e scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "scanl1 is variant of scanl that has no starting value argument This function will fuse scanl1 x1 x2 x1 x1 x2",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "scanl1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003escanr is the right-to-left dual of scanl.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e Char -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "scanr is the right-to-left dual of scanl",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "scanr",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eChar-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "scanr1 is variant of scanr that has no starting value argument",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "scanr1",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Convert Char into CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "singleton",
        "normalized": "Char-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append a byte to the end of a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e Char -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append byte to the end of CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "snoc",
        "normalized": "CompactString a-\u003eChar-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eChar-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:sort",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e Sort a CompactString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#sort",
        "fct-type": "function",
        "title": "sort"
      },
      "index": {
        "description": "log Sort CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "sort",
        "normalized": "CompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep xs\u003c/code\u003e breaks the ByteString into two segments. It is\n equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e p xs, \u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e p xs)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e (CompactString a, CompactString a)",
        "fct-source": "src/Data-CompactString.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "span xs breaks the ByteString into two segments It is equivalent to takeWhile xs dropWhile xs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "span",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)",
        "package": "compact-string",
        "partial": "",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:spanEnd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003espanEnd\u003c/a\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e but from the end of the \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWe have\n\u003c/p\u003e\u003cpre\u003e spanEnd (not.isSpace) \"x y z\" == (\"x y \",\"z\")\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e spanEnd (not . isSpace) cs\n    == \n let (x,y) = span (not.isSpace) (reverse cs) in (reverse y, reverse x)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e (CompactString a, CompactString a)",
        "fct-source": "src/Data-CompactString.html#spanEnd",
        "fct-type": "function",
        "title": "spanEnd"
      },
      "index": {
        "description": "spanEnd behaves like span but from the end of the CompactString We have spanEnd not.isSpace and spanEnd not isSpace cs let span not.isSpace reverse cs in reverse reverse",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "spanEnd",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)",
        "package": "compact-string",
        "partial": "End",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003e(CompactString a,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:split",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Break a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into pieces separated by the byte\n argument, consuming the delimiter. I.e.\n\u003c/p\u003e\u003cpre\u003e split '\\n' \"a\\nb\\nd\\ne\" == [\"a\",\"b\",\"d\",\"e\"]\n split 'a'  \"aXaXaXa\"    == [\"\",\"X\",\"X\",\"X\",\"\"]\n split 'x'  \"x\"          == [\"\",\"\"]\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e intercalate [c] . split c == id\n split == splitWith . (==)\n\u003c/pre\u003e\u003cp\u003eAs for all splitting functions in this library, this function does\n not copy the substrings, it just constructs new \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e that\n are slices of the original.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Char -\u003e CompactString a -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#split",
        "fct-type": "function",
        "title": "split"
      },
      "index": {
        "description": "Break ByteString into pieces separated by the byte argument consuming the delimiter I.e split nb nd ne split aXaXaXa split and intercalate split id split splitWith As for all splitting functions in this library this function does not copy the substrings it just constructs new CompactString that are slices of the original",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "split",
        "normalized": "Char-\u003eCompactString a-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "",
        "signature": "Char-\u003eCompactString a-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en xs\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n xs)\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString a -\u003e (CompactString a, CompactString a)",
        "fct-source": "src/Data-CompactString.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "splitAt xs is equivalent to take xs drop xs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "splitAt",
        "normalized": "Int-\u003eCompactString a-\u003e(CompactString a,CompactString a)",
        "package": "compact-string",
        "partial": "At",
        "signature": "Int-\u003eCompactString a-\u003e(CompactString a,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:splitWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Splits a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e into components delimited by\n separators, where the predicate returns True for a separator element.\n The resulting components do not contain the separators.  Two adjacent\n separators result in an empty component in the output.  eg.\n\u003c/p\u003e\u003cpre\u003e splitWith (=='a') \"aabbaca\" == [\"\",\"\",\"bb\",\"c\",\"\"]\n splitWith (=='a') []        == []\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#splitWith",
        "fct-type": "function",
        "title": "splitWith"
      },
      "index": {
        "description": "Splits CompactString into components delimited by separators where the predicate returns True for separator element The resulting components do not contain the separators Two adjacent separators result in an empty component in the output eg splitWith aabbaca bb splitWith",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "splitWith",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "With",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Extract the elements after the head of a CompactString, which must be non-empty.\n An exception will be thrown in the case of an empty CompactString.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Extract the elements after the head of CompactString which must be non-empty An exception will be thrown in the case of an empty CompactString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "tail",
        "normalized": "CompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:tails",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Return all final segments of the given \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e, longest first.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#tails",
        "fct-type": "function",
        "title": "tails"
      },
      "index": {
        "description": "Return all final segments of the given CompactString longest first",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "tails",
        "normalized": "CompactString a-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en\u003c/code\u003e, applied to a CompactString \u003ccode\u003exs\u003c/code\u003e, returns the prefix\n of \u003ccode\u003exs\u003c/code\u003e of length \u003ccode\u003en\u003c/code\u003e, or \u003ccode\u003exs\u003c/code\u003e itself if \u003ccode\u003en \u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e xs\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "take applied to CompactString xs returns the prefix of xs of length or xs itself if length xs",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "take",
        "normalized": "Int-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e, applied to a predicate \u003ccode\u003ep\u003c/code\u003e and a CompactString \u003ccode\u003exs\u003c/code\u003e,\n returns the longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n satisfy \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Bool) -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "takeWhile applied to predicate and CompactString xs returns the longest prefix possibly empty of xs of elements that satisfy",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "takeWhile",
        "normalized": "(Char-\u003eBool)-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "While",
        "signature": "(Char-\u003eBool)-\u003eCompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:toByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a CompactString to a ByteString\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e ByteString",
        "fct-source": "src/Data-CompactString.html#toByteString",
        "fct-type": "function",
        "title": "toByteString"
      },
      "index": {
        "description": "Convert CompactString to ByteString",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "toByteString",
        "normalized": "CompactString a-\u003eByteString",
        "package": "compact-string",
        "partial": "Byte String",
        "signature": "CompactString a-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:transpose",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e function transposes the rows and columns of its\n \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e argument.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString a] -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#transpose",
        "fct-type": "function",
        "title": "transpose"
      },
      "index": {
        "description": "The transpose function transposes the rows and columns of its CompactString argument",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "transpose",
        "normalized": "[CompactString a]-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString a]-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e, where \u003cem\u003en\u003c/em\u003e is the length of the result.  The \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e \n function is analogous to the List 'unfoldr'.  \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e builds a \n ByteString from a seed value.  The function takes the element and \n returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it is done producing the CompactString or returns \n \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(a,b)\u003c/code\u003e, in which case, \u003ccode\u003ea\u003c/code\u003e is the next byte in the string, \n and \u003ccode\u003eb\u003c/code\u003e is the seed value for further production.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e    unfoldr (\\x -\u003e if x \u003c= 5 then Just (x, x + 1) else Nothing) 0\n == pack [0, 1, 2, 3, 4, 5]\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(acc -\u003e Maybe (Char, acc)) -\u003e acc -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "where is the length of the result The unfoldr function is analogous to the List unfoldr unfoldr builds ByteString from seed value The function takes the element and returns Nothing if it is done producing the CompactString or returns Just in which case is the next byte in the string and is the seed value for further production Examples unfoldr if then Just else Nothing pack",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(Char,a))-\u003ea-\u003eCompactString b",
        "package": "compact-string",
        "partial": "",
        "signature": "(acc-\u003eMaybe(Char,acc))-\u003eacc-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Like \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e builds a ByteString from a seed\n value.  However, the length of the result is limited by the first\n argument to \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e.  This function is more efficient than \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e\n when the maximum length of the result is known.\n\u003c/p\u003e\u003cp\u003eThe following equation relates \u003ccode\u003e\u003ca\u003eunfoldrN\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e fst (unfoldrN n f s) == take n (unfoldr f s)\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "Int -\u003e (acc -\u003e Maybe (Char, acc)) -\u003e acc -\u003e (CompactString a, Maybe acc)",
        "fct-source": "src/Data-CompactString.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Like unfoldr unfoldrN builds ByteString from seed value However the length of the result is limited by the first argument to unfoldrN This function is more efficient than unfoldr when the maximum length of the result is known The following equation relates unfoldrN and unfoldr fst unfoldrN take unfoldr",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(Char,a))-\u003ea-\u003e(CompactString b,Maybe a)",
        "package": "compact-string",
        "partial": "",
        "signature": "Int-\u003e(acc-\u003eMaybe(Char,acc))-\u003eacc-\u003e(CompactString a,Maybe acc)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:unlines",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e is an inverse operation to \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e.  It joins lines,\n after appending a terminating newline to each.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString a] -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#unlines",
        "fct-type": "function",
        "title": "unlines"
      },
      "index": {
        "description": "unlines is an inverse operation to lines It joins lines after appending terminating newline to each",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "unlines",
        "normalized": "[CompactString a]-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString a]-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:unpack",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Converts a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e String",
        "fct-source": "src/Data-CompactString.html#unpack",
        "fct-type": "function",
        "title": "unpack"
      },
      "index": {
        "description": "Converts CompactString to String",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "unpack",
        "normalized": "CompactString a-\u003eString",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:unwords",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunwords\u003c/a\u003e\u003c/code\u003e function is analogous to the \u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e function, on words.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "[CompactString a] -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#unwords",
        "fct-type": "function",
        "title": "unwords"
      },
      "index": {
        "description": "The unwords function is analogous to the unlines function on words",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "unwords",
        "normalized": "[CompactString a]-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "[CompactString a]-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e transforms a list of pairs of bytes into a pair of\n CompactStrings. Note that this performs two \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "[(Char, Char)] -\u003e (CompactString a, CompactString a)",
        "fct-source": "src/Data-CompactString.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "unzip transforms list of pairs of bytes into pair of CompactStrings Note that this performs two pack operations",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "unzip",
        "normalized": "[(Char,Char)]-\u003e(CompactString a,CompactString a)",
        "package": "compact-string",
        "partial": "",
        "signature": "[(Char,Char)]-\u003e(CompactString a,CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:validate",
      "description": {
        "fct-descr": "\u003cp\u003eValidates a CompactString.\n   If the string is invalid, fails, otherwise returns the input.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e m (CompactString a)",
        "fct-source": "src/Data-CompactString.html#validate",
        "fct-type": "function",
        "title": "validate"
      },
      "index": {
        "description": "Validates CompactString If the string is invalid fails otherwise returns the input",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "validate",
        "normalized": "CompactString a-\u003eb(CompactString a)",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003em(CompactString a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:validate_",
      "description": {
        "fct-descr": "\u003cp\u003eValidates a CompactString.\n   If the string is invalid, throws an error, otherwise returns the input.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#validate_",
        "fct-type": "function",
        "title": "validate_"
      },
      "index": {
        "description": "Validates CompactString If the string is invalid throws an error otherwise returns the input",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "validate_",
        "normalized": "CompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:words",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e breaks a ByteString up into a list of words, which\n were delimited by Chars representing white space. And\n\u003c/p\u003e\u003cpre\u003e words = filter (not . null) . splitWith isSpace\n\u003c/pre\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e [CompactString a]",
        "fct-source": "src/Data-CompactString.html#words",
        "fct-type": "function",
        "title": "words"
      },
      "index": {
        "description": "words breaks ByteString up into list of words which were delimited by Chars representing white space And words filter not null splitWith isSpace",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "words",
        "normalized": "CompactString a-\u003e[CompactString a]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003e[CompactString a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:writeFile",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using the encoding \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#writeFile",
        "fct-type": "function",
        "title": "writeFile"
      },
      "index": {
        "description": "Write CompactString to file Files are written using the encoding",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "writeFile",
        "normalized": "FilePath-\u003eCompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "File",
        "signature": "FilePath-\u003eCompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:writeFile-39-",
      "description": {
        "fct-descr": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003e to a file.\n\u003c/p\u003e\u003cp\u003eFiles are written using the encoding \u003ccode\u003ea\u003c/code\u003e.\n   A Byte Order Mark is also written.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "FilePath -\u003e CompactString a -\u003e IO ()",
        "fct-source": "src/Data-CompactString.html#writeFile%27",
        "fct-type": "function",
        "title": "writeFile'"
      },
      "index": {
        "description": "Write CompactString to file Files are written using the encoding Byte Order Mark is also written",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "writeFile'",
        "normalized": "FilePath-\u003eCompactString a-\u003eIO()",
        "package": "compact-string",
        "partial": "File'",
        "signature": "FilePath-\u003eCompactString a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e takes two ByteStrings and returns a list of\n corresponding pairs of bytes. If one input ByteString is short,\n excess elements of the longer ByteString are discarded. This is\n equivalent to a pair of \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "CompactString a -\u003e CompactString a -\u003e [(Char, Char)]",
        "fct-source": "src/Data-CompactString.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "zip takes two ByteStrings and returns list of corresponding pairs of bytes If one input ByteString is short excess elements of the longer ByteString are discarded This is equivalent to pair of unpack operations",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "zip",
        "normalized": "CompactString a-\u003eCompactString a-\u003e[(Char,Char)]",
        "package": "compact-string",
        "partial": "",
        "signature": "CompactString a-\u003eCompactString a-\u003e[(Char,Char)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e generalises \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e by zipping with the function given as\n the first argument, instead of a tupling function.  For example,\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e (+)\u003c/code\u003e is applied to two ByteStrings to produce the list of\n corresponding sums. \n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e b) -\u003e CompactString a -\u003e CompactString a -\u003e [b]",
        "fct-source": "src/Data-CompactString.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "zipWith generalises zip by zipping with the function given as the first argument instead of tupling function For example zipWith is applied to two ByteStrings to produce the list of corresponding sums",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "zipWith",
        "normalized": "(Char-\u003eChar-\u003ea)-\u003eCompactString b-\u003eCompactString b-\u003e[a]",
        "package": "compact-string",
        "partial": "With",
        "signature": "(Char-\u003eChar-\u003eb)-\u003eCompactString a-\u003eCompactString a-\u003e[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compact-string/docs/Data-CompactString.html#v:zipWith-39-",
      "description": {
        "fct-descr": "\u003cp\u003eA specialised version of \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e for the common case of a\n simultaneous map over two \u003ccode\u003e\u003ca\u003eCompactString\u003c/a\u003e\u003c/code\u003es, to build a 3rd. Rewrite rules\n are used to automatically covert zipWith into zipWith' when a pack is\n performed on the result of zipWith, but we also export it for\n convenience.\n\u003c/p\u003e",
        "fct-module": "Data.CompactString",
        "fct-package": "compact-string",
        "fct-signature": "(Char -\u003e Char -\u003e Char) -\u003e CompactString a -\u003e CompactString a -\u003e CompactString a",
        "fct-source": "src/Data-CompactString.html#zipWith%27",
        "fct-type": "function",
        "title": "zipWith'"
      },
      "index": {
        "description": "specialised version of zipWith for the common case of simultaneous map over two CompactString to build rd Rewrite rules are used to automatically covert zipWith into zipWith when pack is performed on the result of zipWith but we also export it for convenience",
        "hierarchy": "Data CompactString",
        "module": "Data.CompactString",
        "name": "zipWith'",
        "normalized": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eCompactString a-\u003eCompactString a",
        "package": "compact-string",
        "partial": "With'",
        "signature": "(Char-\u003eChar-\u003eChar)-\u003eCompactString a-\u003eCompactString a-\u003eCompactString a"
      }
    }
  }
]
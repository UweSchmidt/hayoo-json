[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eAUTHOR\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\tDr. Alistair Ward\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eDESCRIPTION\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\tAn \u003ccode\u003e\u003ca\u003eExtendedRegEx\u003c/a\u003e\u003c/code\u003e, which has been specialised for \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e, to create a tradition non-polymorphic \u003cem\u003eregex\u003c/em\u003e.\n\u003c/dd\u003e\u003c/dl\u003e\u003c/div\u003e",
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "module",
        "fct-source": "src/RegExChar-ExtendedRegExChar.html",
        "fct-type": "module",
        "title": "ExtendedRegExChar"
      },
      "index": {
        "description": "AUTHOR Dr Alistair Ward DESCRIPTION An ExtendedRegEx which has been specialised for Char to create tradition non-polymorphic regex",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "ExtendedRegExChar",
        "normalized": "",
        "package": "regexchar",
        "partial": "Extended Reg Ex Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#t:ExtendedRegExChar",
      "description": {
        "fct-descr": "\u003cp\u003eSpecialise a \u003ccode\u003e\u003ca\u003eExtendedRegEx\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e, & encapsulate it to permit tailored instance-declarations.\n\u003c/p\u003e",
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "data",
        "fct-source": "src/RegExChar-ExtendedRegExChar.html#ExtendedRegExChar",
        "fct-type": "data",
        "title": "ExtendedRegExChar"
      },
      "index": {
        "description": "Specialise ExtendedRegEx for Char encapsulate it to permit tailored instance-declarations",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "ExtendedRegExChar",
        "normalized": "",
        "package": "regexchar",
        "partial": "Extended Reg Ex Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#t:InputData",
      "description": {
        "fct-descr": "\u003cp\u003eAbbreviation.\n\u003c/p\u003e",
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "type",
        "fct-source": "src/RegExChar-ExtendedRegExChar.html#InputData",
        "fct-type": "type",
        "title": "InputData"
      },
      "index": {
        "description": "Abbreviation",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "InputData",
        "normalized": "",
        "package": "regexchar",
        "partial": "Input Data",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#v:-43--126-",
      "description": {
        "fct-descr": "\u003cp\u003eA veneer over the underlying polymorphic operator, \u003ccode\u003e\u003ca\u003e+~\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "InputData-\u003e RegExOpts ExtendedRegExChar-\u003e Result Char",
        "fct-type": "function",
        "title": "(+~)"
      },
      "index": {
        "description": "veneer over the underlying polymorphic operator",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "(+~) +~",
        "normalized": "InputData-\u003eRegExOpts ExtendedRegExChar-\u003eResult Char",
        "package": "regexchar",
        "partial": "",
        "signature": "InputData-\u003eRegExOpts ExtendedRegExChar-\u003eResult Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#v:-47--126-",
      "description": {
        "fct-descr": "\u003cp\u003ePattern-mismatch operator.\n\u003c/p\u003e",
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "InputData-\u003e RegExOpts ExtendedRegExChar-\u003e Bool",
        "fct-type": "function",
        "title": "(/~)"
      },
      "index": {
        "description": "Pattern-mismatch operator",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "(/~) /~",
        "normalized": "InputData-\u003eRegExOpts ExtendedRegExChar-\u003eBool",
        "package": "regexchar",
        "partial": "",
        "signature": "InputData-\u003eRegExOpts ExtendedRegExChar-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#v:-61--126-",
      "description": {
        "fct-descr": "\u003cp\u003eA veneer over the underlying polymorphic operator, \u003ccode\u003e\u003ca\u003e=~\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "InputData-\u003e RegExOpts ExtendedRegExChar-\u003e Bool",
        "fct-type": "function",
        "title": "(=~)"
      },
      "index": {
        "description": "veneer over the underlying polymorphic operator",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "(=~) =~",
        "normalized": "InputData-\u003eRegExOpts ExtendedRegExChar-\u003eBool",
        "package": "regexchar",
        "partial": "",
        "signature": "InputData-\u003eRegExOpts ExtendedRegExChar-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#v:MkExtendedRegExChar",
      "description": {
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "MkExtendedRegExChar",
        "fct-source": "src/RegExChar-ExtendedRegExChar.html#ExtendedRegExChar",
        "fct-type": "function",
        "title": "MkExtendedRegExChar"
      },
      "index": {
        "description": "",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "MkExtendedRegExChar",
        "normalized": "",
        "package": "regexchar",
        "partial": "Mk Extended Reg Ex Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#v:extendedRegEx",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "ExtendedRegEx Char",
        "fct-source": "src/RegExChar-ExtendedRegExChar.html#ExtendedRegExChar",
        "fct-type": "function",
        "title": "extendedRegEx"
      },
      "index": {
        "description": "",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "extendedRegEx",
        "normalized": "",
        "package": "regexchar",
        "partial": "Reg Ex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-ExtendedRegExChar.html#v:hasNonCapturingTopLevelAlternatives",
      "description": {
        "fct-descr": "\u003cp\u003eThe string from which a \u003ccode\u003e\u003ca\u003eExtendedRegEx\u003c/a\u003e\u003c/code\u003e is read, may, if data-capture isn't required, omit explicit delimiters around top-level \u003ccode\u003e\u003ca\u003eAlternatives\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "RegExChar.ExtendedRegExChar",
        "fct-package": "regexchar",
        "fct-signature": "Bool",
        "fct-source": "src/RegExChar-ExtendedRegExChar.html#ExtendedRegExChar",
        "fct-type": "function",
        "title": "hasNonCapturingTopLevelAlternatives"
      },
      "index": {
        "description": "The string from which ExtendedRegEx is read may if data-capture isn required omit explicit delimiters around top-level Alternatives",
        "hierarchy": "RegExChar ExtendedRegExChar",
        "module": "RegExChar.ExtendedRegExChar",
        "name": "hasNonCapturingTopLevelAlternatives",
        "normalized": "",
        "package": "regexchar",
        "partial": "Non Capturing Top Level Alternatives",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-MetaChar.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eAUTHOR\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\tDr. Alistair Ward\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eDESCRIPTION\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n\u003c/dd\u003e\u003c/dl\u003e\u003cul\u003e\u003cli\u003e Implements \u003ccode\u003e\u003ca\u003eShortcutExpander\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e, to implement some of the traditional \u003cem\u003ePerl-style shortcuts\u003c/em\u003e:\n\u003c/li\u003e\u003c/ul\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003e\\d\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\t\t=\u003e Any \u003ccode\u003e\u003ca\u003eisDigit\u003c/a\u003e\u003c/code\u003e-character.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\\D\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\t\t=\u003e Any non-\u003ccode\u003e\u003ca\u003eisDigit\u003c/a\u003e\u003c/code\u003e character.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\\s\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\t\t=\u003e Any \u003ccode\u003e\u003ca\u003eisSpace\u003c/a\u003e\u003c/code\u003e-character.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\\S\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\t\t=\u003e Any non-\u003ccode\u003e\u003ca\u003eisSpace\u003c/a\u003e\u003c/code\u003e character.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\\w\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\t\t=\u003e Any \u003ccode\u003e\u003ca\u003eisWord\u003c/a\u003e\u003c/code\u003e letter.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\\W\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\t\t=\u003e Any non-\u003ccode\u003e\u003ca\u003eisWord\u003c/a\u003e\u003c/code\u003e letter.\n\u003c/dd\u003e\u003c/dl\u003e\u003cul\u003e\u003cli\u003e Enables one to compose concise regexen, containing any \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e that's a member of one of these predefined sets.\n\u003c/li\u003e\u003cli\u003e Though \u003ccode\u003e\u003ca\u003eMeta\u003c/a\u003e\u003c/code\u003e is polymorphic, & the type-parameter can't be assumed to implement either \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e,\n\t\u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e actually does, so this module is able to implement ranges within a \u003cem\u003eBracket-expression\u003c/em\u003e.\n\u003c/li\u003e\u003cli\u003e Defines specialised instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e & \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e, to cope with \u003cem\u003ePerl-style shortcuts\u003c/em\u003e, \u003cem\u003ePosix Character-classes\u003c/em\u003e & \u003cem\u003eBracket-expression\u003c/em\u003e range-specifications.\n\u003c/li\u003e\u003c/ul\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eTODO\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\tUse \u003ccode\u003eEnvironment.getLocale\u003c/code\u003e. Regrettably, this returns in the \u003ca\u003eIO\u003c/a\u003e-monad, & even it didn't, how does one pass that information to \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e ?!\n\u003c/dd\u003e\u003c/dl\u003e\u003c/div\u003e",
        "fct-module": "RegExChar.MetaChar",
        "fct-package": "regexchar",
        "fct-signature": "module",
        "fct-source": "src/RegExChar-MetaChar.html",
        "fct-type": "module",
        "title": "MetaChar"
      },
      "index": {
        "description": "AUTHOR Dr Alistair Ward DESCRIPTION Implements ShortcutExpander Char to implement some of the traditional Perl-style shortcuts Any isDigit character Any non isDigit character Any isSpace character Any non isSpace character Any isWord letter Any non isWord letter Enables one to compose concise regexen containing any Char that member of one of these predefined sets Though Meta is polymorphic the type-parameter can be assumed to implement either Enum or Ord Char actually does so this module is able to implement ranges within Bracket-expression Defines specialised instances of Read Show to cope with Perl-style shortcuts Posix Character-classes Bracket-expression range-specifications TODO Use Environment.getLocale Regrettably this returns in the IO monad even it didn how does one pass that information to Read",
        "hierarchy": "RegExChar MetaChar",
        "module": "RegExChar.MetaChar",
        "name": "MetaChar",
        "normalized": "",
        "package": "regexchar",
        "partial": "Meta Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-MetaChar.html#t:MetaChar",
      "description": {
        "fct-descr": "\u003cp\u003eA specialised instance, encapsulated to permit tailored instance-declarations.\n\u003c/p\u003e",
        "fct-module": "RegExChar.MetaChar",
        "fct-package": "regexchar",
        "fct-signature": "newtype",
        "fct-source": "src/RegExChar-MetaChar.html#MetaChar",
        "fct-type": "newtype",
        "title": "MetaChar"
      },
      "index": {
        "description": "specialised instance encapsulated to permit tailored instance-declarations",
        "hierarchy": "RegExChar MetaChar",
        "module": "RegExChar.MetaChar",
        "name": "MetaChar",
        "normalized": "",
        "package": "regexchar",
        "partial": "Meta Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-MetaChar.html#v:MkMetaChar",
      "description": {
        "fct-module": "RegExChar.MetaChar",
        "fct-package": "regexchar",
        "fct-signature": "MkMetaChar (Meta Char)",
        "fct-source": "src/RegExChar-MetaChar.html#MetaChar",
        "fct-type": "function",
        "title": "MkMetaChar"
      },
      "index": {
        "description": "",
        "hierarchy": "RegExChar MetaChar",
        "module": "RegExChar.MetaChar",
        "name": "MkMetaChar",
        "normalized": "",
        "package": "regexchar",
        "partial": "Mk Meta Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-MetaChar.html#v:deconstruct",
      "description": {
        "fct-descr": "\u003cp\u003eAccessor.\n\u003c/p\u003e",
        "fct-module": "RegExChar.MetaChar",
        "fct-package": "regexchar",
        "fct-signature": "MetaChar -\u003e Meta Char",
        "fct-source": "src/RegExChar-MetaChar.html#deconstruct",
        "fct-type": "function",
        "title": "deconstruct"
      },
      "index": {
        "description": "Accessor",
        "hierarchy": "RegExChar MetaChar",
        "module": "RegExChar.MetaChar",
        "name": "deconstruct",
        "normalized": "MetaChar-\u003eMeta Char",
        "package": "regexchar",
        "partial": "",
        "signature": "MetaChar-\u003eMeta Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-MetaChar.html#v:metaCharParser",
      "description": {
        "fct-descr": "\u003cp\u003eBuilds a parser of traditional regex-syntax, which understands \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e-specific concepts like \u003cem\u003ePerl-style shortcuts\u003c/em\u003e & \u003cem\u003ePosix Character-classes\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "RegExChar.MetaChar",
        "fct-package": "regexchar",
        "fct-signature": "Parser MetaChar",
        "fct-source": "src/RegExChar-MetaChar.html#metaCharParser",
        "fct-type": "function",
        "title": "metaCharParser"
      },
      "index": {
        "description": "Builds parser of traditional regex-syntax which understands Char specific concepts like Perl-style shortcuts Posix Character-classes",
        "hierarchy": "RegExChar MetaChar",
        "module": "RegExChar.MetaChar",
        "name": "metaCharParser",
        "normalized": "",
        "package": "regexchar",
        "partial": "Char Parser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-RegExOptsChar.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eAUTHOR\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\tDr. Alistair Ward\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eDESCRIPTION\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\tCreates a \u003cem\u003eback-end\u003c/em\u003e implementation, conforming to \u003ca\u003ehttp://hackage.haskell.org/packages/archive/regex-base/latest/doc/html/Text-Regex-Base-RegexLike.html\u003c/a\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eCAVEATS\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n\u003c/dd\u003e\u003c/dl\u003e\u003cul\u003e\u003cli\u003e The underlying polymorphic (in terms of the base-type of the list of input data) \u003ccode\u003e\u003ca\u003eExtendedRegEx\u003c/a\u003e\u003c/code\u003e-engine is never going to be a drop-in replacement for other \u003cem\u003eregex\u003c/em\u003e-engines,\n\tso this standard interface has only been implemented for traditional input data-type [\u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e].\n\u003c/li\u003e\u003cli\u003e The standard interface requires many Haskell-extensions, but since this implementation is just a thin layer over the underlying portable polymorphic \u003ccode\u003e\u003ca\u003eExtendedRegEx\u003c/a\u003e\u003c/code\u003e-engine,\n\tthe latter can still be used directly, where any of these extensions are unavailable.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "RegExChar.RegExOptsChar",
        "fct-package": "regexchar",
        "fct-signature": "module",
        "fct-source": "src/RegExChar-RegExOptsChar.html",
        "fct-type": "module",
        "title": "RegExOptsChar"
      },
      "index": {
        "description": "AUTHOR Dr Alistair Ward DESCRIPTION Creates back-end implementation conforming to http hackage.haskell.org packages archive regex-base latest doc html Text-Regex-Base-RegexLike.html CAVEATS The underlying polymorphic in terms of the base-type of the list of input data ExtendedRegEx engine is never going to be drop-in replacement for other regex engines so this standard interface has only been implemented for traditional input data-type Char The standard interface requires many Haskell-extensions but since this implementation is just thin layer over the underlying portable polymorphic ExtendedRegEx engine the latter can still be used directly where any of these extensions are unavailable",
        "hierarchy": "RegExChar RegExOptsChar",
        "module": "RegExChar.RegExOptsChar",
        "name": "RegExOptsChar",
        "normalized": "",
        "package": "regexchar",
        "partial": "Reg Ex Opts Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-RegExOptsChar.html#t:MatchSpan",
      "description": {
        "fct-descr": "\u003cp\u003eThe offset and length of the \u003ccode\u003e\u003ca\u003eInputData\u003c/a\u003e\u003c/code\u003e consumed in one \u003ccode\u003e\u003ca\u003eMatch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "RegExChar.RegExOptsChar",
        "fct-package": "regexchar",
        "fct-signature": "type",
        "fct-source": "src/RegExChar-RegExOptsChar.html#MatchSpan",
        "fct-type": "type",
        "title": "MatchSpan"
      },
      "index": {
        "description": "The offset and length of the InputData consumed in one Match",
        "hierarchy": "RegExChar RegExOptsChar",
        "module": "RegExChar.RegExOptsChar",
        "name": "MatchSpan",
        "normalized": "",
        "package": "regexchar",
        "partial": "Match Span",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-RegExOptsChar.html#t:RegExOptsChar",
      "description": {
        "fct-descr": "\u003cp\u003eDefines a specific instance of the polymorphic base-type.\n\u003c/p\u003e",
        "fct-module": "RegExChar.RegExOptsChar",
        "fct-package": "regexchar",
        "fct-signature": "type",
        "fct-source": "src/RegExChar-RegExOptsChar.html#RegExOptsChar",
        "fct-type": "type",
        "title": "RegExOptsChar"
      },
      "index": {
        "description": "Defines specific instance of the polymorphic base-type",
        "hierarchy": "RegExChar RegExOptsChar",
        "module": "RegExChar.RegExOptsChar",
        "name": "RegExOptsChar",
        "normalized": "",
        "package": "regexchar",
        "partial": "Reg Ex Opts Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-RegExOptsChar.html#v:-61--126-",
      "description": {
        "fct-descr": "\u003cul\u003e\u003cli\u003e Match-operator.\n\u003c/li\u003e\u003cli\u003e The polymorphic return-type is resolved by the caller's \u003ca\u003eRegexLike.RegexContext\u003c/a\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "RegExChar.RegExOptsChar",
        "fct-package": "regexchar",
        "fct-signature": "InputData-\u003e String-\u003e target",
        "fct-type": "function",
        "title": "(=~)"
      },
      "index": {
        "description": "Match-operator The polymorphic return-type is resolved by the caller RegexLike.RegexContext",
        "hierarchy": "RegExChar RegExOptsChar",
        "module": "RegExChar.RegExOptsChar",
        "name": "(=~) =~",
        "normalized": "InputData-\u003eString-\u003ea",
        "package": "regexchar",
        "partial": "",
        "signature": "InputData-\u003eString-\u003etarget"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/regexchar/docs/RegExChar-RegExOptsChar.html#v:toZeroIndexedArray",
      "description": {
        "fct-descr": "\u003cp\u003eConvert the specified list, into a zero-indexed array.\n\u003c/p\u003e",
        "fct-module": "RegExChar.RegExOptsChar",
        "fct-package": "regexchar",
        "fct-signature": "[e] -\u003e Array Int e",
        "fct-source": "src/RegExChar-RegExOptsChar.html#toZeroIndexedArray",
        "fct-type": "function",
        "title": "toZeroIndexedArray"
      },
      "index": {
        "description": "Convert the specified list into zero-indexed array",
        "hierarchy": "RegExChar RegExOptsChar",
        "module": "RegExChar.RegExOptsChar",
        "name": "toZeroIndexedArray",
        "normalized": "[a]-\u003eArray Int a",
        "package": "regexchar",
        "partial": "Zero Indexed Array",
        "signature": "[e]-\u003eArray Int e"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-random/docs/Data-Vector-Random-Mersenne.html#",
      "description": {
        "fct-module": "Data.Vector.Random.Mersenne",
        "fct-package": "vector-random",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Random-Mersenne.html",
        "fct-type": "module",
        "title": "Mersenne"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Random Mersenne",
        "module": "Data.Vector.Random.Mersenne",
        "name": "Mersenne",
        "normalized": "",
        "package": "vector-random",
        "partial": "Mersenne",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-random/docs/Data-Vector-Random-Mersenne.html#t:PureMTRandom",
      "description": {
        "fct-descr": "\u003cp\u003eClass of types that we have efficient generators for.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Random.Mersenne",
        "fct-package": "vector-random",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Random-Mersenne.html#PureMTRandom",
        "fct-type": "class",
        "title": "PureMTRandom"
      },
      "index": {
        "description": "Class of types that we have efficient generators for",
        "hierarchy": "Data Vector Random Mersenne",
        "module": "Data.Vector.Random.Mersenne",
        "name": "PureMTRandom",
        "normalized": "",
        "package": "vector-random",
        "partial": "Pure MTRandom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-random/docs/Data-Vector-Random-Mersenne.html#v:random",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a pure mersenne twister state, yield a new random value,\n and the next state.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Random.Mersenne",
        "fct-package": "vector-random",
        "fct-signature": "PureMT -\u003e (a, PureMT)",
        "fct-source": "src/Data-Vector-Random-Mersenne.html#random",
        "fct-type": "method",
        "title": "random"
      },
      "index": {
        "description": "Given pure mersenne twister state yield new random value and the next state",
        "hierarchy": "Data Vector Random Mersenne",
        "module": "Data.Vector.Random.Mersenne",
        "name": "random",
        "normalized": "PureMT-\u003e(a,PureMT)",
        "package": "vector-random",
        "partial": "",
        "signature": "PureMT-\u003e(a,PureMT)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector-random/docs/Data-Vector-Random-Mersenne.html#v:randoms",
      "description": {
        "fct-descr": "\u003cp\u003eReturn a random vector of length \u003ccode\u003en\u003c/code\u003e, filled with random elements\n of type \u003ccode\u003ea\u003c/code\u003e generated by the mersenne-twister.\n\u003c/p\u003e\u003cp\u003eE.g. to compute the sum of 100 million random Double values in a vector:\n\u003c/p\u003e\u003cpre\u003e import qualified Data.VectorUnboxed as U\n import System.Random.Mersenne.Pure64\n import qualified Data.Vector.Random.Mersenne as G\n \n main = do\n     g \u003c- newPureMT\n     let a = G.random g 10000000 :: U.Vector Double\n     print (U.sum a)\n\u003c/pre\u003e\u003cp\u003eThe generator will fuse under stream fusion, so e.g. sum . random g\n will allocate no intermediate array.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Random.Mersenne",
        "fct-package": "vector-random",
        "fct-signature": "PureMT -\u003e Int -\u003e v a",
        "fct-source": "src/Data-Vector-Random-Mersenne.html#randoms",
        "fct-type": "function",
        "title": "randoms"
      },
      "index": {
        "description": "Return random vector of length filled with random elements of type generated by the mersenne-twister E.g to compute the sum of million random Double values in vector import qualified Data.VectorUnboxed as import System.Random.Mersenne.Pure64 import qualified Data.Vector.Random.Mersenne as main do newPureMT let G.random U.Vector Double print U.sum The generator will fuse under stream fusion so e.g sum random will allocate no intermediate array",
        "hierarchy": "Data Vector Random Mersenne",
        "module": "Data.Vector.Random.Mersenne",
        "name": "randoms",
        "normalized": "PureMT-\u003eInt-\u003ea b",
        "package": "vector-random",
        "partial": "",
        "signature": "PureMT-\u003eInt-\u003ev a"
      }
    }
  }
]
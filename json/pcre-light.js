[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDocumentation based on \u003cem\u003eman pcreapi\u003c/em\u003e, written by Philip Hazel, 2007.\n\u003c/p\u003e\u003cp\u003eLicense   : BSD3\n Maintainer:  Don Stewart \u003ca\u003edons@galois.com\u003c/a\u003e\n Stability :  experimental\n Portability: CPP, FFI\n Tested with: GHC 6.8.2\n\u003c/p\u003e\u003cp\u003eRaw FFI bindings to PCRE functions and constants. \n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "module",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html",
        "fct-type": "module",
        "title": "Base"
      },
      "index": {
        "description": "Documentation based on man pcreapi written by Philip Hazel License BSD3 Maintainer Don Stewart dons@galois.com Stability experimental Portability CPP FFI Tested with GHC Raw FFI bindings to PCRE functions and constants",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "Base",
        "normalized": "",
        "package": "pcre-light",
        "partial": "Base",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#t:PCRE",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "type",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCRE",
        "fct-type": "type",
        "title": "PCRE"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "PCRE",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCRE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#t:PCREConfig",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "type",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREConfig",
        "fct-type": "type",
        "title": "PCREConfig"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "PCREConfig",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREConfig",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#t:PCREError",
      "description": {
        "fct-descr": "\u003cp\u003eA type for PCRE Errors: exec-time error codes.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "type",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREError",
        "fct-type": "type",
        "title": "PCREError"
      },
      "index": {
        "description": "type for PCRE Errors exec-time error codes",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "PCREError",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREError",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#t:PCREExecOption",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREExecOption",
        "fct-type": "data",
        "title": "PCREExecOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "PCREExecOption",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREExec Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#t:PCREExtraFlags",
      "description": {
        "fct-descr": "\u003cp\u003ePCREExtraFlags. bit flags for extra structure.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "type",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREExtraFlags",
        "fct-type": "type",
        "title": "PCREExtraFlags"
      },
      "index": {
        "description": "PCREExtraFlags bit flags for extra structure",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "PCREExtraFlags",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREExtra Flags",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#t:PCREInfo",
      "description": {
        "fct-descr": "\u003cp\u003ePCRE Info requests -- provides information about the compiled pattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "type",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREInfo",
        "fct-type": "type",
        "title": "PCREInfo"
      },
      "index": {
        "description": "PCRE Info requests provides information about the compiled pattern",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "PCREInfo",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREInfo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#t:PCREOption",
      "description": {
        "fct-descr": "\u003cp\u003eA type for PCRE compile-time options. These are newtyped CInts,\n which can be bitwise-or'd together, using '(Data.Bits..|.)'\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREOption",
        "fct-type": "data",
        "title": "PCREOption"
      },
      "index": {
        "description": "type for PCRE compile-time options These are newtyped CInts which can be bitwise-or together using Data.Bits",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "PCREOption",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREOption",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#t:Regex",
      "description": {
        "fct-descr": "\u003cp\u003eAn abstract pointer to a compiled PCRE Regex structure\n The structure allocated by the PCRE library will be deallocated\n automatically by the Haskell storage manager.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#Regex",
        "fct-type": "data",
        "title": "Regex"
      },
      "index": {
        "description": "An abstract pointer to compiled PCRE Regex structure The structure allocated by the PCRE library will be deallocated automatically by the Haskell storage manager",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "Regex",
        "normalized": "",
        "package": "pcre-light",
        "partial": "Regex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:Regex",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "Regex !(ForeignPtr PCRE) !ByteString",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#Regex",
        "fct-type": "function",
        "title": "Regex"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "Regex",
        "normalized": "",
        "package": "pcre-light",
        "partial": "Regex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:anchored",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, the pattern is forced to be \u003cem\u003eanchored\u003c/em\u003e, that is,\n it is constrained to match only at the first matching point in the\n string that is being searched (the \u003cem\u003esubject string\u003c/em\u003e). This effect can\n also be achieved by appropriate constructs in the pattern itself, which\n is the only way to do it in Perl.  \n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#anchored",
        "fct-type": "function",
        "title": "anchored"
      },
      "index": {
        "description": "anchored If this bit is set the pattern is forced to be anchored that is it is constrained to match only at the first matching point in the string that is being searched the subject string This effect can also be achieved by appropriate constructs in the pattern itself which is the only way to do it in Perl",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "anchored",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:auto_callout",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eauto_callout\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, \u003ca\u003ecompile\u003c/a\u003e automatically inserts callout\n items, all with number 255, before each pattern item. For discussion\n of the callout facility, see the man pcrecallout documentation\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#auto_callout",
        "fct-type": "function",
        "title": "auto_callout"
      },
      "index": {
        "description": "auto callout If this bit is set compile automatically inserts callout items all with number before each pattern item For discussion of the callout facility see the man pcrecallout documentation",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "auto_callout",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:c_pcre_compile",
      "description": {
        "fct-descr": "\u003cp\u003eCompile a pattern to an internal form. The pattern is a C string\n terminated by a binary zero. A pointer to a single block of memory that is\n obtained via pcre_malloc is returned. It is up to the caller to free\n the memory (via pcre_free) when it is no longer required\n\u003c/p\u003e\u003cp\u003eThe options argument contains various bit settings that affect the\n compilation. It should be zero if no options are required.\n\u003c/p\u003e\u003cp\u003eIf errptr is NULL, pcre_compile() returns NULL immediately.\n Otherwise, if compilation of a pattern fails, pcre_compile() returns NULL,\n and sets the variable pointed to by errptr to point to a textual error\n message.\n\u003c/p\u003e\u003cp\u003eThe offset from the start of the pattern to the character where the error\n was discovered is placed in the variable pointed to by erroffset, which must\n not be NULL.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "CString -\u003e PCREOption -\u003e Ptr CString -\u003e Ptr CInt -\u003e Ptr Word8 -\u003e IO (Ptr PCRE)",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#c_pcre_compile",
        "fct-type": "function",
        "title": "c_pcre_compile"
      },
      "index": {
        "description": "Compile pattern to an internal form The pattern is string terminated by binary zero pointer to single block of memory that is obtained via pcre malloc is returned It is up to the caller to free the memory via pcre free when it is no longer required The options argument contains various bit settings that affect the compilation It should be zero if no options are required If errptr is NULL pcre compile returns NULL immediately Otherwise if compilation of pattern fails pcre compile returns NULL and sets the variable pointed to by errptr to point to textual error message The offset from the start of the pattern to the character where the error was discovered is placed in the variable pointed to by erroffset which must not be NULL",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "c_pcre_compile",
        "normalized": "CString-\u003ePCREOption-\u003ePtr CString-\u003ePtr CInt-\u003ePtr Word-\u003eIO(Ptr PCRE)",
        "package": "pcre-light",
        "partial": "",
        "signature": "CString-\u003ePCREOption-\u003ePtr CString-\u003ePtr CInt-\u003ePtr Word-\u003eIO(Ptr PCRE)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:c_pcre_exec",
      "description": {
        "fct-descr": "\u003cp\u003eThis function matches a compiled regular expression\n against a given subject string, using a matching algorithm\n that is similar to Perl's. It returns offsets to captured\n substrings.\n\u003c/p\u003e\u003cp\u003eIts arguments are, in order:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ecode\u003c/code\u003e        Points to the compiled pattern (result of pcre_compile)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eextra\u003c/a\u003e\u003c/code\u003e       Points to an associated pcre_extra structure (result of pcre_study), or is NULL\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003esubject\u003c/code\u003e      Points to the subject string\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e       Length of the subject string, in bytes\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003estartoffset\u003c/code\u003e  Offset in bytes in the subject at which to start matching\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eoptions\u003c/code\u003e      Option bits\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eovector\u003c/code\u003e      Points to a vector of ints for result substrings\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eovecsize\u003c/code\u003e     Number of elements in the vector (a  multiple of 3)\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote, subject not required to be null terminated.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "Ptr PCRE -\u003e Ptr PCREExtra -\u003e Ptr Word8 -\u003e CInt -\u003e CInt -\u003e PCREExecOption -\u003e Ptr CInt -\u003e CInt -\u003e IO CInt",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#c_pcre_exec",
        "fct-type": "function",
        "title": "c_pcre_exec"
      },
      "index": {
        "description": "This function matches compiled regular expression against given subject string using matching algorithm that is similar to Perl It returns offsets to captured substrings Its arguments are in order code Points to the compiled pattern result of pcre compile extra Points to an associated pcre extra structure result of pcre study or is NULL subject Points to the subject string length Length of the subject string in bytes startoffset Offset in bytes in the subject at which to start matching options Option bits ovector Points to vector of ints for result substrings ovecsize Number of elements in the vector multiple of Note subject not required to be null terminated",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "c_pcre_exec",
        "normalized": "Ptr PCRE-\u003ePtr PCREExtra-\u003ePtr Word-\u003eCInt-\u003eCInt-\u003ePCREExecOption-\u003ePtr CInt-\u003eCInt-\u003eIO CInt",
        "package": "pcre-light",
        "partial": "",
        "signature": "Ptr PCRE-\u003ePtr PCREExtra-\u003ePtr Word-\u003eCInt-\u003eCInt-\u003ePCREExecOption-\u003ePtr CInt-\u003eCInt-\u003eIO CInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:c_pcre_fullinfo",
      "description": {
        "fct-descr": "\u003cp\u003eReturn information about a compiled pattern\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "Ptr PCRE -\u003e Ptr PCREExtra -\u003e PCREInfo -\u003e Ptr a -\u003e IO CInt",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#c_pcre_fullinfo",
        "fct-type": "function",
        "title": "c_pcre_fullinfo"
      },
      "index": {
        "description": "Return information about compiled pattern",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "c_pcre_fullinfo",
        "normalized": "Ptr PCRE-\u003ePtr PCREExtra-\u003ePCREInfo-\u003ePtr a-\u003eIO CInt",
        "package": "pcre-light",
        "partial": "",
        "signature": "Ptr PCRE-\u003ePtr PCREExtra-\u003ePCREInfo-\u003ePtr a-\u003eIO CInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:caseless",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ebsr_anycrlf\u003c/code\u003e and \u003ccode\u003ebsr_unicode\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options (which are mutually exclusive) control what the \\R escape\n sequence matches. The choice is either to match only CR, LF, or CRLF, or to\n match any Unicode new- line sequence. The default is specified when PCRE is\n built. It can be overridden from within the pattern, or by setting an option\n when a compiled pattern is matched.\n\u003c/p\u003e\u003cp\u003ebsr_anycrlf        :: PCREOption\n bsr_anycrlf        = PCREOption bsr_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ebsr_unicode\u003c/code\u003e. See \u003ccode\u003ebse_anycrlf\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003ebsr_unicode        :: PCREOption\n bsr_unicode        = PCREOption bsr_unicode_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ecaseless\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, letters in the pattern match both upper and lower case\n letters. It is equivalent to Perl's /i option, and it can be changed within a\n pattern by a (?i) option setting. In UTF-8 mode, PCRE always understands the\n concept of case for characters whose values are less than 128, so caseless\n matching is always possible. For characters with higher values, the concept of\n case is supported if PCRE is compiled with Unicode property sup- port, but not\n otherwise. If you want to use caseless matching for characters 128 and above,\n you must ensure that PCRE is compiled with Unicode property support as well as\n with UTF-8 support.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#caseless",
        "fct-type": "function",
        "title": "caseless"
      },
      "index": {
        "description": "bsr anycrlf and bsr unicode These options which are mutually exclusive control what the escape sequence matches The choice is either to match only CR LF or CRLF or to match any Unicode new line sequence The default is specified when PCRE is built It can be overridden from within the pattern or by setting an option when compiled pattern is matched bsr anycrlf PCREOption bsr anycrlf PCREOption bsr anycrlf cint bsr unicode See bse anycrlf bsr unicode PCREOption bsr unicode PCREOption bsr unicode cint caseless If this bit is set letters in the pattern match both upper and lower case letters It is equivalent to Perl option and it can be changed within pattern by option setting In UTF-8 mode PCRE always understands the concept of case for characters whose values are less than so caseless matching is always possible For characters with higher values the concept of case is supported if PCRE is compiled with Unicode property sup port but not otherwise If you want to use caseless matching for characters and above you must ensure that PCRE is compiled with Unicode property support as well as with UTF-8 support",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "caseless",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:combineExecOptions",
      "description": {
        "fct-descr": "\u003cp\u003eCombine a list of exec options into a single option, using bitwise (.|.)\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "[PCREExecOption] -\u003e PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#combineExecOptions",
        "fct-type": "function",
        "title": "combineExecOptions"
      },
      "index": {
        "description": "Combine list of exec options into single option using bitwise",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "combineExecOptions",
        "normalized": "[PCREExecOption]-\u003ePCREExecOption",
        "package": "pcre-light",
        "partial": "Exec Options",
        "signature": "[PCREExecOption]-\u003ePCREExecOption"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:combineOptions",
      "description": {
        "fct-descr": "\u003cp\u003eCombine a list of options into a single option, using bitwise (.|.)\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "[PCREOption] -\u003e PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#combineOptions",
        "fct-type": "function",
        "title": "combineOptions"
      },
      "index": {
        "description": "Combine list of options into single option using bitwise",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "combineOptions",
        "normalized": "[PCREOption]-\u003ePCREOption",
        "package": "pcre-light",
        "partial": "Options",
        "signature": "[PCREOption]-\u003ePCREOption"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:config_link_size",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREConfig",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#config_link_size",
        "fct-type": "function",
        "title": "config_link_size"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "config_link_size",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:config_match_limit",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREConfig",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#config_match_limit",
        "fct-type": "function",
        "title": "config_match_limit"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "config_match_limit",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:config_match_limit_recursion",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREConfig",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#config_match_limit_recursion",
        "fct-type": "function",
        "title": "config_match_limit_recursion"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "config_match_limit_recursion",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:config_newline",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREConfig",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#config_newline",
        "fct-type": "function",
        "title": "config_newline"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "config_newline",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:config_posix_malloc_threshold",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREConfig",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#config_posix_malloc_threshold",
        "fct-type": "function",
        "title": "config_posix_malloc_threshold"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "config_posix_malloc_threshold",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:config_stackrecurse",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREConfig",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#config_stackrecurse",
        "fct-type": "function",
        "title": "config_stackrecurse"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "config_stackrecurse",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:config_unicode_properties",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREConfig",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#config_unicode_properties",
        "fct-type": "function",
        "title": "config_unicode_properties"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "config_unicode_properties",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:config_utf8",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREConfig",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#config_utf8",
        "fct-type": "function",
        "title": "config_utf8"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "config_utf8",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:dollar_endonly",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, a dollar metacharacter in the pattern matches only at\n the end of the subject string. Without this option, a dollar also matches\n immediately before a newline at the end of the string (but not before any other\n newlines). The \u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e option is ignored if \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e\n is set.  There is no equivalent to this option in Perl, and no way to set it\n within a pattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dollar_endonly",
        "fct-type": "function",
        "title": "dollar_endonly"
      },
      "index": {
        "description": "dollar endonly If this bit is set dollar metacharacter in the pattern matches only at the end of the subject string Without this option dollar also matches immediately before newline at the end of the string but not before any other newlines The dollar endonly option is ignored if multiline is set There is no equivalent to this option in Perl and no way to set it within pattern",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "dollar_endonly",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:dotall",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edotall\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, a dot metacharater in the pattern matches all\n characters, including those that indicate newline. Without it, a dot does\n not match when the current position is at a newline. This option is\n equivalent to Perl's /s option, and it can be changed within a pattern by a\n (?s) option setting. A negative class such as [^a] always matches newline\n characters, independent of the setting of this option.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dotall",
        "fct-type": "function",
        "title": "dotall"
      },
      "index": {
        "description": "dotall If this bit is set dot metacharater in the pattern matches all characters including those that indicate newline Without it dot does not match when the current position is at newline This option is equivalent to Perl option and it can be changed within pattern by option setting negative class such as always matches newline characters independent of the setting of this option",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "dotall",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:dupnames",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edupnames\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, names used to identify capturing subpatterns need not be\n unique. This can be helpful for certain types of pattern when it is known\n that only one instance of the named subpattern can ever be matched. There are\n more details of named subpatterns in the \u003cem\u003eman pcreapi\u003c/em\u003e documentation.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dupnames",
        "fct-type": "function",
        "title": "dupnames"
      },
      "index": {
        "description": "dupnames If this bit is set names used to identify capturing subpatterns need not be unique This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched There are more details of named subpatterns in the man pcreapi documentation",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "dupnames",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_badcount",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_badcount",
        "fct-type": "function",
        "title": "error_badcount"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_badcount",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_badmagic",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_badmagic",
        "fct-type": "function",
        "title": "error_badmagic"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_badmagic",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_badoption",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_badoption",
        "fct-type": "function",
        "title": "error_badoption"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_badoption",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_badpartial",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_badpartial",
        "fct-type": "function",
        "title": "error_badpartial"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_badpartial",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_badutf8",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_badutf8",
        "fct-type": "function",
        "title": "error_badutf8"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_badutf8",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_badutf8_offset",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_badutf8_offset",
        "fct-type": "function",
        "title": "error_badutf8_offset"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_badutf8_offset",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_callout",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_callout",
        "fct-type": "function",
        "title": "error_callout"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_callout",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_dfa_recurse",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_dfa_recurse",
        "fct-type": "function",
        "title": "error_dfa_recurse"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_dfa_recurse",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_dfa_ucond",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_dfa_ucond",
        "fct-type": "function",
        "title": "error_dfa_ucond"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_dfa_ucond",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_dfa_uitem",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_dfa_uitem",
        "fct-type": "function",
        "title": "error_dfa_uitem"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_dfa_uitem",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_dfa_umlimit",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_dfa_umlimit",
        "fct-type": "function",
        "title": "error_dfa_umlimit"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_dfa_umlimit",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_dfa_wssize",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_dfa_wssize",
        "fct-type": "function",
        "title": "error_dfa_wssize"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_dfa_wssize",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_internal",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_internal",
        "fct-type": "function",
        "title": "error_internal"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_internal",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_matchlimit",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_matchlimit",
        "fct-type": "function",
        "title": "error_matchlimit"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_matchlimit",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_nomatch",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_nomatch",
        "fct-type": "function",
        "title": "error_nomatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_nomatch",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_nomemory",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_nomemory",
        "fct-type": "function",
        "title": "error_nomemory"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_nomemory",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_nosubstring",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_nosubstring",
        "fct-type": "function",
        "title": "error_nosubstring"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_nosubstring",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_null",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_null",
        "fct-type": "function",
        "title": "error_null"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_null",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_partial",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_partial",
        "fct-type": "function",
        "title": "error_partial"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_partial",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_recursionlimit",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_recursionlimit",
        "fct-type": "function",
        "title": "error_recursionlimit"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_recursionlimit",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:error_unknown_node",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREError",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#error_unknown_node",
        "fct-type": "function",
        "title": "error_unknown_node"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "error_unknown_node",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_anchored",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e option limits \u003ccode\u003eexec\u003c/code\u003e to matching at\n the first matching position. If a pattern was compiled\n with \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e, or turned out to be anchored by virtue\n of its contents, it cannot be made unachored at matching\n time.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_anchored",
        "fct-type": "function",
        "title": "exec_anchored"
      },
      "index": {
        "description": "anchored The anchored option limits exec to matching at the first matching position If pattern was compiled with anchored or turned out to be anchored by virtue of its contents it cannot be made unachored at matching time",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_anchored",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_newline_cr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003enewline_anycrlf\u003c/code\u003e, \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options override the newline definition that was\n chosen or defaulted when the pattern was compiled. For\n details, see the description of \u003ccode\u003ecompile\u003c/code\u003e above. Dur-\n ing matching, the newline choice affects the behaviour of\n the dot, circumflex, and dollar metacharacters. It may\n also alter the way the match position is advanced after a\n match failure for an unanchored pattern.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003enewline_anycrlf\u003c/code\u003e, or \u003ccode\u003enewline_any\u003c/code\u003e\n is set, and a match attempt for an unanchored\n pattern fails when the current position is at a CRLF\n sequence, and the pattern contains no explicit matches for\n CR or LF characters, the match position is advanced by two\n characters instead of one, in other words, to after the\n CRLF.\n\u003c/p\u003e\u003cp\u003eThe above rule is a compromise that makes the most common\n cases work as expected. For example, if the pattern is .+A\n (and the \u003ccode\u003e\u003ca\u003edotall\u003c/a\u003e\u003c/code\u003e option is not set), it does not match\n the string \u003cem\u003e\\\\r\\\\nA\u003c/em\u003e because, after failing at the start, it\n skips both the CR and the LF before retrying. However, the\n pattern \u003cem\u003e[\\\\r\\\\n]A\u003c/em\u003e does match that string, because it contains\n an explicit CR or LF reference, and so advances only\n by one character after the first failure.\n\u003c/p\u003e\u003cp\u003eAn explicit match for CR of LF is either a literal appear-\n ance of one of those characters, or one of the \\r or \\n\n escape sequences. Implicit matches such as [^X] do not\n count, nor does \\s (which includes CR and LF in the char-\n acters that it matches).\n\u003c/p\u003e\u003cp\u003eNotwithstanding the above, anomalous effects may still\n occur when CRLF is a valid newline sequence and explicit\n \\r or \\n escapes appear in the pattern.\n\u003c/p\u003e\u003cp\u003eexec_newline_any           :: PCREExecOption\n exec_newline_any           = PCREExecOption exec_newline_any_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eexec_newline_anycrlf\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n exec_newline_anycrlf       :: PCREExecOption\n exec_newline_anycrlf       = PCREExecOption exec_newline_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_cr\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_cr",
        "fct-type": "function",
        "title": "exec_newline_cr"
      },
      "index": {
        "description": "newline cr newline lf newline crlf newline anycrlf newline any These options override the newline definition that was chosen or defaulted when the pattern was compiled For details see the description of compile above Dur ing matching the newline choice affects the behaviour of the dot circumflex and dollar metacharacters It may also alter the way the match position is advanced after match failure for an unanchored pattern When newline crlf newline anycrlf or newline any is set and match attempt for an unanchored pattern fails when the current position is at CRLF sequence and the pattern contains no explicit matches for CR or LF characters the match position is advanced by two characters instead of one in other words to after the CRLF The above rule is compromise that makes the most common cases work as expected For example if the pattern is and the dotall option is not set it does not match the string nA because after failing at the start it skips both the CR and the LF before retrying However the pattern does match that string because it contains an explicit CR or LF reference and so advances only by one character after the first failure An explicit match for CR of LF is either literal appear ance of one of those characters or one of the or escape sequences Implicit matches such as do not count nor does which includes CR and LF in the char acters that it matches Notwithstanding the above anomalous effects may still occur when CRLF is valid newline sequence and explicit or escapes appear in the pattern exec newline any PCREExecOption exec newline any PCREExecOption exec newline any cint exec newline anycrlf see exec newline any exec newline anycrlf PCREExecOption exec newline anycrlf PCREExecOption exec newline anycrlf cint exec newline cr see exec newline any",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_newline_cr",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_newline_crlf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_crlf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_crlf",
        "fct-type": "function",
        "title": "exec_newline_crlf"
      },
      "index": {
        "description": "exec newline crlf see exec newline any",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_newline_crlf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_newline_lf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_lf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_lf",
        "fct-type": "function",
        "title": "exec_newline_lf"
      },
      "index": {
        "description": "exec newline lf see exec newline any",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_newline_lf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_no_utf8_check",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e is set at compile time, the validity of the\n subject as a UTF-8 string is automatically checked when\n exec() is subsequently called. The value of\n startoffset is also checked to ensure that it points to\n the start of a UTF-8 character. There is a discussion\n about the validity of UTF-8 strings in the section on\n UTF-8 support in the main pcre page. If an invalid UTF-8\n sequence of bytes is found, exec() returns the error\n \u003ccode\u003e\u003ca\u003eerror_badutf8\u003c/a\u003e\u003c/code\u003e. If startoffset contains an invalid\n value, \u003ccode\u003e\u003ca\u003eerror_badutf8_offset\u003c/a\u003e\u003c/code\u003e is returned.\n\u003c/p\u003e\u003cp\u003eIf you already know that your subject is valid, and you\n want to skip these checks for performance reasons, you can\n set the \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e option when calling\n \u003ccode\u003eexec\u003c/code\u003e. You might want to do this for the second and\n subsequent calls to exec() if you are making repeated\n calls to find all the matches in a single subject string.\n However, you should be sure that the value of startoffset\n points to the start of a UTF-8 character. When\n \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e is set, the effect of passing an\n invalid UTF-8 string as a subject, or a value of startoff-\n set that does not point to the start of a UTF-8 character,\n is undefined. Your program may crash.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_no_utf8_check",
        "fct-type": "function",
        "title": "exec_no_utf8_check"
      },
      "index": {
        "description": "no utf8 check When utf8 is set at compile time the validity of the subject as UTF-8 string is automatically checked when exec is subsequently called The value of startoffset is also checked to ensure that it points to the start of UTF-8 character There is discussion about the validity of UTF-8 strings in the section on UTF-8 support in the main pcre page If an invalid UTF-8 sequence of bytes is found exec returns the error error badutf8 If startoffset contains an invalid value error badutf8 offset is returned If you already know that your subject is valid and you want to skip these checks for performance reasons you can set the no utf8 check option when calling exec You might want to do this for the second and subsequent calls to exec if you are making repeated calls to find all the matches in single subject string However you should be sure that the value of startoffset points to the start of UTF-8 character When no utf8 check is set the effect of passing an invalid UTF-8 string as subject or value of startoff set that does not point to the start of UTF-8 character is undefined Your program may crash",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_no_utf8_check",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_notbol",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ePCRE_NOTBOL\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option specifies that first character of the subject\n string is not the beginning of a line, so the circumflex\n metacharacter should not match before it. Setting this\n without \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e (at compile time) causes circumflex\n never to match. This option affects only the behaviour of\n the circumflex metacharacter. It does not affect \\A.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_notbol",
        "fct-type": "function",
        "title": "exec_notbol"
      },
      "index": {
        "description": "PCRE NOTBOL This option specifies that first character of the subject string is not the beginning of line so the circumflex metacharacter should not match before it Setting this without multiline at compile time causes circumflex never to match This option affects only the behaviour of the circumflex metacharacter It does not affect",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_notbol",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_notempty",
      "description": {
        "fct-descr": "\u003cp\u003ePCRE_NOTEMPTY\n\u003c/p\u003e\u003cp\u003eAn empty string is not considered to be a valid match if\n this option is set. If there are alternatives in the pattern,\n they are tried. If all the alternatives match the\n empty string, the entire match fails. For example, if the\n pattern\n\u003c/p\u003e\u003cpre\u003e a?b?\n\u003c/pre\u003e\u003cp\u003eis applied to a string not beginning with \u003cem\u003ea\u003c/em\u003e or \u003cem\u003eb\u003c/em\u003e, it\n matches the empty string at the start of the subject. With\n \u003ccode\u003enotempty\u003c/code\u003e set, this match is not valid, so 'PCRE\n searches further into the string for occurrences of \u003cem\u003ea\u003c/em\u003e or\n \u003cem\u003eb\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003ePerl has no direct equivalent of \u003ccode\u003enotempty\u003c/code\u003e, but it\n does make a special case of a pattern match of the empty\n string within its split() function, and when using the /g\n modifier. It is possible to emulate Perl's behaviour after\n matching a null string by first trying the match again at\n the same offset with PCRE_NOTEMPTY and PCRE_ANCHORED, and\n then if that fails by advancing the starting offset (see\n below) and trying an ordinary match again. There is some\n code that demonstrates how to do this in the pcredemo.c\n sample program.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_notempty",
        "fct-type": "function",
        "title": "exec_notempty"
      },
      "index": {
        "description": "PCRE NOTEMPTY An empty string is not considered to be valid match if this option is set If there are alternatives in the pattern they are tried If all the alternatives match the empty string the entire match fails For example if the pattern is applied to string not beginning with or it matches the empty string at the start of the subject With notempty set this match is not valid so PCRE searches further into the string for occurrences of or Perl has no direct equivalent of notempty but it does make special case of pattern match of the empty string within its split function and when using the modifier It is possible to emulate Perl behaviour after matching null string by first trying the match again at the same offset with PCRE NOTEMPTY and PCRE ANCHORED and then if that fails by advancing the starting offset see below and trying an ordinary match again There is some code that demonstrates how to do this in the pcredemo.c sample program",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_notempty",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_noteol",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003enoteol\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option specifies that the end of the subject string\n is not the end of a line, so the dollar metacharacter\n should not match it nor (except in multiline mode) a newline\n immediately before it. Setting this without \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e \n (at compile time) causes dollar never to match.\n This option affects only the behaviour of the dollar\n metacharacter. It does not affect \\Z or \\z.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_noteol",
        "fct-type": "function",
        "title": "exec_noteol"
      },
      "index": {
        "description": "noteol This option specifies that the end of the subject string is not the end of line so the dollar metacharacter should not match it nor except in multiline mode newline immediately before it Setting this without multiline at compile time causes dollar never to match This option affects only the behaviour of the dollar metacharacter It does not affect or",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_noteol",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:exec_partial",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003epartial\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option turns on the partial matching feature. If the\n subject string fails to match the pattern, but at some\n point during the matching process the end of the subject\n was reached (that is, the subject partially matches the\n pattern and the failure to match occurred only because\n there were not enough subject characters), \u003ccode\u003eexec\u003c/code\u003e\n returns \u003ccode\u003e\u003ca\u003eerror_partial\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003eerror_nomatch\u003c/a\u003e\u003c/code\u003e.\n When \u003ccode\u003epartial\u003c/code\u003e is used, there are restrictions on what\n may appear in the pattern. These are discussed in the\n pcrepartial documentation.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_partial",
        "fct-type": "function",
        "title": "exec_partial"
      },
      "index": {
        "description": "partial This option turns on the partial matching feature If the subject string fails to match the pattern but at some point during the matching process the end of the subject was reached that is the subject partially matches the pattern and the failure to match occurred only because there were not enough subject characters exec returns error partial instead of error nomatch When partial is used there are restrictions on what may appear in the pattern These are discussed in the pcrepartial documentation",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "exec_partial",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:extended",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, whitespace data characters in the pattern are totally\n ignored except when escaped or inside a character class. Whitespace does not\n include the VT character (code 11). In addition, characters between an\n unescaped # outside a character class and the next newline, inclusive, are\n also ignored. This is equivalent to Perl's /x option, and it can be changed\nwithin a pattern by a (?x) option setting.\n\u003c/p\u003e\u003cp\u003eThis option makes it possible to include comments inside complicated\n patterns. Note, however, that this applies only to data characters. Whitespace\n characters may never appear within special character sequences in a pattern,\n for example within the sequence (?( which introduces a conditional subpattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extended",
        "fct-type": "function",
        "title": "extended"
      },
      "index": {
        "description": "extended If this bit is set whitespace data characters in the pattern are totally ignored except when escaped or inside character class Whitespace does not include the VT character code In addition characters between an unescaped outside character class and the next newline inclusive are also ignored This is equivalent to Perl option and it can be changed within pattern by option setting This option makes it possible to include comments inside complicated patterns Note however that this applies only to data characters Whitespace characters may never appear within special character sequences in pattern for example within the sequence which introduces conditional subpattern",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "extended",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:extra",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eextra\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option was invented in order to turn on additional functionality of\n PCRE that is incompatible with Perl, but it is currently of very little use.\n When set, any backslash in a pattern that is followed by a letter that has no\n special meaning causes an error, thus reserving these combinations for future\n expansion. By default, as in Perl, a backslash followed by a letter with no\n special meaning is treated as a literal. (Perl can, however, be persuaded to\n give a warning for this.) There are at present no other features controlled by\n this option. It can also be set by a (?X) option setting within a pattern. \n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extra",
        "fct-type": "function",
        "title": "extra"
      },
      "index": {
        "description": "extra This option was invented in order to turn on additional functionality of PCRE that is incompatible with Perl but it is currently of very little use When set any backslash in pattern that is followed by letter that has no special meaning causes an error thus reserving these combinations for future expansion By default as in Perl backslash followed by letter with no special meaning is treated as literal Perl can however be persuaded to give warning for this There are at present no other features controlled by this option It can also be set by option setting within pattern",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "extra",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:extra_callout_data",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExtraFlags",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extra_callout_data",
        "fct-type": "function",
        "title": "extra_callout_data"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "extra_callout_data",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:extra_match_limit",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExtraFlags",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extra_match_limit",
        "fct-type": "function",
        "title": "extra_match_limit"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "extra_match_limit",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:extra_match_limit_recursion",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExtraFlags",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extra_match_limit_recursion",
        "fct-type": "function",
        "title": "extra_match_limit_recursion"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "extra_match_limit_recursion",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:extra_study_data",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExtraFlags",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extra_study_data",
        "fct-type": "function",
        "title": "extra_study_data"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "extra_study_data",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:extra_tables",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExtraFlags",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extra_tables",
        "fct-type": "function",
        "title": "extra_tables"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "extra_tables",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:firstline",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efirstline\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this option is set, an unanchored pattern is required to match before or\n at the first newline in the subject string, though the matched text may\ncontinue over the newline.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#firstline",
        "fct-type": "function",
        "title": "firstline"
      },
      "index": {
        "description": "firstline If this option is set an unanchored pattern is required to match before or at the first newline in the subject string though the matched text may continue over the newline",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "firstline",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_backrefmax",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_backrefmax",
        "fct-type": "function",
        "title": "info_backrefmax"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_backrefmax",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_capturecount",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_capturecount",
        "fct-type": "function",
        "title": "info_capturecount"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_capturecount",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_default_tables",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_default_tables",
        "fct-type": "function",
        "title": "info_default_tables"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_default_tables",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_firstbyte",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_firstbyte",
        "fct-type": "function",
        "title": "info_firstbyte"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_firstbyte",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_firstchar",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_firstchar",
        "fct-type": "function",
        "title": "info_firstchar"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_firstchar",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_firsttable",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_firsttable",
        "fct-type": "function",
        "title": "info_firsttable"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_firsttable",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_lastliteral",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_lastliteral",
        "fct-type": "function",
        "title": "info_lastliteral"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_lastliteral",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_namecount",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_namecount",
        "fct-type": "function",
        "title": "info_namecount"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_namecount",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_nameentrysize",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_nameentrysize",
        "fct-type": "function",
        "title": "info_nameentrysize"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_nameentrysize",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_nametable",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_nametable",
        "fct-type": "function",
        "title": "info_nametable"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_nametable",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_options",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_options",
        "fct-type": "function",
        "title": "info_options"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_options",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_size",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_size",
        "fct-type": "function",
        "title": "info_size"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_size",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:info_studysize",
      "description": {
        "fct-descr": "\u003cp\u003eRequest types for config()\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREInfo",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#info_studysize",
        "fct-type": "function",
        "title": "info_studysize"
      },
      "index": {
        "description": "Request types for config",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "info_studysize",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:multiline",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eBy default, PCRE treats the subject string as consisting of a single line\n of characters (even if it actually contains newlines). The \u003cem\u003estart of line\u003c/em\u003e\n metacharacter (^) matches only at the start of the string, while the \u003cem\u003eend of line\u003c/em\u003e\n  metacharacter ($) matches only at the end of the string, or before a\n terminating newline (unless \u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e is set). This is the same\n as Perl.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e it is set, the \u003cem\u003estart of line\u003c/em\u003e and \u003cem\u003eend of line\u003c/em\u003e\n constructs match immediately following or immediately before internal newlines\n in the subject string, respectively, as well as at the very start and end. This\n is equivalent to Perl's /m option, and it can be changed within a pattern by a\n (?m) option setting. If there are no newlines in a subject string, or no occur-\n rences of ^ or $ in a pattern, setting PCRE_MULTILINE has no effect.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#multiline",
        "fct-type": "function",
        "title": "multiline"
      },
      "index": {
        "description": "multiline By default PCRE treats the subject string as consisting of single line of characters even if it actually contains newlines The start of line metacharacter matches only at the start of the string while the end of line metacharacter matches only at the end of the string or before terminating newline unless dollar endonly is set This is the same as Perl When multiline it is set the start of line and end of line constructs match immediately following or immediately before internal newlines in the subject string respectively as well as at the very start and end This is equivalent to Perl option and it can be changed within pattern by option setting If there are no newlines in subject string or no occur rences of or in pattern setting PCRE MULTILINE has no effect",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "multiline",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:newline_cr",
      "description": {
        "fct-descr": "\u003cp\u003enewline_cr', \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003enewline_anycrlf\u003c/code\u003e, \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options override the default newline definition that\n was chosen when PCRE was built. Setting the first or the\n second specifies that a newline is indicated by a single\n character (CR or LF, respectively). Setting \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e specifies\n that a newline is indicated by the two-character CRLF sequence.\n Setting \u003ccode\u003enewline_anycrlf\u003c/code\u003e\n specifies that any of the three preceding sequences should\n be recognized. Setting \u003ccode\u003enewline_any\u003c/code\u003e specifies that any\n Unicode newline sequence should be recognized. The Unicode\n newline sequences are the three just mentioned, plus the\n single characters VT (vertical tab, U+000B), FF (formfeed,\n U+000C), NEL (next line, U+0085), LS (line separator,\n U+2028), and PS (paragraph separator, U+2029). The last\n two are recognized only in UTF-8 mode.\n\u003c/p\u003e\u003cp\u003eThe newline setting in the options word uses three bits\n that are treated as a number, giving eight possibilities.\n Currently only six are used (default plus the five values\n above). This means that if you set more than one newline\n option, the combination may or may not be sensible. For\n example, \u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, but other combinations may yield unused numbers and\n cause an error.\n\u003c/p\u003e\u003cp\u003eThe only time that a line break is specially recognized\n when compiling a pattern is if \u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e is set, and\n an unescaped # outside a character class is encountered.\n This indicates a comment that lasts until after the next\n line break sequence. In other circumstances, line break\n sequences are treated as literal data, except that in\n \u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e mode, both CR and LF are treated as whitespace characters\n and are therefore ignored.  -- \n\u003c/p\u003e\u003cp\u003eThe newline option that is set at compile time becomes the\n default that is used for \u003ccode\u003eexec\u003c/code\u003e but it can be overridden.\n\u003c/p\u003e\u003cp\u003enewline_any        :: PCREOption\n newline_any        = PCREOption newline_any_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003enewline_anycrlf\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n newline_anycrlf    :: PCREOption\n newline_anycrlf    = PCREOption newline_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_cr",
        "fct-type": "function",
        "title": "newline_cr"
      },
      "index": {
        "description": "newline cr newline lf newline crlf newline anycrlf newline any These options override the default newline definition that was chosen when PCRE was built Setting the first or the second specifies that newline is indicated by single character CR or LF respectively Setting newline crlf specifies that newline is indicated by the two-character CRLF sequence Setting newline anycrlf specifies that any of the three preceding sequences should be recognized Setting newline any specifies that any Unicode newline sequence should be recognized The Unicode newline sequences are the three just mentioned plus the single characters VT vertical tab FF formfeed NEL next line LS line separator and PS paragraph separator The last two are recognized only in UTF-8 mode The newline setting in the options word uses three bits that are treated as number giving eight possibilities Currently only six are used default plus the five values above This means that if you set more than one newline option the combination may or may not be sensible For example newline cr with newline lf is equivalent to newline crlf but other combinations may yield unused numbers and cause an error The only time that line break is specially recognized when compiling pattern is if extended is set and an unescaped outside character class is encountered This indicates comment that lasts until after the next line break sequence In other circumstances line break sequences are treated as literal data except that in extended mode both CR and LF are treated as whitespace characters and are therefore ignored The newline option that is set at compile time becomes the default that is used for exec but it can be overridden newline any PCREOption newline any PCREOption newline any cint newline anycrlf see newline any newline anycrlf PCREOption newline anycrlf PCREOption newline anycrlf cint newline cr see newline any",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "newline_cr",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:newline_crlf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_crlf",
        "fct-type": "function",
        "title": "newline_crlf"
      },
      "index": {
        "description": "newline crlf see newline any",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "newline_crlf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:newline_lf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_lf",
        "fct-type": "function",
        "title": "newline_lf"
      },
      "index": {
        "description": "newline lf see newline any",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "newline_lf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:no_auto_capture",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_auto_capture\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this option is set, it disables the use of numbered\n capturing parentheses in the pattern. Any opening paren-\n thesis that is not followed by ? behaves as if it were\n followed by ?: but named parentheses can still be used for\n capturing (and they acquire numbers in the usual way).\n There is no equivalent of this option in Perl.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#no_auto_capture",
        "fct-type": "function",
        "title": "no_auto_capture"
      },
      "index": {
        "description": "no auto capture If this option is set it disables the use of numbered capturing parentheses in the pattern Any opening paren thesis that is not followed by behaves as if it were followed by but named parentheses can still be used for capturing and they acquire numbers in the usual way There is no equivalent of this option in Perl",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "no_auto_capture",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:no_utf8_check",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen PCRE_UTF8 is set, the validity of the pattern as a\n UTF-8 string is automatically checked. There is a discussion \n about the validity of UTF-8 strings in the main pcre\n page. If an invalid UTF-8 sequence of bytes is found,\n compile() returns an error. If you already know that\n your pattern is valid, and you want to skip this check for\n performance reasons, you can set the \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n option. When it is set, the effect of passing an invalid\n UTF-8 string as a pattern is undefined. It may cause your\n program to crash. Note that this option can also be passed\n to \u003ccode\u003eexec\u003c/code\u003e, to suppress the UTF-8 validity checking of subject strings.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#no_utf8_check",
        "fct-type": "function",
        "title": "no_utf8_check"
      },
      "index": {
        "description": "no utf8 check When PCRE UTF8 is set the validity of the pattern as UTF-8 string is automatically checked There is discussion about the validity of UTF-8 strings in the main pcre page If an invalid UTF-8 sequence of bytes is found compile returns an error If you already know that your pattern is valid and you want to skip this check for performance reasons you can set the no utf8 check option When it is set the effect of passing an invalid UTF-8 string as pattern is undefined It may cause your program to crash Note that this option can also be passed to exec to suppress the UTF-8 validity checking of subject strings",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "no_utf8_check",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:size_of_cint",
      "description": {
        "fct-descr": "\u003cp\u003eGet sizeof CInt from hsc2hs\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "Int",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#size_of_cint",
        "fct-type": "function",
        "title": "size_of_cint"
      },
      "index": {
        "description": "Get sizeof CInt from hsc2hs",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "size_of_cint",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:ungreedy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eungreedy\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option inverts the \u003cem\u003egreediness\u003c/em\u003e of the quantifiers so\n that they are not greedy by default, but become greedy if\n followed by \u003cem\u003e?\u003c/em\u003e. It is not compatible with Perl. It can\n also be set by a (?U) option setting within the pattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#ungreedy",
        "fct-type": "function",
        "title": "ungreedy"
      },
      "index": {
        "description": "ungreedy This option inverts the greediness of the quantifiers so that they are not greedy by default but become greedy if followed by It is not compatible with Perl It can also be set by option setting within the pattern",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "ungreedy",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Base.html#v:utf8",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option causes PCRE to regard both the pattern and the\n subject as strings of UTF-8 characters instead of single-byte character\n strings. However, it is available only when \n PCRE is built to include UTF-8 support. If not, the use of\n this option provokes an error. Details of how this option\n changes the behaviour of PCRE are given in the section on\n UTF-8 support in the main pcre page.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Base",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#utf8",
        "fct-type": "function",
        "title": "utf8"
      },
      "index": {
        "description": "utf8 This option causes PCRE to regard both the pattern and the subject as strings of UTF-8 characters instead of single-byte character strings However it is available only when PCRE is built to include UTF-8 support If not the use of this option provokes an error Details of how this option changes the behaviour of PCRE are given in the section on UTF-8 support in the main pcre page",
        "hierarchy": "Text Regex PCRE Light Base",
        "module": "Text.Regex.PCRE.Light.Base",
        "name": "utf8",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "module",
        "fct-source": "src/Text-Regex-PCRE-Light-Char8.html",
        "fct-type": "module",
        "title": "Char8"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "Char8",
        "normalized": "",
        "package": "pcre-light",
        "partial": "Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#t:PCREExecOption",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREExecOption",
        "fct-type": "data",
        "title": "PCREExecOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "PCREExecOption",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREExec Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#t:PCREOption",
      "description": {
        "fct-descr": "\u003cp\u003eA type for PCRE compile-time options. These are newtyped CInts,\n which can be bitwise-or'd together, using '(Data.Bits..|.)'\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREOption",
        "fct-type": "data",
        "title": "PCREOption"
      },
      "index": {
        "description": "type for PCRE compile-time options These are newtyped CInts which can be bitwise-or together using Data.Bits",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "PCREOption",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREOption",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#t:Regex",
      "description": {
        "fct-descr": "\u003cp\u003eAn abstract pointer to a compiled PCRE Regex structure\n The structure allocated by the PCRE library will be deallocated\n automatically by the Haskell storage manager.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#Regex",
        "fct-type": "data",
        "title": "Regex"
      },
      "index": {
        "description": "An abstract pointer to compiled PCRE Regex structure The structure allocated by the PCRE library will be deallocated automatically by the Haskell storage manager",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "Regex",
        "normalized": "",
        "package": "pcre-light",
        "partial": "Regex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:anchored",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, the pattern is forced to be \u003cem\u003eanchored\u003c/em\u003e, that is,\n it is constrained to match only at the first matching point in the\n string that is being searched (the \u003cem\u003esubject string\u003c/em\u003e). This effect can\n also be achieved by appropriate constructs in the pattern itself, which\n is the only way to do it in Perl.  \n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#anchored",
        "fct-type": "function",
        "title": "anchored"
      },
      "index": {
        "description": "anchored If this bit is set the pattern is forced to be anchored that is it is constrained to match only at the first matching point in the string that is being searched the subject string This effect can also be achieved by appropriate constructs in the pattern itself which is the only way to do it in Perl",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "anchored",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:auto_callout",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eauto_callout\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, \u003ca\u003ecompile\u003c/a\u003e automatically inserts callout\n items, all with number 255, before each pattern item. For discussion\n of the callout facility, see the man pcrecallout documentation\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#auto_callout",
        "fct-type": "function",
        "title": "auto_callout"
      },
      "index": {
        "description": "auto callout If this bit is set compile automatically inserts callout items all with number before each pattern item For discussion of the callout facility see the man pcrecallout documentation",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "auto_callout",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:caseless",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ebsr_anycrlf\u003c/code\u003e and \u003ccode\u003ebsr_unicode\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options (which are mutually exclusive) control what the \\R escape\n sequence matches. The choice is either to match only CR, LF, or CRLF, or to\n match any Unicode new- line sequence. The default is specified when PCRE is\n built. It can be overridden from within the pattern, or by setting an option\n when a compiled pattern is matched.\n\u003c/p\u003e\u003cp\u003ebsr_anycrlf        :: PCREOption\n bsr_anycrlf        = PCREOption bsr_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ebsr_unicode\u003c/code\u003e. See \u003ccode\u003ebse_anycrlf\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003ebsr_unicode        :: PCREOption\n bsr_unicode        = PCREOption bsr_unicode_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ecaseless\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, letters in the pattern match both upper and lower case\n letters. It is equivalent to Perl's /i option, and it can be changed within a\n pattern by a (?i) option setting. In UTF-8 mode, PCRE always understands the\n concept of case for characters whose values are less than 128, so caseless\n matching is always possible. For characters with higher values, the concept of\n case is supported if PCRE is compiled with Unicode property sup- port, but not\n otherwise. If you want to use caseless matching for characters 128 and above,\n you must ensure that PCRE is compiled with Unicode property support as well as\n with UTF-8 support.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#caseless",
        "fct-type": "function",
        "title": "caseless"
      },
      "index": {
        "description": "bsr anycrlf and bsr unicode These options which are mutually exclusive control what the escape sequence matches The choice is either to match only CR LF or CRLF or to match any Unicode new line sequence The default is specified when PCRE is built It can be overridden from within the pattern or by setting an option when compiled pattern is matched bsr anycrlf PCREOption bsr anycrlf PCREOption bsr anycrlf cint bsr unicode See bse anycrlf bsr unicode PCREOption bsr unicode PCREOption bsr unicode cint caseless If this bit is set letters in the pattern match both upper and lower case letters It is equivalent to Perl option and it can be changed within pattern by option setting In UTF-8 mode PCRE always understands the concept of case for characters whose values are less than so caseless matching is always possible For characters with higher values the concept of case is supported if PCRE is compiled with Unicode property sup port but not otherwise If you want to use caseless matching for characters and above you must ensure that PCRE is compiled with Unicode property support as well as with UTF-8 support",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "caseless",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:compile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eCompile a perl-compatible regular expression, in a strict bytestring.\n The arguments are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003epat\u003c/code\u003e: A ByteString, which may or may not be zero-terminated,\n containing the regular expression to be compiled. \n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eflags\u003c/code\u003e, optional bit flags. If \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is provided, defaults are used.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eValid compile-time flags are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e        - Force pattern anchoring\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eauto_callout\u003c/a\u003e\u003c/code\u003e    - Compile automatic callouts\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ebsr_anycrlf\u003c/code\u003e     - \\R matches only CR, LF, or CRLF\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ebsr_unicode\u003c/code\u003e     - \\R matches all Unicode line endings\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ecaseless\u003c/a\u003e\u003c/code\u003e        - Do caseless matching\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e  - \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e not to match newline at end\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edotall\u003c/a\u003e\u003c/code\u003e          - matches anything including NL\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edupnames\u003c/a\u003e\u003c/code\u003e        - Allow duplicate names for subpatterns\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e        - Ignore whitespace and # comments\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eextra\u003c/a\u003e\u003c/code\u003e           - PCRE extra features (not much use currently)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003efirstline\u003c/a\u003e\u003c/code\u003e       - Force matching to be  before  newline\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e       - \u003ccode\u003e\u003ca\u003e^\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e match newlines within data\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enewline_any\u003c/code\u003e     - Recognize any Unicode newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enewline_anycrlf\u003c/code\u003e - Recognize CR, LF, and CRLF as newline sequences\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e      - Set CR as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e    - Set CRLF as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e      - Set LF as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eno_auto_capture\u003c/a\u003e\u003c/code\u003e - Disable numbered capturing parentheses (named ones available)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eungreedy\u003c/a\u003e\u003c/code\u003e        - Invert greediness of quantifiers\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e            - Run in UTF-8 mode\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e   - Do not check the pattern for UTF-8 validity\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIf compilation of the pattern fails, the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e constructor is \n returned with the error string. Otherwise an abstract type\n representing the compiled regular expression is returned.\n The regex is allocated via malloc on the C side, and will be\n deallocated by the runtime when the Haskell value representing it\n goes out of scope.\n\u003c/p\u003e\u003cp\u003eAs regexes are often defined statically, GHC will compile them \n to null-terminated, strict C strings, enabling compilation of the \n pattern without copying. This may be useful for very large patterns.\n\u003c/p\u003e\u003cp\u003eSee man pcreapi for more details.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "String -\u003e [PCREOption] -\u003e Regex",
        "fct-source": "src/Text-Regex-PCRE-Light-Char8.html#compile",
        "fct-type": "function",
        "title": "compile"
      },
      "index": {
        "description": "compile Compile perl-compatible regular expression in strict bytestring The arguments are pat ByteString which may or may not be zero-terminated containing the regular expression to be compiled flags optional bit flags If Nothing is provided defaults are used Valid compile-time flags are anchored Force pattern anchoring auto callout Compile automatic callouts bsr anycrlf matches only CR LF or CRLF bsr unicode matches all Unicode line endings caseless Do caseless matching dollar endonly not to match newline at end dotall matches anything including NL dupnames Allow duplicate names for subpatterns extended Ignore whitespace and comments extra PCRE extra features not much use currently firstline Force matching to be before newline multiline and match newlines within data newline any Recognize any Unicode newline sequence newline anycrlf Recognize CR LF and CRLF as newline sequences newline cr Set CR as the newline sequence newline crlf Set CRLF as the newline sequence newline lf Set LF as the newline sequence no auto capture Disable numbered capturing parentheses named ones available ungreedy Invert greediness of quantifiers utf8 Run in UTF-8 mode no utf8 check Do not check the pattern for UTF-8 validity If compilation of the pattern fails the Left constructor is returned with the error string Otherwise an abstract type representing the compiled regular expression is returned The regex is allocated via malloc on the side and will be deallocated by the runtime when the Haskell value representing it goes out of scope As regexes are often defined statically GHC will compile them to null-terminated strict strings enabling compilation of the pattern without copying This may be useful for very large patterns See man pcreapi for more details",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "compile",
        "normalized": "String-\u003e[PCREOption]-\u003eRegex",
        "package": "pcre-light",
        "partial": "",
        "signature": "String-\u003e[PCREOption]-\u003eRegex"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:compileM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecompileM\u003c/a\u003e\u003c/code\u003e\n A safe version of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e with failure lifted into an Either\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "String -\u003e [PCREOption] -\u003e Either String Regex",
        "fct-source": "src/Text-Regex-PCRE-Light-Char8.html#compileM",
        "fct-type": "function",
        "title": "compileM"
      },
      "index": {
        "description": "compileM safe version of compile with failure lifted into an Either",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "compileM",
        "normalized": "String-\u003e[PCREOption]-\u003eEither String Regex",
        "package": "pcre-light",
        "partial": "",
        "signature": "String-\u003e[PCREOption]-\u003eEither String Regex"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:dollar_endonly",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, a dollar metacharacter in the pattern matches only at\n the end of the subject string. Without this option, a dollar also matches\n immediately before a newline at the end of the string (but not before any other\n newlines). The \u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e option is ignored if \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e\n is set.  There is no equivalent to this option in Perl, and no way to set it\n within a pattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dollar_endonly",
        "fct-type": "function",
        "title": "dollar_endonly"
      },
      "index": {
        "description": "dollar endonly If this bit is set dollar metacharacter in the pattern matches only at the end of the subject string Without this option dollar also matches immediately before newline at the end of the string but not before any other newlines The dollar endonly option is ignored if multiline is set There is no equivalent to this option in Perl and no way to set it within pattern",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "dollar_endonly",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:dotall",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edotall\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, a dot metacharater in the pattern matches all\n characters, including those that indicate newline. Without it, a dot does\n not match when the current position is at a newline. This option is\n equivalent to Perl's /s option, and it can be changed within a pattern by a\n (?s) option setting. A negative class such as [^a] always matches newline\n characters, independent of the setting of this option.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dotall",
        "fct-type": "function",
        "title": "dotall"
      },
      "index": {
        "description": "dotall If this bit is set dot metacharater in the pattern matches all characters including those that indicate newline Without it dot does not match when the current position is at newline This option is equivalent to Perl option and it can be changed within pattern by option setting negative class such as always matches newline characters independent of the setting of this option",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "dotall",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:dupnames",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edupnames\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, names used to identify capturing subpatterns need not be\n unique. This can be helpful for certain types of pattern when it is known\n that only one instance of the named subpattern can ever be matched. There are\n more details of named subpatterns in the \u003cem\u003eman pcreapi\u003c/em\u003e documentation.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dupnames",
        "fct-type": "function",
        "title": "dupnames"
      },
      "index": {
        "description": "dupnames If this bit is set names used to identify capturing subpatterns need not be unique This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched There are more details of named subpatterns in the man pcreapi documentation",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "dupnames",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_anchored",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e option limits \u003ccode\u003eexec\u003c/code\u003e to matching at\n the first matching position. If a pattern was compiled\n with \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e, or turned out to be anchored by virtue\n of its contents, it cannot be made unachored at matching\n time.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_anchored",
        "fct-type": "function",
        "title": "exec_anchored"
      },
      "index": {
        "description": "anchored The anchored option limits exec to matching at the first matching position If pattern was compiled with anchored or turned out to be anchored by virtue of its contents it cannot be made unachored at matching time",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_anchored",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_newline_cr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003enewline_anycrlf\u003c/code\u003e, \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options override the newline definition that was\n chosen or defaulted when the pattern was compiled. For\n details, see the description of \u003ccode\u003ecompile\u003c/code\u003e above. Dur-\n ing matching, the newline choice affects the behaviour of\n the dot, circumflex, and dollar metacharacters. It may\n also alter the way the match position is advanced after a\n match failure for an unanchored pattern.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003enewline_anycrlf\u003c/code\u003e, or \u003ccode\u003enewline_any\u003c/code\u003e\n is set, and a match attempt for an unanchored\n pattern fails when the current position is at a CRLF\n sequence, and the pattern contains no explicit matches for\n CR or LF characters, the match position is advanced by two\n characters instead of one, in other words, to after the\n CRLF.\n\u003c/p\u003e\u003cp\u003eThe above rule is a compromise that makes the most common\n cases work as expected. For example, if the pattern is .+A\n (and the \u003ccode\u003e\u003ca\u003edotall\u003c/a\u003e\u003c/code\u003e option is not set), it does not match\n the string \u003cem\u003e\\\\r\\\\nA\u003c/em\u003e because, after failing at the start, it\n skips both the CR and the LF before retrying. However, the\n pattern \u003cem\u003e[\\\\r\\\\n]A\u003c/em\u003e does match that string, because it contains\n an explicit CR or LF reference, and so advances only\n by one character after the first failure.\n\u003c/p\u003e\u003cp\u003eAn explicit match for CR of LF is either a literal appear-\n ance of one of those characters, or one of the \\r or \\n\n escape sequences. Implicit matches such as [^X] do not\n count, nor does \\s (which includes CR and LF in the char-\n acters that it matches).\n\u003c/p\u003e\u003cp\u003eNotwithstanding the above, anomalous effects may still\n occur when CRLF is a valid newline sequence and explicit\n \\r or \\n escapes appear in the pattern.\n\u003c/p\u003e\u003cp\u003eexec_newline_any           :: PCREExecOption\n exec_newline_any           = PCREExecOption exec_newline_any_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eexec_newline_anycrlf\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n exec_newline_anycrlf       :: PCREExecOption\n exec_newline_anycrlf       = PCREExecOption exec_newline_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_cr\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_cr",
        "fct-type": "function",
        "title": "exec_newline_cr"
      },
      "index": {
        "description": "newline cr newline lf newline crlf newline anycrlf newline any These options override the newline definition that was chosen or defaulted when the pattern was compiled For details see the description of compile above Dur ing matching the newline choice affects the behaviour of the dot circumflex and dollar metacharacters It may also alter the way the match position is advanced after match failure for an unanchored pattern When newline crlf newline anycrlf or newline any is set and match attempt for an unanchored pattern fails when the current position is at CRLF sequence and the pattern contains no explicit matches for CR or LF characters the match position is advanced by two characters instead of one in other words to after the CRLF The above rule is compromise that makes the most common cases work as expected For example if the pattern is and the dotall option is not set it does not match the string nA because after failing at the start it skips both the CR and the LF before retrying However the pattern does match that string because it contains an explicit CR or LF reference and so advances only by one character after the first failure An explicit match for CR of LF is either literal appear ance of one of those characters or one of the or escape sequences Implicit matches such as do not count nor does which includes CR and LF in the char acters that it matches Notwithstanding the above anomalous effects may still occur when CRLF is valid newline sequence and explicit or escapes appear in the pattern exec newline any PCREExecOption exec newline any PCREExecOption exec newline any cint exec newline anycrlf see exec newline any exec newline anycrlf PCREExecOption exec newline anycrlf PCREExecOption exec newline anycrlf cint exec newline cr see exec newline any",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_newline_cr",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_newline_crlf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_crlf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_crlf",
        "fct-type": "function",
        "title": "exec_newline_crlf"
      },
      "index": {
        "description": "exec newline crlf see exec newline any",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_newline_crlf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_newline_lf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_lf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_lf",
        "fct-type": "function",
        "title": "exec_newline_lf"
      },
      "index": {
        "description": "exec newline lf see exec newline any",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_newline_lf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_no_utf8_check",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e is set at compile time, the validity of the\n subject as a UTF-8 string is automatically checked when\n exec() is subsequently called. The value of\n startoffset is also checked to ensure that it points to\n the start of a UTF-8 character. There is a discussion\n about the validity of UTF-8 strings in the section on\n UTF-8 support in the main pcre page. If an invalid UTF-8\n sequence of bytes is found, exec() returns the error\n \u003ccode\u003e\u003ca\u003eerror_badutf8\u003c/a\u003e\u003c/code\u003e. If startoffset contains an invalid\n value, \u003ccode\u003e\u003ca\u003eerror_badutf8_offset\u003c/a\u003e\u003c/code\u003e is returned.\n\u003c/p\u003e\u003cp\u003eIf you already know that your subject is valid, and you\n want to skip these checks for performance reasons, you can\n set the \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e option when calling\n \u003ccode\u003eexec\u003c/code\u003e. You might want to do this for the second and\n subsequent calls to exec() if you are making repeated\n calls to find all the matches in a single subject string.\n However, you should be sure that the value of startoffset\n points to the start of a UTF-8 character. When\n \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e is set, the effect of passing an\n invalid UTF-8 string as a subject, or a value of startoff-\n set that does not point to the start of a UTF-8 character,\n is undefined. Your program may crash.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_no_utf8_check",
        "fct-type": "function",
        "title": "exec_no_utf8_check"
      },
      "index": {
        "description": "no utf8 check When utf8 is set at compile time the validity of the subject as UTF-8 string is automatically checked when exec is subsequently called The value of startoffset is also checked to ensure that it points to the start of UTF-8 character There is discussion about the validity of UTF-8 strings in the section on UTF-8 support in the main pcre page If an invalid UTF-8 sequence of bytes is found exec returns the error error badutf8 If startoffset contains an invalid value error badutf8 offset is returned If you already know that your subject is valid and you want to skip these checks for performance reasons you can set the no utf8 check option when calling exec You might want to do this for the second and subsequent calls to exec if you are making repeated calls to find all the matches in single subject string However you should be sure that the value of startoffset points to the start of UTF-8 character When no utf8 check is set the effect of passing an invalid UTF-8 string as subject or value of startoff set that does not point to the start of UTF-8 character is undefined Your program may crash",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_no_utf8_check",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_notbol",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ePCRE_NOTBOL\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option specifies that first character of the subject\n string is not the beginning of a line, so the circumflex\n metacharacter should not match before it. Setting this\n without \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e (at compile time) causes circumflex\n never to match. This option affects only the behaviour of\n the circumflex metacharacter. It does not affect \\A.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_notbol",
        "fct-type": "function",
        "title": "exec_notbol"
      },
      "index": {
        "description": "PCRE NOTBOL This option specifies that first character of the subject string is not the beginning of line so the circumflex metacharacter should not match before it Setting this without multiline at compile time causes circumflex never to match This option affects only the behaviour of the circumflex metacharacter It does not affect",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_notbol",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_notempty",
      "description": {
        "fct-descr": "\u003cp\u003ePCRE_NOTEMPTY\n\u003c/p\u003e\u003cp\u003eAn empty string is not considered to be a valid match if\n this option is set. If there are alternatives in the pattern,\n they are tried. If all the alternatives match the\n empty string, the entire match fails. For example, if the\n pattern\n\u003c/p\u003e\u003cpre\u003e a?b?\n\u003c/pre\u003e\u003cp\u003eis applied to a string not beginning with \u003cem\u003ea\u003c/em\u003e or \u003cem\u003eb\u003c/em\u003e, it\n matches the empty string at the start of the subject. With\n \u003ccode\u003enotempty\u003c/code\u003e set, this match is not valid, so 'PCRE\n searches further into the string for occurrences of \u003cem\u003ea\u003c/em\u003e or\n \u003cem\u003eb\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003ePerl has no direct equivalent of \u003ccode\u003enotempty\u003c/code\u003e, but it\n does make a special case of a pattern match of the empty\n string within its split() function, and when using the /g\n modifier. It is possible to emulate Perl's behaviour after\n matching a null string by first trying the match again at\n the same offset with PCRE_NOTEMPTY and PCRE_ANCHORED, and\n then if that fails by advancing the starting offset (see\n below) and trying an ordinary match again. There is some\n code that demonstrates how to do this in the pcredemo.c\n sample program.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_notempty",
        "fct-type": "function",
        "title": "exec_notempty"
      },
      "index": {
        "description": "PCRE NOTEMPTY An empty string is not considered to be valid match if this option is set If there are alternatives in the pattern they are tried If all the alternatives match the empty string the entire match fails For example if the pattern is applied to string not beginning with or it matches the empty string at the start of the subject With notempty set this match is not valid so PCRE searches further into the string for occurrences of or Perl has no direct equivalent of notempty but it does make special case of pattern match of the empty string within its split function and when using the modifier It is possible to emulate Perl behaviour after matching null string by first trying the match again at the same offset with PCRE NOTEMPTY and PCRE ANCHORED and then if that fails by advancing the starting offset see below and trying an ordinary match again There is some code that demonstrates how to do this in the pcredemo.c sample program",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_notempty",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_noteol",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003enoteol\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option specifies that the end of the subject string\n is not the end of a line, so the dollar metacharacter\n should not match it nor (except in multiline mode) a newline\n immediately before it. Setting this without \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e \n (at compile time) causes dollar never to match.\n This option affects only the behaviour of the dollar\n metacharacter. It does not affect \\Z or \\z.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_noteol",
        "fct-type": "function",
        "title": "exec_noteol"
      },
      "index": {
        "description": "noteol This option specifies that the end of the subject string is not the end of line so the dollar metacharacter should not match it nor except in multiline mode newline immediately before it Setting this without multiline at compile time causes dollar never to match This option affects only the behaviour of the dollar metacharacter It does not affect or",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_noteol",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:exec_partial",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003epartial\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option turns on the partial matching feature. If the\n subject string fails to match the pattern, but at some\n point during the matching process the end of the subject\n was reached (that is, the subject partially matches the\n pattern and the failure to match occurred only because\n there were not enough subject characters), \u003ccode\u003eexec\u003c/code\u003e\n returns \u003ccode\u003e\u003ca\u003eerror_partial\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003eerror_nomatch\u003c/a\u003e\u003c/code\u003e.\n When \u003ccode\u003epartial\u003c/code\u003e is used, there are restrictions on what\n may appear in the pattern. These are discussed in the\n pcrepartial documentation.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_partial",
        "fct-type": "function",
        "title": "exec_partial"
      },
      "index": {
        "description": "partial This option turns on the partial matching feature If the subject string fails to match the pattern but at some point during the matching process the end of the subject was reached that is the subject partially matches the pattern and the failure to match occurred only because there were not enough subject characters exec returns error partial instead of error nomatch When partial is used there are restrictions on what may appear in the pattern These are discussed in the pcrepartial documentation",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "exec_partial",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:extended",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, whitespace data characters in the pattern are totally\n ignored except when escaped or inside a character class. Whitespace does not\n include the VT character (code 11). In addition, characters between an\n unescaped # outside a character class and the next newline, inclusive, are\n also ignored. This is equivalent to Perl's /x option, and it can be changed\nwithin a pattern by a (?x) option setting.\n\u003c/p\u003e\u003cp\u003eThis option makes it possible to include comments inside complicated\n patterns. Note, however, that this applies only to data characters. Whitespace\n characters may never appear within special character sequences in a pattern,\n for example within the sequence (?( which introduces a conditional subpattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extended",
        "fct-type": "function",
        "title": "extended"
      },
      "index": {
        "description": "extended If this bit is set whitespace data characters in the pattern are totally ignored except when escaped or inside character class Whitespace does not include the VT character code In addition characters between an unescaped outside character class and the next newline inclusive are also ignored This is equivalent to Perl option and it can be changed within pattern by option setting This option makes it possible to include comments inside complicated patterns Note however that this applies only to data characters Whitespace characters may never appear within special character sequences in pattern for example within the sequence which introduces conditional subpattern",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "extended",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:extra",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eextra\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option was invented in order to turn on additional functionality of\n PCRE that is incompatible with Perl, but it is currently of very little use.\n When set, any backslash in a pattern that is followed by a letter that has no\n special meaning causes an error, thus reserving these combinations for future\n expansion. By default, as in Perl, a backslash followed by a letter with no\n special meaning is treated as a literal. (Perl can, however, be persuaded to\n give a warning for this.) There are at present no other features controlled by\n this option. It can also be set by a (?X) option setting within a pattern. \n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extra",
        "fct-type": "function",
        "title": "extra"
      },
      "index": {
        "description": "extra This option was invented in order to turn on additional functionality of PCRE that is incompatible with Perl but it is currently of very little use When set any backslash in pattern that is followed by letter that has no special meaning causes an error thus reserving these combinations for future expansion By default as in Perl backslash followed by letter with no special meaning is treated as literal Perl can however be persuaded to give warning for this There are at present no other features controlled by this option It can also be set by option setting within pattern",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "extra",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:firstline",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efirstline\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this option is set, an unanchored pattern is required to match before or\n at the first newline in the subject string, though the matched text may\ncontinue over the newline.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#firstline",
        "fct-type": "function",
        "title": "firstline"
      },
      "index": {
        "description": "firstline If this option is set an unanchored pattern is required to match before or at the first newline in the subject string though the matched text may continue over the newline",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "firstline",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:match",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eMatches a compiled regular expression against a given subject string,\n using a matching algorithm that is similar to Perl's. If the subject\n string doesn't match the regular expression, \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is returned,\n otherwise the portion of the string that matched is returned, along\n with any captured subpatterns.\n\u003c/p\u003e\u003cp\u003eThe arguments are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eregex\u003c/code\u003e, a PCRE regular expression value produced by compile\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003esubject\u003c/code\u003e, the subject string to match against\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eoptions\u003c/code\u003e, an optional set of exec-time flags to exec.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAvailable runtime options are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e        - Match only at the first position\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ebsr_anycrlf\u003c/code\u003e     - '\\\\R' matches only CR, LF, or CRLF\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ebsr_unicode\u003c/code\u003e     - '\\\\R' matches all Unicode line endings\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enewline_any\u003c/code\u003e     - Recognize any Unicode newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enewline_anycrlf\u003c/code\u003e - Recognize CR, LF, and CRLF as newline sequences\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e      - Set CR as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e    - Set CRLF as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e      - Set LF as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enotbol\u003c/code\u003e          - Subject is not the beginning of a line\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enoteol\u003c/code\u003e          - Subject is not the end of a line\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enotempty\u003c/code\u003e        - An empty string is not a valid match\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e   - Do not check the subject for UTF-8\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003epartial\u003c/code\u003e         - Return PCRE_ERROR_PARTIAL for a partial match\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe result value, and any captured subpatterns, are returned.\n If the regex is invalid, or the subject string is empty, Nothing\n is returned.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "Regex -\u003e String -\u003e [PCREExecOption] -\u003e Maybe [String]",
        "fct-source": "src/Text-Regex-PCRE-Light-Char8.html#match",
        "fct-type": "function",
        "title": "match"
      },
      "index": {
        "description": "match Matches compiled regular expression against given subject string using matching algorithm that is similar to Perl If the subject string doesn match the regular expression Nothing is returned otherwise the portion of the string that matched is returned along with any captured subpatterns The arguments are regex PCRE regular expression value produced by compile subject the subject string to match against options an optional set of exec-time flags to exec Available runtime options are anchored Match only at the first position bsr anycrlf matches only CR LF or CRLF bsr unicode matches all Unicode line endings newline any Recognize any Unicode newline sequence newline anycrlf Recognize CR LF and CRLF as newline sequences newline cr Set CR as the newline sequence newline crlf Set CRLF as the newline sequence newline lf Set LF as the newline sequence notbol Subject is not the beginning of line noteol Subject is not the end of line notempty An empty string is not valid match no utf8 check Do not check the subject for UTF-8 partial Return PCRE ERROR PARTIAL for partial match The result value and any captured subpatterns are returned If the regex is invalid or the subject string is empty Nothing is returned",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "match",
        "normalized": "Regex-\u003eString-\u003e[PCREExecOption]-\u003eMaybe[String]",
        "package": "pcre-light",
        "partial": "",
        "signature": "Regex-\u003eString-\u003e[PCREExecOption]-\u003eMaybe[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:multiline",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eBy default, PCRE treats the subject string as consisting of a single line\n of characters (even if it actually contains newlines). The \u003cem\u003estart of line\u003c/em\u003e\n metacharacter (^) matches only at the start of the string, while the \u003cem\u003eend of line\u003c/em\u003e\n  metacharacter ($) matches only at the end of the string, or before a\n terminating newline (unless \u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e is set). This is the same\n as Perl.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e it is set, the \u003cem\u003estart of line\u003c/em\u003e and \u003cem\u003eend of line\u003c/em\u003e\n constructs match immediately following or immediately before internal newlines\n in the subject string, respectively, as well as at the very start and end. This\n is equivalent to Perl's /m option, and it can be changed within a pattern by a\n (?m) option setting. If there are no newlines in a subject string, or no occur-\n rences of ^ or $ in a pattern, setting PCRE_MULTILINE has no effect.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#multiline",
        "fct-type": "function",
        "title": "multiline"
      },
      "index": {
        "description": "multiline By default PCRE treats the subject string as consisting of single line of characters even if it actually contains newlines The start of line metacharacter matches only at the start of the string while the end of line metacharacter matches only at the end of the string or before terminating newline unless dollar endonly is set This is the same as Perl When multiline it is set the start of line and end of line constructs match immediately following or immediately before internal newlines in the subject string respectively as well as at the very start and end This is equivalent to Perl option and it can be changed within pattern by option setting If there are no newlines in subject string or no occur rences of or in pattern setting PCRE MULTILINE has no effect",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "multiline",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:newline_cr",
      "description": {
        "fct-descr": "\u003cp\u003enewline_cr', \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003enewline_anycrlf\u003c/code\u003e, \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options override the default newline definition that\n was chosen when PCRE was built. Setting the first or the\n second specifies that a newline is indicated by a single\n character (CR or LF, respectively). Setting \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e specifies\n that a newline is indicated by the two-character CRLF sequence.\n Setting \u003ccode\u003enewline_anycrlf\u003c/code\u003e\n specifies that any of the three preceding sequences should\n be recognized. Setting \u003ccode\u003enewline_any\u003c/code\u003e specifies that any\n Unicode newline sequence should be recognized. The Unicode\n newline sequences are the three just mentioned, plus the\n single characters VT (vertical tab, U+000B), FF (formfeed,\n U+000C), NEL (next line, U+0085), LS (line separator,\n U+2028), and PS (paragraph separator, U+2029). The last\n two are recognized only in UTF-8 mode.\n\u003c/p\u003e\u003cp\u003eThe newline setting in the options word uses three bits\n that are treated as a number, giving eight possibilities.\n Currently only six are used (default plus the five values\n above). This means that if you set more than one newline\n option, the combination may or may not be sensible. For\n example, \u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, but other combinations may yield unused numbers and\n cause an error.\n\u003c/p\u003e\u003cp\u003eThe only time that a line break is specially recognized\n when compiling a pattern is if \u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e is set, and\n an unescaped # outside a character class is encountered.\n This indicates a comment that lasts until after the next\n line break sequence. In other circumstances, line break\n sequences are treated as literal data, except that in\n \u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e mode, both CR and LF are treated as whitespace characters\n and are therefore ignored.  -- \n\u003c/p\u003e\u003cp\u003eThe newline option that is set at compile time becomes the\n default that is used for \u003ccode\u003eexec\u003c/code\u003e but it can be overridden.\n\u003c/p\u003e\u003cp\u003enewline_any        :: PCREOption\n newline_any        = PCREOption newline_any_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003enewline_anycrlf\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n newline_anycrlf    :: PCREOption\n newline_anycrlf    = PCREOption newline_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_cr",
        "fct-type": "function",
        "title": "newline_cr"
      },
      "index": {
        "description": "newline cr newline lf newline crlf newline anycrlf newline any These options override the default newline definition that was chosen when PCRE was built Setting the first or the second specifies that newline is indicated by single character CR or LF respectively Setting newline crlf specifies that newline is indicated by the two-character CRLF sequence Setting newline anycrlf specifies that any of the three preceding sequences should be recognized Setting newline any specifies that any Unicode newline sequence should be recognized The Unicode newline sequences are the three just mentioned plus the single characters VT vertical tab FF formfeed NEL next line LS line separator and PS paragraph separator The last two are recognized only in UTF-8 mode The newline setting in the options word uses three bits that are treated as number giving eight possibilities Currently only six are used default plus the five values above This means that if you set more than one newline option the combination may or may not be sensible For example newline cr with newline lf is equivalent to newline crlf but other combinations may yield unused numbers and cause an error The only time that line break is specially recognized when compiling pattern is if extended is set and an unescaped outside character class is encountered This indicates comment that lasts until after the next line break sequence In other circumstances line break sequences are treated as literal data except that in extended mode both CR and LF are treated as whitespace characters and are therefore ignored The newline option that is set at compile time becomes the default that is used for exec but it can be overridden newline any PCREOption newline any PCREOption newline any cint newline anycrlf see newline any newline anycrlf PCREOption newline anycrlf PCREOption newline anycrlf cint newline cr see newline any",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "newline_cr",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:newline_crlf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_crlf",
        "fct-type": "function",
        "title": "newline_crlf"
      },
      "index": {
        "description": "newline crlf see newline any",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "newline_crlf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:newline_lf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_lf",
        "fct-type": "function",
        "title": "newline_lf"
      },
      "index": {
        "description": "newline lf see newline any",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "newline_lf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:no_auto_capture",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_auto_capture\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this option is set, it disables the use of numbered\n capturing parentheses in the pattern. Any opening paren-\n thesis that is not followed by ? behaves as if it were\n followed by ?: but named parentheses can still be used for\n capturing (and they acquire numbers in the usual way).\n There is no equivalent of this option in Perl.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#no_auto_capture",
        "fct-type": "function",
        "title": "no_auto_capture"
      },
      "index": {
        "description": "no auto capture If this option is set it disables the use of numbered capturing parentheses in the pattern Any opening paren thesis that is not followed by behaves as if it were followed by but named parentheses can still be used for capturing and they acquire numbers in the usual way There is no equivalent of this option in Perl",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "no_auto_capture",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:no_utf8_check",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen PCRE_UTF8 is set, the validity of the pattern as a\n UTF-8 string is automatically checked. There is a discussion \n about the validity of UTF-8 strings in the main pcre\n page. If an invalid UTF-8 sequence of bytes is found,\n compile() returns an error. If you already know that\n your pattern is valid, and you want to skip this check for\n performance reasons, you can set the \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n option. When it is set, the effect of passing an invalid\n UTF-8 string as a pattern is undefined. It may cause your\n program to crash. Note that this option can also be passed\n to \u003ccode\u003eexec\u003c/code\u003e, to suppress the UTF-8 validity checking of subject strings.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#no_utf8_check",
        "fct-type": "function",
        "title": "no_utf8_check"
      },
      "index": {
        "description": "no utf8 check When PCRE UTF8 is set the validity of the pattern as UTF-8 string is automatically checked There is discussion about the validity of UTF-8 strings in the main pcre page If an invalid UTF-8 sequence of bytes is found compile returns an error If you already know that your pattern is valid and you want to skip this check for performance reasons you can set the no utf8 check option When it is set the effect of passing an invalid UTF-8 string as pattern is undefined It may cause your program to crash Note that this option can also be passed to exec to suppress the UTF-8 validity checking of subject strings",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "no_utf8_check",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:ungreedy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eungreedy\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option inverts the \u003cem\u003egreediness\u003c/em\u003e of the quantifiers so\n that they are not greedy by default, but become greedy if\n followed by \u003cem\u003e?\u003c/em\u003e. It is not compatible with Perl. It can\n also be set by a (?U) option setting within the pattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#ungreedy",
        "fct-type": "function",
        "title": "ungreedy"
      },
      "index": {
        "description": "ungreedy This option inverts the greediness of the quantifiers so that they are not greedy by default but become greedy if followed by It is not compatible with Perl It can also be set by option setting within the pattern",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "ungreedy",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light-Char8.html#v:utf8",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option causes PCRE to regard both the pattern and the\n subject as strings of UTF-8 characters instead of single-byte character\n strings. However, it is available only when \n PCRE is built to include UTF-8 support. If not, the use of\n this option provokes an error. Details of how this option\n changes the behaviour of PCRE are given in the section on\n UTF-8 support in the main pcre page.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light.Char8",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#utf8",
        "fct-type": "function",
        "title": "utf8"
      },
      "index": {
        "description": "utf8 This option causes PCRE to regard both the pattern and the subject as strings of UTF-8 characters instead of single-byte character strings However it is available only when PCRE is built to include UTF-8 support If not the use of this option provokes an error Details of how this option changes the behaviour of PCRE are given in the section on UTF-8 support in the main pcre page",
        "hierarchy": "Text Regex PCRE Light Char8",
        "module": "Text.Regex.PCRE.Light.Char8",
        "name": "utf8",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "module",
        "fct-source": "src/Text-Regex-PCRE-Light.html",
        "fct-type": "module",
        "title": "Light"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "Light",
        "normalized": "",
        "package": "pcre-light",
        "partial": "Light",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#t:PCREExecOption",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREExecOption",
        "fct-type": "data",
        "title": "PCREExecOption"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "PCREExecOption",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREExec Option",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#t:PCREOption",
      "description": {
        "fct-descr": "\u003cp\u003eA type for PCRE compile-time options. These are newtyped CInts,\n which can be bitwise-or'd together, using '(Data.Bits..|.)'\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#PCREOption",
        "fct-type": "data",
        "title": "PCREOption"
      },
      "index": {
        "description": "type for PCRE compile-time options These are newtyped CInts which can be bitwise-or together using Data.Bits",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "PCREOption",
        "normalized": "",
        "package": "pcre-light",
        "partial": "PCREOption",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#t:Regex",
      "description": {
        "fct-descr": "\u003cp\u003eAn abstract pointer to a compiled PCRE Regex structure\n The structure allocated by the PCRE library will be deallocated\n automatically by the Haskell storage manager.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "data",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#Regex",
        "fct-type": "data",
        "title": "Regex"
      },
      "index": {
        "description": "An abstract pointer to compiled PCRE Regex structure The structure allocated by the PCRE library will be deallocated automatically by the Haskell storage manager",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "Regex",
        "normalized": "",
        "package": "pcre-light",
        "partial": "Regex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:anchored",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, the pattern is forced to be \u003cem\u003eanchored\u003c/em\u003e, that is,\n it is constrained to match only at the first matching point in the\n string that is being searched (the \u003cem\u003esubject string\u003c/em\u003e). This effect can\n also be achieved by appropriate constructs in the pattern itself, which\n is the only way to do it in Perl.  \n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#anchored",
        "fct-type": "function",
        "title": "anchored"
      },
      "index": {
        "description": "anchored If this bit is set the pattern is forced to be anchored that is it is constrained to match only at the first matching point in the string that is being searched the subject string This effect can also be achieved by appropriate constructs in the pattern itself which is the only way to do it in Perl",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "anchored",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:auto_callout",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eauto_callout\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, \u003ca\u003ecompile\u003c/a\u003e automatically inserts callout\n items, all with number 255, before each pattern item. For discussion\n of the callout facility, see the man pcrecallout documentation\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#auto_callout",
        "fct-type": "function",
        "title": "auto_callout"
      },
      "index": {
        "description": "auto callout If this bit is set compile automatically inserts callout items all with number before each pattern item For discussion of the callout facility see the man pcrecallout documentation",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "auto_callout",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:captureCount",
      "description": {
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "Regex -\u003e Int",
        "fct-source": "src/Text-Regex-PCRE-Light.html#captureCount",
        "fct-type": "function",
        "title": "captureCount"
      },
      "index": {
        "description": "",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "captureCount",
        "normalized": "Regex-\u003eInt",
        "package": "pcre-light",
        "partial": "Count",
        "signature": "Regex-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:caseless",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ebsr_anycrlf\u003c/code\u003e and \u003ccode\u003ebsr_unicode\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options (which are mutually exclusive) control what the \\R escape\n sequence matches. The choice is either to match only CR, LF, or CRLF, or to\n match any Unicode new- line sequence. The default is specified when PCRE is\n built. It can be overridden from within the pattern, or by setting an option\n when a compiled pattern is matched.\n\u003c/p\u003e\u003cp\u003ebsr_anycrlf        :: PCREOption\n bsr_anycrlf        = PCREOption bsr_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ebsr_unicode\u003c/code\u003e. See \u003ccode\u003ebse_anycrlf\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003ebsr_unicode        :: PCREOption\n bsr_unicode        = PCREOption bsr_unicode_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ecaseless\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, letters in the pattern match both upper and lower case\n letters. It is equivalent to Perl's /i option, and it can be changed within a\n pattern by a (?i) option setting. In UTF-8 mode, PCRE always understands the\n concept of case for characters whose values are less than 128, so caseless\n matching is always possible. For characters with higher values, the concept of\n case is supported if PCRE is compiled with Unicode property sup- port, but not\n otherwise. If you want to use caseless matching for characters 128 and above,\n you must ensure that PCRE is compiled with Unicode property support as well as\n with UTF-8 support.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#caseless",
        "fct-type": "function",
        "title": "caseless"
      },
      "index": {
        "description": "bsr anycrlf and bsr unicode These options which are mutually exclusive control what the escape sequence matches The choice is either to match only CR LF or CRLF or to match any Unicode new line sequence The default is specified when PCRE is built It can be overridden from within the pattern or by setting an option when compiled pattern is matched bsr anycrlf PCREOption bsr anycrlf PCREOption bsr anycrlf cint bsr unicode See bse anycrlf bsr unicode PCREOption bsr unicode PCREOption bsr unicode cint caseless If this bit is set letters in the pattern match both upper and lower case letters It is equivalent to Perl option and it can be changed within pattern by option setting In UTF-8 mode PCRE always understands the concept of case for characters whose values are less than so caseless matching is always possible For characters with higher values the concept of case is supported if PCRE is compiled with Unicode property sup port but not otherwise If you want to use caseless matching for characters and above you must ensure that PCRE is compiled with Unicode property support as well as with UTF-8 support",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "caseless",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:compile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eCompile a perl-compatible regular expression stored in a strict bytestring.\n\u003c/p\u003e\u003cp\u003eAn example\n\u003c/p\u003e\u003cpre\u003e let r = compile (pack \"^(b+|a){1,2}?bc\") []\n\u003c/pre\u003e\u003cp\u003eOr using GHC's -XOverloadedStrings flag, and importing\n Data.ByteString.Char8, we can avoid the pack:\n\u003c/p\u003e\u003cpre\u003e let r = compile \"^(b+|a){1,2}?bc\" []\n\u003c/pre\u003e\u003cp\u003eIf the regular expression is invalid, an exception is thrown.\n If this is unsuitable, \u003ccode\u003e\u003ca\u003ecompileM\u003c/a\u003e\u003c/code\u003e is availlable, which returns failure \n in a monad.\n\u003c/p\u003e\u003cp\u003eTo do case insentive matching,\n\u003c/p\u003e\u003cpre\u003e compile \"^(b+|a){1,2}?bc\" [caseless]\n\u003c/pre\u003e\u003cp\u003eOther flags are documented below.\n\u003c/p\u003e\u003cp\u003eThe resulting abstract regular expression can be passed to \u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e\n for matching against a subject string.\n\u003c/p\u003e\u003cp\u003eThe arguments are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003epat\u003c/code\u003e: A ByteString containing the regular expression to be compiled. \n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eflags\u003c/code\u003e, optional bit flags. If \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is provided, defaults are used.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eValid compile-time flags are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e        - Force pattern anchoring\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eauto_callout\u003c/a\u003e\u003c/code\u003e    - Compile automatic callouts\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ebsr_anycrlf\u003c/code\u003e     - \\R matches only CR, LF, or CRLF\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ebsr_unicode\u003c/code\u003e     - \\R matches all Unicode line endings\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ecaseless\u003c/a\u003e\u003c/code\u003e        - Do caseless matching\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e  - \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e not to match newline at end\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edotall\u003c/a\u003e\u003c/code\u003e          - matches anything including NL\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003edupnames\u003c/a\u003e\u003c/code\u003e        - Allow duplicate names for subpatterns\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e        - Ignore whitespace and # comments\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eextra\u003c/a\u003e\u003c/code\u003e           - PCRE extra features (not much use currently)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003efirstline\u003c/a\u003e\u003c/code\u003e       - Force matching to be  before  newline\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e       - \u003ccode\u003e\u003ca\u003e^\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e match newlines within data\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enewline_any\u003c/code\u003e     - Recognize any Unicode newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003enewline_anycrlf\u003c/code\u003e - Recognize CR, LF, and CRLF as newline sequences\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e      - Set CR as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e    - Set CRLF as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e      - Set LF as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eno_auto_capture\u003c/a\u003e\u003c/code\u003e - Disable numbered capturing parentheses (named ones available)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eungreedy\u003c/a\u003e\u003c/code\u003e        - Invert greediness of quantifiers\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e            - Run in UTF-8 mode\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e   - Do not check the pattern for UTF-8 validity\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe regex is allocated via malloc on the C side, and will be\n deallocated by the runtime when the Haskell value representing it\n goes out of scope.\n\u003c/p\u003e\u003cp\u003eSee 'man pcreapi for more details.\n\u003c/p\u003e\u003cp\u003eCaveats: patterns with embedded nulls, such as \u003ca\u003e0*\u003c/a\u003e seem to be\n mishandled, as this won't currently match the subject \u003ca\u003e000\u003c/a\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "ByteString -\u003e [PCREOption] -\u003e Regex",
        "fct-source": "src/Text-Regex-PCRE-Light.html#compile",
        "fct-type": "function",
        "title": "compile"
      },
      "index": {
        "description": "compile Compile perl-compatible regular expression stored in strict bytestring An example let compile pack bc Or using GHC XOverloadedStrings flag and importing Data.ByteString.Char8 we can avoid the pack let compile bc If the regular expression is invalid an exception is thrown If this is unsuitable compileM is availlable which returns failure in monad To do case insentive matching compile bc caseless Other flags are documented below The resulting abstract regular expression can be passed to match for matching against subject string The arguments are pat ByteString containing the regular expression to be compiled flags optional bit flags If Nothing is provided defaults are used Valid compile-time flags are anchored Force pattern anchoring auto callout Compile automatic callouts bsr anycrlf matches only CR LF or CRLF bsr unicode matches all Unicode line endings caseless Do caseless matching dollar endonly not to match newline at end dotall matches anything including NL dupnames Allow duplicate names for subpatterns extended Ignore whitespace and comments extra PCRE extra features not much use currently firstline Force matching to be before newline multiline and match newlines within data newline any Recognize any Unicode newline sequence newline anycrlf Recognize CR LF and CRLF as newline sequences newline cr Set CR as the newline sequence newline crlf Set CRLF as the newline sequence newline lf Set LF as the newline sequence no auto capture Disable numbered capturing parentheses named ones available ungreedy Invert greediness of quantifiers utf8 Run in UTF-8 mode no utf8 check Do not check the pattern for UTF-8 validity The regex is allocated via malloc on the side and will be deallocated by the runtime when the Haskell value representing it goes out of scope See man pcreapi for more details Caveats patterns with embedded nulls such as seem to be mishandled as this won currently match the subject",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "compile",
        "normalized": "ByteString-\u003e[PCREOption]-\u003eRegex",
        "package": "pcre-light",
        "partial": "",
        "signature": "ByteString-\u003e[PCREOption]-\u003eRegex"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:compileM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecompileM\u003c/a\u003e\u003c/code\u003e\n A safe version of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e with failure wrapped in an Either.\n\u003c/p\u003e\u003cp\u003eExamples,\n\u003c/p\u003e\u003cpre\u003e \u003e compileM \".*\" [] :: Either String Regex\n Right (Regex 0x000000004bb5b980 \".*\")\n\u003c/pre\u003e\u003cpre\u003e \u003e compileM \"*\" [] :: Either String Regex\n Left \"nothing to repeat\"\n\u003c/pre\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "ByteString -\u003e [PCREOption] -\u003e Either String Regex",
        "fct-source": "src/Text-Regex-PCRE-Light.html#compileM",
        "fct-type": "function",
        "title": "compileM"
      },
      "index": {
        "description": "compileM safe version of compile with failure wrapped in an Either Examples compileM Either String Regex Right Regex x000000004bb5b980 compileM Either String Regex Left nothing to repeat",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "compileM",
        "normalized": "ByteString-\u003e[PCREOption]-\u003eEither String Regex",
        "package": "pcre-light",
        "partial": "",
        "signature": "ByteString-\u003e[PCREOption]-\u003eEither String Regex"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:dollar_endonly",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, a dollar metacharacter in the pattern matches only at\n the end of the subject string. Without this option, a dollar also matches\n immediately before a newline at the end of the string (but not before any other\n newlines). The \u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e option is ignored if \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e\n is set.  There is no equivalent to this option in Perl, and no way to set it\n within a pattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dollar_endonly",
        "fct-type": "function",
        "title": "dollar_endonly"
      },
      "index": {
        "description": "dollar endonly If this bit is set dollar metacharacter in the pattern matches only at the end of the subject string Without this option dollar also matches immediately before newline at the end of the string but not before any other newlines The dollar endonly option is ignored if multiline is set There is no equivalent to this option in Perl and no way to set it within pattern",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "dollar_endonly",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:dotall",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edotall\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, a dot metacharater in the pattern matches all\n characters, including those that indicate newline. Without it, a dot does\n not match when the current position is at a newline. This option is\n equivalent to Perl's /s option, and it can be changed within a pattern by a\n (?s) option setting. A negative class such as [^a] always matches newline\n characters, independent of the setting of this option.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dotall",
        "fct-type": "function",
        "title": "dotall"
      },
      "index": {
        "description": "dotall If this bit is set dot metacharater in the pattern matches all characters including those that indicate newline Without it dot does not match when the current position is at newline This option is equivalent to Perl option and it can be changed within pattern by option setting negative class such as always matches newline characters independent of the setting of this option",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "dotall",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:dupnames",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edupnames\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, names used to identify capturing subpatterns need not be\n unique. This can be helpful for certain types of pattern when it is known\n that only one instance of the named subpattern can ever be matched. There are\n more details of named subpatterns in the \u003cem\u003eman pcreapi\u003c/em\u003e documentation.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#dupnames",
        "fct-type": "function",
        "title": "dupnames"
      },
      "index": {
        "description": "dupnames If this bit is set names used to identify capturing subpatterns need not be unique This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched There are more details of named subpatterns in the man pcreapi documentation",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "dupnames",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_anchored",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e option limits \u003ccode\u003eexec\u003c/code\u003e to matching at\n the first matching position. If a pattern was compiled\n with \u003ccode\u003e\u003ca\u003eanchored\u003c/a\u003e\u003c/code\u003e, or turned out to be anchored by virtue\n of its contents, it cannot be made unachored at matching\n time.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_anchored",
        "fct-type": "function",
        "title": "exec_anchored"
      },
      "index": {
        "description": "anchored The anchored option limits exec to matching at the first matching position If pattern was compiled with anchored or turned out to be anchored by virtue of its contents it cannot be made unachored at matching time",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_anchored",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_newline_cr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003enewline_anycrlf\u003c/code\u003e, \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options override the newline definition that was\n chosen or defaulted when the pattern was compiled. For\n details, see the description of \u003ccode\u003ecompile\u003c/code\u003e above. Dur-\n ing matching, the newline choice affects the behaviour of\n the dot, circumflex, and dollar metacharacters. It may\n also alter the way the match position is advanced after a\n match failure for an unanchored pattern.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003enewline_anycrlf\u003c/code\u003e, or \u003ccode\u003enewline_any\u003c/code\u003e\n is set, and a match attempt for an unanchored\n pattern fails when the current position is at a CRLF\n sequence, and the pattern contains no explicit matches for\n CR or LF characters, the match position is advanced by two\n characters instead of one, in other words, to after the\n CRLF.\n\u003c/p\u003e\u003cp\u003eThe above rule is a compromise that makes the most common\n cases work as expected. For example, if the pattern is .+A\n (and the \u003ccode\u003e\u003ca\u003edotall\u003c/a\u003e\u003c/code\u003e option is not set), it does not match\n the string \u003cem\u003e\\\\r\\\\nA\u003c/em\u003e because, after failing at the start, it\n skips both the CR and the LF before retrying. However, the\n pattern \u003cem\u003e[\\\\r\\\\n]A\u003c/em\u003e does match that string, because it contains\n an explicit CR or LF reference, and so advances only\n by one character after the first failure.\n\u003c/p\u003e\u003cp\u003eAn explicit match for CR of LF is either a literal appear-\n ance of one of those characters, or one of the \\r or \\n\n escape sequences. Implicit matches such as [^X] do not\n count, nor does \\s (which includes CR and LF in the char-\n acters that it matches).\n\u003c/p\u003e\u003cp\u003eNotwithstanding the above, anomalous effects may still\n occur when CRLF is a valid newline sequence and explicit\n \\r or \\n escapes appear in the pattern.\n\u003c/p\u003e\u003cp\u003eexec_newline_any           :: PCREExecOption\n exec_newline_any           = PCREExecOption exec_newline_any_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eexec_newline_anycrlf\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n exec_newline_anycrlf       :: PCREExecOption\n exec_newline_anycrlf       = PCREExecOption exec_newline_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_cr\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_cr",
        "fct-type": "function",
        "title": "exec_newline_cr"
      },
      "index": {
        "description": "newline cr newline lf newline crlf newline anycrlf newline any These options override the newline definition that was chosen or defaulted when the pattern was compiled For details see the description of compile above Dur ing matching the newline choice affects the behaviour of the dot circumflex and dollar metacharacters It may also alter the way the match position is advanced after match failure for an unanchored pattern When newline crlf newline anycrlf or newline any is set and match attempt for an unanchored pattern fails when the current position is at CRLF sequence and the pattern contains no explicit matches for CR or LF characters the match position is advanced by two characters instead of one in other words to after the CRLF The above rule is compromise that makes the most common cases work as expected For example if the pattern is and the dotall option is not set it does not match the string nA because after failing at the start it skips both the CR and the LF before retrying However the pattern does match that string because it contains an explicit CR or LF reference and so advances only by one character after the first failure An explicit match for CR of LF is either literal appear ance of one of those characters or one of the or escape sequences Implicit matches such as do not count nor does which includes CR and LF in the char acters that it matches Notwithstanding the above anomalous effects may still occur when CRLF is valid newline sequence and explicit or escapes appear in the pattern exec newline any PCREExecOption exec newline any PCREExecOption exec newline any cint exec newline anycrlf see exec newline any exec newline anycrlf PCREExecOption exec newline anycrlf PCREExecOption exec newline anycrlf cint exec newline cr see exec newline any",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_newline_cr",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_newline_crlf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_crlf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_crlf",
        "fct-type": "function",
        "title": "exec_newline_crlf"
      },
      "index": {
        "description": "exec newline crlf see exec newline any",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_newline_crlf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_newline_lf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eexec_newline_lf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003eexec_newline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_newline_lf",
        "fct-type": "function",
        "title": "exec_newline_lf"
      },
      "index": {
        "description": "exec newline lf see exec newline any",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_newline_lf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_no_utf8_check",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e is set at compile time, the validity of the\n subject as a UTF-8 string is automatically checked when\n exec() is subsequently called. The value of\n startoffset is also checked to ensure that it points to\n the start of a UTF-8 character. There is a discussion\n about the validity of UTF-8 strings in the section on\n UTF-8 support in the main pcre page. If an invalid UTF-8\n sequence of bytes is found, exec() returns the error\n \u003ccode\u003e\u003ca\u003eerror_badutf8\u003c/a\u003e\u003c/code\u003e. If startoffset contains an invalid\n value, \u003ccode\u003e\u003ca\u003eerror_badutf8_offset\u003c/a\u003e\u003c/code\u003e is returned.\n\u003c/p\u003e\u003cp\u003eIf you already know that your subject is valid, and you\n want to skip these checks for performance reasons, you can\n set the \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e option when calling\n \u003ccode\u003eexec\u003c/code\u003e. You might want to do this for the second and\n subsequent calls to exec() if you are making repeated\n calls to find all the matches in a single subject string.\n However, you should be sure that the value of startoffset\n points to the start of a UTF-8 character. When\n \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e is set, the effect of passing an\n invalid UTF-8 string as a subject, or a value of startoff-\n set that does not point to the start of a UTF-8 character,\n is undefined. Your program may crash.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_no_utf8_check",
        "fct-type": "function",
        "title": "exec_no_utf8_check"
      },
      "index": {
        "description": "no utf8 check When utf8 is set at compile time the validity of the subject as UTF-8 string is automatically checked when exec is subsequently called The value of startoffset is also checked to ensure that it points to the start of UTF-8 character There is discussion about the validity of UTF-8 strings in the section on UTF-8 support in the main pcre page If an invalid UTF-8 sequence of bytes is found exec returns the error error badutf8 If startoffset contains an invalid value error badutf8 offset is returned If you already know that your subject is valid and you want to skip these checks for performance reasons you can set the no utf8 check option when calling exec You might want to do this for the second and subsequent calls to exec if you are making repeated calls to find all the matches in single subject string However you should be sure that the value of startoffset points to the start of UTF-8 character When no utf8 check is set the effect of passing an invalid UTF-8 string as subject or value of startoff set that does not point to the start of UTF-8 character is undefined Your program may crash",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_no_utf8_check",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_notbol",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ePCRE_NOTBOL\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option specifies that first character of the subject\n string is not the beginning of a line, so the circumflex\n metacharacter should not match before it. Setting this\n without \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e (at compile time) causes circumflex\n never to match. This option affects only the behaviour of\n the circumflex metacharacter. It does not affect \\A.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_notbol",
        "fct-type": "function",
        "title": "exec_notbol"
      },
      "index": {
        "description": "PCRE NOTBOL This option specifies that first character of the subject string is not the beginning of line so the circumflex metacharacter should not match before it Setting this without multiline at compile time causes circumflex never to match This option affects only the behaviour of the circumflex metacharacter It does not affect",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_notbol",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_notempty",
      "description": {
        "fct-descr": "\u003cp\u003ePCRE_NOTEMPTY\n\u003c/p\u003e\u003cp\u003eAn empty string is not considered to be a valid match if\n this option is set. If there are alternatives in the pattern,\n they are tried. If all the alternatives match the\n empty string, the entire match fails. For example, if the\n pattern\n\u003c/p\u003e\u003cpre\u003e a?b?\n\u003c/pre\u003e\u003cp\u003eis applied to a string not beginning with \u003cem\u003ea\u003c/em\u003e or \u003cem\u003eb\u003c/em\u003e, it\n matches the empty string at the start of the subject. With\n \u003ccode\u003enotempty\u003c/code\u003e set, this match is not valid, so 'PCRE\n searches further into the string for occurrences of \u003cem\u003ea\u003c/em\u003e or\n \u003cem\u003eb\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003ePerl has no direct equivalent of \u003ccode\u003enotempty\u003c/code\u003e, but it\n does make a special case of a pattern match of the empty\n string within its split() function, and when using the /g\n modifier. It is possible to emulate Perl's behaviour after\n matching a null string by first trying the match again at\n the same offset with PCRE_NOTEMPTY and PCRE_ANCHORED, and\n then if that fails by advancing the starting offset (see\n below) and trying an ordinary match again. There is some\n code that demonstrates how to do this in the pcredemo.c\n sample program.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_notempty",
        "fct-type": "function",
        "title": "exec_notempty"
      },
      "index": {
        "description": "PCRE NOTEMPTY An empty string is not considered to be valid match if this option is set If there are alternatives in the pattern they are tried If all the alternatives match the empty string the entire match fails For example if the pattern is applied to string not beginning with or it matches the empty string at the start of the subject With notempty set this match is not valid so PCRE searches further into the string for occurrences of or Perl has no direct equivalent of notempty but it does make special case of pattern match of the empty string within its split function and when using the modifier It is possible to emulate Perl behaviour after matching null string by first trying the match again at the same offset with PCRE NOTEMPTY and PCRE ANCHORED and then if that fails by advancing the starting offset see below and trying an ordinary match again There is some code that demonstrates how to do this in the pcredemo.c sample program",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_notempty",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_noteol",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003enoteol\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option specifies that the end of the subject string\n is not the end of a line, so the dollar metacharacter\n should not match it nor (except in multiline mode) a newline\n immediately before it. Setting this without \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e \n (at compile time) causes dollar never to match.\n This option affects only the behaviour of the dollar\n metacharacter. It does not affect \\Z or \\z.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_noteol",
        "fct-type": "function",
        "title": "exec_noteol"
      },
      "index": {
        "description": "noteol This option specifies that the end of the subject string is not the end of line so the dollar metacharacter should not match it nor except in multiline mode newline immediately before it Setting this without multiline at compile time causes dollar never to match This option affects only the behaviour of the dollar metacharacter It does not affect or",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_noteol",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:exec_partial",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003epartial\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option turns on the partial matching feature. If the\n subject string fails to match the pattern, but at some\n point during the matching process the end of the subject\n was reached (that is, the subject partially matches the\n pattern and the failure to match occurred only because\n there were not enough subject characters), \u003ccode\u003eexec\u003c/code\u003e\n returns \u003ccode\u003e\u003ca\u003eerror_partial\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003eerror_nomatch\u003c/a\u003e\u003c/code\u003e.\n When \u003ccode\u003epartial\u003c/code\u003e is used, there are restrictions on what\n may appear in the pattern. These are discussed in the\n pcrepartial documentation.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREExecOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#exec_partial",
        "fct-type": "function",
        "title": "exec_partial"
      },
      "index": {
        "description": "partial This option turns on the partial matching feature If the subject string fails to match the pattern but at some point during the matching process the end of the subject was reached that is the subject partially matches the pattern and the failure to match occurred only because there were not enough subject characters exec returns error partial instead of error nomatch When partial is used there are restrictions on what may appear in the pattern These are discussed in the pcrepartial documentation",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "exec_partial",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:extended",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this bit is set, whitespace data characters in the pattern are totally\n ignored except when escaped or inside a character class. Whitespace does not\n include the VT character (code 11). In addition, characters between an\n unescaped # outside a character class and the next newline, inclusive, are\n also ignored. This is equivalent to Perl's /x option, and it can be changed\nwithin a pattern by a (?x) option setting.\n\u003c/p\u003e\u003cp\u003eThis option makes it possible to include comments inside complicated\n patterns. Note, however, that this applies only to data characters. Whitespace\n characters may never appear within special character sequences in a pattern,\n for example within the sequence (?( which introduces a conditional subpattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extended",
        "fct-type": "function",
        "title": "extended"
      },
      "index": {
        "description": "extended If this bit is set whitespace data characters in the pattern are totally ignored except when escaped or inside character class Whitespace does not include the VT character code In addition characters between an unescaped outside character class and the next newline inclusive are also ignored This is equivalent to Perl option and it can be changed within pattern by option setting This option makes it possible to include comments inside complicated patterns Note however that this applies only to data characters Whitespace characters may never appear within special character sequences in pattern for example within the sequence which introduces conditional subpattern",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "extended",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:extra",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eextra\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option was invented in order to turn on additional functionality of\n PCRE that is incompatible with Perl, but it is currently of very little use.\n When set, any backslash in a pattern that is followed by a letter that has no\n special meaning causes an error, thus reserving these combinations for future\n expansion. By default, as in Perl, a backslash followed by a letter with no\n special meaning is treated as a literal. (Perl can, however, be persuaded to\n give a warning for this.) There are at present no other features controlled by\n this option. It can also be set by a (?X) option setting within a pattern. \n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#extra",
        "fct-type": "function",
        "title": "extra"
      },
      "index": {
        "description": "extra This option was invented in order to turn on additional functionality of PCRE that is incompatible with Perl but it is currently of very little use When set any backslash in pattern that is followed by letter that has no special meaning causes an error thus reserving these combinations for future expansion By default as in Perl backslash followed by letter with no special meaning is treated as literal Perl can however be persuaded to give warning for this There are at present no other features controlled by this option It can also be set by option setting within pattern",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "extra",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:firstline",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efirstline\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this option is set, an unanchored pattern is required to match before or\n at the first newline in the subject string, though the matched text may\ncontinue over the newline.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#firstline",
        "fct-type": "function",
        "title": "firstline"
      },
      "index": {
        "description": "firstline If this option is set an unanchored pattern is required to match before or at the first newline in the subject string though the matched text may continue over the newline",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "firstline",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:match",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eMatches a compiled regular expression against a given subject string,\n using a matching algorithm that is similar to Perl's. If the subject\n string doesn't match the regular expression, \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is returned,\n otherwise the portion of the string that matched is returned, along\n with any captured subpatterns.\n\u003c/p\u003e\u003cp\u003eThe arguments are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eregex\u003c/code\u003e, a PCRE regular expression value produced by compile\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003esubject\u003c/code\u003e, the subject string to match against\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eoptions\u003c/code\u003e, an optional set of exec-time flags to exec.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAvailable runtime options are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_anchored\u003c/a\u003e\u003c/code\u003e        - Match only at the first position\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eexec_newline_any\u003c/code\u003e     - Recognize any Unicode newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eexec_newline_anycrlf\u003c/code\u003e - Recognize CR, LF, and CRLF as newline sequences\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_newline_cr\u003c/a\u003e\u003c/code\u003e      - Set CR as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_newline_crlf\u003c/a\u003e\u003c/code\u003e    - Set CRLF as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_newline_lf\u003c/a\u003e\u003c/code\u003e      - Set LF as the newline sequence\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_notbol\u003c/a\u003e\u003c/code\u003e          - Subject is not the beginning of a line\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_noteol\u003c/a\u003e\u003c/code\u003e          - Subject is not the end of a line\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_notempty\u003c/a\u003e\u003c/code\u003e        - An empty string is not a valid match\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_no_utf8_check\u003c/a\u003e\u003c/code\u003e   - Do not check the subject for UTF-8\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eexec_partial\u003c/a\u003e\u003c/code\u003e         - Return PCRE_ERROR_PARTIAL for a partial match\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe result value, and any captured subpatterns, are returned.\n If the regex is invalid, or the subject string is empty, Nothing\n is returned.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "Regex -\u003e ByteString -\u003e [PCREExecOption] -\u003e Maybe [ByteString]",
        "fct-source": "src/Text-Regex-PCRE-Light.html#match",
        "fct-type": "function",
        "title": "match"
      },
      "index": {
        "description": "match Matches compiled regular expression against given subject string using matching algorithm that is similar to Perl If the subject string doesn match the regular expression Nothing is returned otherwise the portion of the string that matched is returned along with any captured subpatterns The arguments are regex PCRE regular expression value produced by compile subject the subject string to match against options an optional set of exec-time flags to exec Available runtime options are exec anchored Match only at the first position exec newline any Recognize any Unicode newline sequence exec newline anycrlf Recognize CR LF and CRLF as newline sequences exec newline cr Set CR as the newline sequence exec newline crlf Set CRLF as the newline sequence exec newline lf Set LF as the newline sequence exec notbol Subject is not the beginning of line exec noteol Subject is not the end of line exec notempty An empty string is not valid match exec no utf8 check Do not check the subject for UTF-8 exec partial Return PCRE ERROR PARTIAL for partial match The result value and any captured subpatterns are returned If the regex is invalid or the subject string is empty Nothing is returned",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "match",
        "normalized": "Regex-\u003eByteString-\u003e[PCREExecOption]-\u003eMaybe[ByteString]",
        "package": "pcre-light",
        "partial": "",
        "signature": "Regex-\u003eByteString-\u003e[PCREExecOption]-\u003eMaybe[ByteString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:multiline",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eBy default, PCRE treats the subject string as consisting of a single line\n of characters (even if it actually contains newlines). The \u003cem\u003estart of line\u003c/em\u003e\n metacharacter (^) matches only at the start of the string, while the \u003cem\u003eend of line\u003c/em\u003e\n  metacharacter ($) matches only at the end of the string, or before a\n terminating newline (unless \u003ccode\u003e\u003ca\u003edollar_endonly\u003c/a\u003e\u003c/code\u003e is set). This is the same\n as Perl.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003emultiline\u003c/a\u003e\u003c/code\u003e it is set, the \u003cem\u003estart of line\u003c/em\u003e and \u003cem\u003eend of line\u003c/em\u003e\n constructs match immediately following or immediately before internal newlines\n in the subject string, respectively, as well as at the very start and end. This\n is equivalent to Perl's /m option, and it can be changed within a pattern by a\n (?m) option setting. If there are no newlines in a subject string, or no occur-\n rences of ^ or $ in a pattern, setting PCRE_MULTILINE has no effect.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#multiline",
        "fct-type": "function",
        "title": "multiline"
      },
      "index": {
        "description": "multiline By default PCRE treats the subject string as consisting of single line of characters even if it actually contains newlines The start of line metacharacter matches only at the start of the string while the end of line metacharacter matches only at the end of the string or before terminating newline unless dollar endonly is set This is the same as Perl When multiline it is set the start of line and end of line constructs match immediately following or immediately before internal newlines in the subject string respectively as well as at the very start and end This is equivalent to Perl option and it can be changed within pattern by option setting If there are no newlines in subject string or no occur rences of or in pattern setting PCRE MULTILINE has no effect",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "multiline",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:newline_cr",
      "description": {
        "fct-descr": "\u003cp\u003enewline_cr', \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003enewline_anycrlf\u003c/code\u003e, \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese options override the default newline definition that\n was chosen when PCRE was built. Setting the first or the\n second specifies that a newline is indicated by a single\n character (CR or LF, respectively). Setting \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e specifies\n that a newline is indicated by the two-character CRLF sequence.\n Setting \u003ccode\u003enewline_anycrlf\u003c/code\u003e\n specifies that any of the three preceding sequences should\n be recognized. Setting \u003ccode\u003enewline_any\u003c/code\u003e specifies that any\n Unicode newline sequence should be recognized. The Unicode\n newline sequences are the three just mentioned, plus the\n single characters VT (vertical tab, U+000B), FF (formfeed,\n U+000C), NEL (next line, U+0085), LS (line separator,\n U+2028), and PS (paragraph separator, U+2029). The last\n two are recognized only in UTF-8 mode.\n\u003c/p\u003e\u003cp\u003eThe newline setting in the options word uses three bits\n that are treated as a number, giving eight possibilities.\n Currently only six are used (default plus the five values\n above). This means that if you set more than one newline\n option, the combination may or may not be sensible. For\n example, \u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, but other combinations may yield unused numbers and\n cause an error.\n\u003c/p\u003e\u003cp\u003eThe only time that a line break is specially recognized\n when compiling a pattern is if \u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e is set, and\n an unescaped # outside a character class is encountered.\n This indicates a comment that lasts until after the next\n line break sequence. In other circumstances, line break\n sequences are treated as literal data, except that in\n \u003ccode\u003e\u003ca\u003eextended\u003c/a\u003e\u003c/code\u003e mode, both CR and LF are treated as whitespace characters\n and are therefore ignored.  -- \n\u003c/p\u003e\u003cp\u003eThe newline option that is set at compile time becomes the\n default that is used for \u003ccode\u003eexec\u003c/code\u003e but it can be overridden.\n\u003c/p\u003e\u003cp\u003enewline_any        :: PCREOption\n newline_any        = PCREOption newline_any_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003enewline_anycrlf\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n newline_anycrlf    :: PCREOption\n newline_anycrlf    = PCREOption newline_anycrlf_cint\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_cr\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_cr",
        "fct-type": "function",
        "title": "newline_cr"
      },
      "index": {
        "description": "newline cr newline lf newline crlf newline anycrlf newline any These options override the default newline definition that was chosen when PCRE was built Setting the first or the second specifies that newline is indicated by single character CR or LF respectively Setting newline crlf specifies that newline is indicated by the two-character CRLF sequence Setting newline anycrlf specifies that any of the three preceding sequences should be recognized Setting newline any specifies that any Unicode newline sequence should be recognized The Unicode newline sequences are the three just mentioned plus the single characters VT vertical tab FF formfeed NEL next line LS line separator and PS paragraph separator The last two are recognized only in UTF-8 mode The newline setting in the options word uses three bits that are treated as number giving eight possibilities Currently only six are used default plus the five values above This means that if you set more than one newline option the combination may or may not be sensible For example newline cr with newline lf is equivalent to newline crlf but other combinations may yield unused numbers and cause an error The only time that line break is specially recognized when compiling pattern is if extended is set and an unescaped outside character class is encountered This indicates comment that lasts until after the next line break sequence In other circumstances line break sequences are treated as literal data except that in extended mode both CR and LF are treated as whitespace characters and are therefore ignored The newline option that is set at compile time becomes the default that is used for exec but it can be overridden newline any PCREOption newline any PCREOption newline any cint newline anycrlf see newline any newline anycrlf PCREOption newline anycrlf PCREOption newline anycrlf cint newline cr see newline any",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "newline_cr",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:newline_crlf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_crlf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_crlf",
        "fct-type": "function",
        "title": "newline_crlf"
      },
      "index": {
        "description": "newline crlf see newline any",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "newline_crlf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:newline_lf",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enewline_lf\u003c/a\u003e\u003c/code\u003e, see \u003ccode\u003enewline_any\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#newline_lf",
        "fct-type": "function",
        "title": "newline_lf"
      },
      "index": {
        "description": "newline lf see newline any",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "newline_lf",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:no_auto_capture",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_auto_capture\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf this option is set, it disables the use of numbered\n capturing parentheses in the pattern. Any opening paren-\n thesis that is not followed by ? behaves as if it were\n followed by ?: but named parentheses can still be used for\n capturing (and they acquire numbers in the usual way).\n There is no equivalent of this option in Perl.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#no_auto_capture",
        "fct-type": "function",
        "title": "no_auto_capture"
      },
      "index": {
        "description": "no auto capture If this option is set it disables the use of numbered capturing parentheses in the pattern Any opening paren thesis that is not followed by behaves as if it were followed by but named parentheses can still be used for capturing and they acquire numbers in the usual way There is no equivalent of this option in Perl",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "no_auto_capture",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:no_utf8_check",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen PCRE_UTF8 is set, the validity of the pattern as a\n UTF-8 string is automatically checked. There is a discussion \n about the validity of UTF-8 strings in the main pcre\n page. If an invalid UTF-8 sequence of bytes is found,\n compile() returns an error. If you already know that\n your pattern is valid, and you want to skip this check for\n performance reasons, you can set the \u003ccode\u003e\u003ca\u003eno_utf8_check\u003c/a\u003e\u003c/code\u003e\n option. When it is set, the effect of passing an invalid\n UTF-8 string as a pattern is undefined. It may cause your\n program to crash. Note that this option can also be passed\n to \u003ccode\u003eexec\u003c/code\u003e, to suppress the UTF-8 validity checking of subject strings.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#no_utf8_check",
        "fct-type": "function",
        "title": "no_utf8_check"
      },
      "index": {
        "description": "no utf8 check When PCRE UTF8 is set the validity of the pattern as UTF-8 string is automatically checked There is discussion about the validity of UTF-8 strings in the main pcre page If an invalid UTF-8 sequence of bytes is found compile returns an error If you already know that your pattern is valid and you want to skip this check for performance reasons you can set the no utf8 check option When it is set the effect of passing an invalid UTF-8 string as pattern is undefined It may cause your program to crash Note that this option can also be passed to exec to suppress the UTF-8 validity checking of subject strings",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "no_utf8_check",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:ungreedy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eungreedy\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option inverts the \u003cem\u003egreediness\u003c/em\u003e of the quantifiers so\n that they are not greedy by default, but become greedy if\n followed by \u003cem\u003e?\u003c/em\u003e. It is not compatible with Perl. It can\n also be set by a (?U) option setting within the pattern.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#ungreedy",
        "fct-type": "function",
        "title": "ungreedy"
      },
      "index": {
        "description": "ungreedy This option inverts the greediness of the quantifiers so that they are not greedy by default but become greedy if followed by It is not compatible with Perl It can also be set by option setting within the pattern",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "ungreedy",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/pcre-light/docs/Text-Regex-PCRE-Light.html#v:utf8",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis option causes PCRE to regard both the pattern and the\n subject as strings of UTF-8 characters instead of single-byte character\n strings. However, it is available only when \n PCRE is built to include UTF-8 support. If not, the use of\n this option provokes an error. Details of how this option\n changes the behaviour of PCRE are given in the section on\n UTF-8 support in the main pcre page.\n\u003c/p\u003e",
        "fct-module": "Text.Regex.PCRE.Light",
        "fct-package": "pcre-light",
        "fct-signature": "PCREOption",
        "fct-source": "src/Text-Regex-PCRE-Light-Base.html#utf8",
        "fct-type": "function",
        "title": "utf8"
      },
      "index": {
        "description": "utf8 This option causes PCRE to regard both the pattern and the subject as strings of UTF-8 characters instead of single-byte character strings However it is available only when PCRE is built to include UTF-8 support If not the use of this option provokes an error Details of how this option changes the behaviour of PCRE are given in the section on UTF-8 support in the main pcre page",
        "hierarchy": "Text Regex PCRE Light",
        "module": "Text.Regex.PCRE.Light",
        "name": "utf8",
        "normalized": "",
        "package": "pcre-light",
        "partial": "",
        "signature": ""
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn abstract, parameterizable interface for queues.  \n\u003c/p\u003e\u003cp\u003eThis interface includes a non-associated type family for Deques\n   plus separate type classes encapsulating the Deque operations.\n   That is, we separate type selection (type family) from function overloading\n   (vanilla type classes).\n\u003c/p\u003e\u003cp\u003eThis design strives to hide the extra phantom-type parameters from\n   the Class constraints and therefore from the type signatures of\n   client code.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "module",
        "fct-source": "src/Data-Concurrent-Deque-Class.html",
        "fct-type": "module",
        "title": "Class"
      },
      "index": {
        "description": "An abstract parameterizable interface for queues This interface includes non-associated type family for Deques plus separate type classes encapsulating the Deque operations That is we separate type selection type family from function overloading vanilla type classes This design strives to hide the extra phantom-type parameters from the Class constraints and therefore from the type signatures of client code",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Class",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Class",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:Bound",
      "description": {
        "fct-descr": "\u003cp\u003eThe queue has bounded capacity.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#Bound",
        "fct-type": "data",
        "title": "Bound"
      },
      "index": {
        "description": "The queue has bounded capacity",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Bound",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Bound",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:BoundedL",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "class",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#BoundedL",
        "fct-type": "class",
        "title": "BoundedL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "BoundedL",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Bounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:BoundedR",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "class",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#BoundedR",
        "fct-type": "class",
        "title": "BoundedR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "BoundedR",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Bounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:ConcDeque",
      "description": {
        "fct-descr": "\u003cp\u003eA concurrent deque.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "type",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#ConcDeque",
        "fct-type": "type",
        "title": "ConcDeque"
      },
      "index": {
        "description": "concurrent deque",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "ConcDeque",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Conc Deque",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:ConcQueue",
      "description": {
        "fct-descr": "\u003cp\u003eA concurrent queue.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "type",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#ConcQueue",
        "fct-type": "type",
        "title": "ConcQueue"
      },
      "index": {
        "description": "concurrent queue",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "ConcQueue",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Conc Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:D",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "type",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#D",
        "fct-type": "type",
        "title": "D"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "D",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:Deque",
      "description": {
        "fct-descr": "\u003cp\u003eA family of Deques implementations.  A concrete Deque implementation\n is selected based on the (phantom) type parameters, which encode\n several choices.\n\u003c/p\u003e\u003cp\u003eFor example, a work stealing deque is threadsafe only on one end and\n supports push/pop on one end (and pop-only) on the other:\n\u003c/p\u003e\u003cpre\u003e\u003e (Deque NT T  D S Grow elt)\n\u003c/pre\u003e\u003cp\u003eNote, however, that the above example is overconstraining in many\n situations.  It demands an implementation which is NOT threadsafe on\n one end and does NOT support push on one end, whereas both these\n features would not hurt, if present.\n\u003c/p\u003e\u003cp\u003eThus when accepting a queue as input to a function you probably never\n want to overconstrain by demanding a less-featureful option.\n\u003c/p\u003e\u003cp\u003eFor example, rather than \u003ccode\u003e(Deque NT D T S Grow elt)\u003c/code\u003e\n   You would probably want: \u003ccode\u003e(Deque nt D T s Grow elt)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "Deque",
        "fct-type": "function",
        "title": "Deque"
      },
      "index": {
        "description": "family of Deques implementations concrete Deque implementation is selected based on the phantom type parameters which encode several choices For example work stealing deque is threadsafe only on one end and supports push pop on one end and pop-only on the other Deque NT Grow elt Note however that the above example is overconstraining in many situations It demands an implementation which is NOT threadsafe on one end and does NOT support push on one end whereas both these features would not hurt if present Thus when accepting queue as input to function you probably never want to overconstrain by demanding less-featureful option For example rather than Deque NT Grow elt You would probably want Deque nt Grow elt",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Deque",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Deque",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:DequeClass",
      "description": {
        "fct-descr": "\u003cp\u003eClass encompassing the basic queue operations that hold for all\n   single, 1.5, and double ended modes.  We arbitrarily call the\n   ends \"left\" and \"right\" and choose the natural operations to be\n   pushing on the left and popping on the right.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "class",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#DequeClass",
        "fct-type": "class",
        "title": "DequeClass"
      },
      "index": {
        "description": "Class encompassing the basic queue operations that hold for all single and double ended modes We arbitrarily call the ends left and right and choose the natural operations to be pushing on the left and popping on the right",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "DequeClass",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Deque Class",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:DoubleEnd",
      "description": {
        "fct-descr": "\u003cp\u003eThis end of the queue supports both push and pop.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#DoubleEnd",
        "fct-type": "data",
        "title": "DoubleEnd"
      },
      "index": {
        "description": "This end of the queue supports both push and pop",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "DoubleEnd",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Double End",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:Dup",
      "description": {
        "fct-descr": "\u003cp\u003ePop operations may possibly duplicate elements.  Hopefully with low probability!\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#Dup",
        "fct-type": "data",
        "title": "Dup"
      },
      "index": {
        "description": "Pop operations may possibly duplicate elements Hopefully with low probability",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Dup",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Dup",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:Grow",
      "description": {
        "fct-descr": "\u003cp\u003eThe queue can grow as elements are added.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#Grow",
        "fct-type": "data",
        "title": "Grow"
      },
      "index": {
        "description": "The queue can grow as elements are added",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Grow",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Grow",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:NT",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "type",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#NT",
        "fct-type": "type",
        "title": "NT"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "NT",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "NT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:Nonthreadsafe",
      "description": {
        "fct-descr": "\u003cp\u003eOnly one thread at a time may access this end of the queue.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#Nonthreadsafe",
        "fct-type": "data",
        "title": "Nonthreadsafe"
      },
      "index": {
        "description": "Only one thread at time may access this end of the queue",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Nonthreadsafe",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Nonthreadsafe",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:PopL",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "class",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#PopL",
        "fct-type": "class",
        "title": "PopL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "PopL",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Pop",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:PushR",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "class",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#PushR",
        "fct-type": "class",
        "title": "PushR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "PushR",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Push",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:Queue",
      "description": {
        "fct-descr": "\u003cp\u003eA traditional single-threaded, single-ended queue.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "type",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#Queue",
        "fct-type": "type",
        "title": "Queue"
      },
      "index": {
        "description": "traditional single-threaded single-ended queue",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Queue",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:S",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "type",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#S",
        "fct-type": "type",
        "title": "S"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "S",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:Safe",
      "description": {
        "fct-descr": "\u003cp\u003eThe queue will not duplicate elements.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#Safe",
        "fct-type": "data",
        "title": "Safe"
      },
      "index": {
        "description": "The queue will not duplicate elements",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Safe",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Safe",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:SingleEnd",
      "description": {
        "fct-descr": "\u003cp\u003eThis end of the queue provides push-only (left) or pop-only\n   (right) functionality. Thus a \u003ccode\u003e\u003ca\u003eSingleEnd\u003c/a\u003e\u003c/code\u003e / \u003ccode\u003e\u003ca\u003eSingleEnd\u003c/a\u003e\u003c/code\u003e combination\n   is what is commonly referred to as a \u003cem\u003esingle ended queue\u003c/em\u003e, whereas\n   \u003ccode\u003e\u003ca\u003eDoubleEnd\u003c/a\u003e\u003c/code\u003e / \u003ccode\u003e\u003ca\u003eDoubleEnd\u003c/a\u003e\u003c/code\u003e is \n   a \u003cem\u003edouble ended queue\u003c/em\u003e.  Heterogeneous combinations are sometimes\n   colloquially referred to as \"1.5 ended queues\".\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#SingleEnd",
        "fct-type": "data",
        "title": "SingleEnd"
      },
      "index": {
        "description": "This end of the queue provides push-only left or pop-only right functionality Thus SingleEnd SingleEnd combination is what is commonly referred to as single ended queue whereas DoubleEnd DoubleEnd is double ended queue Heterogeneous combinations are sometimes colloquially referred to as ended queues",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "SingleEnd",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Single End",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:T",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "type",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#T",
        "fct-type": "type",
        "title": "T"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "T",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:Threadsafe",
      "description": {
        "fct-descr": "\u003cp\u003eHaskell IO threads (\u003ca\u003eControl.Concurrent\u003c/a\u003e) may concurrently access\n   this end of the queue.  Note that this attribute is set\n   separately for the left and right ends.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#Threadsafe",
        "fct-type": "data",
        "title": "Threadsafe"
      },
      "index": {
        "description": "Haskell IO threads Control.Concurrent may concurrently access this end of the queue Note that this attribute is set separately for the left and right ends",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "Threadsafe",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Threadsafe",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#t:WSDeque",
      "description": {
        "fct-descr": "\u003cp\u003eWork-stealing deques (1.5 ended).  Typically the worker pushes\n   and pops its own queue (left) whereas thieves only pop (right).\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "type",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#WSDeque",
        "fct-type": "type",
        "title": "WSDeque"
      },
      "index": {
        "description": "Work-stealing deques ended Typically the worker pushes and pops its own queue left whereas thieves only pop right",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "WSDeque",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "WSDeque",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:leftThreadSafe",
      "description": {
        "fct-descr": "\u003cp\u003eRuntime indication of thread saftey for \u003ccode\u003e\u003ca\u003epushL\u003c/a\u003e\u003c/code\u003e (and \u003ccode\u003epopL\u003c/code\u003e).\n (Argument unused.)            \n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e Bool",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#leftThreadSafe",
        "fct-type": "method",
        "title": "leftThreadSafe"
      },
      "index": {
        "description": "Runtime indication of thread saftey for pushL and popL Argument unused",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "leftThreadSafe",
        "normalized": "a b-\u003eBool",
        "package": "abstract-deque",
        "partial": "Thread Safe",
        "signature": "d elt-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:newBoundedQ",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new, bounded deque with a specified capacity.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "Int -\u003e IO (d elt)",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#newBoundedQ",
        "fct-type": "method",
        "title": "newBoundedQ"
      },
      "index": {
        "description": "Create new bounded deque with specified capacity",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "newBoundedQ",
        "normalized": "Int-\u003eIO(a b)",
        "package": "abstract-deque",
        "partial": "Bounded",
        "signature": "Int-\u003eIO(d elt)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:newQ",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new deque.  Most appropriate for unbounded deques.\n   If bounded, the size is unspecified.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "IO (d elt)",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#newQ",
        "fct-type": "method",
        "title": "newQ"
      },
      "index": {
        "description": "Create new deque Most appropriate for unbounded deques If bounded the size is unspecified",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "newQ",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:nullQ",
      "description": {
        "fct-descr": "\u003cp\u003eIs the queue currently empty?  Beware that this can be a highly transient state.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e IO Bool",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#nullQ",
        "fct-type": "method",
        "title": "nullQ"
      },
      "index": {
        "description": "Is the queue currently empty Beware that this can be highly transient state",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "nullQ",
        "normalized": "a b-\u003eIO Bool",
        "package": "abstract-deque",
        "partial": "",
        "signature": "d elt-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:pushL",
      "description": {
        "fct-descr": "\u003cp\u003eNatural push: push onto the left end of the deque.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e elt -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#pushL",
        "fct-type": "method",
        "title": "pushL"
      },
      "index": {
        "description": "Natural push push onto the left end of the deque",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "pushL",
        "normalized": "a b-\u003eb-\u003eIO()",
        "package": "abstract-deque",
        "partial": "",
        "signature": "d elt-\u003eelt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:pushR",
      "description": {
        "fct-descr": "\u003cp\u003ePushing is not the native operation for the right end, so it requires\n   that end be a \u003ccode\u003e\u003ca\u003eDoubleEnd\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e elt -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#pushR",
        "fct-type": "method",
        "title": "pushR"
      },
      "index": {
        "description": "Pushing is not the native operation for the right end so it requires that end be DoubleEnd",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "pushR",
        "normalized": "a b-\u003eb-\u003eIO()",
        "package": "abstract-deque",
        "partial": "",
        "signature": "d elt-\u003eelt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:rightThreadSafe",
      "description": {
        "fct-descr": "\u003cp\u003eRuntime indication of thread saftey for \u003ccode\u003e\u003ca\u003etryPopR\u003c/a\u003e\u003c/code\u003e (and \u003ccode\u003e\u003ca\u003epushR\u003c/a\u003e\u003c/code\u003e).\n (Argument unused.) \n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e Bool",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#rightThreadSafe",
        "fct-type": "method",
        "title": "rightThreadSafe"
      },
      "index": {
        "description": "Runtime indication of thread saftey for tryPopR and pushR Argument unused",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "rightThreadSafe",
        "normalized": "a b-\u003eBool",
        "package": "abstract-deque",
        "partial": "Thread Safe",
        "signature": "d elt-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:tryPopL",
      "description": {
        "fct-descr": "\u003cp\u003ePopL is not the native operation for the left end, so it requires\n   that the left end be a \u003ccode\u003e\u003ca\u003eDoubleEnd\u003c/a\u003e\u003c/code\u003e, but places no other requirements\n   on the input queue.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e IO (Maybe elt)",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#tryPopL",
        "fct-type": "method",
        "title": "tryPopL"
      },
      "index": {
        "description": "PopL is not the native operation for the left end so it requires that the left end be DoubleEnd but places no other requirements on the input queue",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "tryPopL",
        "normalized": "a b-\u003eIO(Maybe b)",
        "package": "abstract-deque",
        "partial": "Pop",
        "signature": "d elt-\u003eIO(Maybe elt)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:tryPopR",
      "description": {
        "fct-descr": "\u003cp\u003eNatural pop: pop from the right end of the deque.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e IO (Maybe elt)",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#tryPopR",
        "fct-type": "method",
        "title": "tryPopR"
      },
      "index": {
        "description": "Natural pop pop from the right end of the deque",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "tryPopR",
        "normalized": "a b-\u003eIO(Maybe b)",
        "package": "abstract-deque",
        "partial": "Pop",
        "signature": "d elt-\u003eIO(Maybe elt)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:tryPushL",
      "description": {
        "fct-descr": "\u003cp\u003eFor a bounded deque, pushing may fail if the deque is full.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e elt -\u003e IO Bool",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#tryPushL",
        "fct-type": "method",
        "title": "tryPushL"
      },
      "index": {
        "description": "For bounded deque pushing may fail if the deque is full",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "tryPushL",
        "normalized": "a b-\u003eb-\u003eIO Bool",
        "package": "abstract-deque",
        "partial": "Push",
        "signature": "d elt-\u003eelt-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Class.html#v:tryPushR",
      "description": {
        "fct-descr": "\u003cp\u003eFor a bounded deque, pushing may fail if the deque is full.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Class",
        "fct-package": "abstract-deque",
        "fct-signature": "d elt -\u003e elt -\u003e IO Bool",
        "fct-source": "src/Data-Concurrent-Deque-Class.html#tryPushR",
        "fct-type": "method",
        "title": "tryPushR"
      },
      "index": {
        "description": "For bounded deque pushing may fail if the deque is full",
        "hierarchy": "Data Concurrent Deque Class",
        "module": "Data.Concurrent.Deque.Class",
        "name": "tryPushR",
        "normalized": "a b-\u003eb-\u003eIO Bool",
        "package": "abstract-deque",
        "partial": "Push",
        "signature": "d elt-\u003eelt-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Debugger.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides a wrapper around a deque that can enforce additional\n invariants at runtime for debugging purposes.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Concurrent.Deque.Debugger",
        "fct-package": "abstract-deque",
        "fct-signature": "module",
        "fct-source": "src/Data-Concurrent-Deque-Debugger.html",
        "fct-type": "module",
        "title": "Debugger"
      },
      "index": {
        "description": "This module provides wrapper around deque that can enforce additional invariants at runtime for debugging purposes",
        "hierarchy": "Data Concurrent Deque Debugger",
        "module": "Data.Concurrent.Deque.Debugger",
        "name": "Debugger",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Debugger",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Debugger.html#t:DebugDeque",
      "description": {
        "fct-descr": "\u003cp\u003eWarning, this enforces the excessively STRONG invariant that if any end of the\n deque is non-threadsafe then it may ever only be touched by one thread during its\n entire lifetime.\n\u003c/p\u003e\u003cp\u003eThis extreme form of monagamy is easier to verify, because we don't have enough\n information to know if two operations on different threads are racing with one\n another or are properly synchronized.\n\u003c/p\u003e\u003cp\u003eThe wrapper data structure has two IORefs to track the last thread that touched\n the left and right end of the deque, respectively.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Debugger",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Debugger.html#DebugDeque",
        "fct-type": "data",
        "title": "DebugDeque"
      },
      "index": {
        "description": "Warning this enforces the excessively STRONG invariant that if any end of the deque is non-threadsafe then it may ever only be touched by one thread during its entire lifetime This extreme form of monagamy is easier to verify because we don have enough information to know if two operations on different threads are racing with one another or are properly synchronized The wrapper data structure has two IORefs to track the last thread that touched the left and right end of the deque respectively",
        "hierarchy": "Data Concurrent Deque Debugger",
        "module": "Data.Concurrent.Deque.Debugger",
        "name": "DebugDeque",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Debug Deque",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Debugger.html#v:DebugDeque",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Debugger",
        "fct-package": "abstract-deque",
        "fct-signature": "DebugDeque (IORef (Maybe ThreadId), IORef (Maybe ThreadId)) (d elt)",
        "fct-source": "src/Data-Concurrent-Deque-Debugger.html#DebugDeque",
        "fct-type": "function",
        "title": "DebugDeque"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Debugger",
        "module": "Data.Concurrent.Deque.Debugger",
        "name": "DebugDeque",
        "normalized": "DebugDeque(IORef(Maybe ThreadId),IORef(Maybe ThreadId))(a b)",
        "package": "abstract-deque",
        "partial": "Debug Deque",
        "signature": "DebugDeque(IORef(Maybe ThreadId),IORef(Maybe ThreadId))(d elt)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference-DequeInstance.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBy convention, every provider of the \u003ca\u003eData.Concurrent.Deque.Class\u003c/a\u003e\n  interface optionally provides a module that provides the relevant\n  instances of the \u003ccode\u003e\u003ca\u003eDeque\u003c/a\u003e\u003c/code\u003e type class, covering the [maximum] portion\n  of the configuration space that the implementation is able to\n  handle.\n\u003c/p\u003e\u003cp\u003eThis is kept in a separate package because importing instances is\n  unconditional and the user may well want to assemble their own\n  combination of \u003ccode\u003e\u003ca\u003eDeque\u003c/a\u003e\u003c/code\u003e instances to cover the configuration\n  space.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Concurrent.Deque.Reference.DequeInstance",
        "fct-package": "abstract-deque",
        "fct-signature": "module",
        "fct-source": "src/Data-Concurrent-Deque-Reference-DequeInstance.html",
        "fct-type": "module",
        "title": "DequeInstance"
      },
      "index": {
        "description": "By convention every provider of the Data.Concurrent.Deque.Class interface optionally provides module that provides the relevant instances of the Deque type class covering the maximum portion of the configuration space that the implementation is able to handle This is kept in separate package because importing instances is unconditional and the user may well want to assemble their own combination of Deque instances to cover the configuration space",
        "hierarchy": "Data Concurrent Deque Reference DequeInstance",
        "module": "Data.Concurrent.Deque.Reference.DequeInstance",
        "name": "DequeInstance",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Deque Instance",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA strawman implementation of concurrent Dequeues.  This\n  implementation is so simple that it also makes a good reference\n  implementation for debugging.\n\u003c/p\u003e\u003cp\u003eThe queue representation is simply an IORef containing a Data.Sequence.\n\u003c/p\u003e\u003cp\u003eAlso see \u003ca\u003eData.Concurrent.Deque.Reference.DequeInstance\u003c/a\u003e.\n  By convention a module of this name is also provided.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "module",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html",
        "fct-type": "module",
        "title": "Reference"
      },
      "index": {
        "description": "strawman implementation of concurrent Dequeues This implementation is so simple that it also makes good reference implementation for debugging The queue representation is simply an IORef containing Data.Sequence Also see Data.Concurrent.Deque.Reference.DequeInstance By convention module of this name is also provided",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "Reference",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Reference",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#t:SimpleDeque",
      "description": {
        "fct-descr": "\u003cp\u003eStores a size bound (if any) as well as a mutable Seq.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "data",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#SimpleDeque",
        "fct-type": "data",
        "title": "SimpleDeque"
      },
      "index": {
        "description": "Stores size bound if any as well as mutable Seq",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "SimpleDeque",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Simple Deque",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:DQ",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "DQ !Int !(IORef (Seq elt))",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#SimpleDeque",
        "fct-type": "function",
        "title": "DQ"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "DQ",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "DQ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:_is_using_CAS",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "Bool",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#_is_using_CAS",
        "fct-type": "function",
        "title": "_is_using_CAS"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "_is_using_CAS",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "CAS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:newBoundedQ",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "Int -\u003e IO (SimpleDeque elt)",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#newBoundedQ",
        "fct-type": "function",
        "title": "newBoundedQ"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "newBoundedQ",
        "normalized": "Int-\u003eIO(SimpleDeque a)",
        "package": "abstract-deque",
        "partial": "Bounded",
        "signature": "Int-\u003eIO(SimpleDeque elt)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:newQ",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "IO (SimpleDeque elt)",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#newQ",
        "fct-type": "function",
        "title": "newQ"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "newQ",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:nullQ",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "SimpleDeque elt -\u003e IO Bool",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#nullQ",
        "fct-type": "function",
        "title": "nullQ"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "nullQ",
        "normalized": "SimpleDeque a-\u003eIO Bool",
        "package": "abstract-deque",
        "partial": "",
        "signature": "SimpleDeque elt-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:pushL",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "SimpleDeque t -\u003e t -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#pushL",
        "fct-type": "function",
        "title": "pushL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "pushL",
        "normalized": "SimpleDeque a-\u003ea-\u003eIO()",
        "package": "abstract-deque",
        "partial": "",
        "signature": "SimpleDeque t-\u003et-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:pushR",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "SimpleDeque t -\u003e t -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#pushR",
        "fct-type": "function",
        "title": "pushR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "pushR",
        "normalized": "SimpleDeque a-\u003ea-\u003eIO()",
        "package": "abstract-deque",
        "partial": "",
        "signature": "SimpleDeque t-\u003et-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:tryPopL",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "SimpleDeque a -\u003e IO (Maybe a)",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#tryPopL",
        "fct-type": "function",
        "title": "tryPopL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "tryPopL",
        "normalized": "SimpleDeque a-\u003eIO(Maybe a)",
        "package": "abstract-deque",
        "partial": "Pop",
        "signature": "SimpleDeque a-\u003eIO(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:tryPopR",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "SimpleDeque a -\u003e IO (Maybe a)",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#tryPopR",
        "fct-type": "function",
        "title": "tryPopR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "tryPopR",
        "normalized": "SimpleDeque a-\u003eIO(Maybe a)",
        "package": "abstract-deque",
        "partial": "Pop",
        "signature": "SimpleDeque a-\u003eIO(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:tryPushL",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "SimpleDeque a -\u003e a -\u003e IO Bool",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#tryPushL",
        "fct-type": "function",
        "title": "tryPushL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "tryPushL",
        "normalized": "SimpleDeque a-\u003ea-\u003eIO Bool",
        "package": "abstract-deque",
        "partial": "Push",
        "signature": "SimpleDeque a-\u003ea-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Reference.html#v:tryPushR",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Reference",
        "fct-package": "abstract-deque",
        "fct-signature": "SimpleDeque a -\u003e a -\u003e IO Bool",
        "fct-source": "src/Data-Concurrent-Deque-Reference.html#tryPushR",
        "fct-type": "function",
        "title": "tryPushR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Reference",
        "module": "Data.Concurrent.Deque.Reference",
        "name": "tryPushR",
        "normalized": "SimpleDeque a-\u003ea-\u003eIO Bool",
        "package": "abstract-deque",
        "partial": "Push",
        "signature": "SimpleDeque a-\u003ea-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a battery of simple tests for queues\n   implementing the interface defined in\n ` Data.Concurrent.Deque.Class`.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "module",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html",
        "fct-type": "module",
        "title": "Tests"
      },
      "index": {
        "description": "This module contains battery of simple tests for queues implementing the interface defined in Data.Concurrent.Deque.Class",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "Tests",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Tests",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:getNumAgents",
      "description": {
        "fct-descr": "\u003cp\u003eHow many communicating agents are there?  By default one per\n thread used by the RTS.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "IO Int",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#getNumAgents",
        "fct-type": "function",
        "title": "getNumAgents"
      },
      "index": {
        "description": "How many communicating agents are there By default one per thread used by the RTS",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "getNumAgents",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Num Agents",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:numElems",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "Int",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#numElems",
        "fct-type": "function",
        "title": "numElems"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "numElems",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Elems",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:producerRatio",
      "description": {
        "fct-descr": "\u003cp\u003eIt is possible to have imbalanced concurrency where there is more\n contention on the producing or consuming side (which corresponds to\n settings of this parameter less than or greater than 1).\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "Double",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#producerRatio",
        "fct-type": "function",
        "title": "producerRatio"
      },
      "index": {
        "description": "It is possible to have imbalanced concurrency where there is more contention on the producing or consuming side which corresponds to settings of this parameter less than or greater than",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "producerRatio",
        "normalized": "",
        "package": "abstract-deque",
        "partial": "Ratio",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:setTestThreads",
      "description": {
        "fct-descr": "\u003cp\u003eDig through the test constructors to find the leaf IO actions and bracket them\n   with a thread-setting action.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "Int -\u003e Test -\u003e Test",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#setTestThreads",
        "fct-type": "function",
        "title": "setTestThreads"
      },
      "index": {
        "description": "Dig through the test constructors to find the leaf IO actions and bracket them with thread-setting action",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "setTestThreads",
        "normalized": "Int-\u003eTest-\u003eTest",
        "package": "abstract-deque",
        "partial": "Test Threads",
        "signature": "Int-\u003eTest-\u003eTest"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:stdTestHarness",
      "description": {
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "IO Test -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#stdTestHarness",
        "fct-type": "function",
        "title": "stdTestHarness"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "stdTestHarness",
        "normalized": "IO Test-\u003eIO()",
        "package": "abstract-deque",
        "partial": "Test Harness",
        "signature": "IO Test-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:test_fifo_OneBottleneck",
      "description": {
        "fct-descr": "\u003cp\u003eThis test splits the \u003ccode\u003enumAgents\u003c/code\u003e threads into producers and\n consumers which all communicate through a SINGLE queue.  Each\n thread performs its designated operation as fast as possible.  The\n \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e argument \u003ccode\u003etotal\u003c/code\u003e designates how many total items should be\n communicated (irrespective of \u003ccode\u003enumAgents\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "Bool -\u003e Int -\u003e d Elt -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#test_fifo_OneBottleneck",
        "fct-type": "function",
        "title": "test_fifo_OneBottleneck"
      },
      "index": {
        "description": "This test splits the numAgents threads into producers and consumers which all communicate through SINGLE queue Each thread performs its designated operation as fast as possible The Int argument total designates how many total items should be communicated irrespective of numAgents",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "test_fifo_OneBottleneck",
        "normalized": "Bool-\u003eInt-\u003ea Elt-\u003eIO()",
        "package": "abstract-deque",
        "partial": "One Bottleneck",
        "signature": "Bool-\u003eInt-\u003ed Elt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:test_fifo_filldrain",
      "description": {
        "fct-descr": "\u003cp\u003eThis test serially fills up a queue and then drains it.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "d Elt -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#test_fifo_filldrain",
        "fct-type": "function",
        "title": "test_fifo_filldrain"
      },
      "index": {
        "description": "This test serially fills up queue and then drains it",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "test_fifo_filldrain",
        "normalized": "a Elt-\u003eIO()",
        "package": "abstract-deque",
        "partial": "",
        "signature": "d Elt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:test_ws_triv1",
      "description": {
        "fct-descr": "\u003cp\u003eTrivial test: push then pop.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "d [Char] -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#test_ws_triv1",
        "fct-type": "function",
        "title": "test_ws_triv1"
      },
      "index": {
        "description": "Trivial test push then pop",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "test_ws_triv1",
        "normalized": "a[Char]-\u003eIO()",
        "package": "abstract-deque",
        "partial": "",
        "signature": "d[Char]-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:test_ws_triv2",
      "description": {
        "fct-descr": "\u003cp\u003eTrivial test: push left, pop left and right.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "d [Char] -\u003e IO ()",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#test_ws_triv2",
        "fct-type": "function",
        "title": "test_ws_triv2"
      },
      "index": {
        "description": "Trivial test push left pop left and right",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "test_ws_triv2",
        "normalized": "a[Char]-\u003eIO()",
        "package": "abstract-deque",
        "partial": "",
        "signature": "d[Char]-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:tests_all",
      "description": {
        "fct-descr": "\u003cp\u003eThis requires double ended queues that are threadsafe on BOTH ends.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "(forall elt.  IO (d elt)) -\u003e Test",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#tests_all",
        "fct-type": "function",
        "title": "tests_all"
      },
      "index": {
        "description": "This requires double ended queues that are threadsafe on BOTH ends",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "tests_all",
        "normalized": "(a b IO(c d))-\u003eTest",
        "package": "abstract-deque",
        "partial": "",
        "signature": "(forall elt. IO(d elt))-\u003eTest"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:tests_fifo",
      "description": {
        "fct-descr": "\u003cp\u003eThis creates an HUnit test list to perform all the tests that apply to a\n   single-ended (threadsafe) queue.  It requires thread safety at \u003cem\u003eboth\u003c/em\u003e ends.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "(forall elt.  IO (d elt)) -\u003e Test",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#tests_fifo",
        "fct-type": "function",
        "title": "tests_fifo"
      },
      "index": {
        "description": "This creates an HUnit test list to perform all the tests that apply to single-ended threadsafe queue It requires thread safety at both ends",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "tests_fifo",
        "normalized": "(a b IO(c d))-\u003eTest",
        "package": "abstract-deque",
        "partial": "",
        "signature": "(forall elt. IO(d elt))-\u003eTest"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/abstract-deque/docs/Data-Concurrent-Deque-Tests.html#v:tests_wsqueue",
      "description": {
        "fct-descr": "\u003cp\u003eAggregate tests for work stealing queues.  None of these require thread-safety\n on the left end.  There is some duplication with tests_fifo.\n\u003c/p\u003e",
        "fct-module": "Data.Concurrent.Deque.Tests",
        "fct-package": "abstract-deque",
        "fct-signature": "(forall elt.  IO (d elt)) -\u003e Test",
        "fct-source": "src/Data-Concurrent-Deque-Tests.html#tests_wsqueue",
        "fct-type": "function",
        "title": "tests_wsqueue"
      },
      "index": {
        "description": "Aggregate tests for work stealing queues None of these require thread-safety on the left end There is some duplication with tests fifo",
        "hierarchy": "Data Concurrent Deque Tests",
        "module": "Data.Concurrent.Deque.Tests",
        "name": "tests_wsqueue",
        "normalized": "(a b IO(c d))-\u003eTest",
        "package": "abstract-deque",
        "partial": "",
        "signature": "(forall elt. IO(d elt))-\u003eTest"
      }
    }
  }
]
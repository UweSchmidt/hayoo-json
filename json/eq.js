[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLeibnizian equality. Injectivity in the presence of type families\n is provided by a generalization of a trick by Oleg Kiselyv posted here:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.haskell.org/pipermail/haskell-cafe/2010-May/077177.html\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "module",
        "fct-source": "src/Data-Eq-Type.html",
        "fct-type": "module",
        "title": "Type"
      },
      "index": {
        "description": "Leibnizian equality Injectivity in the presence of type families is provided by generalization of trick by Oleg Kiselyv posted here http www.haskell.org pipermail haskell-cafe May html",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "Type",
        "normalized": "",
        "package": "eq",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#t::-61-",
      "description": {
        "fct-descr": "\u003cp\u003eLeibnizian equality states that two things are equal if you can\n substite one for the other in all contexts\n\u003c/p\u003e",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "data",
        "fct-source": "src/Data-Eq-Type.html#%3A%3D",
        "fct-type": "data",
        "title": ":="
      },
      "index": {
        "description": "Leibnizian equality states that two things are equal if you can substite one for the other in all contexts",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": ":=",
        "normalized": "",
        "package": "eq",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:Refl",
      "description": {
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "Refl",
        "fct-source": "src/Data-Eq-Type.html#%3A%3D",
        "fct-type": "function",
        "title": "Refl"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "Refl",
        "normalized": "",
        "package": "eq",
        "partial": "Refl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:coerce",
      "description": {
        "fct-descr": "\u003cp\u003eIf two things are equal you can convert one to the other\n\u003c/p\u003e",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "(a := b) -\u003e a -\u003e b",
        "fct-source": "src/Data-Eq-Type.html#coerce",
        "fct-type": "function",
        "title": "coerce"
      },
      "index": {
        "description": "If two things are equal you can convert one to the other",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "coerce",
        "normalized": "(a b)-\u003ea-\u003eb",
        "package": "eq",
        "partial": "",
        "signature": "(a b)-\u003ea-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:lift",
      "description": {
        "fct-descr": "\u003cp\u003eYou can lift equality into any type constructor\n\u003c/p\u003e",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "(a := b) -\u003e f a := f b",
        "fct-source": "src/Data-Eq-Type.html#lift",
        "fct-type": "function",
        "title": "lift"
      },
      "index": {
        "description": "You can lift equality into any type constructor",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "lift",
        "normalized": "(a b)-\u003ec a c b",
        "package": "eq",
        "partial": "",
        "signature": "(a b)-\u003ef a f b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:lift2",
      "description": {
        "fct-descr": "\u003cp\u003e... in any position\n\u003c/p\u003e",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "(a := b) -\u003e f a c := f b c",
        "fct-source": "src/Data-Eq-Type.html#lift2",
        "fct-type": "function",
        "title": "lift2"
      },
      "index": {
        "description": "in any position",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "lift2",
        "normalized": "(a b)-\u003ec a d c b d",
        "package": "eq",
        "partial": "",
        "signature": "(a b)-\u003ef a c f b c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:lift2-39-",
      "description": {
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "(a := b) -\u003e (c := d) -\u003e f a c := f b d",
        "fct-source": "src/Data-Eq-Type.html#lift2%27",
        "fct-type": "function",
        "title": "lift2'"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "lift2'",
        "normalized": "(a b)-\u003e(c d)-\u003ee a c e b d",
        "package": "eq",
        "partial": "",
        "signature": "(a b)-\u003e(c d)-\u003ef a c f b d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:lift3",
      "description": {
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "(a := b) -\u003e f a c d := f b c d",
        "fct-source": "src/Data-Eq-Type.html#lift3",
        "fct-type": "function",
        "title": "lift3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "lift3",
        "normalized": "(a b)-\u003ec a d e c b d e",
        "package": "eq",
        "partial": "",
        "signature": "(a b)-\u003ef a c d f b c d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:lift3-39-",
      "description": {
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "(a := b) -\u003e (c := d) -\u003e (e := f) -\u003e g a c e := g b d f",
        "fct-source": "src/Data-Eq-Type.html#lift3%27",
        "fct-type": "function",
        "title": "lift3'"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "lift3'",
        "normalized": "(a b)-\u003e(c d)-\u003e(e f)-\u003eg a c e g b d f",
        "package": "eq",
        "partial": "",
        "signature": "(a b)-\u003e(c d)-\u003e(e f)-\u003eg a c e g b d f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:refl",
      "description": {
        "fct-descr": "\u003cp\u003eEquality is reflexive\n\u003c/p\u003e",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "a := a",
        "fct-source": "src/Data-Eq-Type.html#refl",
        "fct-type": "function",
        "title": "refl"
      },
      "index": {
        "description": "Equality is reflexive",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "refl",
        "normalized": "",
        "package": "eq",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:subst",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "forall c.  c a -\u003e c b",
        "fct-source": "src/Data-Eq-Type.html#%3A%3D",
        "fct-type": "function",
        "title": "subst"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "subst",
        "normalized": "a b c d-\u003ec e",
        "package": "eq",
        "partial": "",
        "signature": "forall c. c a-\u003ec b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:symm",
      "description": {
        "fct-descr": "\u003cp\u003eEquality is symmetric\n\u003c/p\u003e",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "(a := b) -\u003e b := a",
        "fct-source": "src/Data-Eq-Type.html#symm",
        "fct-type": "function",
        "title": "symm"
      },
      "index": {
        "description": "Equality is symmetric",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "symm",
        "normalized": "(a b)-\u003eb a",
        "package": "eq",
        "partial": "",
        "signature": "(a b)-\u003eb a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/eq/docs/Data-Eq-Type.html#v:trans",
      "description": {
        "fct-descr": "\u003cp\u003eEquality is transitive\n\u003c/p\u003e",
        "fct-module": "Data.Eq.Type",
        "fct-package": "eq",
        "fct-signature": "(a := b) -\u003e (b := c) -\u003e a := c",
        "fct-source": "src/Data-Eq-Type.html#trans",
        "fct-type": "function",
        "title": "trans"
      },
      "index": {
        "description": "Equality is transitive",
        "hierarchy": "Data Eq Type",
        "module": "Data.Eq.Type",
        "name": "trans",
        "normalized": "(a b)-\u003e(b c)-\u003ea c",
        "package": "eq",
        "partial": "",
        "signature": "(a b)-\u003e(b c)-\u003ea c"
      }
    }
  }
]
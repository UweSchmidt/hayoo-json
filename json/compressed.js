[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompression algorithms are all about exploiting redundancy. When applying\n an expensive \u003ccode\u003e\u003ca\u003eReducer\u003c/a\u003e\u003c/code\u003e to a redundant source, it may be better to\n extract the structural redundancy that is present. \u003ccode\u003e\u003ca\u003eLZ78\u003c/a\u003e\u003c/code\u003e is a compression\n algorithm that does so, without requiring the dictionary to be populated\n with all of the possible values of a data type unlike its later\n refinement LZW, and which has fewer comparison reqirements during encoding\n than its earlier counterpart LZ77.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "module",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html",
        "fct-type": "module",
        "title": "LZ78"
      },
      "index": {
        "description": "Compression algorithms are all about exploiting redundancy When applying an expensive Reducer to redundant source it may be better to extract the structural redundancy that is present LZ78 is compression algorithm that does so without requiring the dictionary to be populated with all of the possible values of data type unlike its later refinement LZW and which has fewer comparison reqirements during encoding than its earlier counterpart LZ77",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "LZ78",
        "normalized": "",
        "package": "compressed",
        "partial": "LZ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#t:Entry",
      "description": {
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "data",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#Entry",
        "fct-type": "data",
        "title": "Entry"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "Entry",
        "normalized": "",
        "package": "compressed",
        "partial": "Entry",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#t:LZ78",
      "description": {
        "fct-descr": "\u003cp\u003eAn LZ78 compressed \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "data",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#LZ78",
        "fct-type": "data",
        "title": "LZ78"
      },
      "index": {
        "description": "An LZ78 compressed Generator",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "LZ78",
        "normalized": "",
        "package": "compressed",
        "partial": "LZ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#t:Token",
      "description": {
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "data",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#Token",
        "fct-type": "data",
        "title": "Token"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "Token",
        "normalized": "",
        "package": "compressed",
        "partial": "Token",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:Cons",
      "description": {
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "Cons !(Token a) (LZ78 a)",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#LZ78",
        "fct-type": "function",
        "title": "Cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "Cons",
        "normalized": "",
        "package": "compressed",
        "partial": "Cons",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:Entry",
      "description": {
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "Entry !i a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#Entry",
        "fct-type": "function",
        "title": "Entry"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "Entry",
        "normalized": "",
        "package": "compressed",
        "partial": "Entry",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:Nil",
      "description": {
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "Nil",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#LZ78",
        "fct-type": "function",
        "title": "Nil"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "Nil",
        "normalized": "",
        "package": "compressed",
        "partial": "Nil",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:Token",
      "description": {
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "Token !Int a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#Token",
        "fct-type": "function",
        "title": "Token"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "Token",
        "normalized": "",
        "package": "compressed",
        "partial": "Token",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eA type-constrained \u003ccode\u003e\u003ca\u003ereduce\u003c/a\u003e\u003c/code\u003e operation\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e [a]",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "type-constrained reduce operation",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "decode",
        "normalized": "LZ a-\u003e[a]",
        "package": "compressed",
        "partial": "",
        "signature": "LZ a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct an LZ78-compressed \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e using a \u003ccode\u003eHashMap\u003c/code\u003e internally.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "[a] -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Construct an LZ78-compressed Generator using HashMap internally",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "encode",
        "normalized": "[a]-\u003eLZ a",
        "package": "compressed",
        "partial": "",
        "signature": "[a]-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:encodeEq",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n^2)\u003c/em\u003e Contruct an LZ78-compressed \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e using a list internally, requires an instance of Eq,\n less efficient than encode.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "[a] -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#encodeEq",
        "fct-type": "function",
        "title": "encodeEq"
      },
      "index": {
        "description": "Contruct an LZ78-compressed Generator using list internally requires an instance of Eq less efficient than encode",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "encodeEq",
        "normalized": "[a]-\u003eLZ a",
        "package": "compressed",
        "partial": "Eq",
        "signature": "[a]-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:encodeOrd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e Contruct an LZ78-compressed \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e using a \u003ccode\u003eMap\u003c/code\u003e internally.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "[a] -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#encodeOrd",
        "fct-type": "function",
        "title": "encodeOrd"
      },
      "index": {
        "description": "log Contruct an LZ78-compressed Generator using Map internally",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "encodeOrd",
        "normalized": "[a]-\u003eLZ a",
        "package": "compressed",
        "partial": "Ord",
        "signature": "[a]-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:entries",
      "description": {
        "fct-descr": "\u003cp\u003eexposes internal structure\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e LZ78 (Entry Int a)",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#entries",
        "fct-type": "function",
        "title": "entries"
      },
      "index": {
        "description": "exposes internal structure",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "entries",
        "normalized": "LZ a-\u003eLZ(Entry Int a)",
        "package": "compressed",
        "partial": "",
        "signature": "LZ a-\u003eLZ(Entry Int a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:recode",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Recompress with \u003ccode\u003e\u003ca\u003eHashable\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#recode",
        "fct-type": "function",
        "title": "recode"
      },
      "index": {
        "description": "Recompress with Hashable",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "recode",
        "normalized": "LZ a-\u003eLZ a",
        "package": "compressed",
        "partial": "",
        "signature": "LZ a-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:recodeEq",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n^2)\u003c/em\u003e. Recompress with \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#recodeEq",
        "fct-type": "function",
        "title": "recodeEq"
      },
      "index": {
        "description": "Recompress with Eq",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "recodeEq",
        "normalized": "LZ a-\u003eLZ a",
        "package": "compressed",
        "partial": "Eq",
        "signature": "LZ a-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-Internal-LZ78.html#v:recodeOrd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e. Recompress with \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.Internal.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#recodeOrd",
        "fct-type": "function",
        "title": "recodeOrd"
      },
      "index": {
        "description": "log Recompress with Ord",
        "hierarchy": "Data Compressed Internal LZ78",
        "module": "Data.Compressed.Internal.LZ78",
        "name": "recodeOrd",
        "normalized": "LZ a-\u003eLZ a",
        "package": "compressed",
        "partial": "Ord",
        "signature": "LZ a-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompression algorithms are all about exploiting redundancy. When applying\n an expensive \u003ccode\u003eReducer\u003c/code\u003e to a redundant source, it may be better to\n extract the structural redundancy that is present. \u003ccode\u003e\u003ca\u003eLZ78\u003c/a\u003e\u003c/code\u003e is a compression\n algorithm that does so, without requiring the dictionary to be populated\n with all of the possible values of a data type unlike its later\n refinement LZW, and which has fewer comparison reqirements during encoding\n than its earlier counterpart LZ77.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "module",
        "fct-source": "src/Data-Compressed-LZ78.html",
        "fct-type": "module",
        "title": "LZ78"
      },
      "index": {
        "description": "Compression algorithms are all about exploiting redundancy When applying an expensive Reducer to redundant source it may be better to extract the structural redundancy that is present LZ78 is compression algorithm that does so without requiring the dictionary to be populated with all of the possible values of data type unlike its later refinement LZW and which has fewer comparison reqirements during encoding than its earlier counterpart LZ77",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "LZ78",
        "normalized": "",
        "package": "compressed",
        "partial": "LZ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#t:LZ78",
      "description": {
        "fct-descr": "\u003cp\u003eAn LZ78 compressed \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "data",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#LZ78",
        "fct-type": "data",
        "title": "LZ78"
      },
      "index": {
        "description": "An LZ78 compressed Generator",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "LZ78",
        "normalized": "",
        "package": "compressed",
        "partial": "LZ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eA type-constrained \u003ccode\u003e\u003ca\u003ereduce\u003c/a\u003e\u003c/code\u003e operation\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e [a]",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "type-constrained reduce operation",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "decode",
        "normalized": "LZ a-\u003e[a]",
        "package": "compressed",
        "partial": "",
        "signature": "LZ a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct an LZ78-compressed \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e using a \u003ccode\u003eHashMap\u003c/code\u003e internally.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "[a] -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Construct an LZ78-compressed Generator using HashMap internally",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "encode",
        "normalized": "[a]-\u003eLZ a",
        "package": "compressed",
        "partial": "",
        "signature": "[a]-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#v:encodeEq",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n^2)\u003c/em\u003e Contruct an LZ78-compressed \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e using a list internally, requires an instance of Eq,\n less efficient than encode.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "[a] -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#encodeEq",
        "fct-type": "function",
        "title": "encodeEq"
      },
      "index": {
        "description": "Contruct an LZ78-compressed Generator using list internally requires an instance of Eq less efficient than encode",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "encodeEq",
        "normalized": "[a]-\u003eLZ a",
        "package": "compressed",
        "partial": "Eq",
        "signature": "[a]-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#v:encodeOrd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e Contruct an LZ78-compressed \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e using a \u003ccode\u003eMap\u003c/code\u003e internally.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "[a] -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#encodeOrd",
        "fct-type": "function",
        "title": "encodeOrd"
      },
      "index": {
        "description": "log Contruct an LZ78-compressed Generator using Map internally",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "encodeOrd",
        "normalized": "[a]-\u003eLZ a",
        "package": "compressed",
        "partial": "Ord",
        "signature": "[a]-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#v:recode",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Recompress with \u003ccode\u003e\u003ca\u003eHashable\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#recode",
        "fct-type": "function",
        "title": "recode"
      },
      "index": {
        "description": "Recompress with Hashable",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "recode",
        "normalized": "LZ a-\u003eLZ a",
        "package": "compressed",
        "partial": "",
        "signature": "LZ a-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#v:recodeEq",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n^2)\u003c/em\u003e. Recompress with \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#recodeEq",
        "fct-type": "function",
        "title": "recodeEq"
      },
      "index": {
        "description": "Recompress with Eq",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "recodeEq",
        "normalized": "LZ a-\u003eLZ a",
        "package": "compressed",
        "partial": "Eq",
        "signature": "LZ a-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-LZ78.html#v:recodeOrd",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e. Recompress with \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.LZ78",
        "fct-package": "compressed",
        "fct-signature": "LZ78 a -\u003e LZ78 a",
        "fct-source": "src/Data-Compressed-Internal-LZ78.html#recodeOrd",
        "fct-type": "function",
        "title": "recodeOrd"
      },
      "index": {
        "description": "log Recompress with Ord",
        "hierarchy": "Data Compressed LZ78",
        "module": "Data.Compressed.LZ78",
        "name": "recodeOrd",
        "normalized": "LZ a-\u003eLZ a",
        "package": "compressed",
        "partial": "Ord",
        "signature": "LZ a-\u003eLZ a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompression algorithms are all about exploiting redundancy. When applying\n an expensive \u003ccode\u003e\u003ca\u003eReducer\u003c/a\u003e\u003c/code\u003e to a redundant source, it may be better to\n extract the structural redundancy that is present. Run length encoding\n can do so for long runs of identical inputs.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "module",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html",
        "fct-type": "module",
        "title": "RunLengthEncoding"
      },
      "index": {
        "description": "Compression algorithms are all about exploiting redundancy When applying an expensive Reducer to redundant source it may be better to extract the structural redundancy that is present Run length encoding can do so for long runs of identical inputs",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "RunLengthEncoding",
        "normalized": "",
        "package": "compressed",
        "partial": "Run Length Encoding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#t:RLE",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eGenerator\u003c/a\u003e\u003c/code\u003e which supports efficient \u003ccode\u003e\u003ca\u003emapReduce\u003c/a\u003e\u003c/code\u003e operations over run-length encoded data.\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#RLE",
        "fct-type": "newtype",
        "title": "RLE"
      },
      "index": {
        "description": "Generator which supports efficient mapReduce operations over run-length encoded data",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "RLE",
        "normalized": "",
        "package": "compressed",
        "partial": "RLE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#t:Run",
      "description": {
        "fct-descr": "\u003cp\u003eA single run with a strict length\n\u003c/p\u003e",
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "data",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#Run",
        "fct-type": "data",
        "title": "Run"
      },
      "index": {
        "description": "single run with strict length",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "Run",
        "normalized": "",
        "package": "compressed",
        "partial": "Run",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#v:RLE",
      "description": {
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "RLE",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#RLE",
        "fct-type": "function",
        "title": "RLE"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "RLE",
        "normalized": "",
        "package": "compressed",
        "partial": "RLE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#v:decode",
      "description": {
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "RLE a -\u003e [a]",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "decode",
        "normalized": "RLE a-\u003e[a]",
        "package": "compressed",
        "partial": "",
        "signature": "RLE a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#v:encode",
      "description": {
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "c -\u003e RLE (Elem c)",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "encode",
        "normalized": "a-\u003eRLE(Elem a)",
        "package": "compressed",
        "partial": "",
        "signature": "c-\u003eRLE(Elem c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#v:fromRuns",
      "description": {
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "[Run a] -\u003e RLE a",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#fromRuns",
        "fct-type": "function",
        "title": "fromRuns"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "fromRuns",
        "normalized": "[Run a]-\u003eRLE a",
        "package": "compressed",
        "partial": "Runs",
        "signature": "[Run a]-\u003eRLE a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#v:getRLE",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "FingerTree Count (Run a)",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#RLE",
        "fct-type": "function",
        "title": "getRLE"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "getRLE",
        "normalized": "",
        "package": "compressed",
        "partial": "RLE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#v:recode",
      "description": {
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "RLE a -\u003e RLE a",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#recode",
        "fct-type": "function",
        "title": "recode"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "recode",
        "normalized": "RLE a-\u003eRLE a",
        "package": "compressed",
        "partial": "",
        "signature": "RLE a-\u003eRLE a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#v:runLength",
      "description": {
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "Run a -\u003e Int",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#runLength",
        "fct-type": "function",
        "title": "runLength"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "runLength",
        "normalized": "Run a-\u003eInt",
        "package": "compressed",
        "partial": "Length",
        "signature": "Run a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/compressed/docs/Data-Compressed-RunLengthEncoding.html#v:toRuns",
      "description": {
        "fct-module": "Data.Compressed.RunLengthEncoding",
        "fct-package": "compressed",
        "fct-signature": "RLE a -\u003e [Run a]",
        "fct-source": "src/Data-Compressed-RunLengthEncoding.html#toRuns",
        "fct-type": "function",
        "title": "toRuns"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Compressed RunLengthEncoding",
        "module": "Data.Compressed.RunLengthEncoding",
        "name": "toRuns",
        "normalized": "RLE a-\u003e[Run a]",
        "package": "compressed",
        "partial": "Runs",
        "signature": "RLE a-\u003e[Run a]"
      }
    }
  }
]
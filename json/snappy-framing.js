[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "module",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html",
        "fct-type": "module",
        "title": "Framing"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "Framing",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Framing",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#t:Checksum",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "type",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#Checksum",
        "fct-type": "type",
        "title": "Checksum"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "Checksum",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Checksum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#t:Chunk",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "data",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#Chunk",
        "fct-type": "data",
        "title": "Chunk"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "Chunk",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Chunk",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#t:DecodeError",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "type",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#DecodeError",
        "fct-type": "type",
        "title": "DecodeError"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "DecodeError",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Decode Error",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:Compressed",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "Compressed !Checksum !ByteString",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#Chunk",
        "fct-type": "function",
        "title": "Compressed"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "Compressed",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Compressed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:Skippable",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "Skippable !Word8",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#Chunk",
        "fct-type": "function",
        "title": "Skippable"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "Skippable",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Skippable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:StreamIdentifier",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "StreamIdentifier",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#Chunk",
        "fct-type": "function",
        "title": "StreamIdentifier"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "StreamIdentifier",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Stream Identifier",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:Uncompressed",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "Uncompressed !Checksum !ByteString",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#Chunk",
        "fct-type": "function",
        "title": "Uncompressed"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "Uncompressed",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Uncompressed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:Unskippable",
      "description": {
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "Unskippable !Word8",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#Chunk",
        "fct-type": "function",
        "title": "Unskippable"
      },
      "index": {
        "description": "",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "Unskippable",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Unskippable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:checksum",
      "description": {
        "fct-descr": "\u003cp\u003eCompute a masked CRC32C checksum of the input\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "ByteString -\u003e Checksum",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#checksum",
        "fct-type": "function",
        "title": "checksum"
      },
      "index": {
        "description": "Compute masked CRC32C checksum of the input",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "checksum",
        "normalized": "ByteString-\u003eChecksum",
        "package": "snappy-framing",
        "partial": "",
        "signature": "ByteString-\u003eChecksum"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "ByteString -\u003e (Either DecodeError Chunk, Maybe ByteString)",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "Decode lazy ByteString into Chunk",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "decode",
        "normalized": "ByteString-\u003e(Either DecodeError Chunk,Maybe ByteString)",
        "package": "snappy-framing",
        "partial": "",
        "signature": "ByteString-\u003e(Either DecodeError Chunk,Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:decode-39-",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "ByteString -\u003e (Either DecodeError Chunk, Maybe ByteString)",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#decode%27",
        "fct-type": "function",
        "title": "decode'"
      },
      "index": {
        "description": "Decode strict ByteString into Chunk",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "decode'",
        "normalized": "ByteString-\u003e(Either DecodeError Chunk,Maybe ByteString)",
        "package": "snappy-framing",
        "partial": "",
        "signature": "ByteString-\u003e(Either DecodeError Chunk,Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:decodeM",
      "description": {
        "fct-descr": "\u003cp\u003eDecode drawing input from the given monadic action as needed\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "m (Maybe ByteString)-\u003e m (Either DecodeError Chunk, Maybe ByteString)",
        "fct-type": "function",
        "title": "decodeM"
      },
      "index": {
        "description": "Decode drawing input from the given monadic action as needed",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "decodeM",
        "normalized": "a(Maybe ByteString)-\u003ea(Either DecodeError Chunk,Maybe ByteString)",
        "package": "snappy-framing",
        "partial": "",
        "signature": "m(Maybe ByteString)-\u003em(Either DecodeError Chunk,Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:decodeVerify",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003everify\u003c/a\u003e\u003c/code\u003e the result\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "ByteString -\u003e (Either DecodeError Chunk, Maybe ByteString)",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#decodeVerify",
        "fct-type": "function",
        "title": "decodeVerify"
      },
      "index": {
        "description": "Decode lazy ByteString into Chunk and verify the result",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "decodeVerify",
        "normalized": "ByteString-\u003e(Either DecodeError Chunk,Maybe ByteString)",
        "package": "snappy-framing",
        "partial": "Verify",
        "signature": "ByteString-\u003e(Either DecodeError Chunk,Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:decodeVerify-39-",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003everify\u003c/a\u003e\u003c/code\u003e the result\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "ByteString -\u003e (Either DecodeError Chunk, Maybe ByteString)",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#decodeVerify%27",
        "fct-type": "function",
        "title": "decodeVerify'"
      },
      "index": {
        "description": "Decode strict ByteString into Chunk and verify the result",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "decodeVerify'",
        "normalized": "ByteString-\u003e(Either DecodeError Chunk,Maybe ByteString)",
        "package": "snappy-framing",
        "partial": "Verify'",
        "signature": "ByteString-\u003e(Either DecodeError Chunk,Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:decodeVerifyM",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003edecodeM\u003c/a\u003e\u003c/code\u003e, but \u003ccode\u003e\u003ca\u003everify\u003c/a\u003e\u003c/code\u003e the result\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "m (Maybe ByteString) -\u003e m (Either DecodeError Chunk, Maybe ByteString)",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#decodeVerifyM",
        "fct-type": "function",
        "title": "decodeVerifyM"
      },
      "index": {
        "description": "Like decodeM but verify the result",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "decodeVerifyM",
        "normalized": "a(Maybe ByteString)-\u003ea(Either DecodeError Chunk,Maybe ByteString)",
        "package": "snappy-framing",
        "partial": "Verify",
        "signature": "m(Maybe ByteString)-\u003em(Either DecodeError Chunk,Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf the input is longer than \u003ccode\u003eminCompressible\u003c/code\u003e bytes, the resulting chunk is\n \u003ccode\u003e\u003ca\u003eCompressed\u003c/a\u003e\u003c/code\u003e otherwise \u003ccode\u003e\u003ca\u003eUncompressed\u003c/a\u003e\u003c/code\u003e. If the input size exceeds\n \u003ccode\u003emaxUncompressed\u003c/code\u003e bytes, the leftover input is returned in a \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "ByteString -\u003e (Chunk, Maybe ByteString)",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Encode lazy ByteString into Chunk If the input is longer than minCompressible bytes the resulting chunk is Compressed otherwise Uncompressed If the input size exceeds maxUncompressed bytes the leftover input is returned in Just",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "encode",
        "normalized": "ByteString-\u003e(Chunk,Maybe ByteString)",
        "package": "snappy-framing",
        "partial": "",
        "signature": "ByteString-\u003e(Chunk,Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:encode-39-",
      "description": {
        "fct-descr": "\u003cp\u003eEncode a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf the input is longer than \u003ccode\u003eminCompressible\u003c/code\u003e bytes, the resulting chunk is\n \u003ccode\u003e\u003ca\u003eCompressed\u003c/a\u003e\u003c/code\u003e otherwise \u003ccode\u003e\u003ca\u003eUncompressed\u003c/a\u003e\u003c/code\u003e. If the input size exceeds\n \u003ccode\u003emaxUncompressed\u003c/code\u003e bytes, the leftover input is returned in a \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "ByteString -\u003e (Chunk, Maybe ByteString)",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#encode%27",
        "fct-type": "function",
        "title": "encode'"
      },
      "index": {
        "description": "Encode strict ByteString into Chunk If the input is longer than minCompressible bytes the resulting chunk is Compressed otherwise Uncompressed If the input size exceeds maxUncompressed bytes the leftover input is returned in Just",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "encode'",
        "normalized": "ByteString-\u003e(Chunk,Maybe ByteString)",
        "package": "snappy-framing",
        "partial": "",
        "signature": "ByteString-\u003e(Chunk,Maybe ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:streamIdentifier",
      "description": {
        "fct-descr": "\u003cp\u003eYield a stream identifier (start-of-stream marker)\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "ByteString",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#streamIdentifier",
        "fct-type": "function",
        "title": "streamIdentifier"
      },
      "index": {
        "description": "Yield stream identifier start-of-stream marker",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "streamIdentifier",
        "normalized": "",
        "package": "snappy-framing",
        "partial": "Identifier",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/snappy-framing/docs/Codec-Compression-Snappy-Framing.html#v:verify",
      "description": {
        "fct-descr": "\u003cp\u003eVerify a \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the input is an \u003ccode\u003e\u003ca\u003eUnskippable\u003c/a\u003e\u003c/code\u003e chunk, or the checksum\n verification fails (if the input is a \u003ccode\u003e\u003ca\u003eCompressed\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eUncompressed\u003c/a\u003e\u003c/code\u003e chunk).\n Otherwise, the input \u003ccode\u003e\u003ca\u003eChunk\u003c/a\u003e\u003c/code\u003e is returned in a \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e. Note that \u003ccode\u003e\u003ca\u003eCompressed\u003c/a\u003e\u003c/code\u003e\n chunks are decompressed into \u003ccode\u003e\u003ca\u003eUncompressed\u003c/a\u003e\u003c/code\u003e chunks on the fly.\n\u003c/p\u003e",
        "fct-module": "Codec.Compression.Snappy.Framing",
        "fct-package": "snappy-framing",
        "fct-signature": "Chunk -\u003e Maybe Chunk",
        "fct-source": "src/Codec-Compression-Snappy-Framing.html#verify",
        "fct-type": "function",
        "title": "verify"
      },
      "index": {
        "description": "Verify Chunk Returns Nothing if the input is an Unskippable chunk or the checksum verification fails if the input is Compressed or Uncompressed chunk Otherwise the input Chunk is returned in Just Note that Compressed chunks are decompressed into Uncompressed chunks on the fly",
        "hierarchy": "Codec Compression Snappy Framing",
        "module": "Codec.Compression.Snappy.Framing",
        "name": "verify",
        "normalized": "Chunk-\u003eMaybe Chunk",
        "package": "snappy-framing",
        "partial": "",
        "signature": "Chunk-\u003eMaybe Chunk"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-FunctionFactory.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module which defines a function \u003ccode\u003e\u003ca\u003eliftOp\u003c/a\u003e\u003c/code\u003e which coverts pure functions \n into reference taking functions.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Imperative.FunctionFactory",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Imperative-FunctionFactory.html",
        "fct-type": "module",
        "title": "FunctionFactory"
      },
      "index": {
        "description": "module which defines function liftOp which coverts pure functions into reference taking functions",
        "hierarchy": "Control Monad Imperative FunctionFactory",
        "module": "Control.Monad.Imperative.FunctionFactory",
        "name": "FunctionFactory",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Function Factory",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-FunctionFactory.html#v:liftOp",
      "description": {
        "fct-module": "Control.Monad.Imperative.FunctionFactory",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "Name -\u003e Q Exp",
        "fct-source": "src/Control-Monad-Imperative-FunctionFactory.html#liftOp",
        "fct-type": "function",
        "title": "liftOp"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative FunctionFactory",
        "module": "Control.Monad.Imperative.FunctionFactory",
        "name": "liftOp",
        "normalized": "Name-\u003eQ Exp",
        "package": "ImperativeHaskell",
        "partial": "Op",
        "signature": "Name-\u003eQ Exp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module which defines the monad for ImperativeHaskell,  \n and some control operator to interact with \u003ccode\u003e\u003ca\u003eMIO\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Imperative-Internals.html",
        "fct-type": "module",
        "title": "Internals"
      },
      "index": {
        "description": "module which defines the monad for ImperativeHaskell and some control operator to interact with MIO",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "Internals",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Internals",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:CState",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "class",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#CState",
        "fct-type": "class",
        "title": "CState"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "CState",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "CState",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:HasValue",
      "description": {
        "fct-descr": "\u003cp\u003eAlthough the functional dependency \u003ccode\u003eb -\u003e i\u003c/code\u003e is declared, \n it does not do anything useful. \n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "class",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#HasValue",
        "fct-type": "class",
        "title": "HasValue"
      },
      "index": {
        "description": "Although the functional dependency is declared it does not do anything useful",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "HasValue",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Has Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:MIO",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "data",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#MIO",
        "fct-type": "data",
        "title": "MIO"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "MIO",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "MIO",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:TyComp",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "data",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#TyComp",
        "fct-type": "data",
        "title": "TyComp"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "TyComp",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Ty Comp",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:TyInFunc",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "data",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#TyInFunc",
        "fct-type": "data",
        "title": "TyInFunc"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "TyInFunc",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Ty In Func",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:TyInLoop",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "data",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#TyInLoop",
        "fct-type": "data",
        "title": "TyInLoop"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "TyInLoop",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Ty In Loop",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:TyVal",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "data",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#TyVal",
        "fct-type": "data",
        "title": "TyVal"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "TyVal",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Ty Val",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:TyVar",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "data",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#TyVar",
        "fct-type": "data",
        "title": "TyVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "TyVar",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Ty Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#t:V",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "data",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#V",
        "fct-type": "data",
        "title": "V"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "V",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:-38-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e(\u003ccode\u003e\u003ca\u003e&\u003c/a\u003e\u003c/code\u003e)a\u003c/code\u003e gets a reference/pointer to the variable specified\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V TyVar r a -\u003e V TyVar s a",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#%26",
        "fct-type": "function",
        "title": "(&)"
      },
      "index": {
        "description": "gets reference pointer to the variable specified",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "(&) &",
        "normalized": "V TyVar a b-\u003eV TyVar c b",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V TyVar r a-\u003eV TyVar s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:-61-:",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003evariable \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e value\u003c/code\u003e executes \u003ccode\u003evalue\u003c/code\u003e and writes it  \n to the location pointed to by \u003ccode\u003evariable\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V TyVar r a -\u003e valt a -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#%3D%3A",
        "fct-type": "function",
        "title": "(=:)"
      },
      "index": {
        "description": "variable value executes value and writes it to the location pointed to by variable",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "(=:) =:",
        "normalized": "V TyVar a b-\u003ec b-\u003eMIO d a()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V TyVar r a-\u003evalt a-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:C",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "MIO i r (V b r a) -\u003e V (TyComp i b) r a",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#V",
        "fct-type": "function",
        "title": "C"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "C",
        "normalized": "MIO a b(V c b d)-\u003eV(TyComp a c)b d",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "MIO i r(V b r a)-\u003eV(TyComp i b)r a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:Lit",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "a -\u003e V TyVal r a",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#V",
        "fct-type": "function",
        "title": "Lit"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "Lit",
        "normalized": "a-\u003eV TyVal b a",
        "package": "ImperativeHaskell",
        "partial": "Lit",
        "signature": "a-\u003eV TyVal r a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:auto",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eauto\u003c/a\u003e\u003c/code\u003e should just be used where the \n type can be automatically infered and we don't need an initial value\n Use caution, as it is simply an alternate name for \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "a",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#auto",
        "fct-type": "function",
        "title": "auto"
      },
      "index": {
        "description": "auto should just be used where the type can be automatically infered and we don need an initial value Use caution as it is simply an alternate name for undefined",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "auto",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:break-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ebreak'\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e exists the current loop.  \n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "MIO TyInLoop r ()",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#break%27",
        "fct-type": "function",
        "title": "break'"
      },
      "index": {
        "description": "break exists the current loop",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "break'",
        "normalized": "MIO TyInLoop a()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "MIO TyInLoop r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:continue-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003econtinue'\u003c/a\u003e\u003c/code\u003e continues the current loop, passing over\n any control flow that is defined.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "MIO TyInLoop r ()",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#continue%27",
        "fct-type": "function",
        "title": "continue'"
      },
      "index": {
        "description": "continue continues the current loop passing over any control flow that is defined",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "continue'",
        "normalized": "MIO TyInLoop a()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "MIO TyInLoop r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:defer-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edefer'\u003c/a\u003e\u003c/code\u003e executes the given action (or value) before the \n function returns.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "valt a -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#defer%27",
        "fct-type": "function",
        "title": "defer'"
      },
      "index": {
        "description": "defer executes the given action or value before the function returns",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "defer'",
        "normalized": "a b-\u003eMIO c d()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "valt a-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:for-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efor'\u003c/a\u003e\u003c/code\u003e(init, check, incr)\u003c/code\u003e acts like its imperative \u003ccode\u003efor\u003c/code\u003e counterpart\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "(MIO i r irr1, V b r Bool, MIO i r irr2) -\u003e valt () -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#for%27",
        "fct-type": "function",
        "title": "for'"
      },
      "index": {
        "description": "for init check incr acts like its imperative for counterpart",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "for'",
        "normalized": "(MIO a b c,V d b Bool,MIO a b c)-\u003ee()-\u003eMIO a b()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "(MIO i r irr,V b r Bool,MIO i r irr)-\u003evalt()-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:function",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efunction\u003c/a\u003e\u003c/code\u003e foo\u003c/code\u003e takes an ImperativeMonad action and removes it from it's  \n specific function context, specifically making it applicable \n in the body of other functions.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "MIO TyInFunc a a -\u003e MIO i b a",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#function",
        "fct-type": "function",
        "title": "function"
      },
      "index": {
        "description": "function foo takes an ImperativeMonad action and removes it from it specific function context specifically making it applicable in the body of other functions",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "function",
        "normalized": "MIO TyInFunc a a-\u003eMIO b c a",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "MIO TyInFunc a a-\u003eMIO i b a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:if-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eif'\u003c/a\u003e\u003c/code\u003e(check) act\u003c/code\u003e only performs \u003ccode\u003eact\u003c/code\u003e if \u003ccode\u003echeck\u003c/code\u003e evaluates to true\n it is specifically a value in its argument.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b r Bool -\u003e valt () -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#if%27",
        "fct-type": "function",
        "title": "if'"
      },
      "index": {
        "description": "if check act only performs act if check evaluates to true it is specifically value in its argument",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "if'",
        "normalized": "V a b Bool-\u003ec()-\u003eMIO d b()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r Bool-\u003evalt()-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:io",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eio\u003c/a\u003e\u003c/code\u003e action\u003c/code\u003e takes a haskell \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eaction\u003c/code\u003e and makes it useable from within\n the MIO monad.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "IO a -\u003e MIO i r a",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#io",
        "fct-type": "function",
        "title": "io"
      },
      "index": {
        "description": "io action takes haskell IO action and makes it useable from within the MIO monad",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "io",
        "normalized": "IO a-\u003eMIO b c a",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "IO a-\u003eMIO i r a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:modifyOp",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003emodifyOp\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e makes a modification assignment operator \n out of a binary haskell function.\n The suggested use is to replicate functionality of assignments\n like \u003ccode\u003e-=\u003c/code\u003e or \u003ccode\u003e%=\u003c/code\u003e from C style languages.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e V TyVar r a -\u003e V k r b -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#modifyOp",
        "fct-type": "function",
        "title": "modifyOp"
      },
      "index": {
        "description": "modifyOp makes modification assignment operator out of binary haskell function The suggested use is to replicate functionality of assignments like or from style languages",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "modifyOp",
        "normalized": "(a-\u003eb-\u003ea)-\u003eV TyVar c a-\u003eV d c b-\u003eMIO e c()",
        "package": "ImperativeHaskell",
        "partial": "Op",
        "signature": "(a-\u003eb-\u003ea)-\u003eV TyVar r a-\u003eV k r b-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003enew\u003c/a\u003e\u003c/code\u003e constructs a new reference to the specified pure value\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "a -\u003e MIO i r (V TyVar r a)",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "new constructs new reference to the specified pure value",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "new",
        "normalized": "a-\u003eMIO b c(V TyVar c a)",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "a-\u003eMIO i r(V TyVar r a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:return-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ereturn'\u003c/a\u003e\u003c/code\u003e value\u003c/code\u003e acts like an imperative return. It passes\n the given value to the return continuation.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V a r r -\u003e MIO i r (RetTy i r)",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#return%27",
        "fct-type": "method",
        "title": "return'"
      },
      "index": {
        "description": "return value acts like an imperative return It passes the given value to the return continuation",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "return'",
        "normalized": "V a b b-\u003eMIO c b(RetTy c b)",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V a r r-\u003eMIO i r(RetTy i r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:runImperative",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003erunImperative\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e takes an MIO action as returned by a function, \n and lifts it into IO.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "MIO TyInFunc a a -\u003e IO a",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#runImperative",
        "fct-type": "function",
        "title": "runImperative"
      },
      "index": {
        "description": "runImperative takes an MIO action as returned by function and lifts it into IO",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "runImperative",
        "normalized": "MIO TyInFunc a a-\u003eIO a",
        "package": "ImperativeHaskell",
        "partial": "Imperative",
        "signature": "MIO TyInFunc a a-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:val",
      "description": {
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "b a -\u003e MIO i r a",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#val",
        "fct-type": "method",
        "title": "val"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "val",
        "normalized": "a b-\u003eMIO c d b",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "b a-\u003eMIO i r a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Internals.html#v:while-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ewhile'\u003c/a\u003e\u003c/code\u003e(check)\u003c/code\u003e acts like its imperative \u003ccode\u003ewhile\u003c/code\u003e counterpart.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Internals",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b r Bool -\u003e valt () -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Internals.html#while%27",
        "fct-type": "function",
        "title": "while'"
      },
      "index": {
        "description": "while check acts like its imperative while counterpart",
        "hierarchy": "Control Monad Imperative Internals",
        "module": "Control.Monad.Imperative.Internals",
        "name": "while'",
        "normalized": "V a b Bool-\u003ec()-\u003eMIO d b()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r Bool-\u003evalt()-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome predefined operators for the imperative monad.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Imperative-Operators.html",
        "fct-type": "module",
        "title": "Operators"
      },
      "index": {
        "description": "Some predefined operators for the imperative monad",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "Operators",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Operators",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-124--124-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r Bool -\u003e V b2 r Bool -\u003e V (TyComp i TyVal) r Bool",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%26%26.",
        "fct-type": "function",
        "title": "(||.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(||.) ||.",
        "normalized": "V a b Bool-\u003eV a b Bool-\u003eV(TyComp c TyVal)b Bool",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r Bool-\u003eV b r Bool-\u003eV(TyComp i TyVal)r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-126-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b r Bool -\u003e V (TyComp i TyVal) r Bool",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#~.",
        "fct-type": "function",
        "title": "(~.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(~.) ~.",
        "normalized": "V a b Bool-\u003eV(TyComp c TyVal)b Bool",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r Bool-\u003eV(TyComp i TyVal)r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-37--61-:",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V TyVar r b -\u003e V k r b -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%25%3D%3A",
        "fct-type": "function",
        "title": "(%=:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(%=:) %=:",
        "normalized": "V TyVar a b-\u003eV c a b-\u003eMIO d a()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V TyVar r b-\u003eV k r b-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-37-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r c",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%25.",
        "fct-type": "function",
        "title": "(%.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(%.) %.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b c",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-38--38-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r Bool -\u003e V b2 r Bool -\u003e V (TyComp i TyVal) r Bool",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%26%26.",
        "fct-type": "function",
        "title": "(&&.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(&&.) &&.",
        "normalized": "V a b Bool-\u003eV a b Bool-\u003eV(TyComp c TyVal)b Bool",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r Bool-\u003eV b r Bool-\u003eV(TyComp i TyVal)r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-42--61-:",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V TyVar r b -\u003e V k r b -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%2B%3D%3A",
        "fct-type": "function",
        "title": "(*=:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(*=:) *=:",
        "normalized": "V TyVar a b-\u003eV c a b-\u003eMIO d a()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V TyVar r b-\u003eV k r b-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-42-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r c",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%2B.",
        "fct-type": "function",
        "title": "(*.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(*.) *.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b c",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-43--61-:",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V TyVar r b -\u003e V k r b -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%2B%3D%3A",
        "fct-type": "function",
        "title": "(+=:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(+=:) +=:",
        "normalized": "V TyVar a b-\u003eV c a b-\u003eMIO d a()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V TyVar r b-\u003eV k r b-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-43-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r c",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%2B.",
        "fct-type": "function",
        "title": "(+.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(+.) +.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b c",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-45--61-:",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V TyVar r b -\u003e V k r b -\u003e MIO i r ()",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%2B%3D%3A",
        "fct-type": "function",
        "title": "(-=:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(-=:) -=:",
        "normalized": "V TyVar a b-\u003eV c a b-\u003eMIO d a()",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V TyVar r b-\u003eV k r b-\u003eMIO i r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-45-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r c",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%2B.",
        "fct-type": "function",
        "title": "(-.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(-.) -.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b c",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-47-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r c",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%2F.",
        "fct-type": "function",
        "title": "(/.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(/.) /.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b c",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-60--61-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r Bool",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%3C.",
        "fct-type": "function",
        "title": "(\u003c=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(\u003c=.) \u003c=.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b Bool",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-60-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r Bool",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%3C.",
        "fct-type": "function",
        "title": "(\u003c.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(\u003c.) \u003c.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b Bool",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-61--61-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r Bool",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%3D%3D.",
        "fct-type": "function",
        "title": "(==.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(==.) ==.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b Bool",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-62--61-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r Bool",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%3C.",
        "fct-type": "function",
        "title": "(\u003e=.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(\u003e=.) \u003e=.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b Bool",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:-62-.",
      "description": {
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "V b1 r c -\u003e V b2 r c -\u003e V (TyComp i TyVal) r Bool",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#%3C.",
        "fct-type": "function",
        "title": "(\u003e.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "(\u003e.) \u003e.",
        "normalized": "V a b c-\u003eV a b c-\u003eV(TyComp d TyVal)b Bool",
        "package": "ImperativeHaskell",
        "partial": "",
        "signature": "V b r c-\u003eV b r c-\u003eV(TyComp i TyVal)r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative-Operators.html#v:liftOp2",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eliftOp2\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e turns a pure function into one which\n gets executes its arguments and returns their value as a\n function.  It is defined using \u003ccode\u003eliftOp\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Imperative.Operators",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e V b1 r a -\u003e V b2 r b -\u003e V (TyComp i TyVal) r c",
        "fct-source": "src/Control-Monad-Imperative-Operators.html#liftOp2",
        "fct-type": "function",
        "title": "liftOp2"
      },
      "index": {
        "description": "liftOp2 turns pure function into one which gets executes its arguments and returns their value as function It is defined using liftOp",
        "hierarchy": "Control Monad Imperative Operators",
        "module": "Control.Monad.Imperative.Operators",
        "name": "liftOp2",
        "normalized": "(a-\u003eb-\u003ec)-\u003eV b d a-\u003eV b d b-\u003eV(TyComp e TyVal)d c",
        "package": "ImperativeHaskell",
        "partial": "Op",
        "signature": "(a-\u003eb-\u003ec)-\u003eV b r a-\u003eV b r b-\u003eV(TyComp i TyVal)r c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ImperativeHaskell/docs/Control-Monad-Imperative.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA front end for the ImperativeMonad\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Imperative",
        "fct-package": "ImperativeHaskell",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Imperative.html",
        "fct-type": "module",
        "title": "Imperative"
      },
      "index": {
        "description": "front end for the ImperativeMonad",
        "hierarchy": "Control Monad Imperative",
        "module": "Control.Monad.Imperative",
        "name": "Imperative",
        "normalized": "",
        "package": "ImperativeHaskell",
        "partial": "Imperative",
        "signature": ""
      }
    }
  }
]
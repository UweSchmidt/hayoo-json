[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#",
      "description": {
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "module",
        "fct-source": "src/Network-Secure-Identity.html",
        "fct-type": "module",
        "title": "Identity"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "Identity",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Identity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#t:Identity",
      "description": {
        "fct-descr": "\u003cp\u003eAn identity, public or private.\n\u003c/p\u003e",
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "class",
        "fct-source": "src/Network-Secure-Identity.html#Identity",
        "fct-type": "class",
        "title": "Identity"
      },
      "index": {
        "description": "An identity public or private",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "Identity",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Identity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#t:LocalIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eA local identity. This kind of identity can be used to\n authenticate \u003cem\u003eto\u003c/em\u003e remote ends of connections.\n\u003c/p\u003e",
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "data",
        "fct-source": "src/Network-Secure-Identity.html#LocalIdentity",
        "fct-type": "data",
        "title": "LocalIdentity"
      },
      "index": {
        "description": "local identity This kind of identity can be used to authenticate to remote ends of connections",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "LocalIdentity",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Local Identity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#t:PeerIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eThe public identity of a peer. This kind of identity can be used\n to authenticate the remote ends of connections.\n\u003c/p\u003e",
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "data",
        "fct-source": "src/Network-Secure-Identity.html#PeerIdentity",
        "fct-type": "data",
        "title": "PeerIdentity"
      },
      "index": {
        "description": "The public identity of peer This kind of identity can be used to authenticate the remote ends of connections",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "PeerIdentity",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Peer Identity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:fromX509",
      "description": {
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "X509 -\u003e IO PeerIdentity",
        "fct-source": "src/Network-Secure-Identity.html#fromX509",
        "fct-type": "function",
        "title": "fromX509"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "fromX509",
        "normalized": "X-\u003eIO PeerIdentity",
        "package": "secure-sockets",
        "partial": "",
        "signature": "X-\u003eIO PeerIdentity"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:identityName",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the description that was associated with the identity\n when it was created.\n\u003c/p\u003e",
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Network-Secure-Identity.html#identityName",
        "fct-type": "method",
        "title": "identityName"
      },
      "index": {
        "description": "Return the description that was associated with the identity when it was created",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "identityName",
        "normalized": "a-\u003eString",
        "package": "secure-sockets",
        "partial": "Name",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:liKey",
      "description": {
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "LocalIdentity -\u003e RSAKeyPair",
        "fct-source": "src/Network-Secure-Identity.html#liKey",
        "fct-type": "function",
        "title": "liKey"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "liKey",
        "normalized": "LocalIdentity-\u003eRSAKeyPair",
        "package": "secure-sockets",
        "partial": "Key",
        "signature": "LocalIdentity-\u003eRSAKeyPair"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:liX509",
      "description": {
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "LocalIdentity -\u003e X509",
        "fct-source": "src/Network-Secure-Identity.html#liX509",
        "fct-type": "function",
        "title": "liX509"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "liX509",
        "normalized": "LocalIdentity-\u003eX",
        "package": "secure-sockets",
        "partial": "",
        "signature": "LocalIdentity-\u003eX"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:newLocalIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate a new \u003ccode\u003e\u003ca\u003eLocalIdentity\u003c/a\u003e\u003c/code\u003e, giving it an identifying name and\n a validity period in days.\n\u003c/p\u003e\u003cp\u003eNote that this function may take quite a while to execute, as it is\n generating key material for the identity.\n\u003c/p\u003e",
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "String -\u003e Int -\u003e m LocalIdentity",
        "fct-source": "src/Network-Secure-Identity.html#newLocalIdentity",
        "fct-type": "function",
        "title": "newLocalIdentity"
      },
      "index": {
        "description": "Generate new LocalIdentity giving it an identifying name and validity period in days Note that this function may take quite while to execute as it is generating key material for the identity",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "newLocalIdentity",
        "normalized": "String-\u003eInt-\u003ea LocalIdentity",
        "package": "secure-sockets",
        "partial": "Local Identity",
        "signature": "String-\u003eInt-\u003em LocalIdentity"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:piX509",
      "description": {
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "PeerIdentity -\u003e X509",
        "fct-source": "src/Network-Secure-Identity.html#piX509",
        "fct-type": "function",
        "title": "piX509"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "piX509",
        "normalized": "PeerIdentity-\u003eX",
        "package": "secure-sockets",
        "partial": "",
        "signature": "PeerIdentity-\u003eX"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:readIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eRead back an identity previously serialized with\n writeIdentity.\n\u003c/p\u003e",
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "ByteString -\u003e m a",
        "fct-source": "src/Network-Secure-Identity.html#readIdentity",
        "fct-type": "method",
        "title": "readIdentity"
      },
      "index": {
        "description": "Read back an identity previously serialized with writeIdentity",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "readIdentity",
        "normalized": "ByteString-\u003ea b",
        "package": "secure-sockets",
        "partial": "Identity",
        "signature": "ByteString-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:toPeerIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eExtract the public parts of a \u003ccode\u003e\u003ca\u003eLocalIdentity\u003c/a\u003e\u003c/code\u003e into a\n \u003ccode\u003e\u003ca\u003ePeerIdentity\u003c/a\u003e\u003c/code\u003e suitable for sharing with peers. The resulting\n \u003ccode\u003e\u003ca\u003ePeerIdentity\u003c/a\u003e\u003c/code\u003e will allow them to verify your identity when you\n authenticate using the corresponding \u003ccode\u003e\u003ca\u003eLocalIdentity\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "LocalIdentity -\u003e PeerIdentity",
        "fct-source": "src/Network-Secure-Identity.html#toPeerIdentity",
        "fct-type": "function",
        "title": "toPeerIdentity"
      },
      "index": {
        "description": "Extract the public parts of LocalIdentity into PeerIdentity suitable for sharing with peers The resulting PeerIdentity will allow them to verify your identity when you authenticate using the corresponding LocalIdentity",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "toPeerIdentity",
        "normalized": "LocalIdentity-\u003ePeerIdentity",
        "package": "secure-sockets",
        "partial": "Peer Identity",
        "signature": "LocalIdentity-\u003ePeerIdentity"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure-Identity.html#v:writeIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eSerialize an identity to a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e for storage or\n transmission.\n\u003c/p\u003e",
        "fct-module": "Network.Secure.Identity",
        "fct-package": "secure-sockets",
        "fct-signature": "a -\u003e m ByteString",
        "fct-source": "src/Network-Secure-Identity.html#writeIdentity",
        "fct-type": "method",
        "title": "writeIdentity"
      },
      "index": {
        "description": "Serialize an identity to ByteString for storage or transmission",
        "hierarchy": "Network Secure Identity",
        "module": "Network.Secure.Identity",
        "name": "writeIdentity",
        "normalized": "a-\u003eb ByteString",
        "package": "secure-sockets",
        "partial": "Identity",
        "signature": "a-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library simplifies the task of securely connecting two\n servers to each other. It closely mimicks the regular socket API,\n and adds the concept of identity: each communicating server has an\n identity, and connections can only be established between two\n servers who know each other and expect to be communicating.\n\u003c/p\u003e\u003cp\u003eUnder the hood, the library takes care of strongly authenticating\n the connection, and of encrypting all traffic. If you successfully\n establish a connection using this library, you have the guarantee\n that the connection is secure.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "module",
        "fct-source": "src/Network-Secure.html",
        "fct-type": "module",
        "title": "Secure"
      },
      "index": {
        "description": "This library simplifies the task of securely connecting two servers to each other It closely mimicks the regular socket API and adds the concept of identity each communicating server has an identity and connections can only be established between two servers who know each other and expect to be communicating Under the hood the library takes care of strongly authenticating the connection and of encrypting all traffic If you successfully establish connection using this library you have the guarantee that the connection is secure",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "Secure",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Secure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#t:Connection",
      "description": {
        "fct-descr": "\u003cp\u003eAn established authenticated connection to a peer. It is\n guaranteed that all Connection objects are with a known peer, and\n that the connection is strongly encrypted.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "data",
        "fct-source": "src/Network-Secure-Connection.html#Connection",
        "fct-type": "data",
        "title": "Connection"
      },
      "index": {
        "description": "An established authenticated connection to peer It is guaranteed that all Connection objects are with known peer and that the connection is strongly encrypted",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "Connection",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Connection",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#t:HostName",
      "description": {
        "fct-descr": "\u003cp\u003eEither a host name e.g., \u003ccode\u003e\"haskell.org\"\u003c/code\u003e or a numeric host\n address string consisting of a dotted decimal IPv4 address or an\n IPv6 address e.g., \u003ccode\u003e\"192.168.0.1\"\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "type",
        "fct-type": "type",
        "title": "HostName"
      },
      "index": {
        "description": "Either host name e.g haskell.org or numeric host address string consisting of dotted decimal IPv4 address or an IPv6 address e.g",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "HostName",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Host Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#t:Identity",
      "description": {
        "fct-descr": "\u003cp\u003eAn identity, public or private.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "class",
        "fct-source": "src/Network-Secure-Identity.html#Identity",
        "fct-type": "class",
        "title": "Identity"
      },
      "index": {
        "description": "An identity public or private",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "Identity",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Identity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#t:LocalIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eA local identity. This kind of identity can be used to\n authenticate \u003cem\u003eto\u003c/em\u003e remote ends of connections.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "data",
        "fct-source": "src/Network-Secure-Identity.html#LocalIdentity",
        "fct-type": "data",
        "title": "LocalIdentity"
      },
      "index": {
        "description": "local identity This kind of identity can be used to authenticate to remote ends of connections",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "LocalIdentity",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Local Identity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#t:PeerIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eThe public identity of a peer. This kind of identity can be used\n to authenticate the remote ends of connections.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "data",
        "fct-source": "src/Network-Secure-Identity.html#PeerIdentity",
        "fct-type": "data",
        "title": "PeerIdentity"
      },
      "index": {
        "description": "The public identity of peer This kind of identity can be used to authenticate the remote ends of connections",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "PeerIdentity",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Peer Identity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#t:ServiceName",
      "description": {
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "type",
        "fct-type": "type",
        "title": "ServiceName"
      },
      "index": {
        "description": "",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "ServiceName",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Service Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#t:Socket",
      "description": {
        "fct-descr": "\u003cp\u003eA server socket that accepts only secure connections.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "data",
        "fct-source": "src/Network-Secure-Connection.html#Socket",
        "fct-type": "data",
        "title": "Socket"
      },
      "index": {
        "description": "server socket that accepts only secure connections",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "Socket",
        "normalized": "",
        "package": "secure-sockets",
        "partial": "Socket",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:accept",
      "description": {
        "fct-descr": "\u003cp\u003eAccept one secure connection from a remote peer. The peer may\n authenticate as any of the given peer identities. A \u003ccode\u003e\u003ca\u003eConnection\u003c/a\u003e\u003c/code\u003e is\n returned iff the autentication completes successfully.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "LocalIdentity -\u003e [PeerIdentity] -\u003e Socket -\u003e IO Connection",
        "fct-source": "src/Network-Secure-Connection.html#accept",
        "fct-type": "function",
        "title": "accept"
      },
      "index": {
        "description": "Accept one secure connection from remote peer The peer may authenticate as any of the given peer identities Connection is returned iff the autentication completes successfully",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "accept",
        "normalized": "LocalIdentity-\u003e[PeerIdentity]-\u003eSocket-\u003eIO Connection",
        "package": "secure-sockets",
        "partial": "",
        "signature": "LocalIdentity-\u003e[PeerIdentity]-\u003eSocket-\u003eIO Connection"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:close",
      "description": {
        "fct-descr": "\u003cp\u003eClose the connection. No other operations on \u003ccode\u003e\u003ca\u003eConnection\u003c/a\u003e\u003c/code\u003es should\n be used after closing it.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "Connection -\u003e IO ()",
        "fct-source": "src/Network-Secure-Connection.html#close",
        "fct-type": "function",
        "title": "close"
      },
      "index": {
        "description": "Close the connection No other operations on Connection should be used after closing it",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "close",
        "normalized": "Connection-\u003eIO()",
        "package": "secure-sockets",
        "partial": "",
        "signature": "Connection-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:connect",
      "description": {
        "fct-descr": "\u003cp\u003eConnect securely to the given host/port. The \u003ccode\u003e\u003ca\u003eConnection\u003c/a\u003e\u003c/code\u003e is\n returned only if the peer accepts the given \u003ccode\u003e\u003ca\u003eLocalIdentity\u003c/a\u003e\u003c/code\u003e, and if\n the remote endpoint successfully authenticates as one of the given\n \u003ccode\u003e\u003ca\u003ePeerIdentity\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "LocalIdentity -\u003e [PeerIdentity] -\u003e (HostName, ServiceName) -\u003e IO Connection",
        "fct-source": "src/Network-Secure-Connection.html#connect",
        "fct-type": "function",
        "title": "connect"
      },
      "index": {
        "description": "Connect securely to the given host port The Connection is returned only if the peer accepts the given LocalIdentity and if the remote endpoint successfully authenticates as one of the given PeerIdentity",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "connect",
        "normalized": "LocalIdentity-\u003e[PeerIdentity]-\u003e(HostName,ServiceName)-\u003eIO Connection",
        "package": "secure-sockets",
        "partial": "",
        "signature": "LocalIdentity-\u003e[PeerIdentity]-\u003e(HostName,ServiceName)-\u003eIO Connection"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:identityName",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the description that was associated with the identity\n when it was created.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Network-Secure-Identity.html#identityName",
        "fct-type": "method",
        "title": "identityName"
      },
      "index": {
        "description": "Return the description that was associated with the identity when it was created",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "identityName",
        "normalized": "a-\u003eString",
        "package": "secure-sockets",
        "partial": "Name",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:newLocalIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate a new \u003ccode\u003e\u003ca\u003eLocalIdentity\u003c/a\u003e\u003c/code\u003e, giving it an identifying name and\n a validity period in days.\n\u003c/p\u003e\u003cp\u003eNote that this function may take quite a while to execute, as it is\n generating key material for the identity.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "String -\u003e Int -\u003e m LocalIdentity",
        "fct-source": "src/Network-Secure-Identity.html#newLocalIdentity",
        "fct-type": "function",
        "title": "newLocalIdentity"
      },
      "index": {
        "description": "Generate new LocalIdentity giving it an identifying name and validity period in days Note that this function may take quite while to execute as it is generating key material for the identity",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "newLocalIdentity",
        "normalized": "String-\u003eInt-\u003ea LocalIdentity",
        "package": "secure-sockets",
        "partial": "Local Identity",
        "signature": "String-\u003eInt-\u003em LocalIdentity"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:newServer",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new secure socket server, listening on the given\n address/port. The host may be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e to signify that the socket\n should listen on all available addresses.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "(Maybe HostName, ServiceName) -\u003e IO Socket",
        "fct-source": "src/Network-Secure-Connection.html#newServer",
        "fct-type": "function",
        "title": "newServer"
      },
      "index": {
        "description": "Create new secure socket server listening on the given address port The host may be Nothing to signify that the socket should listen on all available addresses",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "newServer",
        "normalized": "(Maybe HostName,ServiceName)-\u003eIO Socket",
        "package": "secure-sockets",
        "partial": "Server",
        "signature": "(Maybe HostName,ServiceName)-\u003eIO Socket"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:peer",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the \u003ccode\u003e\u003ca\u003ePeerIdentity\u003c/a\u003e\u003c/code\u003e of the remote end of the connection.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "Connection -\u003e PeerIdentity",
        "fct-source": "src/Network-Secure-Connection.html#peer",
        "fct-type": "function",
        "title": "peer"
      },
      "index": {
        "description": "Return the PeerIdentity of the remote end of the connection",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "peer",
        "normalized": "Connection-\u003ePeerIdentity",
        "package": "secure-sockets",
        "partial": "",
        "signature": "Connection-\u003ePeerIdentity"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eRead at most \u003ccode\u003en\u003c/code\u003e bytes from the given connection.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "Connection -\u003e Int -\u003e IO ByteString",
        "fct-source": "src/Network-Secure-Connection.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Read at most bytes from the given connection",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "read",
        "normalized": "Connection-\u003eInt-\u003eIO ByteString",
        "package": "secure-sockets",
        "partial": "",
        "signature": "Connection-\u003eInt-\u003eIO ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:readIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eRead back an identity previously serialized with\n writeIdentity.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "ByteString -\u003e m a",
        "fct-source": "src/Network-Secure-Identity.html#readIdentity",
        "fct-type": "method",
        "title": "readIdentity"
      },
      "index": {
        "description": "Read back an identity previously serialized with writeIdentity",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "readIdentity",
        "normalized": "ByteString-\u003ea b",
        "package": "secure-sockets",
        "partial": "Identity",
        "signature": "ByteString-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:readPtr",
      "description": {
        "fct-descr": "\u003cp\u003eRead at most \u003ccode\u003en\u003c/code\u003e bytes from the given connection, into the given raw buffer.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "Connection -\u003e Ptr a -\u003e Int -\u003e IO Int",
        "fct-source": "src/Network-Secure-Connection.html#readPtr",
        "fct-type": "function",
        "title": "readPtr"
      },
      "index": {
        "description": "Read at most bytes from the given connection into the given raw buffer",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "readPtr",
        "normalized": "Connection-\u003ePtr a-\u003eInt-\u003eIO Int",
        "package": "secure-sockets",
        "partial": "Ptr",
        "signature": "Connection-\u003ePtr a-\u003eInt-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:toPeerIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eExtract the public parts of a \u003ccode\u003e\u003ca\u003eLocalIdentity\u003c/a\u003e\u003c/code\u003e into a\n \u003ccode\u003e\u003ca\u003ePeerIdentity\u003c/a\u003e\u003c/code\u003e suitable for sharing with peers. The resulting\n \u003ccode\u003e\u003ca\u003ePeerIdentity\u003c/a\u003e\u003c/code\u003e will allow them to verify your identity when you\n authenticate using the corresponding \u003ccode\u003e\u003ca\u003eLocalIdentity\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "LocalIdentity -\u003e PeerIdentity",
        "fct-source": "src/Network-Secure-Identity.html#toPeerIdentity",
        "fct-type": "function",
        "title": "toPeerIdentity"
      },
      "index": {
        "description": "Extract the public parts of LocalIdentity into PeerIdentity suitable for sharing with peers The resulting PeerIdentity will allow them to verify your identity when you authenticate using the corresponding LocalIdentity",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "toPeerIdentity",
        "normalized": "LocalIdentity-\u003ePeerIdentity",
        "package": "secure-sockets",
        "partial": "Peer Identity",
        "signature": "LocalIdentity-\u003ePeerIdentity"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eSend data to the connected peer.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "Connection -\u003e ByteString -\u003e IO ()",
        "fct-source": "src/Network-Secure-Connection.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Send data to the connected peer",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "write",
        "normalized": "Connection-\u003eByteString-\u003eIO()",
        "package": "secure-sockets",
        "partial": "",
        "signature": "Connection-\u003eByteString-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:writeIdentity",
      "description": {
        "fct-descr": "\u003cp\u003eSerialize an identity to a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e for storage or\n transmission.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "a -\u003e m ByteString",
        "fct-source": "src/Network-Secure-Identity.html#writeIdentity",
        "fct-type": "method",
        "title": "writeIdentity"
      },
      "index": {
        "description": "Serialize an identity to ByteString for storage or transmission",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "writeIdentity",
        "normalized": "a-\u003eb ByteString",
        "package": "secure-sockets",
        "partial": "Identity",
        "signature": "a-\u003em ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/secure-sockets/docs/Network-Secure.html#v:writePtr",
      "description": {
        "fct-descr": "\u003cp\u003eSend data from the given raw pointer to the connected peer.\n\u003c/p\u003e",
        "fct-module": "Network.Secure",
        "fct-package": "secure-sockets",
        "fct-signature": "Connection -\u003e Ptr a -\u003e Int -\u003e IO ()",
        "fct-source": "src/Network-Secure-Connection.html#writePtr",
        "fct-type": "function",
        "title": "writePtr"
      },
      "index": {
        "description": "Send data from the given raw pointer to the connected peer",
        "hierarchy": "Network Secure",
        "module": "Network.Secure",
        "name": "writePtr",
        "normalized": "Connection-\u003ePtr a-\u003eInt-\u003eIO()",
        "package": "secure-sockets",
        "partial": "Ptr",
        "signature": "Connection-\u003ePtr a-\u003eInt-\u003eIO()"
      }
    }
  }
]
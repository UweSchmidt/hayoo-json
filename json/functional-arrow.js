[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "module",
        "fct-source": "src/Control-Arrow-Let.html",
        "fct-type": "module",
        "title": "Let"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "Let",
        "normalized": "",
        "package": "functional-arrow",
        "partial": "Let",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#t:Index",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "class",
        "fct-source": "src/Control-Arrow-Let.html#Index",
        "fct-type": "class",
        "title": "Index"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "Index",
        "normalized": "",
        "package": "functional-arrow",
        "partial": "Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#v:-60--60--60--38-",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "arrow (b, a) c -\u003e arrow a b -\u003e arrow a c",
        "fct-source": "src/Control-Arrow-Let.html#%3C%3C%3C%26",
        "fct-type": "function",
        "title": "(\u003c\u003c\u003c&)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "(\u003c\u003c\u003c&) \u003c\u003c\u003c&",
        "normalized": "a(b,c)d-\u003ea c b-\u003ea c d",
        "package": "functional-arrow",
        "partial": "",
        "signature": "arrow(b,a)c-\u003earrow a b-\u003earrow a c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#v:c1",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "arrow (Int, ()) Bool",
        "fct-source": "src/Control-Arrow-Let.html#c1",
        "fct-type": "function",
        "title": "c1"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "c1",
        "normalized": "a(Int,())Bool",
        "package": "functional-arrow",
        "partial": "",
        "signature": "arrow(Int,())Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#v:c2",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "arrow (Int, ()) Bool",
        "fct-source": "src/Control-Arrow-Let.html#c2",
        "fct-type": "function",
        "title": "c2"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "c2",
        "normalized": "a(Int,())Bool",
        "package": "functional-arrow",
        "partial": "",
        "signature": "arrow(Int,())Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#v:f",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "arrow (Int, ()) Char",
        "fct-source": "src/Control-Arrow-Let.html#f",
        "fct-type": "function",
        "title": "f"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "f",
        "normalized": "a(Int,())Char",
        "package": "functional-arrow",
        "partial": "",
        "signature": "arrow(Int,())Char"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#v:g",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "arrow (Char, (Int, ())) Bool",
        "fct-source": "src/Control-Arrow-Let.html#g",
        "fct-type": "function",
        "title": "g"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "g",
        "normalized": "a(Char,(Int,()))Bool",
        "package": "functional-arrow",
        "partial": "",
        "signature": "arrow(Char,(Int,()))Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#v:input",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "arrow () Int",
        "fct-source": "src/Control-Arrow-Let.html#input",
        "fct-type": "function",
        "title": "input"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "input",
        "normalized": "a()Int",
        "package": "functional-arrow",
        "partial": "",
        "signature": "arrow()Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Let.html#v:ref",
      "description": {
        "fct-module": "Control.Arrow.Let",
        "fct-package": "functional-arrow",
        "fct-signature": "arr envi t -\u003e arr envo t",
        "fct-source": "src/Control-Arrow-Let.html#ref",
        "fct-type": "method",
        "title": "ref"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Let",
        "module": "Control.Arrow.Let",
        "name": "ref",
        "normalized": "a b c-\u003ea d c",
        "package": "functional-arrow",
        "partial": "",
        "signature": "arr envi t-\u003earr envo t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Monad.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is an attempt to simplify the use of arrow combinators.\nIf I have \u003ccode\u003ef :: arrow a b\u003c/code\u003e,\nthen subsequent arrows can only access the \u003ccode\u003eb\u003c/code\u003e,\nbut often I also want to access the \u003ccode\u003ea\u003c/code\u003e.\nThus I often write\n\u003c/p\u003e\u003cpre\u003e f &&& arr id :: arrow a (b,a)  .\n\u003c/pre\u003e\u003cp\u003eIf I repeat this, it yields\n\u003c/p\u003e\u003cpre\u003e g &&& arr id \u003c\u003c\u003c f &&& arr id :: arrow a (c,(b,a))\n h &&& arr id \u003c\u003c\u003c g &&& arr id \u003c\u003c\u003c f &&& arr id :: arrow a (d,(c,(b,a)))  .\n\u003c/pre\u003e\u003cp\u003eHowever accessing the particular inputs of type \u003ccode\u003ed\u003c/code\u003e, \u003ccode\u003ec\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e\nfrom within \u003ccode\u003eh\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e is cumbersome.\nThus I wrote a little support for this style of arrow programming.\nFirst I use \u003ccode\u003eHList\u003c/code\u003e instead of nested pairs.\nUsing type level Peano numbers and reverse \u003ccode\u003eHList\u003c/code\u003e index access\nI can use the same expression (say \u003ccode\u003elisten x\u003c/code\u003e) in both \u003ccode\u003eg\u003c/code\u003e and \u003ccode\u003eh\u003c/code\u003e\nalthough in both contexts they refer to different \u003ccode\u003eHLists\u003c/code\u003e.\nE.g. \u003ccode\u003eg\u003c/code\u003e expects the \u003ccode\u003eb\u003c/code\u003e input at the \u003ccode\u003eHList\u003c/code\u003e head,\nwhereas \u003ccode\u003eh\u003c/code\u003e gets it one position later.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Arrow.Monad",
        "fct-package": "functional-arrow",
        "fct-signature": "module",
        "fct-source": "src/Control-Arrow-Monad.html",
        "fct-type": "module",
        "title": "Monad"
      },
      "index": {
        "description": "This module is an attempt to simplify the use of arrow combinators If have arrow then subsequent arrows can only access the but often also want to access the Thus often write arr id arrow If repeat this it yields arr id arr id arrow arr id arr id arr id arrow However accessing the particular inputs of type from within and is cumbersome Thus wrote little support for this style of arrow programming First use HList instead of nested pairs Using type level Peano numbers and reverse HList index access can use the same expression say listen in both and although in both contexts they refer to different HLists E.g expects the input at the HList head whereas gets it one position later",
        "hierarchy": "Control Arrow Monad",
        "module": "Control.Arrow.Monad",
        "name": "Monad",
        "normalized": "",
        "package": "functional-arrow",
        "partial": "Monad",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Monad.html#t:HAdd",
      "description": {
        "fct-module": "Control.Arrow.Monad",
        "fct-package": "functional-arrow",
        "fct-signature": "class",
        "fct-source": "src/Control-Arrow-Monad.html#HAdd",
        "fct-type": "class",
        "title": "HAdd"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Monad",
        "module": "Control.Arrow.Monad",
        "name": "HAdd",
        "normalized": "",
        "package": "functional-arrow",
        "partial": "HAdd",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Monad.html#v:-61--60--60--60-",
      "description": {
        "fct-module": "Control.Arrow.Monad",
        "fct-package": "functional-arrow",
        "fct-signature": "(n -\u003e arrow (HCons a list) b) -\u003e arrow list a -\u003e arrow list b",
        "fct-source": "src/Control-Arrow-Monad.html#%3D%3C%3C%3C",
        "fct-type": "function",
        "title": "(=\u003c\u003c\u003c)"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Monad",
        "module": "Control.Arrow.Monad",
        "name": "(=\u003c\u003c\u003c) =\u003c\u003c\u003c",
        "normalized": "(a-\u003eb(HCons c d)e)-\u003eb d c-\u003eb d e",
        "package": "functional-arrow",
        "partial": "",
        "signature": "(n-\u003earrow(HCons a list)b)-\u003earrow list a-\u003earrow list b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Monad.html#v:-62--62--62--61-",
      "description": {
        "fct-descr": "\u003cp\u003eThis \u003ccode\u003ebind\u003c/code\u003e-like operator allows you to a share an interim arrow result\nbetween various following arrow inputs.\n\u003c/p\u003e\u003cp\u003eInstead of\n\u003c/p\u003e\u003cpre\u003e mix \u003c\u003c\u003c  id &&& delay  \u003c\u003c\u003c lowpass\n\u003c/pre\u003e\u003cp\u003eyou can write\n\u003c/p\u003e\u003cpre\u003e (\\x -\u003e HL.hCons x HL.hNil) ^\u003e\u003e\n ((HL.hHead ^\u003e\u003e lowpass) \u003e\u003e\u003e= \\x -\u003e\n      mix \u003c\u003c\u003c  listen x &&& (delay \u003c\u003c\u003c listen x))\n\u003c/pre\u003e",
        "fct-module": "Control.Arrow.Monad",
        "fct-package": "functional-arrow",
        "fct-signature": "arrow list a -\u003e (n -\u003e arrow (HCons a list) b) -\u003e arrow list b",
        "fct-source": "src/Control-Arrow-Monad.html#%3E%3E%3E%3D",
        "fct-type": "function",
        "title": "(\u003e\u003e\u003e=)"
      },
      "index": {
        "description": "This bind like operator allows you to share an interim arrow result between various following arrow inputs Instead of mix id delay lowpass you can write HL.hCons HL.hNil HL.hHead lowpass mix listen delay listen",
        "hierarchy": "Control Arrow Monad",
        "module": "Control.Arrow.Monad",
        "name": "(\u003e\u003e\u003e=) \u003e\u003e\u003e=",
        "normalized": "a b c-\u003e(d-\u003ea(HCons c b)e)-\u003ea b e",
        "package": "functional-arrow",
        "partial": "",
        "signature": "arrow list a-\u003e(n-\u003earrow(HCons a list)b)-\u003earrow list b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functional-arrow/docs/Control-Arrow-Monad.html#v:listen",
      "description": {
        "fct-module": "Control.Arrow.Monad",
        "fct-package": "functional-arrow",
        "fct-signature": "n -\u003e arrow list a",
        "fct-source": "src/Control-Arrow-Monad.html#listen",
        "fct-type": "function",
        "title": "listen"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Arrow Monad",
        "module": "Control.Arrow.Monad",
        "name": "listen",
        "normalized": "a-\u003eb c d",
        "package": "functional-arrow",
        "partial": "",
        "signature": "n-\u003earrow list a"
      }
    }
  }
]
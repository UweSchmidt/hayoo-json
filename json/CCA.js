[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "module",
        "fct-source": "src/Control-CCA-CCNF.html",
        "fct-type": "module",
        "title": "CCNF"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "CCNF",
        "normalized": "",
        "package": "CCA",
        "partial": "CCNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#t:ASyn",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "data",
        "fct-source": "src/Control-CCA-CCNF.html#ASyn",
        "fct-type": "data",
        "title": "ASyn"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "ASyn",
        "normalized": "",
        "package": "CCA",
        "partial": "ASyn",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:assoc",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "((t, t1), t2) -\u003e (t, (t1, t2))",
        "fct-source": "src/Control-CCA-CCNF.html#assoc",
        "fct-type": "function",
        "title": "assoc"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "assoc",
        "normalized": "((a,a),a)-\u003e(a,(a,a))",
        "package": "CCA",
        "partial": "",
        "signature": "((t,t),t)-\u003e(t,(t,t))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:cross",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "(t -\u003e t2) -\u003e (t1 -\u003e t3) -\u003e (t, t1) -\u003e (t2, t3)",
        "fct-source": "src/Control-CCA-CCNF.html#cross",
        "fct-type": "function",
        "title": "cross"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "cross",
        "normalized": "(a-\u003ea)-\u003e(a-\u003ea)-\u003e(a,a)-\u003e(a,a)",
        "package": "CCA",
        "partial": "",
        "signature": "(t-\u003et)-\u003e(t-\u003et)-\u003e(t,t)-\u003e(t,t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:dup",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "t -\u003e (t, t)",
        "fct-source": "src/Control-CCA-CCNF.html#dup",
        "fct-type": "function",
        "title": "dup"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "dup",
        "normalized": "a-\u003e(a,a)",
        "package": "CCA",
        "partial": "",
        "signature": "t-\u003e(t,t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:juggle",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "((t1, t), t2) -\u003e ((t1, t2), t)",
        "fct-source": "src/Control-CCA-CCNF.html#juggle",
        "fct-type": "function",
        "title": "juggle"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "juggle",
        "normalized": "((a,a),a)-\u003e((a,a),a)",
        "package": "CCA",
        "partial": "",
        "signature": "((t,t),t)-\u003e((t,t),t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:mirror",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "Either b a -\u003e Either a b",
        "fct-source": "src/Control-CCA-CCNF.html#mirror",
        "fct-type": "function",
        "title": "mirror"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "mirror",
        "normalized": "Either a b-\u003eEither b a",
        "package": "CCA",
        "partial": "",
        "signature": "Either b a-\u003eEither a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:norm",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "ASyn t t1 -\u003e ExpQ",
        "fct-source": "src/Control-CCA-CCNF.html#norm",
        "fct-type": "function",
        "title": "norm"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "norm",
        "normalized": "ASyn a a-\u003eExpQ",
        "package": "CCA",
        "partial": "",
        "signature": "ASyn t t-\u003eExpQ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:normOpt",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "ASyn t t1 -\u003e ExpQ",
        "fct-source": "src/Control-CCA-CCNF.html#normOpt",
        "fct-type": "function",
        "title": "normOpt"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "normOpt",
        "normalized": "ASyn a a-\u003eExpQ",
        "package": "CCA",
        "partial": "Opt",
        "signature": "ASyn t t-\u003eExpQ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:pprNorm",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "ASyn t t1 -\u003e Q Exp",
        "fct-source": "src/Control-CCA-CCNF.html#pprNorm",
        "fct-type": "function",
        "title": "pprNorm"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "pprNorm",
        "normalized": "ASyn a a-\u003eQ Exp",
        "package": "CCA",
        "partial": "Norm",
        "signature": "ASyn t t-\u003eQ Exp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:pprNormOpt",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "ASyn t t1 -\u003e Q Exp",
        "fct-source": "src/Control-CCA-CCNF.html#pprNormOpt",
        "fct-type": "function",
        "title": "pprNormOpt"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "pprNormOpt",
        "normalized": "ASyn a a-\u003eQ Exp",
        "package": "CCA",
        "partial": "Norm Opt",
        "signature": "ASyn t t-\u003eQ Exp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:printCCA",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "ASyn t t1 -\u003e IO ()",
        "fct-source": "src/Control-CCA-CCNF.html#printCCA",
        "fct-type": "function",
        "title": "printCCA"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "printCCA",
        "normalized": "ASyn a a-\u003eIO()",
        "package": "CCA",
        "partial": "CCA",
        "signature": "ASyn t t-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:swap",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "(t1, t) -\u003e (t, t1)",
        "fct-source": "src/Control-CCA-CCNF.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "swap",
        "normalized": "(a,a)-\u003e(a,a)",
        "package": "CCA",
        "partial": "",
        "signature": "(t,t)-\u003e(t,t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:tagT",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "(Either t t1, t2) -\u003e Either (t, t2) (t1, t2)",
        "fct-source": "src/Control-CCA-CCNF.html#tagT",
        "fct-type": "function",
        "title": "tagT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "tagT",
        "normalized": "(Either a a,a)-\u003eEither(a,a)(a,a)",
        "package": "CCA",
        "partial": "",
        "signature": "(Either t t,t)-\u003eEither(t,t)(t,t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:trace",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "((t1, t2) -\u003e (t, t2)) -\u003e t1 -\u003e t",
        "fct-source": "src/Control-CCA-CCNF.html#trace",
        "fct-type": "function",
        "title": "trace"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "trace",
        "normalized": "((a,a)-\u003e(a,a))-\u003ea-\u003ea",
        "package": "CCA",
        "partial": "",
        "signature": "((t,t)-\u003e(t,t))-\u003et-\u003et"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:unassoc",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "(t1, (t2, t)) -\u003e ((t1, t2), t)",
        "fct-source": "src/Control-CCA-CCNF.html#unassoc",
        "fct-type": "function",
        "title": "unassoc"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "unassoc",
        "normalized": "(a,(a,a))-\u003e((a,a),a)",
        "package": "CCA",
        "partial": "",
        "signature": "(t,(t,t))-\u003e((t,t),t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:untag",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "Either t t -\u003e t",
        "fct-source": "src/Control-CCA-CCNF.html#untag",
        "fct-type": "function",
        "title": "untag"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "untag",
        "normalized": "Either a a-\u003ea",
        "package": "CCA",
        "partial": "",
        "signature": "Either t t-\u003et"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-CCNF.html#v:untagT",
      "description": {
        "fct-module": "Control.CCA.CCNF",
        "fct-package": "CCA",
        "fct-signature": "Either (a, t) (b, t) -\u003e (Either a b, t)",
        "fct-source": "src/Control-CCA-CCNF.html#untagT",
        "fct-type": "function",
        "title": "untagT"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA CCNF",
        "module": "Control.CCA.CCNF",
        "name": "untagT",
        "normalized": "Either(a,b)(c,b)-\u003e(Either a c,b)",
        "package": "CCA",
        "partial": "",
        "signature": "Either(a,t)(b,t)-\u003e(Either a b,t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-Types.html#",
      "description": {
        "fct-module": "Control.CCA.Types",
        "fct-package": "CCA",
        "fct-signature": "module",
        "fct-source": "src/Control-CCA-Types.html",
        "fct-type": "module",
        "title": "Types"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA Types",
        "module": "Control.CCA.Types",
        "name": "Types",
        "normalized": "",
        "package": "CCA",
        "partial": "Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-Types.html#t:ArrowInit",
      "description": {
        "fct-module": "Control.CCA.Types",
        "fct-package": "CCA",
        "fct-signature": "class",
        "fct-source": "src/Control-CCA-Types.html#ArrowInit",
        "fct-type": "class",
        "title": "ArrowInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA Types",
        "module": "Control.CCA.Types",
        "name": "ArrowInit",
        "normalized": "",
        "package": "CCA",
        "partial": "Arrow Init",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-Types.html#v:arr-39-",
      "description": {
        "fct-module": "Control.CCA.Types",
        "fct-package": "CCA",
        "fct-signature": "ExpQ -\u003e (b -\u003e c) -\u003e a b c",
        "fct-source": "src/Control-CCA-Types.html#arr%27",
        "fct-type": "method",
        "title": "arr'"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA Types",
        "module": "Control.CCA.Types",
        "name": "arr'",
        "normalized": "ExpQ-\u003e(a-\u003eb)-\u003ec a b",
        "package": "CCA",
        "partial": "",
        "signature": "ExpQ-\u003e(b-\u003ec)-\u003ea b c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-Types.html#v:init",
      "description": {
        "fct-module": "Control.CCA.Types",
        "fct-package": "CCA",
        "fct-signature": "b -\u003e a b b",
        "fct-source": "src/Control-CCA-Types.html#init",
        "fct-type": "method",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA Types",
        "module": "Control.CCA.Types",
        "name": "init",
        "normalized": "a-\u003eb a a",
        "package": "CCA",
        "partial": "",
        "signature": "b-\u003ea b b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-Types.html#v:init-39-",
      "description": {
        "fct-module": "Control.CCA.Types",
        "fct-package": "CCA",
        "fct-signature": "ExpQ -\u003e b -\u003e a b b",
        "fct-source": "src/Control-CCA-Types.html#init%27",
        "fct-type": "method",
        "title": "init'"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA Types",
        "module": "Control.CCA.Types",
        "name": "init'",
        "normalized": "ExpQ-\u003ea-\u003eb a a",
        "package": "CCA",
        "partial": "",
        "signature": "ExpQ-\u003eb-\u003ea b b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA-Types.html#v:loopD",
      "description": {
        "fct-module": "Control.CCA.Types",
        "fct-package": "CCA",
        "fct-signature": "e -\u003e ((b, e) -\u003e (c, e)) -\u003e a b c",
        "fct-source": "src/Control-CCA-Types.html#loopD",
        "fct-type": "method",
        "title": "loopD"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA Types",
        "module": "Control.CCA.Types",
        "name": "loopD",
        "normalized": "a-\u003e((b,a)-\u003e(c,a))-\u003ed b c",
        "package": "CCA",
        "partial": "",
        "signature": "e-\u003e((b,e)-\u003e(c,e))-\u003ea b c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "module",
        "fct-source": "src/Control-CCA.html",
        "fct-type": "module",
        "title": "CCA"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "CCA",
        "normalized": "",
        "package": "CCA",
        "partial": "CCA",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#t:Arrow",
      "description": {
        "fct-descr": "\u003cp\u003eThe basic arrow class.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e, satisfying the laws\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e id = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e g) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e g) = \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e \u003e\u003e\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** g) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** g) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassoc\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassoc\u003c/code\u003e \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ewhere\n\u003c/p\u003e\u003cpre\u003e assoc ((a,b),c) = (a,(b,c))\n\u003c/pre\u003e\u003cp\u003eThe other combinators have sensible default definitions,\n which may be overridden for efficiency.\n\u003c/p\u003e",
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "class",
        "fct-type": "class",
        "title": "Arrow"
      },
      "index": {
        "description": "The basic arrow class Minimal complete definition arr and first satisfying the laws arr id id arr arr arr first arr arr first first first first first arr fst arr fst first arr id arr id first first first arr assoc arr assoc first where assoc The other combinators have sensible default definitions which may be overridden for efficiency",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "Arrow",
        "normalized": "",
        "package": "CCA",
        "partial": "Arrow",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#t:ArrowInit",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "class",
        "fct-source": "src/Control-CCA-Types.html#ArrowInit",
        "fct-type": "class",
        "title": "ArrowInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "ArrowInit",
        "normalized": "",
        "package": "CCA",
        "partial": "Arrow Init",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#t:ArrowLoop",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e operator expresses computations in which an output value\n is fed back as input, although the computation occurs only once.\n It underlies the \u003ccode\u003erec\u003c/code\u003e value recursion construct in arrow notation.\n \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003cem\u003eextension\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\\ b -\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efix\u003c/a\u003e\u003c/code\u003e (\\ (c,d) -\u003e f (b,d))))\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003eleft tightening\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e h \u003e\u003e\u003e f) = h \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003eright tightening\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e h) = \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e h\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003esliding\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** k)) = \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** k) \u003e\u003e\u003e f)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003evanishing\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e unassoc \u003e\u003e\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e assoc)\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003cem\u003esuperposing\u003c/em\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ccode\u003e\u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003eloop\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e assoc \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e unassoc)\u003c/code\u003e\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003ewhere\n\u003c/p\u003e\u003cpre\u003e assoc ((a,b),c) = (a,(b,c))\n unassoc (a,(b,c)) = ((a,b),c)\n\u003c/pre\u003e",
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "class",
        "fct-type": "class",
        "title": "ArrowLoop"
      },
      "index": {
        "description": "The loop operator expresses computations in which an output value is fed back as input although the computation occurs only once It underlies the rec value recursion construct in arrow notation loop should satisfy the following laws extension loop arr arr fst fix left tightening loop first loop right tightening loop first loop sliding loop arr id loop arr id vanishing loop loop loop arr unassoc arr assoc superposing second loop loop arr assoc second arr unassoc where assoc unassoc",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "ArrowLoop",
        "normalized": "",
        "package": "CCA",
        "partial": "Arrow Loop",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:-38--38--38-",
      "description": {
        "fct-descr": "\u003cp\u003eFanout: send the input to both argument arrows and combine\n   their output.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "a b c -\u003e a b c' -\u003e a b (c, c')",
        "fct-type": "method",
        "title": "(&&&)"
      },
      "index": {
        "description": "Fanout send the input to both argument arrows and combine their output The default definition may be overridden with more efficient version if desired",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "(&&&) &&&",
        "normalized": "a b c-\u003ea b d-\u003ea b(c,d)",
        "package": "CCA",
        "partial": "",
        "signature": "a b c-\u003ea b c'-\u003ea b(c,c')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:-42--42--42-",
      "description": {
        "fct-descr": "\u003cp\u003eSplit the input between the two argument arrows and combine\n   their output.  Note that this is in general not a functor.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "a b c -\u003e a b' c' -\u003e a (b, b') (c, c')",
        "fct-type": "method",
        "title": "(***)"
      },
      "index": {
        "description": "Split the input between the two argument arrows and combine their output Note that this is in general not functor The default definition may be overridden with more efficient version if desired",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "(***) ***",
        "normalized": "a b c-\u003ea d e-\u003ea(b,d)(c,e)",
        "package": "CCA",
        "partial": "",
        "signature": "a b c-\u003ea b' c'-\u003ea(b,b')(c,c')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:-60--60--60-",
      "description": {
        "fct-descr": "\u003cp\u003eRight-to-left composition\n\u003c/p\u003e",
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "cat b c -\u003e cat a b -\u003e cat a c",
        "fct-type": "function",
        "title": "(\u003c\u003c\u003c)"
      },
      "index": {
        "description": "Right-to-left composition",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "(\u003c\u003c\u003c) \u003c\u003c\u003c",
        "normalized": "a b c-\u003ea d b-\u003ea d c",
        "package": "CCA",
        "partial": "",
        "signature": "cat b c-\u003ecat a b-\u003ecat a c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:-62--62--62-",
      "description": {
        "fct-descr": "\u003cp\u003eLeft-to-right composition\n\u003c/p\u003e",
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "cat a b -\u003e cat b c -\u003e cat a c",
        "fct-type": "function",
        "title": "(\u003e\u003e\u003e)"
      },
      "index": {
        "description": "Left-to-right composition",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "(\u003e\u003e\u003e) \u003e\u003e\u003e",
        "normalized": "a b c-\u003ea c d-\u003ea b d",
        "package": "CCA",
        "partial": "",
        "signature": "cat a b-\u003ecat b c-\u003ecat a c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:arr",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "ExpQ -\u003e ExpQ",
        "fct-source": "src/Control-CCA.html#arr",
        "fct-type": "function",
        "title": "arr"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "arr",
        "normalized": "ExpQ-\u003eExpQ",
        "package": "CCA",
        "partial": "",
        "signature": "ExpQ-\u003eExpQ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:arr-39-",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "ExpQ -\u003e (b -\u003e c) -\u003e a b c",
        "fct-source": "src/Control-CCA-Types.html#arr%27",
        "fct-type": "method",
        "title": "arr'"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "arr'",
        "normalized": "ExpQ-\u003e(a-\u003eb)-\u003ec a b",
        "package": "CCA",
        "partial": "",
        "signature": "ExpQ-\u003e(b-\u003ec)-\u003ea b c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:constant",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "b -\u003e a () b",
        "fct-source": "src/Control-CCA.html#constant",
        "fct-type": "function",
        "title": "constant"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "constant",
        "normalized": "a-\u003eb()a",
        "package": "CCA",
        "partial": "",
        "signature": "b-\u003ea()b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:first",
      "description": {
        "fct-descr": "\u003cp\u003eSend the first component of the input through the argument\n   arrow, and copy the rest unchanged to the output.\n\u003c/p\u003e",
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "a b c -\u003e a (b, d) (c, d)",
        "fct-type": "method",
        "title": "first"
      },
      "index": {
        "description": "Send the first component of the input through the argument arrow and copy the rest unchanged to the output",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "first",
        "normalized": "a b c-\u003ea(b,d)(c,d)",
        "package": "CCA",
        "partial": "",
        "signature": "a b c-\u003ea(b,d)(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:init",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "ExpQ -\u003e ExpQ",
        "fct-source": "src/Control-CCA.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "init",
        "normalized": "ExpQ-\u003eExpQ",
        "package": "CCA",
        "partial": "",
        "signature": "ExpQ-\u003eExpQ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:init-39-",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "ExpQ -\u003e b -\u003e a b b",
        "fct-source": "src/Control-CCA-Types.html#init%27",
        "fct-type": "method",
        "title": "init'"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "init'",
        "normalized": "ExpQ-\u003ea-\u003eb a a",
        "package": "CCA",
        "partial": "",
        "signature": "ExpQ-\u003eb-\u003ea b b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:loop",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "a (b, d) (c, d) -\u003e a b c",
        "fct-type": "method",
        "title": "loop"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "loop",
        "normalized": "a(b,c)(d,c)-\u003ea b d",
        "package": "CCA",
        "partial": "",
        "signature": "a(b,d)(c,d)-\u003ea b c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:norm",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "ASyn t t1 -\u003e ExpQ",
        "fct-source": "src/Control-CCA-CCNF.html#norm",
        "fct-type": "function",
        "title": "norm"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "norm",
        "normalized": "ASyn a a-\u003eExpQ",
        "package": "CCA",
        "partial": "",
        "signature": "ASyn t t-\u003eExpQ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:normOpt",
      "description": {
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "ASyn t t1 -\u003e ExpQ",
        "fct-source": "src/Control-CCA-CCNF.html#normOpt",
        "fct-type": "function",
        "title": "normOpt"
      },
      "index": {
        "description": "",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "normOpt",
        "normalized": "ASyn a a-\u003eExpQ",
        "package": "CCA",
        "partial": "Opt",
        "signature": "ASyn t t-\u003eExpQ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Control-CCA.html#v:second",
      "description": {
        "fct-descr": "\u003cp\u003eA mirror image of \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
        "fct-module": "Control.CCA",
        "fct-package": "CCA",
        "fct-signature": "a b c -\u003e a (d, b) (d, c)",
        "fct-type": "method",
        "title": "second"
      },
      "index": {
        "description": "mirror image of first The default definition may be overridden with more efficient version if desired",
        "hierarchy": "Control CCA",
        "module": "Control.CCA",
        "name": "second",
        "normalized": "a b c-\u003ea(d,b)(d,c)",
        "package": "CCA",
        "partial": "",
        "signature": "a b c-\u003ea(d,b)(d,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Language-Haskell-TH-Instances.html#",
      "description": {
        "fct-module": "Language.Haskell.TH.Instances",
        "fct-package": "CCA",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-TH-Instances.html",
        "fct-type": "module",
        "title": "Instances"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Instances",
        "module": "Language.Haskell.TH.Instances",
        "name": "Instances",
        "normalized": "",
        "package": "CCA",
        "partial": "Instances",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/CCA/docs/Language-Haskell-TH-Instances.html#v:fromInt",
      "description": {
        "fct-module": "Language.Haskell.TH.Instances",
        "fct-package": "CCA",
        "fct-signature": "Int -\u003e Int#",
        "fct-source": "src/Language-Haskell-TH-Instances.html#fromInt",
        "fct-type": "function",
        "title": "fromInt"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Instances",
        "module": "Language.Haskell.TH.Instances",
        "name": "fromInt",
        "normalized": "Int-\u003eInt #",
        "package": "CCA",
        "partial": "Int",
        "signature": "Int-\u003eInt #"
      }
    }
  }
]
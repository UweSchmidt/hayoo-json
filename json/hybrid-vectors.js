[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Internal.html#",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Hybrid-Internal.html",
        "fct-type": "module",
        "title": "Internal"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Internal",
        "module": "Data.Vector.Hybrid.Internal",
        "name": "Internal",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Internal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Internal.html#t:MVector",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Hybrid-Internal.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Internal",
        "module": "Data.Vector.Hybrid.Internal",
        "name": "MVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Internal.html#t:Vector",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Hybrid-Internal.html#Vector",
        "fct-type": "data",
        "title": "Vector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Internal",
        "module": "Data.Vector.Hybrid.Internal",
        "name": "Vector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Internal.html#v:MV",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "!(u s a) -\u003e !(v s b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Internal.html#MVector",
        "fct-type": "function",
        "title": "MV"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Internal",
        "module": "Data.Vector.Hybrid.Internal",
        "name": "MV",
        "normalized": "(a b c)-\u003e(d b e)-\u003eMVector a d b(c,e)",
        "package": "hybrid-vectors",
        "partial": "MV",
        "signature": "(u s a)-\u003e(v s b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Internal.html#v:V",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "!(u a) -\u003e !(v b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Internal.html#Vector",
        "fct-type": "function",
        "title": "V"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Internal",
        "module": "Data.Vector.Hybrid.Internal",
        "name": "V",
        "normalized": "(a b)-\u003e(c d)-\u003eVector a c(b,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(u a)-\u003e(v b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html",
        "fct-type": "module",
        "title": "Mutable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#t:IOVector",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#IOVector",
        "fct-type": "type",
        "title": "IOVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "IOVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "IOVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#t:MVector",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Hybrid-Internal.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#t:STVector",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#STVector",
        "fct-type": "type",
        "title": "STVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "STVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "STVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:clear",
      "description": {
        "fct-descr": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed vectors. \n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#clear",
        "fct-type": "function",
        "title": "clear"
      },
      "index": {
        "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "clear",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v(PrimState m)(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a copy of a mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e m (MVector u v (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Create copy of mutable vector",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "clone",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003ec(MVector a b(PrimState c)(d,e))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v(PrimState m)(a,b)-\u003em(MVector u v(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e MVector u v (PrimState m) (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "copy",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eMVector a b(PrimState c)(d,e)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eMVector u v(PrimState m)(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:drop",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "drop",
        "normalized": "Int-\u003eMVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eMVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:grow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e Int -\u003e m (MVector u v (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#grow",
        "fct-type": "function",
        "title": "grow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "grow",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eInt-\u003ec(MVector a b(PrimState c)(d,e))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eInt-\u003em(MVector u v(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:init",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "init",
        "normalized": "MVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e Int",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of the mutable vector",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "length",
        "normalized": "MVector a b c(d,e)-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v s(a,b)-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e m (MVector u v (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "Create mutable vector of the given length",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "new",
        "normalized": "Int-\u003ea(MVector b c(PrimState a)(d,e))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003em(MVector u v(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:newWith",
      "description": {
        "fct-descr": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use replicate instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eDEPRECATED\u003c/em\u003e Use \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e instead\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (a, b) -\u003e m (MVector u v (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#newWith",
        "fct-type": "function",
        "title": "newWith"
      },
      "index": {
        "description": "Deprecated Use replicate instead DEPRECATED Use replicate instead",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "newWith",
        "normalized": "Int-\u003e(a,b)-\u003ec(MVector d e(PrimState c)(a,b))",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "Int-\u003e(a,b)-\u003em(MVector u v(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e Bool",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check whether the vector is empty",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "null",
        "normalized": "MVector a b c(d,e)-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v s(a,b)-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:overlaps",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e MVector u v s (a, b) -\u003e Bool",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#overlaps",
        "fct-type": "function",
        "title": "overlaps"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "overlaps",
        "normalized": "MVector a b c(d,e)-\u003eMVector a b c(d,e)-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v s(a,b)-\u003eMVector u v s(a,b)-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:projectFst",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e u s a",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#projectFst",
        "fct-type": "function",
        "title": "projectFst"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "projectFst",
        "normalized": "MVector a b c(d,e)-\u003ea c d",
        "package": "hybrid-vectors",
        "partial": "Fst",
        "signature": "MVector u v s(a,b)-\u003eu s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:projectSnd",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e v s b",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#projectSnd",
        "fct-type": "function",
        "title": "projectSnd"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "projectSnd",
        "normalized": "MVector a b c(d,e)-\u003eb c e",
        "package": "hybrid-vectors",
        "partial": "Snd",
        "signature": "MVector u v s(a,b)-\u003ev s b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e Int -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Yield the element at the given position",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "read",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eInt-\u003ec(d,e)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eInt-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with an initial value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (a, b) -\u003e m (MVector u v (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with an initial value",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "replicate",
        "normalized": "Int-\u003e(a,b)-\u003ec(MVector d e(PrimState c)(a,b))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(a,b)-\u003em(MVector u v(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003eSet all elements of the vector to the given value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#set",
        "fct-type": "function",
        "title": "set"
      },
      "index": {
        "description": "Set all elements of the vector to the given value",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "set",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003e(d,e)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v(PrimState m)(a,b)-\u003e(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e Int -\u003e MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eMVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eMVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:swap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "Swap the elements at the given positions",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "swap",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eInt-\u003eInt-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "tail",
        "normalized": "MVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:take",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "take",
        "normalized": "Int-\u003eMVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eMVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b)-\u003e MVector u v (PrimState m) (a, b)-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap This is not checked",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeCopy",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eMVector a b(PrimState c)(d,e)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "Copy",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eMVector u v(PrimState m)(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeDrop",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eMVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "Drop",
        "signature": "Int-\u003eMVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeGrow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e Int -\u003e m (MVector u v (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeGrow",
        "fct-type": "function",
        "title": "unsafeGrow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive but this is not checked",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeGrow",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eInt-\u003ec(MVector a b(PrimState c)(d,e))",
        "package": "hybrid-vectors",
        "partial": "Grow",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eInt-\u003em(MVector u v(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeInit",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeInit",
        "normalized": "MVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "Init",
        "signature": "MVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeNew",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length. The length is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e m (MVector u v (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeNew",
        "fct-type": "function",
        "title": "unsafeNew"
      },
      "index": {
        "description": "Create mutable vector of the given length The length is not checked",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeNew",
        "normalized": "Int-\u003ea(MVector b c(PrimState a)(d,e))",
        "package": "hybrid-vectors",
        "partial": "New",
        "signature": "Int-\u003em(MVector u v(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeNewWith",
      "description": {
        "fct-descr": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use replicate instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eDEPRECATED\u003c/em\u003e Use \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e instead\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (a, b) -\u003e m (MVector u v (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeNewWith",
        "fct-type": "function",
        "title": "unsafeNewWith"
      },
      "index": {
        "description": "Deprecated Use replicate instead DEPRECATED Use replicate instead",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeNewWith",
        "normalized": "Int-\u003e(a,b)-\u003ec(MVector d e(PrimState c)(a,b))",
        "package": "hybrid-vectors",
        "partial": "New With",
        "signature": "Int-\u003e(a,b)-\u003em(MVector u v(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e Int -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeRead",
        "fct-type": "function",
        "title": "unsafeRead"
      },
      "index": {
        "description": "Yield the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeRead",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eInt-\u003ec(d,e)",
        "package": "hybrid-vectors",
        "partial": "Read",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eInt-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it. No bounds checks\n are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int-\u003e Int-\u003e MVector u v s (a, b)-\u003e MVector u v s (a, b)",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it No bounds checks are performed",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eMVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eMVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeSwap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeSwap",
        "fct-type": "function",
        "title": "unsafeSwap"
      },
      "index": {
        "description": "Swap the elements at the given positions No bounds checks are performed",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeSwap",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eInt-\u003eInt-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "Swap",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeTail",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeTail",
        "normalized": "MVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "Tail",
        "signature": "MVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeTake",
      "description": {
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e MVector u v s (a, b) -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeTake",
        "normalized": "Int-\u003eMVector a b c(d,e)-\u003eMVector a b c(d,e)",
        "package": "hybrid-vectors",
        "partial": "Take",
        "signature": "Int-\u003eMVector u v s(a,b)-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e Int -\u003e (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeWrite",
        "fct-type": "function",
        "title": "unsafeWrite"
      },
      "index": {
        "description": "Replace the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeWrite",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eInt-\u003e(d,e)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "Write",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eInt-\u003e(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:unsafeZip",
      "description": {
        "fct-descr": "\u003cp\u003eThe mutable vectors are assumed to be of the same length and to not overlap. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u s a -\u003e v s b -\u003e MVector u v s (a, b)",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#unsafeZip",
        "fct-type": "function",
        "title": "unsafeZip"
      },
      "index": {
        "description": "The mutable vectors are assumed to be of the same length and to not overlap This is not checked",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "unsafeZip",
        "normalized": "a b c-\u003ed b e-\u003eMVector a d b(c,e)",
        "package": "hybrid-vectors",
        "partial": "Zip",
        "signature": "u s a-\u003ev s b-\u003eMVector u v s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid-Mutable.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector u v (PrimState m) (a, b) -\u003e Int -\u003e (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid-Mutable.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Replace the element at the given position",
        "hierarchy": "Data Vector Hybrid Mutable",
        "module": "Data.Vector.Hybrid.Mutable",
        "name": "write",
        "normalized": "MVector a b(PrimState c)(d,e)-\u003eInt-\u003e(d,e)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector u v(PrimState m)(a,b)-\u003eInt-\u003e(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA hybrid \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e lets you make a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e which is 'partially unboxed', by\n making a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e out of two other \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e types and using each for its\n corresponding side of a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e of pairs.\n\u003c/p\u003e\u003cp\u003eThis enables you to work with a mixture of boxed and unboxed data when\n you go to use something \u003ccode\u003elike vector-algorithms\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Hybrid.html",
        "fct-type": "module",
        "title": "Hybrid"
      },
      "index": {
        "description": "hybrid Vector lets you make Vector which is partially unboxed by making Vector out of two other Vector types and using each for its corresponding side of Vector of pairs This enables you to work with mixture of boxed and unboxed data when you go to use something like vector-algorithms",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "Hybrid",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Hybrid",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#t:MVector",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Hybrid-Internal.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "MVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#t:Vector",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Hybrid-Internal.html#Vector",
        "fct-type": "data",
        "title": "Vector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "Vector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Int -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Indexing",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "(!) !",
        "normalized": "Vector a b(c,d)-\u003eInt-\u003e(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eInt-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Safe indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Int -\u003e Maybe (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Safe indexing",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "(!?) !?",
        "normalized": "Vector a b(c,d)-\u003eInt-\u003eMaybe(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eInt-\u003eMaybe(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e Concatenate two vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two vectors",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "(++) ++",
        "normalized": "Vector a b(c,d)-\u003eVector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:-47--47-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the list, replace the vector\n element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003c5,9,2,7\u003e // [(2,1),(0,3),(2,8)] = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b)-\u003e [(Int, (a, b))]-\u003e Vector u v (a, b)",
        "fct-type": "function",
        "title": "(//)"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "(//) //",
        "normalized": "Vector a b(c,d)-\u003e[(Int,(c,d))]-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003e[(Int,(a,b))]-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:accum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,c)\u003c/code\u003e from the list, replace the vector element\n \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a c\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accum (+) \u003c5,9,2\u003e [(2,4),(1,6),(0,3),(1,7)] = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e c -\u003e (a, b))-\u003e Vector u v (a, b)-\u003e [(Int, c)]-\u003e Vector u v (a, b)",
        "fct-type": "function",
        "title": "accum"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by accum",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "accum",
        "normalized": "((a,b)-\u003ec-\u003e(a,b))-\u003eVector d e(a,b)-\u003e[(Int,c)]-\u003eVector d e(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003ec-\u003e(a,b))-\u003eVector u v(a,b)-\u003e[(Int,c)]-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e Bool",
        "fct-source": "src/Data-Vector-Hybrid.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Check if all elements satisfy the predicate",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "all",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e Bool",
        "fct-source": "src/Data-Vector-Hybrid.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Check if any element satisfies the predicate",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "any",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that do not\n satisfy the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e (Vector u v (a, b), Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that do not satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "break",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003e(Vector c d(a,b),Vector c d(a,b))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003e(Vector u v(a,b),Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate all vectors in the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "[Vector u v (a, b)] -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate all vectors in the list",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "concat",
        "normalized": "[Vector a b(c,d)]-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "[Vector u v(a,b)]-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a vector and concatenate the results.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Vector u v (c, d)) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over vector and concatenate the results",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "concatMap",
        "normalized": "((a,b)-\u003eVector c d(e,f))-\u003eVector c d(a,b)-\u003eVector c d(e,f)",
        "package": "hybrid-vectors",
        "partial": "Map",
        "signature": "((a,b)-\u003eVector u v(c,d))-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a, b) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "cons",
        "normalized": "(a,b)-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a,b)-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:constructN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements by repeatedly applying the\n generator function to the already constructed part of the vector.\n\u003c/p\u003e\u003cpre\u003e constructN 3 f = let a = f \u003c\u003e ; b = f \u003ca\u003e ; c = f \u003ca,b\u003e in f \u003ca,b,c\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (Vector u v (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#constructN",
        "fct-type": "function",
        "title": "constructN"
      },
      "index": {
        "description": "Construct vector with elements by repeatedly applying the generator function to the already constructed part of the vector constructN let in",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "constructN",
        "normalized": "Int-\u003e(Vector a b(c,d)-\u003e(c,d))-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(Vector u v(a,b)-\u003e(a,b))-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:constructrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements from right to left by\n repeatedly applying the generator function to the already constructed part\n of the vector.\n\u003c/p\u003e\u003cpre\u003e constructrN 3 f = let a = f \u003c\u003e ; b = f\u003ca\u003e ; c = f \u003cb,a\u003e in f \u003cc,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (Vector u v (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#constructrN",
        "fct-type": "function",
        "title": "constructrN"
      },
      "index": {
        "description": "Construct vector with elements from right to left by repeatedly applying the generator function to the already constructed part of the vector constructrN let in",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "constructrN",
        "normalized": "Int-\u003e(Vector a b(c,d)-\u003e(c,d))-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(Vector u v(a,b)-\u003e(a,b))-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:convert",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert different vector types\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e w a",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "Convert different vector types",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "convert",
        "normalized": "a b-\u003ec b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Mutable (Vector u v) (PrimState m) (a, b) -\u003e Vector u v (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "copy",
        "normalized": "Mutable(Vector a b)(PrimState c)(d,e)-\u003eVector a b(d,e)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Mutable(Vector u v)(PrimState m)(a,b)-\u003eVector u v(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:create",
      "description": {
        "fct-descr": "\u003cp\u003eExecute the monadic action and freeze the resulting vector.\n\u003c/p\u003e\u003cpre\u003e\n create (do { v \u003c- new 2; write v 0 'a'; write v 1 'b'; return v }) = \u003c\u003ccode\u003ea\u003c/code\u003e,\u003ccode\u003eb\u003c/code\u003e\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(forall s.  ST s (Mutable (Vector u v) s (a, b))) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "Execute the monadic action and freeze the resulting vector create do new write write return",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "create",
        "normalized": "(a b ST c(Mutable(Vector d e)c(f,g)))-\u003eVector d e(f,g)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(forall s. ST s(Mutable(Vector u v)s(a,b)))-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case an empty vector is returned.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector may contain less than elements in which case an empty vector is returned",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "drop",
        "normalized": "Int-\u003eVector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop the longest prefix of elements that satisfy the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate without copying",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "dropWhile",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "While",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a, b) -\u003e Vector u v (a, b) -\u003e Bool",
        "fct-source": "src/Data-Vector-Hybrid.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check if the vector contains an element",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "elem",
        "normalized": "(a,b)-\u003eVector c d(a,b)-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a,b)-\u003eVector u v(a,b)-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first occurence of the given element or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the vector does not contain the element. This is a specialised\n version of \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a, b) -\u003e Vector u v (a, b) -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Hybrid.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "Yield Just the index of the first occurence of the given element or Nothing if the vector does not contain the element This is specialised version of findIndex",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "elemIndex",
        "normalized": "(a,b)-\u003eVector c d(a,b)-\u003eMaybe Int",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "(a,b)-\u003eVector u v(a,b)-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "empty",
        "normalized": "Vector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "filter",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e m Bool) -\u003e Vector u v (a, b) -\u003e m (Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Drop elements that do not satisfy the monadic predicate",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "filterM",
        "normalized": "((a,b)-\u003ec Bool)-\u003eVector d e(a,b)-\u003ec(Vector d e(a,b))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003em Bool)-\u003eVector u v(a,b)-\u003em(Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e Maybe (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "find",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003eMaybe(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003eMaybe(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Hybrid.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "findIndex",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003eMaybe Int",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e m (a, b)) -\u003e Vector u v (a, b) -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "fold1M",
        "normalized": "((a,b)-\u003e(a,b)-\u003ec(a,b))-\u003eVector d e(a,b)-\u003ec(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003em(a,b))-\u003eVector u v(a,b)-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e m (a, b)) -\u003e Vector u v (a, b) -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "fold1M'",
        "normalized": "((a,b)-\u003e(a,b)-\u003ec(a,b))-\u003eVector d e(a,b)-\u003ec(a,b)",
        "package": "hybrid-vectors",
        "partial": "M'",
        "signature": "((a,b)-\u003e(a,b)-\u003em(a,b))-\u003eVector u v(a,b)-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:fold1M-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e m (a, b)) -\u003e Vector u v (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#fold1M%27_",
        "fct-type": "function",
        "title": "fold1M'_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator that discards the result",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "fold1M'_",
        "normalized": "((a,b)-\u003e(a,b)-\u003ec(a,b))-\u003eVector d e(a,b)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "M'",
        "signature": "((a,b)-\u003e(a,b)-\u003em(a,b))-\u003eVector u v(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:fold1M_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e m (a, b)) -\u003e Vector u v (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#fold1M_",
        "fct-type": "function",
        "title": "fold1M_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors that discards the result",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "fold1M_",
        "normalized": "((a,b)-\u003e(a,b)-\u003ec(a,b))-\u003eVector d e(a,b)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003em(a,b))-\u003eVector u v(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(r -\u003e (a, b) -\u003e m r) -\u003e r -\u003e Vector u v (a, b) -\u003e m r",
        "fct-source": "src/Data-Vector-Hybrid.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldM",
        "normalized": "(a-\u003e(b,c)-\u003ed a)-\u003ea-\u003eVector e f(b,c)-\u003ed a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(r-\u003e(a,b)-\u003em r)-\u003er-\u003eVector u v(a,b)-\u003em r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(r -\u003e (a, b) -\u003e m r) -\u003e r -\u003e Vector u v (a, b) -\u003e m r",
        "fct-source": "src/Data-Vector-Hybrid.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Monadic fold with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldM'",
        "normalized": "(a-\u003e(b,c)-\u003ed a)-\u003ea-\u003eVector e f(b,c)-\u003ed a",
        "package": "hybrid-vectors",
        "partial": "M'",
        "signature": "(r-\u003e(a,b)-\u003em r)-\u003er-\u003eVector u v(a,b)-\u003em r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldM-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(r -\u003e (a, b) -\u003e m r) -\u003e r -\u003e Vector u v (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#foldM%27_",
        "fct-type": "function",
        "title": "foldM'_"
      },
      "index": {
        "description": "Monadic fold with strict accumulator that discards the result",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldM'_",
        "normalized": "(a-\u003e(b,c)-\u003ed a)-\u003ea-\u003eVector e f(b,c)-\u003ed()",
        "package": "hybrid-vectors",
        "partial": "M'",
        "signature": "(r-\u003e(a,b)-\u003em r)-\u003er-\u003eVector u v(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(r -\u003e (a, b) -\u003e m r) -\u003e r -\u003e Vector u v (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#foldM_",
        "fct-type": "function",
        "title": "foldM_"
      },
      "index": {
        "description": "Monadic fold that discards the result",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldM_",
        "normalized": "(a-\u003e(b,c)-\u003ed a)-\u003ea-\u003eVector e f(b,c)-\u003ed()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(r-\u003e(a,b)-\u003em r)-\u003er-\u003eVector u v(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(r -\u003e (a, b) -\u003e r) -\u003e r -\u003e Vector u v (a, b) -\u003e r",
        "fct-source": "src/Data-Vector-Hybrid.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldl",
        "normalized": "(a-\u003e(b,c)-\u003ea)-\u003ea-\u003eVector d e(b,c)-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(r-\u003e(a,b)-\u003er)-\u003er-\u003eVector u v(a,b)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(r -\u003e (a, b) -\u003e r) -\u003e r -\u003e Vector u v (a, b) -\u003e r",
        "fct-source": "src/Data-Vector-Hybrid.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldl'",
        "normalized": "(a-\u003e(b,c)-\u003ea)-\u003ea-\u003eVector d e(b,c)-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(r-\u003e(a,b)-\u003er)-\u003er-\u003eVector u v(a,b)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold on non-empty vectors",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldl1",
        "normalized": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector c d(a,b)-\u003e(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldl1'",
        "normalized": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector c d(a,b)-\u003e(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e r -\u003e r) -\u003e r -\u003e Vector u v (a, b) -\u003e r",
        "fct-source": "src/Data-Vector-Hybrid.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldr",
        "normalized": "((a,b)-\u003ec-\u003ec)-\u003ec-\u003eVector d e(a,b)-\u003ec",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003er-\u003er)-\u003er-\u003eVector u v(a,b)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e r -\u003e r) -\u003e r -\u003e Vector u v (a, b) -\u003e r",
        "fct-source": "src/Data-Vector-Hybrid.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldr'",
        "normalized": "((a,b)-\u003ec-\u003ec)-\u003ec-\u003eVector d e(a,b)-\u003ec",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003er-\u003er)-\u003er-\u003eVector u v(a,b)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold on non-empty vectors",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldr1",
        "normalized": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector c d(a,b)-\u003e(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "Right fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "foldr1'",
        "normalized": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector c d(a,b)-\u003e(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:forM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results. Equvalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e ((a, b) -\u003e m (c, d)) -\u003e m (Vector u v (c, d))",
        "fct-source": "src/Data-Vector-Hybrid.html#forM",
        "fct-type": "function",
        "title": "forM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results Equvalent to flip mapM",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "forM",
        "normalized": "Vector a b(c,d)-\u003e((c,d)-\u003ee(f,g))-\u003ee(Vector a b(f,g))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003e((a,b)-\u003em(c,d))-\u003em(Vector u v(c,d))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:forM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results. Equivalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e ((a, b) -\u003e m (c, d)) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#forM_",
        "fct-type": "function",
        "title": "forM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results Equivalent to flip mapM",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "forM_",
        "normalized": "Vector a b(c,d)-\u003e((c,d)-\u003ee(f,g))-\u003ee()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003e((a,b)-\u003em(c,d))-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:force",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the argument but force it not to retain any extra memory,\n possibly by copying it.\n\u003c/p\u003e\u003cp\u003eThis is especially useful when dealing with slices. For example:\n\u003c/p\u003e\u003cpre\u003e force (slice 0 2 \u003chuge vector\u003e)\n\u003c/pre\u003e\u003cp\u003eHere, the slice retains a reference to the huge vector. Forcing it creates\n a copy of just the elements that belong to the slice and allows the huge\n vector to be garbage collected.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#force",
        "fct-type": "function",
        "title": "force"
      },
      "index": {
        "description": "Yield the argument but force it not to retain any extra memory possibly by copying it This is especially useful when dealing with slices For example force slice huge vector Here the slice retains reference to the huge vector Forcing it creates copy of just the elements that belong to the slice and allows the huge vector to be garbage collected",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "force",
        "normalized": "Vector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:freeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield an immutable copy of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Mutable (Vector u v) (PrimState m) (a, b) -\u003e m (Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#freeze",
        "fct-type": "function",
        "title": "freeze"
      },
      "index": {
        "description": "Yield an immutable copy of the mutable vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "freeze",
        "normalized": "Mutable(Vector a b)(PrimState c)(d,e)-\u003ec(Vector a b(d,e))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Mutable(Vector u v)(PrimState m)(a,b)-\u003em(Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a list to a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "[(a, b)] -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "fromList",
        "normalized": "[(a,b)]-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "List",
        "signature": "[(a,b)]-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a vector\n\u003c/p\u003e\u003cpre\u003e\n fromListN n xs = \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e [(a, b)] -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Convert the first elements of list to vector fromListN xs fromList take xs",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "fromListN",
        "normalized": "Int-\u003e[(a,b)]-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "List",
        "signature": "Int-\u003e[(a,b)]-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the function to\n each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (Int -\u003e (a, b)) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Construct vector of the given length by applying the function to each index",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003e(a,b))-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003e(a,b))-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the monadic\n action to each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (Int -\u003e m (a, b)) -\u003e m (Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Construct vector of the given length by applying the monadic action to each index",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "generateM",
        "normalized": "Int-\u003e(Int-\u003ea(b,c))-\u003ea(Vector d e(b,c))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003em(a,b))-\u003em(Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "head",
        "normalized": "Vector a b(c,d)-\u003e(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:headM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#headM",
        "fct-type": "function",
        "title": "headM"
      },
      "index": {
        "description": "First element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "headM",
        "normalized": "Vector a b(c,d)-\u003ee(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:ifilter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate which is applied to\n values and their indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#ifilter",
        "fct-type": "function",
        "title": "ifilter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate which is applied to values and their indices",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "ifilter",
        "normalized": "(Int-\u003e(a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(Int-\u003e(a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(r -\u003e Int -\u003e (a, b) -\u003e r) -\u003e r -\u003e Vector u v (a, b) -\u003e r",
        "fct-source": "src/Data-Vector-Hybrid.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold function applied to each element and its index",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003e(b,c)-\u003ea)-\u003ea-\u003eVector d e(b,c)-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(r-\u003eInt-\u003e(a,b)-\u003er)-\u003er-\u003eVector u v(a,b)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:ifoldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator (function applied to each element\n and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(r -\u003e Int -\u003e (a, b) -\u003e r) -\u003e r -\u003e Vector u v (a, b) -\u003e r",
        "fct-source": "src/Data-Vector-Hybrid.html#ifoldl%27",
        "fct-type": "function",
        "title": "ifoldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "ifoldl'",
        "normalized": "(a-\u003eInt-\u003e(b,c)-\u003ea)-\u003ea-\u003eVector d e(b,c)-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(r-\u003eInt-\u003e(a,b)-\u003er)-\u003er-\u003eVector u v(a,b)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, b) -\u003e r -\u003e r) -\u003e r -\u003e Vector u v (a, b) -\u003e r",
        "fct-source": "src/Data-Vector-Hybrid.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Right fold function applied to each element and its index",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "ifoldr",
        "normalized": "(Int-\u003e(a,b)-\u003ec-\u003ec)-\u003ec-\u003eVector d e(a,b)-\u003ec",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(Int-\u003e(a,b)-\u003er-\u003er)-\u003er-\u003eVector u v(a,b)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:ifoldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with strict accumulator (function applied to each\n element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, b) -\u003e r -\u003e r) -\u003e r -\u003e Vector u v (a, b) -\u003e r",
        "fct-source": "src/Data-Vector-Hybrid.html#ifoldr%27",
        "fct-type": "function",
        "title": "ifoldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "ifoldr'",
        "normalized": "(Int-\u003e(a,b)-\u003ec-\u003ec)-\u003ec-\u003eVector d e(a,b)-\u003ec",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(Int-\u003e(a,b)-\u003er-\u003er)-\u003er-\u003eVector u v(a,b)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply a function to every element of a vector and its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, b) -\u003e (c, d)) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of vector and its index",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "imap",
        "normalized": "(Int-\u003e(a,b)-\u003e(c,d))-\u003eVector e f(a,b)-\u003eVector e f(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(Int-\u003e(a,b)-\u003e(c,d))-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:indexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad.\n\u003c/p\u003e\u003cp\u003eThe monad allows operations to be strict in the vector when necessary.\n Suppose vector copying is implemented like this:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... write mv i (v ! i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, \u003ccode\u003ev ! i\u003c/code\u003e would not be evaluated which means that \u003ccode\u003emv\u003c/code\u003e\n would unnecessarily retain a reference to \u003ccode\u003ev\u003c/code\u003e in each element written.\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e, copying can be implemented like this instead:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... do\n                   x \u003c- indexM v i\n                   write mv i x\n\u003c/pre\u003e\u003cp\u003eHere, no references to \u003ccode\u003ev\u003c/code\u003e are retained because indexing (but \u003cem\u003enot\u003c/em\u003e the\n elements) is evaluated eagerly.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Int -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#indexM",
        "fct-type": "function",
        "title": "indexM"
      },
      "index": {
        "description": "Indexing in monad The monad allows operations to be strict in the vector when necessary Suppose vector copying is implemented like this copy mv write mv For lazy vectors would not be evaluated which means that mv would unnecessarily retain reference to in each element written With indexM copying can be implemented like this instead copy mv do indexM write mv Here no references to are retained because indexing but not the elements is evaluated eagerly",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "indexM",
        "normalized": "Vector a b(c,d)-\u003eInt-\u003ee(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eInt-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "init",
        "normalized": "Vector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e ((a, b) -\u003e (a, b)) -\u003e (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function times to value Zeroth element is original value",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "iterateN",
        "normalized": "Int-\u003e((a,b)-\u003e(a,b))-\u003e(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e((a,b)-\u003e(a,b))-\u003e(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with a function that also takes the\n elements' indices.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, a') -\u003e (b, b') -\u003e (c, c')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c')",
        "fct-source": "src/Data-Vector-Hybrid.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "min Zip two vectors with function that also takes the elements indices",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "izipWith",
        "normalized": "(Int-\u003e(a,b)-\u003e(c,d)-\u003e(e,f))-\u003eVector g h(a,b)-\u003eVector g h(c,d)-\u003eVector g h(e,f)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003e(a,a')-\u003e(b,b')-\u003e(c,c'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:izipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors and their indices with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, a') -\u003e (b, b') -\u003e (c, c') -\u003e (d, d')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c') -\u003e Vector u v (d, d')",
        "fct-source": "src/Data-Vector-Hybrid.html#izipWith3",
        "fct-type": "function",
        "title": "izipWith3"
      },
      "index": {
        "description": "Zip three vectors and their indices with the given function",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "izipWith3",
        "normalized": "(Int-\u003e(a,b)-\u003e(c,d)-\u003e(e,f)-\u003e(g,h))-\u003eVector i j(a,b)-\u003eVector i j(c,d)-\u003eVector i j(e,f)-\u003eVector i j(g,h)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003e(a,a')-\u003e(b,b')-\u003e(c,c')-\u003e(d,d'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')-\u003eVector u v(d,d')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:izipWith4",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, a') -\u003e (b, b') -\u003e (c, c') -\u003e (d, d') -\u003e (e, e')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c') -\u003e Vector u v (d, d') -\u003e Vector u v (e, e')",
        "fct-source": "src/Data-Vector-Hybrid.html#izipWith4",
        "fct-type": "function",
        "title": "izipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "izipWith4",
        "normalized": "(Int-\u003e(a,b)-\u003e(c,d)-\u003e(e,f)-\u003e(g,h)-\u003e(i,j))-\u003eVector k l(a,b)-\u003eVector k l(c,d)-\u003eVector k l(e,f)-\u003eVector k l(g,h)-\u003eVector k l(i,j)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003e(a,a')-\u003e(b,b')-\u003e(c,c')-\u003e(d,d')-\u003e(e,e'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')-\u003eVector u v(d,d')-\u003eVector u v(e,e')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:izipWith5",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, a') -\u003e (b, b') -\u003e (c, c') -\u003e (d, d') -\u003e (e, e') -\u003e (f, f')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c') -\u003e Vector u v (d, d') -\u003e Vector u v (e, e') -\u003e Vector u v (f, f')",
        "fct-source": "src/Data-Vector-Hybrid.html#izipWith5",
        "fct-type": "function",
        "title": "izipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "izipWith5",
        "normalized": "(Int-\u003e(a,b)-\u003e(c,d)-\u003e(e,f)-\u003e(g,h)-\u003e(i,j)-\u003e(k,l))-\u003eVector m n(a,b)-\u003eVector m n(c,d)-\u003eVector m n(e,f)-\u003eVector m n(g,h)-\u003eVector m n(i,j)-\u003eVector m n(k,l)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003e(a,a')-\u003e(b,b')-\u003e(c,c')-\u003e(d,d')-\u003e(e,e')-\u003e(f,f'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')-\u003eVector u v(d,d')-\u003eVector u v(e,e')-\u003eVector u v(f,f')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:izipWith6",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e (a, a') -\u003e (b, b') -\u003e (c, c') -\u003e (d, d') -\u003e (e, e') -\u003e (f, f') -\u003e (g, g')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c') -\u003e Vector u v (d, d') -\u003e Vector u v (e, e') -\u003e Vector u v (f, f') -\u003e Vector u v (g, g')",
        "fct-source": "src/Data-Vector-Hybrid.html#izipWith6",
        "fct-type": "function",
        "title": "izipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "izipWith6",
        "normalized": "(Int-\u003e(a,b)-\u003e(c,d)-\u003e(e,f)-\u003e(g,h)-\u003e(i,j)-\u003e(k,l)-\u003e(m,n))-\u003eVector o p(a,b)-\u003eVector o p(c,d)-\u003eVector o p(e,f)-\u003eVector o p(g,h)-\u003eVector o p(i,j)-\u003eVector o p(k,l)-\u003eVector o p(m,n)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003e(a,a')-\u003e(b,b')-\u003e(c,c')-\u003e(d,d')-\u003e(e,e')-\u003e(f,f')-\u003e(g,g'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')-\u003eVector u v(d,d')-\u003eVector u v(e,e')-\u003eVector u v(f,f')-\u003eVector u v(g,g')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "last",
        "normalized": "Vector a b(c,d)-\u003e(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:lastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#lastM",
        "fct-type": "function",
        "title": "lastM"
      },
      "index": {
        "description": "Last element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "lastM",
        "normalized": "Vector a b(c,d)-\u003ee(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the length of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Int",
        "fct-source": "src/Data-Vector-Hybrid.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Yield the length of the vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "length",
        "normalized": "Vector a b(c,d)-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Map a function over a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d)) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "map",
        "normalized": "((a,b)-\u003e(c,d))-\u003eVector e f(a,b)-\u003eVector e f(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d))-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e m (c, d)) -\u003e Vector u v (a, b) -\u003e m (Vector u v (c, d))",
        "fct-source": "src/Data-Vector-Hybrid.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "mapM",
        "normalized": "((a,b)-\u003ec(d,e))-\u003eVector f g(a,b)-\u003ec(Vector f g(d,e))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003em(c,d))-\u003eVector u v(a,b)-\u003em(Vector u v(c,d))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e m (c, d)) -\u003e Vector u v (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "mapM_",
        "normalized": "((a,b)-\u003ec(d,e))-\u003eVector f g(a,b)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003em(c,d))-\u003eVector u v(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:maxIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Int",
        "fct-source": "src/Data-Vector-Hybrid.html#maxIndex",
        "fct-type": "function",
        "title": "maxIndex"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "maxIndex",
        "normalized": "Vector a b(c,d)-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "Vector u v(a,b)-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:maxIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e Ordering) -\u003e Vector u v (a, b) -\u003e Int",
        "fct-source": "src/Data-Vector-Hybrid.html#maxIndexBy",
        "fct-type": "function",
        "title": "maxIndexBy"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "maxIndexBy",
        "normalized": "((a,b)-\u003e(a,b)-\u003eOrdering)-\u003eVector c d(a,b)-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "Index By",
        "signature": "((a,b)-\u003e(a,b)-\u003eOrdering)-\u003eVector u v(a,b)-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Yield the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "maximum",
        "normalized": "Vector a b(c,d)-\u003e(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:maximumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e Ordering) -\u003e Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#maximumBy",
        "fct-type": "function",
        "title": "maximumBy"
      },
      "index": {
        "description": "Yield the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "maximumBy",
        "normalized": "((a,b)-\u003e(a,b)-\u003eOrdering)-\u003eVector c d(a,b)-\u003e(a,b)",
        "package": "hybrid-vectors",
        "partial": "By",
        "signature": "((a,b)-\u003e(a,b)-\u003eOrdering)-\u003eVector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:minIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Int",
        "fct-source": "src/Data-Vector-Hybrid.html#minIndex",
        "fct-type": "function",
        "title": "minIndex"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "minIndex",
        "normalized": "Vector a b(c,d)-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "Vector u v(a,b)-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:minIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e Ordering) -\u003e Vector u v (a, b) -\u003e Int",
        "fct-source": "src/Data-Vector-Hybrid.html#minIndexBy",
        "fct-type": "function",
        "title": "minIndexBy"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "minIndexBy",
        "normalized": "((a,b)-\u003e(a,b)-\u003eOrdering)-\u003eVector c d(a,b)-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "Index By",
        "signature": "((a,b)-\u003e(a,b)-\u003eOrdering)-\u003eVector u v(a,b)-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Yield the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "minimum",
        "normalized": "Vector a b(c,d)-\u003e(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:minimumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e Ordering) -\u003e Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#minimumBy",
        "fct-type": "function",
        "title": "minimumBy"
      },
      "index": {
        "description": "Yield the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "minimumBy",
        "normalized": "((a,b)-\u003e(a,b)-\u003eOrdering)-\u003eVector c d(a,b)-\u003e(a,b)",
        "package": "hybrid-vectors",
        "partial": "By",
        "signature": "((a,b)-\u003e(a,b)-\u003eOrdering)-\u003eVector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:modify",
      "description": {
        "fct-descr": "\u003cp\u003eApply a destructive operation to a vector. The operation will be\n performed in place if it is safe to do so and will modify a copy of the\n vector otherwise.\n\u003c/p\u003e\u003cpre\u003e\n modify (\\v -\u003e write v 0 'x') (\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e 3 'a') = \u003c'x','a','a'\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(forall s.  Mutable (Vector u v) s (a, b) -\u003e ST s ()) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#modify",
        "fct-type": "function",
        "title": "modify"
      },
      "index": {
        "description": "Apply destructive operation to vector The operation will be performed in place if it is safe to do so and will modify copy of the vector otherwise modify write replicate",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "modify",
        "normalized": "(a b Mutable(Vector c d)e(f,g)-\u003eST e())-\u003eVector c d(f,g)-\u003eVector c d(f,g)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(forall s. Mutable(Vector u v)s(a,b)-\u003eST s())-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector does not contain an element (inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a, b) -\u003e Vector u v (a, b) -\u003e Bool",
        "fct-source": "src/Data-Vector-Hybrid.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Check if the vector does not contain an element inverse of elem",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "notElem",
        "normalized": "(a,b)-\u003eVector c d(a,b)-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "Elem",
        "signature": "(a,b)-\u003eVector u v(a,b)-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a vector if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Bool",
        "fct-source": "src/Data-Vector-Hybrid.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether vector if empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "null",
        "normalized": "Vector a b(c,d)-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't. The\n relative order of the elements is preserved at the cost of a sometimes\n reduced performance compared to \u003ccode\u003e\u003ca\u003eunstablePartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e (Vector u v (a, b), Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The relative order of the elements is preserved at the cost of sometimes reduced performance compared to unstablePartition",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "partition",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003e(Vector c d(a,b),Vector c d(a,b))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003e(Vector u v(a,b),Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan\n\u003c/p\u003e\u003cpre\u003e\n postscanl f z = \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003epostscanl (+) 0 \u003c1,2,3,4\u003e = \u003c1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (a, b)) -\u003e (a, b) -\u003e Vector u v (c, d) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Scan postscanl tail scanl Example postscanl",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "postscanl",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector e f(c,d)-\u003eVector e f(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector u v(c,d)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (a, b)) -\u003e (a, b) -\u003e Vector u v (c, d) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Scan with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "postscanl'",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector e f(c,d)-\u003eVector e f(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector u v(c,d)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:postscanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (c, d)) -\u003e (c, d) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#postscanr",
        "fct-type": "function",
        "title": "postscanr"
      },
      "index": {
        "description": "Right-to-left scan",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "postscanr",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector e f(a,b)-\u003eVector e f(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:postscanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (c, d)) -\u003e (c, d) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#postscanr%27",
        "fct-type": "function",
        "title": "postscanr'"
      },
      "index": {
        "description": "Right-to-left scan with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "postscanr'",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector e f(a,b)-\u003eVector e f(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanl f z = \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003eprescanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (a, b)) -\u003e (a, b) -\u003e Vector u v (c, d) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prescan prescanl init scanl Example prescanl",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "prescanl",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector e f(c,d)-\u003eVector e f(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector u v(c,d)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (a, b)) -\u003e (a, b) -\u003e Vector u v (c, d) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prescan with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "prescanl'",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector e f(c,d)-\u003eVector e f(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector u v(c,d)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:prescanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanr f z = \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eprescanl\u003c/a\u003e\u003c/code\u003e (flip f) z . \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (c, d)) -\u003e (c, d) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#prescanr",
        "fct-type": "function",
        "title": "prescanr"
      },
      "index": {
        "description": "Right-to-left prescan prescanr reverse prescanl flip reverse",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "prescanr",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector e f(a,b)-\u003eVector e f(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:prescanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (c, d)) -\u003e (c, d) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#prescanr%27",
        "fct-type": "function",
        "title": "prescanr'"
      },
      "index": {
        "description": "Right-to-left prescan with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "prescanr'",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector e f(a,b)-\u003eVector e f(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:projectFst",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e u a",
        "fct-source": "src/Data-Vector-Hybrid.html#projectFst",
        "fct-type": "function",
        "title": "projectFst"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "projectFst",
        "normalized": "Vector a b(c,d)-\u003ea c",
        "package": "hybrid-vectors",
        "partial": "Fst",
        "signature": "Vector u v(a,b)-\u003eu a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:projectSnd",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e v b",
        "fct-source": "src/Data-Vector-Hybrid.html#projectSnd",
        "fct-type": "function",
        "title": "projectSnd"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "projectSnd",
        "normalized": "Vector a b(c,d)-\u003eb d",
        "package": "hybrid-vectors",
        "partial": "Snd",
        "signature": "Vector u v(a,b)-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Vector of the given length with the same value in each position\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Vector of the given length with the same value in each position",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "replicate",
        "normalized": "Int-\u003e(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Execute the monadic action the given number of times and store the\n results in a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e m (a, b) -\u003e m (Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute the monadic action the given number of times and store the results in vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "replicateM",
        "normalized": "Int-\u003ea(b,c)-\u003ea(Vector d e(b,c))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003em(a,b)-\u003em(Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Reverse a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "reverse",
        "normalized": "Vector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan\n\u003c/p\u003e\u003cpre\u003e scanl f z \u003cx1,...,xn\u003e = \u003cy1,...,y(n+1)\u003e\n   where y1 = z\n         yi = f y(i-1) x(i-1)\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003escanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (a, b)) -\u003e (a, b) -\u003e Vector u v (c, d) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan scanl x1 xn y1 where y1 yi i-1 i-1 Example scanl",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "scanl",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector e f(c,d)-\u003eVector e f(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector u v(c,d)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (a, b)) -\u003e (a, b) -\u003e Vector u v (c, d) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "scanl'",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector e f(c,d)-\u003eVector e f(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(a,b))-\u003e(a,b)-\u003eVector u v(c,d)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector\n\u003c/p\u003e\u003cpre\u003e scanl f \u003cx1,...,xn\u003e = \u003cy1,...,yn\u003e\n   where y1 = x1\n         yi = f y(i-1) xi\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty vector scanl x1 xn y1 yn where y1 x1 yi i-1 xi",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "scanl1",
        "normalized": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "scanl1'",
        "normalized": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (c, d)) -\u003e (c, d) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "scanr",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector e f(a,b)-\u003eVector e f(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:scanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e (c, d)) -\u003e (c, d) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d)",
        "fct-source": "src/Data-Vector-Hybrid.html#scanr%27",
        "fct-type": "function",
        "title": "scanr'"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "scanr'",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector e f(a,b)-\u003eVector e f(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(c,d)-\u003e(c,d))-\u003e(c,d)-\u003eVector u v(a,b)-\u003eVector u v(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "scanr1",
        "normalized": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:scanr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector with a strict\n accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (a, b) -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#scanr1%27",
        "fct-type": "function",
        "title": "scanr1'"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "scanr1'",
        "normalized": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003e(a,b)-\u003e(a,b))-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Vector with exactly one element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Vector with exactly one element",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "singleton",
        "normalized": "(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying it. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int-\u003e Int-\u003e Vector u v (a, b)-\u003e Vector u v (a, b)",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield slice of the vector without copying it The vector must contain at least elements",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eVector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "snoc",
        "normalized": "Vector a b(c,d)-\u003e(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003e(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that satisfy\n the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e (Vector u v (a, b), Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "span",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003e(Vector c d(a,b),Vector c d(a,b))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003e(Vector u v(a,b),Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements paired with the remainder without copying.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e n v\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n v, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n v)\u003c/code\u003e\n but slightly more efficient.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e Vector u v (a, b) -\u003e (Vector u v (a, b), Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "Yield the first elements paired with the remainder without copying Note that splitAt is equivalent to take drop but slightly more efficient",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "splitAt",
        "normalized": "Int-\u003eVector a b(c,d)-\u003e(Vector a b(c,d),Vector a b(c,d))",
        "package": "hybrid-vectors",
        "partial": "At",
        "signature": "Int-\u003eVector u v(a,b)-\u003e(Vector u v(a,b),Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "tail",
        "normalized": "Vector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield at the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case it is returned unchanged.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "Yield at the first elements without copying The vector may contain less than elements in which case it is returned unchanged",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "take",
        "normalized": "Int-\u003eVector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the longest prefix of elements satisfying the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Yield the longest prefix of elements satisfying the predicate without copying",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "takeWhile",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003eVector c d(a,b)",
        "package": "hybrid-vectors",
        "partial": "While",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:thaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a mutable copy of the immutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e m (Mutable (Vector u v) (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#thaw",
        "fct-type": "function",
        "title": "thaw"
      },
      "index": {
        "description": "Yield mutable copy of the immutable vector",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "thaw",
        "normalized": "Vector a b(c,d)-\u003ee(Mutable(Vector a b)(PrimState e)(c,d))",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector u v(a,b)-\u003em(Mutable(Vector u v)(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a vector to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e [(a, b)]",
        "fct-source": "src/Data-Vector-Hybrid.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to list",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "toList",
        "normalized": "Vector a b(c,d)-\u003e[(c,d)]",
        "package": "hybrid-vectors",
        "partial": "List",
        "signature": "Vector u v(a,b)-\u003e[(a,b)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector by repeatedly applying the generator function\n to a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the next element and the\n new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\n -\u003e if n == 0 then Nothing else Just (n,n-1)) 10\n  = \u003c10,9,8,7,6,5,4,3,2,1\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(c -\u003e Maybe ((a, b), c)) -\u003e c -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Construct vector by repeatedly applying the generator function to seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldr if then Nothing else Just n-1",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe((b,c),a))-\u003ea-\u003eVector d e(b,c)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(c-\u003eMaybe((a,b),c))-\u003ec-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with at most \u003ccode\u003en\u003c/code\u003e by repeatedly applying the\n generator function to the a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the\n next element and the new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldrN 3 (\\n -\u003e Just (n,n-1)) 10 = \u003c10,9,8\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (c -\u003e Maybe ((a, b), c)) -\u003e c -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Construct vector with at most by repeatedly applying the generator function to the seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldrN Just n-1",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe((b,c),a))-\u003ea-\u003eVector d e(b,c)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(c-\u003eMaybe((a,b),c))-\u003ec-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeAccum",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccum\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e c -\u003e (a, b)) -\u003e Vector u v (a, b) -\u003e [(Int, c)] -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeAccum",
        "fct-type": "function",
        "title": "unsafeAccum"
      },
      "index": {
        "description": "Same as accum but without bounds checking",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeAccum",
        "normalized": "((a,b)-\u003ec-\u003e(a,b))-\u003eVector d e(a,b)-\u003e[(Int,c)]-\u003eVector d e(a,b)",
        "package": "hybrid-vectors",
        "partial": "Accum",
        "signature": "((a,b)-\u003ec-\u003e(a,b))-\u003eVector u v(a,b)-\u003e[(Int,c)]-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Mutable (Vector u v) (PrimState m) (a, b) -\u003e Vector u v (a, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeCopy",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length This is not checked",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeCopy",
        "normalized": "Mutable(Vector a b)(PrimState c)(d,e)-\u003eVector a b(d,e)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "Copy",
        "signature": "Mutable(Vector u v)(PrimState m)(a,b)-\u003eVector u v(a,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeDrop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector\n must contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eVector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "Drop",
        "signature": "Int-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe convert a mutable vector to an immutable one without\n copying. The mutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Mutable (Vector u v) (PrimState m) (a, b) -\u003e m (Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeFreeze",
        "fct-type": "function",
        "title": "unsafeFreeze"
      },
      "index": {
        "description": "Unsafe convert mutable vector to an immutable one without copying The mutable vector may not be used after this operation",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeFreeze",
        "normalized": "Mutable(Vector a b)(PrimState c)(d,e)-\u003ec(Vector a b(d,e))",
        "package": "hybrid-vectors",
        "partial": "Freeze",
        "signature": "Mutable(Vector u v)(PrimState m)(a,b)-\u003em(Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeHead",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeHead",
        "fct-type": "function",
        "title": "unsafeHead"
      },
      "index": {
        "description": "First element without checking if the vector is empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeHead",
        "normalized": "Vector a b(c,d)-\u003e(c,d)",
        "package": "hybrid-vectors",
        "partial": "Head",
        "signature": "Vector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeHeadM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeHeadM",
        "fct-type": "function",
        "title": "unsafeHeadM"
      },
      "index": {
        "description": "First element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeHeadM",
        "normalized": "Vector a b(c,d)-\u003ee(c,d)",
        "package": "hybrid-vectors",
        "partial": "Head",
        "signature": "Vector u v(a,b)-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe indexing without bounds checking\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Int -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeIndex",
        "fct-type": "function",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Unsafe indexing without bounds checking",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeIndex",
        "normalized": "Vector a b(c,d)-\u003eInt-\u003e(c,d)",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "Vector u v(a,b)-\u003eInt-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeIndexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad without bounds checks. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Int -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeIndexM",
        "fct-type": "function",
        "title": "unsafeIndexM"
      },
      "index": {
        "description": "Indexing in monad without bounds checks See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeIndexM",
        "normalized": "Vector a b(c,d)-\u003eInt-\u003ee(c,d)",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "Vector u v(a,b)-\u003eInt-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeInit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeInit",
        "normalized": "Vector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "Init",
        "signature": "Vector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeLast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeLast",
        "fct-type": "function",
        "title": "unsafeLast"
      },
      "index": {
        "description": "Last element without checking if the vector is empty",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeLast",
        "normalized": "Vector a b(c,d)-\u003e(c,d)",
        "package": "hybrid-vectors",
        "partial": "Last",
        "signature": "Vector u v(a,b)-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeLastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e m (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeLastM",
        "fct-type": "function",
        "title": "unsafeLastM"
      },
      "index": {
        "description": "Last element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeLastM",
        "normalized": "Vector a b(c,d)-\u003ee(c,d)",
        "package": "hybrid-vectors",
        "partial": "Last",
        "signature": "Vector u v(a,b)-\u003em(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int-\u003e Int-\u003e Vector u v (a, b)-\u003e Vector u v (a, b)",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield slice of the vector without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eVector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeTail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeTail",
        "normalized": "Vector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "Tail",
        "signature": "Vector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeTake",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector must\n contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e Vector u v (a, b) -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "Yield the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeTake",
        "normalized": "Int-\u003eVector a b(c,d)-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "Take",
        "signature": "Int-\u003eVector u v(a,b)-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely convert an immutable vector to a mutable one without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e m (Mutable (Vector u v) (PrimState m) (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeThaw",
        "fct-type": "function",
        "title": "unsafeThaw"
      },
      "index": {
        "description": "Unsafely convert an immutable vector to mutable one without copying The immutable vector may not be used after this operation",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeThaw",
        "normalized": "Vector a b(c,d)-\u003ee(Mutable(Vector a b)(PrimState e)(c,d))",
        "package": "hybrid-vectors",
        "partial": "Thaw",
        "signature": "Vector u v(a,b)-\u003em(Mutable(Vector u v)(PrimState m)(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeUpd",
      "description": {
        "fct-descr": "\u003cp\u003eSame as (\u003ccode\u003e\u003ca\u003e//\u003c/a\u003e\u003c/code\u003e) but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector u v (a, b) -\u003e [(Int, (a, b))] -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeUpd",
        "fct-type": "function",
        "title": "unsafeUpd"
      },
      "index": {
        "description": "Same as but without bounds checking",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeUpd",
        "normalized": "Vector a b(c,d)-\u003e[(Int,(c,d))]-\u003eVector a b(c,d)",
        "package": "hybrid-vectors",
        "partial": "Upd",
        "signature": "Vector u v(a,b)-\u003e[(Int,(a,b))]-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unsafeZip",
      "description": {
        "fct-descr": "\u003cp\u003eWarning: The vectors are assumed to have the same length. This is not checked!\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u a -\u003e v b -\u003e Vector u v (a, b)",
        "fct-source": "src/Data-Vector-Hybrid.html#unsafeZip",
        "fct-type": "function",
        "title": "unsafeZip"
      },
      "index": {
        "description": "Warning The vectors are assumed to have the same length This is not checked",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unsafeZip",
        "normalized": "a b-\u003ec d-\u003eVector a c(b,d)",
        "package": "hybrid-vectors",
        "partial": "Zip",
        "signature": "u a-\u003ev b-\u003eVector u v(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:unstablePartition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't.\n The order of the elements is not preserved but the operation is often\n faster than \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e Bool) -\u003e Vector u v (a, b) -\u003e (Vector u v (a, b), Vector u v (a, b))",
        "fct-source": "src/Data-Vector-Hybrid.html#unstablePartition",
        "fct-type": "function",
        "title": "unstablePartition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The order of the elements is not preserved but the operation is often faster than partition",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "unstablePartition",
        "normalized": "((a,b)-\u003eBool)-\u003eVector c d(a,b)-\u003e(Vector c d(a,b),Vector c d(a,b))",
        "package": "hybrid-vectors",
        "partial": "Partition",
        "signature": "((a,b)-\u003eBool)-\u003eVector u v(a,b)-\u003e(Vector u v(a,b),Vector u v(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, a') -\u003e (b, b') -\u003e (c, c')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c')",
        "fct-source": "src/Data-Vector-Hybrid.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "min Zip two vectors with the given function",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "zipWith",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(e,f))-\u003eVector g h(a,b)-\u003eVector g h(c,d)-\u003eVector g h(e,f)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "((a,a')-\u003e(b,b')-\u003e(c,c'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:zipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, a') -\u003e (b, b') -\u003e (c, c') -\u003e (d, d')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c') -\u003e Vector u v (d, d')",
        "fct-source": "src/Data-Vector-Hybrid.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "Zip three vectors with the given function",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "zipWith3",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(e,f)-\u003e(g,h))-\u003eVector i j(a,b)-\u003eVector i j(c,d)-\u003eVector i j(e,f)-\u003eVector i j(g,h)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "((a,a')-\u003e(b,b')-\u003e(c,c')-\u003e(d,d'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')-\u003eVector u v(d,d')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, a') -\u003e (b, b') -\u003e (c, c') -\u003e (d, d') -\u003e (e, e')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c') -\u003e Vector u v (d, d') -\u003e Vector u v (e, e')",
        "fct-source": "src/Data-Vector-Hybrid.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "zipWith4",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(e,f)-\u003e(g,h)-\u003e(i,j))-\u003eVector k l(a,b)-\u003eVector k l(c,d)-\u003eVector k l(e,f)-\u003eVector k l(g,h)-\u003eVector k l(i,j)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "((a,a')-\u003e(b,b')-\u003e(c,c')-\u003e(d,d')-\u003e(e,e'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')-\u003eVector u v(d,d')-\u003eVector u v(e,e')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, a') -\u003e (b, b') -\u003e (c, c') -\u003e (d, d') -\u003e (e, e') -\u003e (f, f')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c') -\u003e Vector u v (d, d') -\u003e Vector u v (e, e') -\u003e Vector u v (f, f')",
        "fct-source": "src/Data-Vector-Hybrid.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "zipWith5",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(e,f)-\u003e(g,h)-\u003e(i,j)-\u003e(k,l))-\u003eVector m n(a,b)-\u003eVector m n(c,d)-\u003eVector m n(e,f)-\u003eVector m n(g,h)-\u003eVector m n(i,j)-\u003eVector m n(k,l)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "((a,a')-\u003e(b,b')-\u003e(c,c')-\u003e(d,d')-\u003e(e,e')-\u003e(f,f'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')-\u003eVector u v(d,d')-\u003eVector u v(e,e')-\u003eVector u v(f,f')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, a') -\u003e (b, b') -\u003e (c, c') -\u003e (d, d') -\u003e (e, e') -\u003e (f, f') -\u003e (g, g')) -\u003e Vector u v (a, a') -\u003e Vector u v (b, b') -\u003e Vector u v (c, c') -\u003e Vector u v (d, d') -\u003e Vector u v (e, e') -\u003e Vector u v (f, f') -\u003e Vector u v (g, g')",
        "fct-source": "src/Data-Vector-Hybrid.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "zipWith6",
        "normalized": "((a,b)-\u003e(c,d)-\u003e(e,f)-\u003e(g,h)-\u003e(i,j)-\u003e(k,l)-\u003e(m,n))-\u003eVector o p(a,b)-\u003eVector o p(c,d)-\u003eVector o p(e,f)-\u003eVector o p(g,h)-\u003eVector o p(i,j)-\u003eVector o p(k,l)-\u003eVector o p(m,n)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "((a,a')-\u003e(b,b')-\u003e(c,c')-\u003e(d,d')-\u003e(e,e')-\u003e(f,f')-\u003e(g,g'))-\u003eVector u v(a,a')-\u003eVector u v(b,b')-\u003eVector u v(c,c')-\u003eVector u v(d,d')-\u003eVector u v(e,e')-\u003eVector u v(f,f')-\u003eVector u v(g,g')"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and yield a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e m (e, f)) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d) -\u003e m (Vector u v (e, f))",
        "fct-source": "src/Data-Vector-Hybrid.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and yield vector of results",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "zipWithM",
        "normalized": "((a,b)-\u003e(c,d)-\u003ee(f,g))-\u003eVector h i(a,b)-\u003eVector h i(c,d)-\u003ee(Vector h i(f,g))",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "((a,b)-\u003e(c,d)-\u003em(e,f))-\u003eVector u v(a,b)-\u003eVector u v(c,d)-\u003em(Vector u v(e,f))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Hybrid.html#v:zipWithM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Hybrid",
        "fct-package": "hybrid-vectors",
        "fct-signature": "((a, b) -\u003e (c, d) -\u003e m e) -\u003e Vector u v (a, b) -\u003e Vector u v (c, d) -\u003e m ()",
        "fct-source": "src/Data-Vector-Hybrid.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and ignore the results",
        "hierarchy": "Data Vector Hybrid",
        "module": "Data.Vector.Hybrid",
        "name": "zipWithM_",
        "normalized": "((a,b)-\u003e(c,d)-\u003ee f)-\u003eVector g h(a,b)-\u003eVector g h(c,d)-\u003ee()",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "((a,b)-\u003e(c,d)-\u003em e)-\u003eVector u v(a,b)-\u003eVector u v(c,d)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Mixed-Internal.html",
        "fct-type": "module",
        "title": "Internal"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "Internal",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Internal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003eMVector s a\u003c/code\u003e is mutable vector that could have any vector type underneath\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "MVector is mutable vector that could have any vector type underneath",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "MVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#t:Mixed",
      "description": {
        "fct-descr": "\u003cp\u003eVector doesn't provide a way to recover the type of the immutable vector from the mutable vector type\n\u003c/p\u003e\u003cp\u003eThis would otherwise prevent us from finishing the implementation of \u003ccode\u003ebasicUnsafeFreeze\u003c/code\u003e in \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis class captures the invariants necessary to \u003ccode\u003ehide\u003c/code\u003e the choice of vector type from the user in such\n a way that we can go from mutable vector to immutabl vector and back again.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#Mixed",
        "fct-type": "class",
        "title": "Mixed"
      },
      "index": {
        "description": "Vector doesn provide way to recover the type of the immutable vector from the mutable vector type This would otherwise prevent us from finishing the implementation of basicUnsafeFreeze in Vector This class captures the invariants necessary to hide the choice of vector type from the user in such way that we can go from mutable vector to immutabl vector and back again",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "Mixed",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Mixed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#t:Vector",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#Vector",
        "fct-type": "data",
        "title": "Vector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "Vector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#v:MV",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "!(mv s a) -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#MVector",
        "fct-type": "function",
        "title": "MV"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "MV",
        "normalized": "(a b c)-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "MV",
        "signature": "(mv s a)-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#v:V",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "!(v a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#Vector",
        "fct-type": "function",
        "title": "V"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "V",
        "normalized": "(a b)-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(v a)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#v:boxed",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#boxed",
        "fct-type": "function",
        "title": "boxed"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "boxed",
        "normalized": "Vector a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#v:mboxed",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#mboxed",
        "fct-type": "function",
        "title": "mboxed"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "mboxed",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#v:mix",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#mix",
        "fct-type": "method",
        "title": "mix"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "mix",
        "normalized": "a b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#v:mmix",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "mv s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#mmix",
        "fct-type": "method",
        "title": "mmix"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "mmix",
        "normalized": "a b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "mv s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#v:munboxed",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#munboxed",
        "fct-type": "function",
        "title": "munboxed"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "munboxed",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Internal.html#v:unboxed",
      "description": {
        "fct-module": "Data.Vector.Mixed.Internal",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#unboxed",
        "fct-type": "function",
        "title": "unboxed"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Internal",
        "module": "Data.Vector.Mixed.Internal",
        "name": "unboxed",
        "normalized": "Vector a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html",
        "fct-type": "module",
        "title": "Mutable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#t:IOVector",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#IOVector",
        "fct-type": "type",
        "title": "IOVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "IOVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "IOVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003eMVector s a\u003c/code\u003e is mutable vector that could have any vector type underneath\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "MVector is mutable vector that could have any vector type underneath",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#t:STVector",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#STVector",
        "fct-type": "type",
        "title": "STVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "STVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "STVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:clear",
      "description": {
        "fct-descr": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#clear",
        "fct-type": "function",
        "title": "clear"
      },
      "index": {
        "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "clear",
        "normalized": "a(PrimState b)c-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a copy of a mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Create copy of mutable vector",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "clone",
        "normalized": "a(PrimState b)c-\u003eb(MVector(PrimState b)c)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e u' (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "copy",
        "normalized": "a(PrimState b)c-\u003ed(PrimState b)c-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003eu'(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:drop",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "drop",
        "normalized": "Int-\u003ea b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eu s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:grow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#grow",
        "fct-type": "function",
        "title": "grow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "grow",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb(MVector(PrimState b)c)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:init",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "init",
        "normalized": "a b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u s a -\u003e Int",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of the mutable vector",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "length",
        "normalized": "a b c-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u s a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:move",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003ecopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e u' (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#move",
        "fct-type": "function",
        "title": "move"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length If the vectors do not overlap then this is equivalent to copy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "move",
        "normalized": "a(PrimState b)c-\u003ed(PrimState b)c-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003eu'(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "Create mutable vector of the given length",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "new",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check whether the vector is empty",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "null",
        "normalized": "a b c-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:overlaps",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u s a -\u003e u' s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#overlaps",
        "fct-type": "function",
        "title": "overlaps"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "overlaps",
        "normalized": "a b c-\u003ed b c-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u s a-\u003eu' s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Yield the element at the given position",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "read",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with an initial value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with an initial value",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eb(MVector(PrimState b)a)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003ea-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with values produced by repeatedly executing the monadic action.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e m a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with values produced by repeatedly executing the monadic action",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(MVector(PrimState a)b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003eSet all elements of the vector to the given value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#set",
        "fct-type": "function",
        "title": "set"
      },
      "index": {
        "description": "Set all elements of the vector to the given value",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "set",
        "normalized": "a(PrimState b)c-\u003ec-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e Int -\u003e u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003ea b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eu s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:splitAt",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e u s a -\u003e (MVector s a, MVector s a)",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "splitAt",
        "normalized": "Int-\u003ea b c-\u003e(MVector b c,MVector b c)",
        "package": "hybrid-vectors",
        "partial": "At",
        "signature": "Int-\u003eu s a-\u003e(MVector s a,MVector s a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:swap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "Swap the elements at the given positions",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "swap",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eInt-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "tail",
        "normalized": "a b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:take",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "take",
        "normalized": "Int-\u003ea b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eu s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a-\u003e u' (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap This is not checked",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeCopy",
        "normalized": "a(PrimState b)c-\u003ed(PrimState b)c-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "Copy",
        "signature": "u(PrimState m)a-\u003eu'(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeDrop",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeDrop",
        "normalized": "Int-\u003ea b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "Drop",
        "signature": "Int-\u003eu s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeGrow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeGrow",
        "fct-type": "function",
        "title": "unsafeGrow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive but this is not checked",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeGrow",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb(MVector(PrimState b)c)",
        "package": "hybrid-vectors",
        "partial": "Grow",
        "signature": "u(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeInit",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeInit",
        "normalized": "a b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "Init",
        "signature": "u s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeMove",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length, but this is not checked.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003eunsafeCopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a-\u003e u' (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeMove"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length but this is not checked If the vectors do not overlap then this is equivalent to unsafeCopy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeMove",
        "normalized": "a(PrimState b)c-\u003ed(PrimState b)c-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "Move",
        "signature": "u(PrimState m)a-\u003eu'(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeNew",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length. The length is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeNew",
        "fct-type": "function",
        "title": "unsafeNew"
      },
      "index": {
        "description": "Create mutable vector of the given length The length is not checked",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeNew",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "hybrid-vectors",
        "partial": "New",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeRead",
        "fct-type": "function",
        "title": "unsafeRead"
      },
      "index": {
        "description": "Yield the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeRead",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
        "package": "hybrid-vectors",
        "partial": "Read",
        "signature": "u(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it. No bounds checks\n are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int-\u003e Int-\u003e u s a-\u003e MVector s a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it No bounds checks are performed",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003ea b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eu s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeSwap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeSwap",
        "fct-type": "function",
        "title": "unsafeSwap"
      },
      "index": {
        "description": "Swap the elements at the given positions No bounds checks are performed",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeSwap",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eInt-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "Swap",
        "signature": "u(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeTail",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeTail",
        "normalized": "a b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "Tail",
        "signature": "u s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeTake",
      "description": {
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e u s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeTake",
        "normalized": "Int-\u003ea b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "Take",
        "signature": "Int-\u003eu s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:unsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#unsafeWrite",
        "fct-type": "function",
        "title": "unsafeWrite"
      },
      "index": {
        "description": "Replace the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "unsafeWrite",
        "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "Write",
        "signature": "u(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed-Mutable.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed.Mutable",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed-Mutable.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Replace the element at the given position",
        "hierarchy": "Data Vector Mixed Mutable",
        "module": "Data.Vector.Mixed.Mutable",
        "name": "write",
        "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA mixed \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e lets you make a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e out of any other vector type\n you have lying around, and all of the combinators are defined to allow\n you to freely mix input vector type wherever possible.\n\u003c/p\u003e\u003cp\u003eThis enables you to work with a mixture of boxed and unboxed data.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Mixed.html",
        "fct-type": "module",
        "title": "Mixed"
      },
      "index": {
        "description": "mixed Vector lets you make Vector out of any other vector type you have lying around and all of the combinators are defined to allow you to freely mix input vector type wherever possible This enables you to work with mixture of boxed and unboxed data",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "Mixed",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Mixed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003eMVector s a\u003c/code\u003e is mutable vector that could have any vector type underneath\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "MVector is mutable vector that could have any vector type underneath",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "MVector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#t:Mixed",
      "description": {
        "fct-descr": "\u003cp\u003eVector doesn't provide a way to recover the type of the immutable vector from the mutable vector type\n\u003c/p\u003e\u003cp\u003eThis would otherwise prevent us from finishing the implementation of \u003ccode\u003ebasicUnsafeFreeze\u003c/code\u003e in \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis class captures the invariants necessary to \u003ccode\u003ehide\u003c/code\u003e the choice of vector type from the user in such\n a way that we can go from mutable vector to immutabl vector and back again.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#Mixed",
        "fct-type": "class",
        "title": "Mixed"
      },
      "index": {
        "description": "Vector doesn provide way to recover the type of the immutable vector from the mutable vector type This would otherwise prevent us from finishing the implementation of basicUnsafeFreeze in Vector This class captures the invariants necessary to hide the choice of vector type from the user in such way that we can go from mutable vector to immutabl vector and back again",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "Mixed",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Mixed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#t:Vector",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#Vector",
        "fct-type": "data",
        "title": "Vector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "Vector",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Indexing",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "(!) !",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Safe indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Int -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Mixed.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Safe indexing",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "(!?) !?",
        "normalized": "a b-\u003eInt-\u003eMaybe b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eInt-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e Concatenate two vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e v' a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two vectors",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "(++) ++",
        "normalized": "a b-\u003ec b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ev' a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:-47--47-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the list, replace the vector\n element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003c5,9,2,7\u003e // [(2,1),(0,3),(2,8)] = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a-\u003e [(Int, a)]-\u003e Vector a",
        "fct-type": "function",
        "title": "(//)"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "(//) //",
        "normalized": "a b-\u003e[(Int,b)]-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:accum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the list, replace the vector element\n \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accum (+) \u003c5,9,2\u003e [(2,4),(1,6),(0,3),(1,7)] = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e [(Int, b)]-\u003e Vector a",
        "fct-type": "function",
        "title": "accum"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by accum",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "accum",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003e[(Int,b)]-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:accumulate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the vector of pairs, replace the vector\n element \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate (+) \u003c5,9,2\u003e \u003c(2,4),(1,6),(0,3),(1,7)\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e v' (Int, b)-\u003e Vector a",
        "fct-type": "function",
        "title": "accumulate"
      },
      "index": {
        "description": "For each pair from the vector of pairs replace the vector element at position by accumulate",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "accumulate",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ed(Int,b)-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev'(Int,b)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:accumulate_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003eb\u003c/code\u003e from the the value vector,\n replace the element of the initial vector at\n position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate_ (+) \u003c5,9,2\u003e \u003c2,1,0,1\u003e \u003c4,6,3,7\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e provides the same functionality and is usually more\n convenient.\n\u003c/p\u003e\u003cpre\u003e\n accumulate_ f as is bs = \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e f as (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is bs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e v' Int-\u003e v'' b-\u003e Vector a",
        "fct-type": "function",
        "title": "accumulate_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the the value vector replace the element of the initial vector at position by accumulate The function accumulate provides the same functionality and is usually more convenient accumulate as is bs accumulate as zip is bs",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "accumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ed Int-\u003ee b-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev' Int-\u003ev'' b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Check if all elements satisfy the predicate",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements are \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "Check if all elements are True",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "and",
        "normalized": "a Bool-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Check if any element satisfies the predicate",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:backpermute",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the vector obtained by replacing each element \u003ccode\u003ei\u003c/code\u003e of the\n index vector by \u003ccode\u003exs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003ei\u003c/code\u003e. This is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (xs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e) is\u003c/code\u003e but is\n often much more efficient.\n\u003c/p\u003e\u003cpre\u003e backpermute \u003ca,b,c,d\u003e \u003c0,3,2,3,1,0\u003e = \u003ca,d,c,d,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e v' Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#backpermute",
        "fct-type": "function",
        "title": "backpermute"
      },
      "index": {
        "description": "Yield the vector obtained by replacing each element of the index vector by xs This is equivalent to map xs is but is often much more efficient backpermute",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "backpermute",
        "normalized": "a b-\u003ec Int-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ev' Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that do not\n satisfy the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that do not satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "break",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate all vectors in the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "[v a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate all vectors in the list",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "concat",
        "normalized": "[a b]-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "[v a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a vector and concatenate the results.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e v b) -\u003e v' a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over vector and concatenate the results",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "concatMap",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eVector c",
        "package": "hybrid-vectors",
        "partial": "Map",
        "signature": "(a-\u003ev b)-\u003ev' a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "cons",
        "normalized": "a-\u003eb a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "a-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:constructN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements by repeatedly applying the\n generator function to the already constructed part of the vector.\n\u003c/p\u003e\u003cpre\u003e constructN 3 f = let a = f \u003c\u003e ; b = f \u003ca\u003e ; c = f \u003ca,b\u003e in f \u003ca,b,c\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#constructN",
        "fct-type": "function",
        "title": "constructN"
      },
      "index": {
        "description": "Construct vector with elements by repeatedly applying the generator function to the already constructed part of the vector constructN let in",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "constructN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:constructrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements from right to left by\n repeatedly applying the generator function to the already constructed part\n of the vector.\n\u003c/p\u003e\u003cpre\u003e constructrN 3 f = let a = f \u003c\u003e ; b = f\u003ca\u003e ; c = f \u003cb,a\u003e in f \u003cc,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#constructrN",
        "fct-type": "function",
        "title": "constructrN"
      },
      "index": {
        "description": "Construct vector with elements from right to left by repeatedly applying the generator function to the already constructed part of the vector constructrN let in",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "constructrN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:convert",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert different vector types\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e w a",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "Convert different vector types",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "convert",
        "normalized": "a b-\u003ec b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e v' a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "copy",
        "normalized": "a(PrimState b)c-\u003ed c-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003ev' a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:create",
      "description": {
        "fct-descr": "\u003cp\u003eExecute the monadic action and freeze the resulting vector.\n\u003c/p\u003e\u003cpre\u003e\n create (do { v \u003c- new 2; write v 0 'a'; write v 1 'b'; return v }) = \u003c\u003ccode\u003ea\u003c/code\u003e,\u003ccode\u003eb\u003c/code\u003e\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(forall s.  ST s (u s a)) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "Execute the monadic action and freeze the resulting vector create do new write write return",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "create",
        "normalized": "(a b ST c(d c e))-\u003eVector e",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(forall s. ST s(u s a))-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case an empty vector is returned.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector may contain less than elements in which case an empty vector is returned",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "drop",
        "normalized": "Int-\u003ea b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop the longest prefix of elements that satisfy the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate without copying",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "dropWhile",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check if the vector contains an element",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "elem",
        "normalized": "a-\u003eb a-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "a-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first occurence of the given element or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the vector does not contain the element. This is a specialised\n version of \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e v a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Mixed.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "Yield Just the index of the first occurence of the given element or Nothing if the vector does not contain the element This is specialised version of findIndex",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "elemIndex",
        "normalized": "a-\u003eb a-\u003eMaybe Int",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "a-\u003ev a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of all occurences of the given element in\n ascending order. This is a specialised version of \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e v a -\u003e Vector Int",
        "fct-source": "src/Data-Vector-Mixed.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "Yield the indices of all occurences of the given element in ascending order This is specialised version of findIndices",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "elemIndices",
        "normalized": "a-\u003eb a-\u003eVector Int",
        "package": "hybrid-vectors",
        "partial": "Indices",
        "signature": "a-\u003ev a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "empty",
        "normalized": "",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:enumFromN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+1\u003c/code\u003e\n etc. This operation is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromN 5 3 = \u003c5,6,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#enumFromN",
        "fct-type": "function",
        "title": "enumFromN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operation is usually more efficient than enumFromTo enumFromN",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "enumFromN",
        "normalized": "a-\u003eInt-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "From",
        "signature": "a-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:enumFromStepN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc. This operations is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromThenTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromStepN 1 0.1 5 = \u003c1,1.1,1.2,1.3,1.4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#enumFromStepN",
        "fct-type": "function",
        "title": "enumFromStepN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operations is usually more efficient than enumFromThenTo enumFromStepN",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "enumFromStepN",
        "normalized": "a-\u003ea-\u003eInt-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "From Step",
        "signature": "a-\u003ea-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:enumFromThenTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e with a specific step \u003ccode\u003ez\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#enumFromThenTo",
        "fct-type": "function",
        "title": "enumFromThenTo"
      },
      "index": {
        "description": "Enumerate values from to with specific step WARNING This operation can be very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "enumFromThenTo",
        "normalized": "a-\u003ea-\u003ea-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "From Then To",
        "signature": "a-\u003ea-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Enumerate values from to WARNING This operation can be very inefficient If at all possible use enumFromN instead",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "enumFromTo",
        "normalized": "a-\u003ea-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "From To",
        "signature": "a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "filter",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e m Bool) -\u003e v a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Drop elements that do not satisfy the monadic predicate",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "filterM",
        "normalized": "(a-\u003eb Bool)-\u003ec a-\u003eb(Vector a)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003ev a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Mixed.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "find",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eMaybe a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Mixed.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eMaybe Int",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of elements satisfying the predicate in ascending\n order.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Vector Int",
        "fct-source": "src/Data-Vector-Mixed.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "Yield the indices of elements satisfying the predicate in ascending order",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "findIndices",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eVector Int",
        "package": "hybrid-vectors",
        "partial": "Indices",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "fold1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "fold1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb a",
        "package": "hybrid-vectors",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:fold1M-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#fold1M%27_",
        "fct-type": "function",
        "title": "fold1M'_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator that discards the result",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "fold1M'_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:fold1M_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#fold1M_",
        "fct-type": "function",
        "title": "fold1M_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors that discards the result",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "fold1M_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Monadic fold with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
        "package": "hybrid-vectors",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldM-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#foldM%27_",
        "fct-type": "function",
        "title": "foldM'_"
      },
      "index": {
        "description": "Monadic fold with strict accumulator that discards the result",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldM'_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#foldM_",
        "fct-type": "function",
        "title": "foldM_"
      },
      "index": {
        "description": "Monadic fold that discards the result",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldM_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold on non-empty vectors",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Mixed.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Mixed.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold on non-empty vectors",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "Right fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "foldr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:forM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results. Equvalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e (a -\u003e m b) -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector-Mixed.html#forM",
        "fct-type": "function",
        "title": "forM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results Equvalent to flip mapM",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "forM",
        "normalized": "a b-\u003e(b-\u003ec d)-\u003ec(Vector d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003e(a-\u003em b)-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:forM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results. Equivalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e (a -\u003e m b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#forM_",
        "fct-type": "function",
        "title": "forM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results Equivalent to flip mapM",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "forM_",
        "normalized": "a b-\u003e(b-\u003ec d)-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003e(a-\u003em b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:force",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the argument but force it not to retain any extra memory,\n possibly by copying it.\n\u003c/p\u003e\u003cp\u003eThis is especially useful when dealing with slices. For example:\n\u003c/p\u003e\u003cpre\u003e force (slice 0 2 \u003chuge vector\u003e)\n\u003c/pre\u003e\u003cp\u003eHere, the slice retains a reference to the huge vector. Forcing it creates\n a copy of just the elements that belong to the slice and allows the huge\n vector to be garbage collected.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#force",
        "fct-type": "function",
        "title": "force"
      },
      "index": {
        "description": "Yield the argument but force it not to retain any extra memory possibly by copying it This is especially useful when dealing with slices For example force slice huge vector Here the slice retains reference to the huge vector Forcing it creates copy of just the elements that belong to the slice and allows the huge vector to be garbage collected",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "force",
        "normalized": "a b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:freeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield an immutable copy of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#freeze",
        "fct-type": "function",
        "title": "freeze"
      },
      "index": {
        "description": "Yield an immutable copy of the mutable vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "freeze",
        "normalized": "a(PrimState b)c-\u003eb(Vector c)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "u(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a list to a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "[a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "fromList",
        "normalized": "[a]-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "List",
        "signature": "[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a vector\n\u003c/p\u003e\u003cpre\u003e\n fromListN n xs = \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e [a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Convert the first elements of list to vector fromListN xs fromList take xs",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "fromListN",
        "normalized": "Int-\u003e[a]-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "List",
        "signature": "Int-\u003e[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the function to\n each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (Int -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Construct vector of the given length by applying the function to each index",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003ea)-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the monadic\n action to each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (Int -\u003e m a) -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Construct vector of the given length by applying the monadic action to each index",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "generateM",
        "normalized": "Int-\u003e(Int-\u003ea b)-\u003ea(Vector b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003em a)-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "head",
        "normalized": "a b-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:headM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#headM",
        "fct-type": "function",
        "title": "headM"
      },
      "index": {
        "description": "First element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "headM",
        "normalized": "a b-\u003ec b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:ifilter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate which is applied to\n values and their indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e Bool) -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#ifilter",
        "fct-type": "function",
        "title": "ifilter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate which is applied to values and their indices",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "ifilter",
        "normalized": "(Int-\u003ea-\u003eBool)-\u003eb a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eBool)-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold function applied to each element and its index",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:ifoldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator (function applied to each element\n and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#ifoldl%27",
        "fct-type": "function",
        "title": "ifoldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "ifoldl'",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Mixed.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Right fold function applied to each element and its index",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:ifoldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with strict accumulator (function applied to each\n element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Mixed.html#ifoldr%27",
        "fct-type": "function",
        "title": "ifoldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "ifoldr'",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply a function to every element of a vector and its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e v a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of vector and its index",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003eb)-\u003ec a-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003ev a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:indexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad.\n\u003c/p\u003e\u003cp\u003eThe monad allows operations to be strict in the vector when necessary.\n Suppose vector copying is implemented like this:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... write mv i (v ! i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, \u003ccode\u003ev ! i\u003c/code\u003e would not be evaluated which means that \u003ccode\u003emv\u003c/code\u003e\n would unnecessarily retain a reference to \u003ccode\u003ev\u003c/code\u003e in each element written.\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e, copying can be implemented like this instead:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... do\n                   x \u003c- indexM v i\n                   write mv i x\n\u003c/pre\u003e\u003cp\u003eHere, no references to \u003ccode\u003ev\u003c/code\u003e are retained because indexing (but \u003cem\u003enot\u003c/em\u003e the\n elements) is evaluated eagerly.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#indexM",
        "fct-type": "function",
        "title": "indexM"
      },
      "index": {
        "description": "Indexing in monad The monad allows operations to be strict in the vector when necessary Suppose vector copying is implemented like this copy mv write mv For lazy vectors would not be evaluated which means that mv would unnecessarily retain reference to in each element written With indexM copying can be implemented like this instead copy mv do indexM write mv Here no references to are retained because indexing but not the elements is evaluated eagerly",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "indexM",
        "normalized": "a b-\u003eInt-\u003ec b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:indexed",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Pair each element in a vector with its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector (Int, a)",
        "fct-source": "src/Data-Vector-Mixed.html#indexed",
        "fct-type": "function",
        "title": "indexed"
      },
      "index": {
        "description": "Pair each element in vector with its index",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "indexed",
        "normalized": "a b-\u003eVector(Int,b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eVector(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "init",
        "normalized": "a b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function times to value Zeroth element is original value",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "iterateN",
        "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with a function that also takes the\n elements' indices.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e va a -\u003e vb b -\u003e Vector c",
        "fct-source": "src/Data-Vector-Mixed.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "min Zip two vectors with function that also takes the elements indices",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003ed a-\u003ee b-\u003eVector c",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003eva a-\u003evb b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:izipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors and their indices with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d) -\u003e va a -\u003e vb b -\u003e vc c -\u003e Vector d",
        "fct-source": "src/Data-Vector-Mixed.html#izipWith3",
        "fct-type": "function",
        "title": "izipWith3"
      },
      "index": {
        "description": "Zip three vectors and their indices with the given function",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "izipWith3",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ef b-\u003eg c-\u003eVector d",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eva a-\u003evb b-\u003evc c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:izipWith4",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e Vector e",
        "fct-source": "src/Data-Vector-Mixed.html#izipWith4",
        "fct-type": "function",
        "title": "izipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "izipWith4",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003eg b-\u003eh c-\u003ei d-\u003eVector e",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eva a-\u003evb b-\u003evc c-\u003evd d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:izipWith5",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e ve e -\u003e Vector f",
        "fct-source": "src/Data-Vector-Mixed.html#izipWith5",
        "fct-type": "function",
        "title": "izipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "izipWith5",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eg a-\u003eh b-\u003ei c-\u003ej d-\u003ek e-\u003eVector f",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eva a-\u003evb b-\u003evc c-\u003evd d-\u003eve e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:izipWith6",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e ve e -\u003e vf f -\u003e Vector g",
        "fct-source": "src/Data-Vector-Mixed.html#izipWith6",
        "fct-type": "function",
        "title": "izipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "izipWith6",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eh a-\u003ei b-\u003ej c-\u003ek d-\u003el e-\u003em f-\u003eVector g",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eva a-\u003evb b-\u003evc c-\u003evd d-\u003eve e-\u003evf f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "last",
        "normalized": "a b-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:lastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#lastM",
        "fct-type": "function",
        "title": "lastM"
      },
      "index": {
        "description": "Last element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "lastM",
        "normalized": "a b-\u003ec b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the length of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Mixed.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Yield the length of the vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "length",
        "normalized": "a b-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Map a function over a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b) -\u003e v a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003ec a-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb)-\u003ev a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e m b) -\u003e v a -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector-Mixed.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(Vector c)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003em b)-\u003ev a-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e m b) -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003em b)-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:maxIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Mixed.html#maxIndex",
        "fct-type": "function",
        "title": "maxIndex"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "maxIndex",
        "normalized": "a b-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:maxIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e Int",
        "fct-source": "src/Data-Vector-Mixed.html#maxIndexBy",
        "fct-type": "function",
        "title": "maxIndexBy"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "maxIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Yield the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "maximum",
        "normalized": "a b-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:maximumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#maximumBy",
        "fct-type": "function",
        "title": "maximumBy"
      },
      "index": {
        "description": "Yield the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "maximumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003ea",
        "package": "hybrid-vectors",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:minIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Mixed.html#minIndex",
        "fct-type": "function",
        "title": "minIndex"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "minIndex",
        "normalized": "a b-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:minIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e Int",
        "fct-source": "src/Data-Vector-Mixed.html#minIndexBy",
        "fct-type": "function",
        "title": "minIndexBy"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "minIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003eInt",
        "package": "hybrid-vectors",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Yield the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "minimum",
        "normalized": "a b-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:minimumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#minimumBy",
        "fct-type": "function",
        "title": "minimumBy"
      },
      "index": {
        "description": "Yield the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "minimumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003ea",
        "package": "hybrid-vectors",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:mix",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#mix",
        "fct-type": "method",
        "title": "mix"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "mix",
        "normalized": "a b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:mmix",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "mv s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mixed-Internal.html#mmix",
        "fct-type": "method",
        "title": "mmix"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "mmix",
        "normalized": "a b c-\u003eMVector b c",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "mv s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:modify",
      "description": {
        "fct-descr": "\u003cp\u003eApply a destructive operation to a vector. The operation will be\n performed in place if it is safe to do so and will modify a copy of the\n vector otherwise.\n\u003c/p\u003e\u003cpre\u003e\n modify (\\v -\u003e write v 0 'x') (\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e 3 'a') = \u003c'x','a','a'\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(forall s.  u s a -\u003e ST s ()) -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#modify",
        "fct-type": "function",
        "title": "modify"
      },
      "index": {
        "description": "Apply destructive operation to vector The operation will be performed in place if it is safe to do so and will modify copy of the vector otherwise modify write replicate",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "modify",
        "normalized": "(a b c d e-\u003eST d())-\u003ef e-\u003eVector e",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(forall s. u s a-\u003eST s())-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector does not contain an element (inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Check if the vector does not contain an element inverse of elem",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "notElem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "Elem",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a vector if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether vector if empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "null",
        "normalized": "a b-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Mixed.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "Check if any element is True",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "or",
        "normalized": "a Bool-\u003eBool",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't. The\n relative order of the elements is preserved at the cost of a sometimes\n reduced performance compared to \u003ccode\u003e\u003ca\u003eunstablePartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The relative order of the elements is preserved at the cost of sometimes reduced performance compared to unstablePartition",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "partition",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003e(Vector a,Vector a)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan\n\u003c/p\u003e\u003cpre\u003e\n postscanl f z = \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003epostscanl (+) 0 \u003c1,2,3,4\u003e = \u003c1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Scan postscanl tail scanl Example postscanl",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "postscanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Scan with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "postscanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:postscanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#postscanr",
        "fct-type": "function",
        "title": "postscanr"
      },
      "index": {
        "description": "Right-to-left scan",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "postscanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:postscanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#postscanr%27",
        "fct-type": "function",
        "title": "postscanr'"
      },
      "index": {
        "description": "Right-to-left scan with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "postscanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanl f z = \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003eprescanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prescan prescanl init scanl Example prescanl",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "prescanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prescan with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "prescanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:prescanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanr f z = \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eprescanl\u003c/a\u003e\u003c/code\u003e (flip f) z . \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#prescanr",
        "fct-type": "function",
        "title": "prescanr"
      },
      "index": {
        "description": "Right-to-left prescan prescanr reverse prescanl flip reverse",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "prescanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:prescanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#prescanr%27",
        "fct-type": "function",
        "title": "prescanr'"
      },
      "index": {
        "description": "Right-to-left prescan with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "prescanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:product",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the produce of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#product",
        "fct-type": "function",
        "title": "product"
      },
      "index": {
        "description": "Compute the produce of the elements",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "product",
        "normalized": "a b-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Vector of the given length with the same value in each position\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Vector of the given length with the same value in each position",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Execute the monadic action the given number of times and store the\n results in a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e m a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute the monadic action the given number of times and store the results in vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(Vector b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Reverse a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "reverse",
        "normalized": "a b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan\n\u003c/p\u003e\u003cpre\u003e scanl f z \u003cx1,...,xn\u003e = \u003cy1,...,y(n+1)\u003e\n   where y1 = z\n         yi = f y(i-1) x(i-1)\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003escanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan scanl x1 xn y1 where y1 yi i-1 i-1 Example scanl",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "scanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector\n\u003c/p\u003e\u003cpre\u003e scanl f \u003cx1,...,xn\u003e = \u003cy1,...,yn\u003e\n   where y1 = x1\n         yi = f y(i-1) xi\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty vector scanl x1 xn y1 yn where y1 x1 yi i-1 xi",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "scanl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "scanl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "scanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:scanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Mixed.html#scanr%27",
        "fct-type": "function",
        "title": "scanr'"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "scanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "scanr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:scanr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector with a strict\n accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#scanr1%27",
        "fct-type": "function",
        "title": "scanr1'"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "scanr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:sequence",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate each action and collect the results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v (m a) -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#sequence",
        "fct-type": "function",
        "title": "sequence"
      },
      "index": {
        "description": "Evaluate each action and collect the results",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "sequence",
        "normalized": "a(b c)-\u003eb(Vector c)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v(m a)-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:sequence_",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate each action and discard the results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v (m a) -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#sequence_",
        "fct-type": "function",
        "title": "sequence_"
      },
      "index": {
        "description": "Evaluate each action and discard the results",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "sequence_",
        "normalized": "a(b c)-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v(m a)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Vector with exactly one element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Vector with exactly one element",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "singleton",
        "normalized": "a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying it. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int-\u003e Int-\u003e v a-\u003e Vector a",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield slice of the vector without copying it The vector must contain at least elements",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003ea b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003eInt-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "snoc",
        "normalized": "a b-\u003eb-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that satisfy\n the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "span",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003e(Vector a,Vector a)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements paired with the remainder without copying.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e n v\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n v, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n v)\u003c/code\u003e\n but slightly more efficient.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e v a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "Yield the first elements paired with the remainder without copying Note that splitAt is equivalent to take drop but slightly more efficient",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "splitAt",
        "normalized": "Int-\u003ea b-\u003e(Vector b,Vector b)",
        "package": "hybrid-vectors",
        "partial": "At",
        "signature": "Int-\u003ev a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the sum of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "Compute the sum of the elements",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "sum",
        "normalized": "a b-\u003eb",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "tail",
        "normalized": "a b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield at the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case it is returned unchanged.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "Yield at the first elements without copying The vector may contain less than elements in which case it is returned unchanged",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "take",
        "normalized": "Int-\u003ea b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the longest prefix of elements satisfying the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Yield the longest prefix of elements satisfying the predicate without copying",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "takeWhile",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:thaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a mutable copy of the immutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed.html#thaw",
        "fct-type": "function",
        "title": "thaw"
      },
      "index": {
        "description": "Yield mutable copy of the immutable vector",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "thaw",
        "normalized": "a b-\u003ec(MVector(PrimState c)b)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a vector to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e [a]",
        "fct-source": "src/Data-Vector-Mixed.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to list",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "toList",
        "normalized": "a b-\u003e[b]",
        "package": "hybrid-vectors",
        "partial": "List",
        "signature": "v a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector by repeatedly applying the generator function\n to a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the next element and the\n new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\n -\u003e if n == 0 then Nothing else Just (n,n-1)) 10\n  = \u003c10,9,8,7,6,5,4,3,2,1\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Construct vector by repeatedly applying the generator function to seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldr if then Nothing else Just n-1",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with at most \u003ccode\u003en\u003c/code\u003e by repeatedly applying the\n generator function to the a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the\n next element and the new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldrN 3 (\\n -\u003e Just (n,n-1)) 10 = \u003c10,9,8\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e (b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Construct vector with at most by repeatedly applying the generator function to the seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldrN Just n-1",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "Int-\u003e(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeAccum",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccum\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e [(Int, b)] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeAccum",
        "fct-type": "function",
        "title": "unsafeAccum"
      },
      "index": {
        "description": "Same as accum but without bounds checking",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeAccum",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003e[(Int,b)]-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "Accum",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeAccumulate",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e v' (Int, b) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeAccumulate",
        "fct-type": "function",
        "title": "unsafeAccumulate"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeAccumulate",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ed(Int,b)-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev'(Int,b)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeAccumulate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e v' Int -\u003e v'' b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeAccumulate_",
        "fct-type": "function",
        "title": "unsafeAccumulate_"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeAccumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ed Int-\u003ee b-\u003eVector a",
        "package": "hybrid-vectors",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev' Int-\u003ev'' b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeBackpermute",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ebackpermute\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e v' Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeBackpermute",
        "fct-type": "function",
        "title": "unsafeBackpermute"
      },
      "index": {
        "description": "Same as backpermute but without bounds checking",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeBackpermute",
        "normalized": "a b-\u003ec Int-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Backpermute",
        "signature": "v a-\u003ev' Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e v' a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeCopy",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length This is not checked",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeCopy",
        "normalized": "a(PrimState b)c-\u003ed c-\u003eb()",
        "package": "hybrid-vectors",
        "partial": "Copy",
        "signature": "u(PrimState m)a-\u003ev' a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeDrop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector\n must contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeDrop",
        "normalized": "Int-\u003ea b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Drop",
        "signature": "Int-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe convert a mutable vector to an immutable one without\n copying. The mutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "u (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeFreeze",
        "fct-type": "function",
        "title": "unsafeFreeze"
      },
      "index": {
        "description": "Unsafe convert mutable vector to an immutable one without copying The mutable vector may not be used after this operation",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeFreeze",
        "normalized": "a(PrimState b)c-\u003eb(Vector c)",
        "package": "hybrid-vectors",
        "partial": "Freeze",
        "signature": "u(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeHead",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeHead",
        "fct-type": "function",
        "title": "unsafeHead"
      },
      "index": {
        "description": "First element without checking if the vector is empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeHead",
        "normalized": "a b-\u003eb",
        "package": "hybrid-vectors",
        "partial": "Head",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeHeadM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeHeadM",
        "fct-type": "function",
        "title": "unsafeHeadM"
      },
      "index": {
        "description": "First element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeHeadM",
        "normalized": "a b-\u003ec b",
        "package": "hybrid-vectors",
        "partial": "Head",
        "signature": "v a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe indexing without bounds checking\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeIndex",
        "fct-type": "function",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Unsafe indexing without bounds checking",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeIndex",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeIndexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad without bounds checks. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeIndexM",
        "fct-type": "function",
        "title": "unsafeIndexM"
      },
      "index": {
        "description": "Indexing in monad without bounds checks See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeIndexM",
        "normalized": "a b-\u003eInt-\u003ec b",
        "package": "hybrid-vectors",
        "partial": "Index",
        "signature": "v a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeInit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeInit",
        "normalized": "a b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Init",
        "signature": "v a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeLast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeLast",
        "fct-type": "function",
        "title": "unsafeLast"
      },
      "index": {
        "description": "Last element without checking if the vector is empty",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeLast",
        "normalized": "a b-\u003eb",
        "package": "hybrid-vectors",
        "partial": "Last",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeLastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e m a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeLastM",
        "fct-type": "function",
        "title": "unsafeLastM"
      },
      "index": {
        "description": "Last element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeLastM",
        "normalized": "a b-\u003ec b",
        "package": "hybrid-vectors",
        "partial": "Last",
        "signature": "v a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int-\u003e Int-\u003e v a-\u003e Vector a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield slice of the vector without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003ea b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeTail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeTail",
        "normalized": "a b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Tail",
        "signature": "v a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeTake",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector must\n contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "Int -\u003e v a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "Yield the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeTake",
        "normalized": "Int-\u003ea b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Take",
        "signature": "Int-\u003ev a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely convert an immutable vector to a mutable one without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeThaw",
        "fct-type": "function",
        "title": "unsafeThaw"
      },
      "index": {
        "description": "Unsafely convert an immutable vector to mutable one without copying The immutable vector may not be used after this operation",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeThaw",
        "normalized": "a b-\u003ec(MVector(PrimState c)b)",
        "package": "hybrid-vectors",
        "partial": "Thaw",
        "signature": "v a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeUpd",
      "description": {
        "fct-descr": "\u003cp\u003eSame as (\u003ccode\u003e\u003ca\u003e//\u003c/a\u003e\u003c/code\u003e) but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e [(Int, a)] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeUpd",
        "fct-type": "function",
        "title": "unsafeUpd"
      },
      "index": {
        "description": "Same as but without bounds checking",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeUpd",
        "normalized": "a b-\u003e[(Int,b)]-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Upd",
        "signature": "v a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeUpdate",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e v' (Int, a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeUpdate",
        "fct-type": "function",
        "title": "unsafeUpdate"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeUpdate",
        "normalized": "a b-\u003ec(Int,b)-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Update",
        "signature": "v a-\u003ev'(Int,a)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unsafeUpdate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a -\u003e v' Int -\u003e v'' a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Mixed.html#unsafeUpdate_",
        "fct-type": "function",
        "title": "unsafeUpdate_"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unsafeUpdate_",
        "normalized": "a b-\u003ec Int-\u003ed b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "Update",
        "signature": "v a-\u003ev' Int-\u003ev'' a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unstablePartition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't.\n The order of the elements is not preserved but the operation is often\n faster than \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Mixed.html#unstablePartition",
        "fct-type": "function",
        "title": "unstablePartition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The order of the elements is not preserved but the operation is often faster than partition",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unstablePartition",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003e(Vector a,Vector a)",
        "package": "hybrid-vectors",
        "partial": "Partition",
        "signature": "(a-\u003eBool)-\u003ev a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Unzip a vector of pairs.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v (a, b) -\u003e (Vector a, Vector b)",
        "fct-source": "src/Data-Vector-Mixed.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "min Unzip vector of pairs",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unzip",
        "normalized": "a(b,c)-\u003e(Vector b,Vector c)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v(a,b)-\u003e(Vector a,Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unzip3",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v (a, b, c) -\u003e (Vector a, Vector b, Vector c)",
        "fct-source": "src/Data-Vector-Mixed.html#unzip3",
        "fct-type": "function",
        "title": "unzip3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unzip3",
        "normalized": "a(b,c,d)-\u003e(Vector b,Vector c,Vector d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v(a,b,c)-\u003e(Vector a,Vector b,Vector c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unzip4",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v (a, b, c, d) -\u003e (Vector a, Vector b, Vector c, Vector d)",
        "fct-source": "src/Data-Vector-Mixed.html#unzip4",
        "fct-type": "function",
        "title": "unzip4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unzip4",
        "normalized": "a(b,c,d,e)-\u003e(Vector b,Vector c,Vector d,Vector e)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v(a,b,c,d)-\u003e(Vector a,Vector b,Vector c,Vector d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unzip5",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v (a, b, c, d, e) -\u003e (Vector a, Vector b, Vector c, Vector d, Vector e)",
        "fct-source": "src/Data-Vector-Mixed.html#unzip5",
        "fct-type": "function",
        "title": "unzip5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unzip5",
        "normalized": "a(b,c,d,e,f)-\u003e(Vector b,Vector c,Vector d,Vector e,Vector f)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v(a,b,c,d,e)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:unzip6",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v (a, b, c, d, e, f) -\u003e (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)",
        "fct-source": "src/Data-Vector-Mixed.html#unzip6",
        "fct-type": "function",
        "title": "unzip6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "unzip6",
        "normalized": "a(b,c,d,e,f,g)-\u003e(Vector b,Vector c,Vector d,Vector e,Vector f,Vector g)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v(a,b,c,d,e,f)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e,Vector f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:update",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the vector of index/value pairs,\n replace the vector element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update \u003c5,9,2,7\u003e \u003c(2,1),(0,3),(2,8)\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a-\u003e v' (Int, a)-\u003e Vector a",
        "fct-type": "function",
        "title": "update"
      },
      "index": {
        "description": "For each pair from the vector of index value pairs replace the vector element at position by update",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "update",
        "normalized": "a b-\u003ec(Int,b)-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ev'(Int,a)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:update_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003ea\u003c/code\u003e from the value vector, replace the element of the\n initial vector at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update_ \u003c5,9,2,7\u003e  \u003c2,0,2\u003e \u003c1,3,8\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e provides the same functionality and is usually more\n convenient.\n\u003c/p\u003e\u003cpre\u003e\n update_ xs is ys = \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e xs (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is ys)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "v a-\u003e v' Int-\u003e v'' a-\u003e Vector a",
        "fct-type": "function",
        "title": "update_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the value vector replace the element of the initial vector at position by update The function update provides the same functionality and is usually more convenient update xs is ys update xs zip is ys",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "update_",
        "normalized": "a b-\u003ec Int-\u003ed b-\u003eVector b",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "v a-\u003ev' Int-\u003ev'' a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003eElementwise pairing of array elements.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "va a -\u003e vb b -\u003e Vector (a, b)",
        "fct-source": "src/Data-Vector-Mixed.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "Elementwise pairing of array elements",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zip",
        "normalized": "a b-\u003ec d-\u003eVector(b,d)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "va a-\u003evb b-\u003eVector(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zip3",
      "description": {
        "fct-descr": "\u003cp\u003ezip together three vectors into a vector of triples\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "va a -\u003e vb b -\u003e vc c -\u003e Vector (a, b, c)",
        "fct-source": "src/Data-Vector-Mixed.html#zip3",
        "fct-type": "function",
        "title": "zip3"
      },
      "index": {
        "description": "zip together three vectors into vector of triples",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zip3",
        "normalized": "a b-\u003ec d-\u003ee f-\u003eVector(b,d,f)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "va a-\u003evb b-\u003evc c-\u003eVector(a,b,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zip4",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e Vector (a, b, c, d)",
        "fct-source": "src/Data-Vector-Mixed.html#zip4",
        "fct-type": "function",
        "title": "zip4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zip4",
        "normalized": "a b-\u003ec d-\u003ee f-\u003eg h-\u003eVector(b,d,f,h)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "va a-\u003evb b-\u003evc c-\u003evd d-\u003eVector(a,b,c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zip5",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e ve e -\u003e Vector (a, b, c, d, e)",
        "fct-source": "src/Data-Vector-Mixed.html#zip5",
        "fct-type": "function",
        "title": "zip5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zip5",
        "normalized": "a b-\u003ec d-\u003ee f-\u003eg h-\u003ei j-\u003eVector(b,d,f,h,j)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "va a-\u003evb b-\u003evc c-\u003evd d-\u003eve e-\u003eVector(a,b,c,d,e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zip6",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e ve e -\u003e vf f -\u003e Vector (a, b, c, d, e, f)",
        "fct-source": "src/Data-Vector-Mixed.html#zip6",
        "fct-type": "function",
        "title": "zip6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zip6",
        "normalized": "a b-\u003ec d-\u003ee f-\u003eg h-\u003ei j-\u003ek l-\u003eVector(b,d,f,h,j,l)",
        "package": "hybrid-vectors",
        "partial": "",
        "signature": "va a-\u003evb b-\u003evc c-\u003evd d-\u003eve e-\u003evf f-\u003eVector(a,b,c,d,e,f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e va a -\u003e vb b -\u003e Vector c",
        "fct-source": "src/Data-Vector-Mixed.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "min Zip two vectors with the given function",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ee b-\u003eVector c",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eva a-\u003evb b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e va a -\u003e vb b -\u003e vc c -\u003e Vector d",
        "fct-source": "src/Data-Vector-Mixed.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "Zip three vectors with the given function",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zipWith3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ef b-\u003eg c-\u003eVector d",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eva a-\u003evb b-\u003evc c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e Vector e",
        "fct-source": "src/Data-Vector-Mixed.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zipWith4",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003eg b-\u003eh c-\u003ei d-\u003eVector e",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eva a-\u003evb b-\u003evc c-\u003evd d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e ve e -\u003e Vector f",
        "fct-source": "src/Data-Vector-Mixed.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zipWith5",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eg a-\u003eh b-\u003ei c-\u003ej d-\u003ek e-\u003eVector f",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eva a-\u003evb b-\u003evc c-\u003evd d-\u003eve e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e va a -\u003e vb b -\u003e vc c -\u003e vd d -\u003e ve e -\u003e vf f -\u003e Vector g",
        "fct-source": "src/Data-Vector-Mixed.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zipWith6",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eh a-\u003ei b-\u003ej c-\u003ek d-\u003el e-\u003em f-\u003eVector g",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eva a-\u003evb b-\u003evc c-\u003evd d-\u003eve e-\u003evf f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and yield a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e va a -\u003e vb b -\u003e m (Vector c)",
        "fct-source": "src/Data-Vector-Mixed.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and yield vector of results",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003ee a-\u003ef b-\u003ec(Vector d)",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eva a-\u003evb b-\u003em(Vector c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hybrid-vectors/docs/Data-Vector-Mixed.html#v:zipWithM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mixed",
        "fct-package": "hybrid-vectors",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e va a -\u003e vb b -\u003e m ()",
        "fct-source": "src/Data-Vector-Mixed.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and ignore the results",
        "hierarchy": "Data Vector Mixed",
        "module": "Data.Vector.Mixed",
        "name": "zipWithM_",
        "normalized": "(a-\u003eb-\u003ec d)-\u003ee a-\u003ef b-\u003ec()",
        "package": "hybrid-vectors",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eva a-\u003evb b-\u003em()"
      }
    }
  }
]
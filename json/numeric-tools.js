[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Control-Monad-Numeric.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunction useful for writing numeric code which works with mutable\n data.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Numeric",
        "fct-package": "numeric-tools",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Numeric.html",
        "fct-type": "module",
        "title": "Numeric"
      },
      "index": {
        "description": "Function useful for writing numeric code which works with mutable data",
        "hierarchy": "Control Monad Numeric",
        "module": "Control.Monad.Numeric",
        "name": "Numeric",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Numeric",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Control-Monad-Numeric.html#v:for",
      "description": {
        "fct-descr": "\u003cp\u003eSpecialized for loop. Akin to:\n\u003c/p\u003e\u003cpre\u003e for( i = 0; i \u003c 10; i++) { ...\n\u003c/pre\u003e",
        "fct-module": "Control.Monad.Numeric",
        "fct-package": "numeric-tools",
        "fct-signature": "Int-\u003e Int-\u003e (Int -\u003e m ())-\u003e m ()",
        "fct-type": "function",
        "title": "for"
      },
      "index": {
        "description": "Specialized for loop Akin to for",
        "hierarchy": "Control Monad Numeric",
        "module": "Control.Monad.Numeric",
        "name": "for",
        "normalized": "Int-\u003eInt-\u003e(Int-\u003ea())-\u003ea()",
        "package": "numeric-tools",
        "partial": "",
        "signature": "Int-\u003eInt-\u003e(Int-\u003em())-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Control-Monad-Numeric.html#v:forGen",
      "description": {
        "fct-descr": "\u003cp\u003eFor function which act much like for loop in the C\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Numeric",
        "fct-package": "numeric-tools",
        "fct-signature": "a-\u003e (a -\u003e Bool)-\u003e (a -\u003e a)-\u003e (a -\u003e m ())-\u003e m ()",
        "fct-type": "function",
        "title": "forGen"
      },
      "index": {
        "description": "For function which act much like for loop in the",
        "hierarchy": "Control Monad Numeric",
        "module": "Control.Monad.Numeric",
        "name": "forGen",
        "normalized": "a-\u003e(a-\u003eBool)-\u003e(a-\u003ea)-\u003e(a-\u003eb())-\u003eb()",
        "package": "numeric-tools",
        "partial": "Gen",
        "signature": "a-\u003e(a-\u003eBool)-\u003e(a-\u003ea)-\u003e(a-\u003em())-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-ApproxEq.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDifferent implementations of approximate equality for floating\n point values. There are multiple ways to implement approximate\n equality. They have different semantics and it's up to programmer\n to choose right one.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.ApproxEq",
        "fct-package": "numeric-tools",
        "fct-signature": "module",
        "fct-source": "src/Numeric-ApproxEq.html",
        "fct-type": "module",
        "title": "ApproxEq"
      },
      "index": {
        "description": "Different implementations of approximate equality for floating point values There are multiple ways to implement approximate equality They have different semantics and it up to programmer to choose right one",
        "hierarchy": "Numeric ApproxEq",
        "module": "Numeric.ApproxEq",
        "name": "ApproxEq",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Approx Eq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-ApproxEq.html#v:eqAbsolute",
      "description": {
        "fct-descr": "\u003cp\u003eDifference between values is less than specified precision.\n\u003c/p\u003e",
        "fct-module": "Numeric.ApproxEq",
        "fct-package": "numeric-tools",
        "fct-signature": "a-\u003e a-\u003e a-\u003e Bool",
        "fct-type": "function",
        "title": "eqAbsolute"
      },
      "index": {
        "description": "Difference between values is less than specified precision",
        "hierarchy": "Numeric ApproxEq",
        "module": "Numeric.ApproxEq",
        "name": "eqAbsolute",
        "normalized": "a-\u003ea-\u003ea-\u003eBool",
        "package": "numeric-tools",
        "partial": "Absolute",
        "signature": "a-\u003ea-\u003ea-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-ApproxEq.html#v:eqRelCompl",
      "description": {
        "fct-descr": "\u003cp\u003eRelative equality for comlex numbers. \n\u003c/p\u003e",
        "fct-module": "Numeric.ApproxEq",
        "fct-package": "numeric-tools",
        "fct-signature": "a-\u003e Complex a-\u003e Complex a-\u003e Bool",
        "fct-type": "function",
        "title": "eqRelCompl"
      },
      "index": {
        "description": "Relative equality for comlex numbers",
        "hierarchy": "Numeric ApproxEq",
        "module": "Numeric.ApproxEq",
        "name": "eqRelCompl",
        "normalized": "a-\u003eComplex a-\u003eComplex a-\u003eBool",
        "package": "numeric-tools",
        "partial": "Rel Compl",
        "signature": "a-\u003eComplex a-\u003eComplex a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-ApproxEq.html#v:eqRelative",
      "description": {
        "fct-descr": "\u003cp\u003eRelative difference between two numbers are less than predefined\n   value.  For example 1 is approximately equal to 1.0001 with 1e-4\n   precision. Same is true for 10000 and 10001.\n\u003c/p\u003e\u003cp\u003eThis method of camparison doesn't work for numbers which are\n   approximately 0. \u003ccode\u003e\u003ca\u003eeqAbsolute\u003c/a\u003e\u003c/code\u003e should be used instead.\n\u003c/p\u003e",
        "fct-module": "Numeric.ApproxEq",
        "fct-package": "numeric-tools",
        "fct-signature": "a-\u003e a-\u003e a-\u003e Bool",
        "fct-type": "function",
        "title": "eqRelative"
      },
      "index": {
        "description": "Relative difference between two numbers are less than predefined value For example is approximately equal to with e-4 precision Same is true for and This method of camparison doesn work for numbers which are approximately eqAbsolute should be used instead",
        "hierarchy": "Numeric ApproxEq",
        "module": "Numeric.ApproxEq",
        "name": "eqRelative",
        "normalized": "a-\u003ea-\u003ea-\u003eBool",
        "package": "numeric-tools",
        "partial": "Relative",
        "signature": "a-\u003ea-\u003ea-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-ApproxEq.html#v:within",
      "description": {
        "fct-descr": "\u003cp\u003eCompare two \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e values for approximate equality, using\n Dawson's method.\n\u003c/p\u003e\u003cp\u003eThe required accuracy is specified in ULPs (units of least\n precision).  If the two numbers differ by the given number of ULPs\n or less, this function returns \u003ccode\u003eTrue\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAlgorithm is based on Bruce Dawson's \"Comparing floating point\n numbers\":\n \u003ca\u003ehttp://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\u003c/a\u003e\n\u003c/p\u003e",
        "fct-module": "Numeric.ApproxEq",
        "fct-package": "numeric-tools",
        "fct-signature": "Int-\u003e Double-\u003e Double-\u003e Bool",
        "fct-type": "function",
        "title": "within"
      },
      "index": {
        "description": "Compare two Double values for approximate equality using Dawson method The required accuracy is specified in ULPs units of least precision If the two numbers differ by the given number of ULPs or less this function returns True Algorithm is based on Bruce Dawson Comparing floating point numbers http www.cygnus-software.com papers comparingfloats comparingfloats.htm",
        "hierarchy": "Numeric ApproxEq",
        "module": "Numeric.ApproxEq",
        "name": "within",
        "normalized": "Int-\u003eDouble-\u003eDouble-\u003eBool",
        "package": "numeric-tools",
        "partial": "",
        "signature": "Int-\u003eDouble-\u003eDouble-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Classes-Indexing.html#",
      "description": {
        "fct-module": "Numeric.Classes.Indexing",
        "fct-package": "numeric-tools",
        "fct-signature": "module",
        "fct-source": "src/Numeric-Classes-Indexing.html",
        "fct-type": "module",
        "title": "Indexing"
      },
      "index": {
        "description": "",
        "hierarchy": "Numeric Classes Indexing",
        "module": "Numeric.Classes.Indexing",
        "name": "Indexing",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Indexing",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Classes-Indexing.html#t:Indexable",
      "description": {
        "fct-descr": "\u003cp\u003eType class for array-like data type which support \u003ccode\u003eO(1)\u003c/code\u003e access\n   by integer index starting from zero.\n\u003c/p\u003e",
        "fct-module": "Numeric.Classes.Indexing",
        "fct-package": "numeric-tools",
        "fct-signature": "class",
        "fct-source": "src/Numeric-Classes-Indexing.html#Indexable",
        "fct-type": "class",
        "title": "Indexable"
      },
      "index": {
        "description": "Type class for array-like data type which support access by integer index starting from zero",
        "hierarchy": "Numeric Classes Indexing",
        "module": "Numeric.Classes.Indexing",
        "name": "Indexable",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Indexable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Classes-Indexing.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Safe indexing. Calls error if index is out of range.\n\u003c/p\u003e",
        "fct-module": "Numeric.Classes.Indexing",
        "fct-package": "numeric-tools",
        "fct-signature": "a -\u003e Int -\u003e IndexVal a",
        "fct-source": "src/Numeric-Classes-Indexing.html#%21",
        "fct-type": "method",
        "title": "(!)"
      },
      "index": {
        "description": "Safe indexing Calls error if index is out of range",
        "hierarchy": "Numeric Classes Indexing",
        "module": "Numeric.Classes.Indexing",
        "name": "(!) !",
        "normalized": "a-\u003eInt-\u003eIndexVal a",
        "package": "numeric-tools",
        "partial": "",
        "signature": "a-\u003eInt-\u003eIndexVal a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Classes-Indexing.html#v:size",
      "description": {
        "fct-descr": "\u003cp\u003eSize of table.\n\u003c/p\u003e",
        "fct-module": "Numeric.Classes.Indexing",
        "fct-package": "numeric-tools",
        "fct-signature": "a -\u003e Int",
        "fct-source": "src/Numeric-Classes-Indexing.html#size",
        "fct-type": "method",
        "title": "size"
      },
      "index": {
        "description": "Size of table",
        "hierarchy": "Numeric Classes Indexing",
        "module": "Numeric.Classes.Indexing",
        "name": "size",
        "normalized": "a-\u003eInt",
        "package": "numeric-tools",
        "partial": "",
        "signature": "a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Classes-Indexing.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Index table without range cheking.\n\u003c/p\u003e",
        "fct-module": "Numeric.Classes.Indexing",
        "fct-package": "numeric-tools",
        "fct-signature": "a -\u003e Int -\u003e IndexVal a",
        "fct-source": "src/Numeric-Classes-Indexing.html#unsafeIndex",
        "fct-type": "method",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Index table without range cheking",
        "hierarchy": "Numeric Classes Indexing",
        "module": "Numeric.Classes.Indexing",
        "name": "unsafeIndex",
        "normalized": "a-\u003eInt-\u003eIndexVal a",
        "package": "numeric-tools",
        "partial": "Index",
        "signature": "a-\u003eInt-\u003eIndexVal a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Classes-Indexing.html#v:validIndex",
      "description": {
        "fct-descr": "\u003cp\u003eCheck that index is valid\n\u003c/p\u003e",
        "fct-module": "Numeric.Classes.Indexing",
        "fct-package": "numeric-tools",
        "fct-signature": "a -\u003e Int -\u003e Bool",
        "fct-source": "src/Numeric-Classes-Indexing.html#validIndex",
        "fct-type": "function",
        "title": "validIndex"
      },
      "index": {
        "description": "Check that index is valid",
        "hierarchy": "Numeric Classes Indexing",
        "module": "Numeric.Classes.Indexing",
        "name": "validIndex",
        "normalized": "a-\u003eInt-\u003eBool",
        "package": "numeric-tools",
        "partial": "Index",
        "signature": "a-\u003eInt-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNumerical differentiation. \u003ccode\u003e\u003ca\u003ediffRichardson\u003c/a\u003e\u003c/code\u003e is preferred way to\n calculate derivative.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "module",
        "fct-source": "src/Numeric-Tools-Differentiation.html",
        "fct-type": "module",
        "title": "Differentiation"
      },
      "index": {
        "description": "Numerical differentiation diffRichardson is preferred way to calculate derivative",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "Differentiation",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Differentiation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#t:DiffRes",
      "description": {
        "fct-descr": "\u003cp\u003eDifferentiation result\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "data",
        "fct-source": "src/Numeric-Tools-Differentiation.html#DiffRes",
        "fct-type": "data",
        "title": "DiffRes"
      },
      "index": {
        "description": "Differentiation result",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "DiffRes",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Diff Res",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#v:DiffRes",
      "description": {
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "DiffRes",
        "fct-source": "src/Numeric-Tools-Differentiation.html#DiffRes",
        "fct-type": "function",
        "title": "DiffRes"
      },
      "index": {
        "description": "",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "DiffRes",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Diff Res",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#v:diffPrecision",
      "description": {
        "fct-descr": "\u003cp\u003eRough error estimate\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-Tools-Differentiation.html#DiffRes",
        "fct-type": "function",
        "title": "diffPrecision"
      },
      "index": {
        "description": "Rough error estimate",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "diffPrecision",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Precision",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#v:diffRes",
      "description": {
        "fct-descr": "\u003cp\u003eDerivative value\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-Tools-Differentiation.html#DiffRes",
        "fct-type": "function",
        "title": "diffRes"
      },
      "index": {
        "description": "Derivative value",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "diffRes",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Res",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#v:diffRichardson",
      "description": {
        "fct-descr": "\u003cp\u003eCalculate derivative using Richaradson's deferred approach to\n   limit. This is a preferred method for numeric differentiation\n   since it's most precise. Function could be evaluated up to 20\n   times.\n\u003c/p\u003e\u003cp\u003eInitial step size should be chosen fairly big. Too small one will\n   result reduced precision, too big one in nonsensical answer.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "(Double -\u003e Double)-\u003e Double-\u003e Double-\u003e DiffRes",
        "fct-type": "function",
        "title": "diffRichardson"
      },
      "index": {
        "description": "Calculate derivative using Richaradson deferred approach to limit This is preferred method for numeric differentiation since it most precise Function could be evaluated up to times Initial step size should be chosen fairly big Too small one will result reduced precision too big one in nonsensical answer",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "diffRichardson",
        "normalized": "(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003eDiffRes",
        "package": "numeric-tools",
        "partial": "Richardson",
        "signature": "(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003eDiffRes"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#v:diffSimmetric",
      "description": {
        "fct-descr": "\u003cp\u003eSimple differentiation. It uses simmetric rule and provide\n   reasonable accuracy. It's suitable when function evaluation is\n   expensive and precision could be traded for speed.\n\u003c/p\u003e\u003cpre\u003e f'(x) = f(x-h) + f(x+h) / 2h\n\u003c/pre\u003e",
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "(Double -\u003e Double)-\u003e Double-\u003e Double-\u003e Double",
        "fct-type": "function",
        "title": "diffSimmetric"
      },
      "index": {
        "description": "Simple differentiation It uses simmetric rule and provide reasonable accuracy It suitable when function evaluation is expensive and precision could be traded for speed x-h",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "diffSimmetric",
        "normalized": "(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003eDouble",
        "package": "numeric-tools",
        "partial": "Simmetric",
        "signature": "(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#v:diffSimple",
      "description": {
        "fct-descr": "\u003cp\u003eSimplest form of differentiation. Should be used only when\n   function evaluation is prohibitively expensive and already\n   computed value at point \u003ccode\u003ex\u003c/code\u003e should be reused.\n\u003c/p\u003e\u003cpre\u003e f'(x) = f(x+h) - f(x) / h\n\u003c/pre\u003e",
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "(Double -\u003e Double)-\u003e Double-\u003e (Double, Double)-\u003e Double",
        "fct-type": "function",
        "title": "diffSimple"
      },
      "index": {
        "description": "Simplest form of differentiation Should be used only when function evaluation is prohibitively expensive and already computed value at point should be reused",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "diffSimple",
        "normalized": "(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)-\u003eDouble",
        "package": "numeric-tools",
        "partial": "Simple",
        "signature": "(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Differentiation.html#v:representableDelta",
      "description": {
        "fct-descr": "\u003cp\u003eFor number \u003ccode\u003ex\u003c/code\u003e and small \u003ccode\u003eh\u003c/code\u003e return such \u003ccode\u003eh'\u003c/code\u003e that \u003ccode\u003ex+h'\u003c/code\u003e and \u003ccode\u003ex\u003c/code\u003e\n differ by representable number\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Differentiation",
        "fct-package": "numeric-tools",
        "fct-signature": "Double-\u003e Double-\u003e Double",
        "fct-type": "function",
        "title": "representableDelta"
      },
      "index": {
        "description": "For number and small return such that and differ by representable number",
        "hierarchy": "Numeric Tools Differentiation",
        "module": "Numeric.Tools.Differentiation",
        "name": "representableDelta",
        "normalized": "Double-\u003eDouble-\u003eDouble",
        "package": "numeric-tools",
        "partial": "Delta",
        "signature": "Double-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNumerical solution of ordinary equations.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "module",
        "fct-source": "src/Numeric-Tools-Equation.html",
        "fct-type": "module",
        "title": "Equation"
      },
      "index": {
        "description": "Numerical solution of ordinary equations",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "Equation",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Equation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#t:Root",
      "description": {
        "fct-descr": "\u003cp\u003eThe result of searching for a root of a mathematical function.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "data",
        "fct-source": "src/Numeric-Tools-Equation.html#Root",
        "fct-type": "data",
        "title": "Root"
      },
      "index": {
        "description": "The result of searching for root of mathematical function",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "Root",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Root",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#v:NotBracketed",
      "description": {
        "fct-descr": "\u003cp\u003eThe function does not have opposite signs when\n evaluated at the lower and upper bounds of the search.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "NotBracketed",
        "fct-source": "src/Numeric-Tools-Equation.html#Root",
        "fct-type": "function",
        "title": "NotBracketed"
      },
      "index": {
        "description": "The function does not have opposite signs when evaluated at the lower and upper bounds of the search",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "NotBracketed",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Not Bracketed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#v:Root",
      "description": {
        "fct-descr": "\u003cp\u003eA root was successfully found.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "Root a",
        "fct-source": "src/Numeric-Tools-Equation.html#Root",
        "fct-type": "function",
        "title": "Root"
      },
      "index": {
        "description": "root was successfully found",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "Root",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Root",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#v:SearchFailed",
      "description": {
        "fct-descr": "\u003cp\u003eThe search failed to converge to within the given\n error tolerance after the given number of iterations.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "SearchFailed",
        "fct-source": "src/Numeric-Tools-Equation.html#Root",
        "fct-type": "function",
        "title": "SearchFailed"
      },
      "index": {
        "description": "The search failed to converge to within the given error tolerance after the given number of iterations",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "SearchFailed",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Search Failed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#v:fromRoot",
      "description": {
        "fct-descr": "\u003cp\u003eReturns either the result of a search for a root, or the default\n value if the search failed.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "a-\u003e Root a-\u003e a",
        "fct-type": "function",
        "title": "fromRoot"
      },
      "index": {
        "description": "Returns either the result of search for root or the default value if the search failed",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "fromRoot",
        "normalized": "a-\u003eRoot a-\u003ea",
        "package": "numeric-tools",
        "partial": "Root",
        "signature": "a-\u003eRoot a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#v:solveBisection",
      "description": {
        "fct-descr": "\u003cp\u003eUse bisection method to compute root of function.\n\u003c/p\u003e\u003cp\u003eThe function must have opposite signs when evaluated at the lower\n and upper bounds of the search (i.e. the root must be bracketed).\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "Double-\u003e (Double, Double)-\u003e (Double -\u003e Double)-\u003e Root Double",
        "fct-type": "function",
        "title": "solveBisection"
      },
      "index": {
        "description": "Use bisection method to compute root of function The function must have opposite signs when evaluated at the lower and upper bounds of the search i.e the root must be bracketed",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "solveBisection",
        "normalized": "Double-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eRoot Double",
        "package": "numeric-tools",
        "partial": "Bisection",
        "signature": "Double-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eRoot Double"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#v:solveNewton",
      "description": {
        "fct-descr": "\u003cp\u003eSolve equation using Newton-Raphson method. Root must be\n   bracketed. If Newton's step jumps outside of bracket or do not\n   converge sufficiently fast function reverts to bisection.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "Double-\u003e (Double, Double)-\u003e (Double -\u003e Double)-\u003e (Double -\u003e Double)-\u003e Root Double",
        "fct-type": "function",
        "title": "solveNewton"
      },
      "index": {
        "description": "Solve equation using Newton-Raphson method Root must be bracketed If Newton step jumps outside of bracket or do not converge sufficiently fast function reverts to bisection",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "solveNewton",
        "normalized": "Double-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003e(Double-\u003eDouble)-\u003eRoot Double",
        "package": "numeric-tools",
        "partial": "Newton",
        "signature": "Double-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003e(Double-\u003eDouble)-\u003eRoot Double"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Equation.html#v:solveRidders",
      "description": {
        "fct-descr": "\u003cp\u003eUse the method of Ridders to compute a root of a function.\n\u003c/p\u003e\u003cp\u003eThe function must have opposite signs when evaluated at the lower\n and upper bounds of the search (i.e. the root must be bracketed).\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Equation",
        "fct-package": "numeric-tools",
        "fct-signature": "Double-\u003e (Double, Double)-\u003e (Double -\u003e Double)-\u003e Root Double",
        "fct-type": "function",
        "title": "solveRidders"
      },
      "index": {
        "description": "Use the method of Ridders to compute root of function The function must have opposite signs when evaluated at the lower and upper bounds of the search i.e the root must be bracketed",
        "hierarchy": "Numeric Tools Equation",
        "module": "Numeric.Tools.Equation",
        "name": "solveRidders",
        "normalized": "Double-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eRoot Double",
        "package": "numeric-tools",
        "partial": "Ridders",
        "signature": "Double-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eRoot Double"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFuntions for numerical integration. \u003ccode\u003e\u003ca\u003equadRomberg\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003equadSimpson\u003c/a\u003e\u003c/code\u003e\n are reasonable choices in most cases. For non-smooth function they\n converge poorly and \u003ccode\u003e\u003ca\u003equadTrapezoid\u003c/a\u003e\u003c/code\u003e should be used then.\n\u003c/p\u003e\u003cp\u003eFor example this code intergrates exponent from 0 to 1:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet res = quadRomberg defQuad (0, 1) exp\n\u003c/code\u003e\u003c/strong\u003e\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003equadRes res     -- Integration result\n\u003c/code\u003e\u003c/strong\u003eJust 1.718281828459045\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003equadPrecEst res -- Estimate of precision\n\u003c/code\u003e\u003c/strong\u003e2.5844957590474064e-16\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003equadNIter res   -- Number of iterations performed\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e\u003c/div\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "module",
        "fct-source": "src/Numeric-Tools-Integration.html",
        "fct-type": "module",
        "title": "Integration"
      },
      "index": {
        "description": "Funtions for numerical integration quadRomberg or quadSimpson are reasonable choices in most cases For non-smooth function they converge poorly and quadTrapezoid should be used then For example this code intergrates exponent from to let res quadRomberg defQuad exp quadRes res Integration result Just quadPrecEst res Estimate of precision e-16 quadNIter res Number of iterations performed",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "Integration",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Integration",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#t:QuadParam",
      "description": {
        "fct-descr": "\u003cp\u003eIntegration parameters for numerical routines. Note that each\n additional iteration doubles number of function evaluation required\n to compute integral.\n\u003c/p\u003e\u003cp\u003eNumber of iterations is capped at 30.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "data",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadParam",
        "fct-type": "data",
        "title": "QuadParam"
      },
      "index": {
        "description": "Integration parameters for numerical routines Note that each additional iteration doubles number of function evaluation required to compute integral Number of iterations is capped at",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "QuadParam",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Quad Param",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#t:QuadRes",
      "description": {
        "fct-descr": "\u003cp\u003eResult of numeric integration.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "data",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadRes",
        "fct-type": "data",
        "title": "QuadRes"
      },
      "index": {
        "description": "Result of numeric integration",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "QuadRes",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Quad Res",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:QuadParam",
      "description": {
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "QuadParam",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadParam",
        "fct-type": "function",
        "title": "QuadParam"
      },
      "index": {
        "description": "",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "QuadParam",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Quad Param",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:QuadRes",
      "description": {
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "QuadRes",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadRes",
        "fct-type": "function",
        "title": "QuadRes"
      },
      "index": {
        "description": "",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "QuadRes",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Quad Res",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:defQuad",
      "description": {
        "fct-descr": "\u003cp\u003eDefault parameters for integration functions\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Maximum number of iterations = 20\n\u003c/li\u003e\u003cli\u003e Precision is 10&#8315;&#8313;\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "QuadParam",
        "fct-source": "src/Numeric-Tools-Integration.html#defQuad",
        "fct-type": "function",
        "title": "defQuad"
      },
      "index": {
        "description": "Default parameters for integration functions Maximum number of iterations Precision is",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "defQuad",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Quad",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadBestEst",
      "description": {
        "fct-descr": "\u003cp\u003eBest estimate of integral\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadRes",
        "fct-type": "function",
        "title": "quadBestEst"
      },
      "index": {
        "description": "Best estimate of integral",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadBestEst",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Best Est",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadMaxIter",
      "description": {
        "fct-descr": "\u003cp\u003eMaximum number of iterations\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "Int",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadParam",
        "fct-type": "function",
        "title": "quadMaxIter"
      },
      "index": {
        "description": "Maximum number of iterations",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadMaxIter",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Max Iter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadNIter",
      "description": {
        "fct-descr": "\u003cp\u003eNumber of iterations\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "Int",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadRes",
        "fct-type": "function",
        "title": "quadNIter"
      },
      "index": {
        "description": "Number of iterations",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadNIter",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "NIter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadPrecEst",
      "description": {
        "fct-descr": "\u003cp\u003eRough estimate of attained precision\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadRes",
        "fct-type": "function",
        "title": "quadPrecEst"
      },
      "index": {
        "description": "Rough estimate of attained precision",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadPrecEst",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Prec Est",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadPrecision",
      "description": {
        "fct-descr": "\u003cp\u003eRelative precision of answer\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "Double",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadParam",
        "fct-type": "function",
        "title": "quadPrecision"
      },
      "index": {
        "description": "Relative precision of answer",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadPrecision",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Precision",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadRes",
      "description": {
        "fct-descr": "\u003cp\u003eIntegraion result\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "Maybe Double",
        "fct-source": "src/Numeric-Tools-Integration.html#QuadRes",
        "fct-type": "function",
        "title": "quadRes"
      },
      "index": {
        "description": "Integraion result",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadRes",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Res",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadRomberg",
      "description": {
        "fct-descr": "\u003cp\u003eIntegration using Romberg rule. For sufficiently smooth functions\n   (e.g. analytic) it's a fastest of three.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "QuadParam-\u003e (Double, Double)-\u003e (Double -\u003e Double)-\u003e QuadRes",
        "fct-type": "function",
        "title": "quadRomberg"
      },
      "index": {
        "description": "Integration using Romberg rule For sufficiently smooth functions e.g analytic it fastest of three",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadRomberg",
        "normalized": "QuadParam-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eQuadRes",
        "package": "numeric-tools",
        "partial": "Romberg",
        "signature": "QuadParam-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eQuadRes"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadSimpson",
      "description": {
        "fct-descr": "\u003cp\u003eIntegration using Simpson rule. It should be more efficient than\n   \u003ccode\u003e\u003ca\u003equadTrapezoid\u003c/a\u003e\u003c/code\u003e if function being integrated have finite fourth\n   derivative.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "QuadParam-\u003e (Double, Double)-\u003e (Double -\u003e Double)-\u003e QuadRes",
        "fct-type": "function",
        "title": "quadSimpson"
      },
      "index": {
        "description": "Integration using Simpson rule It should be more efficient than quadTrapezoid if function being integrated have finite fourth derivative",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadSimpson",
        "normalized": "QuadParam-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eQuadRes",
        "package": "numeric-tools",
        "partial": "Simpson",
        "signature": "QuadParam-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eQuadRes"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Integration.html#v:quadTrapezoid",
      "description": {
        "fct-descr": "\u003cp\u003eIntegration of using trapezoids. This is robust algorithm and\n   place and useful for not very smooth. But it is very slow. It\n   hundreds times slower then \u003ccode\u003e\u003ca\u003equadRomberg\u003c/a\u003e\u003c/code\u003e if function is\n   sufficiently smooth.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Integration",
        "fct-package": "numeric-tools",
        "fct-signature": "QuadParam-\u003e (Double, Double)-\u003e (Double -\u003e Double)-\u003e QuadRes",
        "fct-type": "function",
        "title": "quadTrapezoid"
      },
      "index": {
        "description": "Integration of using trapezoids This is robust algorithm and place and useful for not very smooth But it is very slow It hundreds times slower then quadRomberg if function is sufficiently smooth",
        "hierarchy": "Numeric Tools Integration",
        "module": "Numeric.Tools.Integration",
        "name": "quadTrapezoid",
        "normalized": "QuadParam-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eQuadRes",
        "package": "numeric-tools",
        "partial": "Trapezoid",
        "signature": "QuadParam-\u003e(Double,Double)-\u003e(Double-\u003eDouble)-\u003eQuadRes"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunction interpolation.\n\u003c/p\u003e\u003cp\u003eSine interpolation using cubic splines:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet tbl = cubicSpline $ tabulateFun (uniformMesh (0,10) 100) sin\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etbl `at` 1.786\n\u003c/code\u003e\u003c/strong\u003e0.9769239849844867\n\u003c/pre\u003e\u003c/div\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "module",
        "fct-source": "src/Numeric-Tools-Interpolation.html",
        "fct-type": "module",
        "title": "Interpolation"
      },
      "index": {
        "description": "Function interpolation Sine interpolation using cubic splines let tbl cubicSpline tabulateFun uniformMesh sin tbl at",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "Interpolation",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Interpolation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#t:CubicSpline",
      "description": {
        "fct-descr": "\u003cp\u003eNatural cubic splines\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "data",
        "fct-source": "src/Numeric-Tools-Interpolation.html#CubicSpline",
        "fct-type": "data",
        "title": "CubicSpline"
      },
      "index": {
        "description": "Natural cubic splines",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "CubicSpline",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Cubic Spline",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#t:Interpolation",
      "description": {
        "fct-descr": "\u003cp\u003eInterpolation for arbitraty meshes\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "class",
        "fct-source": "src/Numeric-Tools-Interpolation.html#Interpolation",
        "fct-type": "class",
        "title": "Interpolation"
      },
      "index": {
        "description": "Interpolation for arbitraty meshes",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "Interpolation",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Interpolation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#t:LinearInterp",
      "description": {
        "fct-descr": "\u003cp\u003eData for linear interpolation\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "data",
        "fct-source": "src/Numeric-Tools-Interpolation.html#LinearInterp",
        "fct-type": "data",
        "title": "LinearInterp"
      },
      "index": {
        "description": "Data for linear interpolation",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "LinearInterp",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Linear Interp",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#v:at",
      "description": {
        "fct-descr": "\u003cp\u003eInterpolate function at some point. Function should not\n   fail outside of mesh however it may and most likely will give\n   nonsensical results\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "a m -\u003e Double -\u003e Double",
        "fct-source": "src/Numeric-Tools-Interpolation.html#at",
        "fct-type": "method",
        "title": "at"
      },
      "index": {
        "description": "Interpolate function at some point Function should not fail outside of mesh however it may and most likely will give nonsensical results",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "at",
        "normalized": "a b-\u003eDouble-\u003eDouble",
        "package": "numeric-tools",
        "partial": "",
        "signature": "a m-\u003eDouble-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#v:cubicSpline",
      "description": {
        "fct-descr": "\u003cp\u003eFunction used to fix types\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "CubicSpline a -\u003e CubicSpline a",
        "fct-source": "src/Numeric-Tools-Interpolation.html#cubicSpline",
        "fct-type": "function",
        "title": "cubicSpline"
      },
      "index": {
        "description": "Function used to fix types",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "cubicSpline",
        "normalized": "CubicSpline a-\u003eCubicSpline a",
        "package": "numeric-tools",
        "partial": "Spline",
        "signature": "CubicSpline a-\u003eCubicSpline a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#v:interpolationMesh",
      "description": {
        "fct-descr": "\u003cp\u003eGet mesh.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "a m -\u003e m",
        "fct-source": "src/Numeric-Tools-Interpolation.html#interpolationMesh",
        "fct-type": "method",
        "title": "interpolationMesh"
      },
      "index": {
        "description": "Get mesh",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "interpolationMesh",
        "normalized": "a b-\u003eb",
        "package": "numeric-tools",
        "partial": "Mesh",
        "signature": "a m-\u003em"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#v:interpolationTable",
      "description": {
        "fct-descr": "\u003cp\u003eGet table of function values \n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "a m -\u003e Vector Double",
        "fct-source": "src/Numeric-Tools-Interpolation.html#interpolationTable",
        "fct-type": "method",
        "title": "interpolationTable"
      },
      "index": {
        "description": "Get table of function values",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "interpolationTable",
        "normalized": "a b-\u003eVector Double",
        "package": "numeric-tools",
        "partial": "Table",
        "signature": "a m-\u003eVector Double"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#v:linearInterp",
      "description": {
        "fct-descr": "\u003cp\u003eFunction used to fix types\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "LinearInterp a -\u003e LinearInterp a",
        "fct-source": "src/Numeric-Tools-Interpolation.html#linearInterp",
        "fct-type": "function",
        "title": "linearInterp"
      },
      "index": {
        "description": "Function used to fix types",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "linearInterp",
        "normalized": "LinearInterp a-\u003eLinearInterp a",
        "package": "numeric-tools",
        "partial": "Interp",
        "signature": "LinearInterp a-\u003eLinearInterp a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#v:tabulate",
      "description": {
        "fct-descr": "\u003cp\u003eUse table of already evaluated function and mesh. Sizes of mesh\n   and table must coincide. \n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "m -\u003e v Double -\u003e a m",
        "fct-source": "src/Numeric-Tools-Interpolation.html#tabulate",
        "fct-type": "function",
        "title": "tabulate"
      },
      "index": {
        "description": "Use table of already evaluated function and mesh Sizes of mesh and table must coincide",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "tabulate",
        "normalized": "a-\u003eb Double-\u003ec a",
        "package": "numeric-tools",
        "partial": "",
        "signature": "m-\u003ev Double-\u003ea m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#v:tabulateFun",
      "description": {
        "fct-descr": "\u003cp\u003eTabulate function\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "m -\u003e (Double -\u003e Double) -\u003e a m",
        "fct-source": "src/Numeric-Tools-Interpolation.html#tabulateFun",
        "fct-type": "method",
        "title": "tabulateFun"
      },
      "index": {
        "description": "Tabulate function",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "tabulateFun",
        "normalized": "a-\u003e(Double-\u003eDouble)-\u003eb a",
        "package": "numeric-tools",
        "partial": "Fun",
        "signature": "m-\u003e(Double-\u003eDouble)-\u003ea m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Interpolation.html#v:unsafeTabulate",
      "description": {
        "fct-descr": "\u003cp\u003eUse table of already evaluated function and mesh. Sizes of mesh\n   and table must coincide but it's not checked. Do not use this\n   function use \u003ccode\u003e\u003ca\u003etabulate\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Interpolation",
        "fct-package": "numeric-tools",
        "fct-signature": "m -\u003e v Double -\u003e a m",
        "fct-source": "src/Numeric-Tools-Interpolation.html#unsafeTabulate",
        "fct-type": "method",
        "title": "unsafeTabulate"
      },
      "index": {
        "description": "Use table of already evaluated function and mesh Sizes of mesh and table must coincide but it not checked Do not use this function use tabulate instead",
        "hierarchy": "Numeric Tools Interpolation",
        "module": "Numeric.Tools.Interpolation",
        "name": "unsafeTabulate",
        "normalized": "a-\u003eb Double-\u003ec a",
        "package": "numeric-tools",
        "partial": "Tabulate",
        "signature": "m-\u003ev Double-\u003ea m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Mesh.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e1-dimensional meshes. Used by \u003ccode\u003eNumeric.Tools.Interpolation\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Numeric.Tools.Mesh",
        "fct-package": "numeric-tools",
        "fct-signature": "module",
        "fct-source": "src/Numeric-Tools-Mesh.html",
        "fct-type": "module",
        "title": "Mesh"
      },
      "index": {
        "description": "dimensional meshes Used by Numeric.Tools.Interpolation",
        "hierarchy": "Numeric Tools Mesh",
        "module": "Numeric.Tools.Mesh",
        "name": "Mesh",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Mesh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Mesh.html#t:Mesh",
      "description": {
        "fct-descr": "\u003cp\u003eClass for 1-dimensional meshes. Mesh is ordered set of\n points. Each instance must guarantee that every next point is\n greater that previous and there is at least 2 points in mesh.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Mesh",
        "fct-package": "numeric-tools",
        "fct-signature": "class",
        "fct-source": "src/Numeric-Tools-Mesh.html#Mesh",
        "fct-type": "class",
        "title": "Mesh"
      },
      "index": {
        "description": "Class for dimensional meshes Mesh is ordered set of points Each instance must guarantee that every next point is greater that previous and there is at least points in mesh",
        "hierarchy": "Numeric Tools Mesh",
        "module": "Numeric.Tools.Mesh",
        "name": "Mesh",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Mesh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Mesh.html#t:UniformMesh",
      "description": {
        "fct-descr": "\u003cp\u003eUniform mesh\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Mesh",
        "fct-package": "numeric-tools",
        "fct-signature": "data",
        "fct-source": "src/Numeric-Tools-Mesh.html#UniformMesh",
        "fct-type": "data",
        "title": "UniformMesh"
      },
      "index": {
        "description": "Uniform mesh",
        "hierarchy": "Numeric Tools Mesh",
        "module": "Numeric.Tools.Mesh",
        "name": "UniformMesh",
        "normalized": "",
        "package": "numeric-tools",
        "partial": "Uniform Mesh",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Mesh.html#v:meshFindIndex",
      "description": {
        "fct-descr": "\u003cp\u003eFind such index for value that\n\u003c/p\u003e\u003cpre\u003e mesh ! i \u003c= x && mesh ! i+1 \u003e x\n\u003c/pre\u003e\u003cp\u003eWill return invalid index if value is out of range.\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Mesh",
        "fct-package": "numeric-tools",
        "fct-signature": "a -\u003e Double -\u003e Int",
        "fct-source": "src/Numeric-Tools-Mesh.html#meshFindIndex",
        "fct-type": "method",
        "title": "meshFindIndex"
      },
      "index": {
        "description": "Find such index for value that mesh mesh Will return invalid index if value is out of range",
        "hierarchy": "Numeric Tools Mesh",
        "module": "Numeric.Tools.Mesh",
        "name": "meshFindIndex",
        "normalized": "a-\u003eDouble-\u003eInt",
        "package": "numeric-tools",
        "partial": "Find Index",
        "signature": "a-\u003eDouble-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Mesh.html#v:meshLowerBound",
      "description": {
        "fct-descr": "\u003cp\u003eLow bound of mesh\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Mesh",
        "fct-package": "numeric-tools",
        "fct-signature": "a -\u003e Double",
        "fct-source": "src/Numeric-Tools-Mesh.html#meshLowerBound",
        "fct-type": "method",
        "title": "meshLowerBound"
      },
      "index": {
        "description": "Low bound of mesh",
        "hierarchy": "Numeric Tools Mesh",
        "module": "Numeric.Tools.Mesh",
        "name": "meshLowerBound",
        "normalized": "a-\u003eDouble",
        "package": "numeric-tools",
        "partial": "Lower Bound",
        "signature": "a-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Mesh.html#v:meshUpperBound",
      "description": {
        "fct-descr": "\u003cp\u003eUpper bound of mesh\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Mesh",
        "fct-package": "numeric-tools",
        "fct-signature": "a -\u003e Double",
        "fct-source": "src/Numeric-Tools-Mesh.html#meshUpperBound",
        "fct-type": "method",
        "title": "meshUpperBound"
      },
      "index": {
        "description": "Upper bound of mesh",
        "hierarchy": "Numeric Tools Mesh",
        "module": "Numeric.Tools.Mesh",
        "name": "meshUpperBound",
        "normalized": "a-\u003eDouble",
        "package": "numeric-tools",
        "partial": "Upper Bound",
        "signature": "a-\u003eDouble"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Mesh.html#v:uniformMesh",
      "description": {
        "fct-descr": "\u003cp\u003eCreate uniform mesh\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Mesh",
        "fct-package": "numeric-tools",
        "fct-signature": "(Double, Double)-\u003e Int-\u003e UniformMesh",
        "fct-type": "function",
        "title": "uniformMesh"
      },
      "index": {
        "description": "Create uniform mesh",
        "hierarchy": "Numeric Tools Mesh",
        "module": "Numeric.Tools.Mesh",
        "name": "uniformMesh",
        "normalized": "(Double,Double)-\u003eInt-\u003eUniformMesh",
        "package": "numeric-tools",
        "partial": "Mesh",
        "signature": "(Double,Double)-\u003eInt-\u003eUniformMesh"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/numeric-tools/docs/Numeric-Tools-Mesh.html#v:uniformMeshStep",
      "description": {
        "fct-descr": "\u003cp\u003eDistance between points\n\u003c/p\u003e",
        "fct-module": "Numeric.Tools.Mesh",
        "fct-package": "numeric-tools",
        "fct-signature": "UniformMesh -\u003e Double",
        "fct-source": "src/Numeric-Tools-Mesh.html#uniformMeshStep",
        "fct-type": "function",
        "title": "uniformMeshStep"
      },
      "index": {
        "description": "Distance between points",
        "hierarchy": "Numeric Tools Mesh",
        "module": "Numeric.Tools.Mesh",
        "name": "uniformMeshStep",
        "normalized": "UniformMesh-\u003eDouble",
        "package": "numeric-tools",
        "partial": "Mesh Step",
        "signature": "UniformMesh-\u003eDouble"
      }
    }
  }
]
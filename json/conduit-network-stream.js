[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "module",
        "fct-source": "src/Data-Conduit-Network-Stream-Exceptions.html",
        "fct-type": "module",
        "title": "Exceptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "Exceptions",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Exceptions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#t:Header",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "data",
        "fct-source": "src/Data-Conduit-Network-Stream-Header.html#Header",
        "fct-type": "data",
        "title": "Header"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "Header",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Header",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#t:StreamException",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "data",
        "fct-source": "src/Data-Conduit-Network-Stream-Exceptions.html#StreamException",
        "fct-type": "data",
        "title": "StreamException"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "StreamException",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Stream Exception",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#v:ClosedStream",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "ClosedStream",
        "fct-source": "src/Data-Conduit-Network-Stream-Exceptions.html#StreamException",
        "fct-type": "function",
        "title": "ClosedStream"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "ClosedStream",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Closed Stream",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#v:ConduitEND",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "ConduitEND",
        "fct-source": "src/Data-Conduit-Network-Stream-Header.html#Header",
        "fct-type": "function",
        "title": "ConduitEND"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "ConduitEND",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Conduit END",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#v:ConduitSTART",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "ConduitSTART",
        "fct-source": "src/Data-Conduit-Network-Stream-Header.html#Header",
        "fct-type": "function",
        "title": "ConduitSTART"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "ConduitSTART",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Conduit START",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#v:EndOfInput",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "EndOfInput",
        "fct-source": "src/Data-Conduit-Network-Stream-Header.html#Header",
        "fct-type": "function",
        "title": "EndOfInput"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "EndOfInput",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "End Of Input",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#v:InvalidHeader",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "InvalidHeader [Word8]",
        "fct-source": "src/Data-Conduit-Network-Stream-Header.html#Header",
        "fct-type": "function",
        "title": "InvalidHeader"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "InvalidHeader",
        "normalized": "InvalidHeader[Word]",
        "package": "conduit-network-stream",
        "partial": "Invalid Header",
        "signature": "InvalidHeader[Word]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#v:UnexpectedHeader",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "UnexpectedHeader Header",
        "fct-source": "src/Data-Conduit-Network-Stream-Exceptions.html#StreamException",
        "fct-type": "function",
        "title": "UnexpectedHeader"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "UnexpectedHeader",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Unexpected Header",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream-Exceptions.html#v:VarInt",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream.Exceptions",
        "fct-package": "conduit-network-stream",
        "fct-signature": "VarInt Int",
        "fct-source": "src/Data-Conduit-Network-Stream-Header.html#Header",
        "fct-type": "function",
        "title": "VarInt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream Exceptions",
        "module": "Data.Conduit.Network.Stream.Exceptions",
        "name": "VarInt",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Var Int",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEasy to use network streaming with conduits. This library properly encodes\nconduit blocks over a network connection such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e each \u003ccode\u003e\u003ca\u003eawait\u003c/a\u003e\u003c/code\u003e corresponds to exactly one \u003ccode\u003e\u003ca\u003eyield\u003c/a\u003e\u003c/code\u003e and\n\u003c/li\u003e\u003cli\u003e each \u003ccode\u003e\u003ca\u003ereceive\u003c/a\u003e\u003c/code\u003e corresponds to exactly one \u003ccode\u003e\u003ca\u003esend\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt also supports sending and receiving of custom data types via the\n\u003ccode\u003e\u003ca\u003eSendable\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eReceivable\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003cp\u003eA simple server/client example (using \u003ccode\u003e-XOverloadedStrings\u003c/code\u003e):\n\u003c/p\u003e\u003cpre\u003e import           Control.Monad.Trans\n import qualified Data.ByteString             as Strict\n import qualified Data.ByteString.Lazy        as Lazy\n import           Data.Conduit\n import qualified Data.Conduit.List           as CL\n import           Data.Conduit.Network\n import           Data.Conduit.Network.Stream\n\n client :: IO ()\n client = runResourceT $ runTCPClient (clientSettings ..) $ \\appData -\u003e do       \n\n     streamData \u003c- toStreamData appData\n\n     send streamData $ mapM_ yield ([\"ab\", \"cd\", \"ef\"] :: [Strict.ByteString])\n     send streamData $ mapM_ yield ([\"123\", \"456\"]     :: [Strict.ByteString])\n\n     closeStream streamData\n\n server :: IO ()\n server = runResourceT $ runTCPServer (serverSettings ..) $ \\appData -\u003e do\n\n     streamData \u003c- toStreamData appData\n\n     bs  \u003c- receive streamData $ CL.consume\n     liftIO $ print (bs  :: [Lazy.ByteString])\n\n     bs' \u003c- receive streamData $ CL.consume\n     liftIO $ print (bs' :: [Lazy.ByteString])\n \n     closeStream streamData\n\u003c/pre\u003e\u003c/div\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "module",
        "fct-source": "src/Data-Conduit-Network-Stream.html",
        "fct-type": "module",
        "title": "Stream"
      },
      "index": {
        "description": "Easy to use network streaming with conduits This library properly encodes conduit blocks over network connection such that each await corresponds to exactly one yield and each receive corresponds to exactly one send It also supports sending and receiving of custom data types via the Sendable and Receivable instances simple server client example using XOverloadedStrings import Control.Monad.Trans import qualified Data.ByteString as Strict import qualified Data.ByteString.Lazy as Lazy import Data.Conduit import qualified Data.Conduit.List as CL import Data.Conduit.Network import Data.Conduit.Network.Stream client IO client runResourceT runTCPClient clientSettings appData do streamData toStreamData appData send streamData mapM yield ab cd ef Strict.ByteString send streamData mapM yield Strict.ByteString closeStream streamData server IO server runResourceT runTCPServer serverSettings appData do streamData toStreamData appData bs receive streamData CL.consume liftIO print bs Lazy.ByteString bs receive streamData CL.consume liftIO print bs Lazy.ByteString closeStream streamData",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "Stream",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Stream",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#t:EncodedBS",
      "description": {
        "fct-descr": "\u003cp\u003eNewtype for properly encoded bytestrings.\n\u003c/p\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "data",
        "fct-source": "src/Data-Conduit-Network-Stream.html#EncodedBS",
        "fct-type": "data",
        "title": "EncodedBS"
      },
      "index": {
        "description": "Newtype for properly encoded bytestrings",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "EncodedBS",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Encoded BS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#t:Receivable",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003e is used after receiving the individual conduit block elements.\n It is therefore not necessary to reuse other \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003e instances (in\n contrast to \u003ccode\u003e\u003ca\u003eSendable\u003c/a\u003e\u003c/code\u003e instance definitions).\n\u003c/p\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "class",
        "fct-source": "src/Data-Conduit-Network-Stream.html#Receivable",
        "fct-type": "class",
        "title": "Receivable"
      },
      "index": {
        "description": "decode is used after receiving the individual conduit block elements It is therefore not necessary to reuse other decode instances in contrast to Sendable instance definitions",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "Receivable",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Receivable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#t:Sendable",
      "description": {
        "fct-descr": "\u003cp\u003eTo define your own \u003ccode\u003e\u003ca\u003eSendable\u003c/a\u003e\u003c/code\u003e instances, reuse the instances for strict and\n lazy bytestrings, for example for \u003ca\u003eData.Text\u003c/a\u003e:\n\u003c/p\u003e\u003cpre\u003e instance (Monad m, Sendable m Data.ByteString.ByteString) =\u003e Sendable m Text where\n     encode = Data.Conduit.List.map encodeUtf8 =$= encode\n\u003c/pre\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "class",
        "fct-source": "src/Data-Conduit-Network-Stream.html#Sendable",
        "fct-type": "class",
        "title": "Sendable"
      },
      "index": {
        "description": "To define your own Sendable instances reuse the instances for strict and lazy bytestrings for example for Data.Text instance Monad Sendable Data.ByteString.ByteString Sendable Text where encode Data.Conduit.List.map encodeUtf8 encode",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "Sendable",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Sendable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#t:StreamData",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "data",
        "fct-source": "src/Data-Conduit-Network-Stream-Internal.html#StreamData",
        "fct-type": "data",
        "title": "StreamData"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "StreamData",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "Stream Data",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#v:closeStream",
      "description": {
        "fct-descr": "\u003cp\u003eClose current stream. In order to guarantee process resource finalization,\n you \u003cem\u003emust\u003c/em\u003e use this operator after using \u003ccode\u003e\u003ca\u003ereceive\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "StreamData m -\u003e m ()",
        "fct-source": "src/Data-Conduit-Network-Stream.html#closeStream",
        "fct-type": "function",
        "title": "closeStream"
      },
      "index": {
        "description": "Close current stream In order to guarantee process resource finalization you must use this operator after using receive",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "closeStream",
        "normalized": "StreamData a-\u003ea()",
        "package": "conduit-network-stream",
        "partial": "Stream",
        "signature": "StreamData m-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#v:decode",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "Conduit ByteString m a",
        "fct-source": "src/Data-Conduit-Network-Stream.html#decode",
        "fct-type": "method",
        "title": "decode"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "decode",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003e is called before sending out conduit block elements. Each\n element has to be encoded either as strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e or as lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n with a known length.\n\u003c/p\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "Conduit a m EncodedBS",
        "fct-source": "src/Data-Conduit-Network-Stream.html#encode",
        "fct-type": "method",
        "title": "encode"
      },
      "index": {
        "description": "encode is called before sending out conduit block elements Each element has to be encoded either as strict ByteString or as lazy ByteString with known length",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "encode",
        "normalized": "",
        "package": "conduit-network-stream",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#v:receive",
      "description": {
        "fct-descr": "\u003cp\u003eReceive the next conduit block. Might fail with the \u003ccode\u003e\u003ca\u003eClosedStream\u003c/a\u003e\u003c/code\u003e\n exception if used on a stream that has been closed by \u003ccode\u003e\u003ca\u003ecloseStream\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "StreamData m -\u003e Sink a m b -\u003e m b",
        "fct-source": "src/Data-Conduit-Network-Stream.html#receive",
        "fct-type": "function",
        "title": "receive"
      },
      "index": {
        "description": "Receive the next conduit block Might fail with the ClosedStream exception if used on stream that has been closed by closeStream",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "receive",
        "normalized": "StreamData a-\u003eSink b a c-\u003ea c",
        "package": "conduit-network-stream",
        "partial": "",
        "signature": "StreamData m-\u003eSink a m b-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#v:send",
      "description": {
        "fct-descr": "\u003cp\u003eSend one conduit block.\n\u003c/p\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "StreamData m -\u003e Source m a -\u003e m ()",
        "fct-source": "src/Data-Conduit-Network-Stream.html#send",
        "fct-type": "function",
        "title": "send"
      },
      "index": {
        "description": "Send one conduit block",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "send",
        "normalized": "StreamData a-\u003eSource a b-\u003ea()",
        "package": "conduit-network-stream",
        "partial": "",
        "signature": "StreamData m-\u003eSource m a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#v:streamSink",
      "description": {
        "fct-descr": "\u003cp\u003eFor bi-directional conversations you sometimes need the sink of the current\n stream, since you can't use \u003ccode\u003e\u003ca\u003esend\u003c/a\u003e\u003c/code\u003e within another \u003ccode\u003e\u003ca\u003ereceive\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eA simple example:\n\u003c/p\u003e\u003cpre\u003e receive streamData $\n     myConduit =$ streamSink streamData\n\u003c/pre\u003e\u003cp\u003eNote, that each \u003ccode\u003e\u003ca\u003estreamSink\u003c/a\u003e\u003c/code\u003e marks its own conduit block. If you want to sink\n single block elements, use \u003ccode\u003e\u003ca\u003ewithElementSink\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "StreamData m -\u003e Sink a m ()",
        "fct-source": "src/Data-Conduit-Network-Stream.html#streamSink",
        "fct-type": "function",
        "title": "streamSink"
      },
      "index": {
        "description": "For bi-directional conversations you sometimes need the sink of the current stream since you can use send within another receive simple example receive streamData myConduit streamSink streamData Note that each streamSink marks its own conduit block If you want to sink single block elements use withElementSink instead",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "streamSink",
        "normalized": "StreamData a-\u003eSink b a()",
        "package": "conduit-network-stream",
        "partial": "Sink",
        "signature": "StreamData m-\u003eSink a m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#v:toStreamData",
      "description": {
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "AppData m -\u003e n (StreamData m)",
        "fct-source": "src/Data-Conduit-Network-Stream.html#toStreamData",
        "fct-type": "function",
        "title": "toStreamData"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "toStreamData",
        "normalized": "AppData a-\u003eb(StreamData a)",
        "package": "conduit-network-stream",
        "partial": "Stream Data",
        "signature": "AppData m-\u003en(StreamData m)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/conduit-network-stream/docs/Data-Conduit-Network-Stream.html#v:withElementSink",
      "description": {
        "fct-descr": "\u003cp\u003eSink single elements inside the same conduit block. Example:\n\u003c/p\u003e\u003cpre\u003e receive streamData $ withElementSink $ \\sinkElem -\u003e do\n     yield singleElem =$ sinkElem\n     mapM_ yield moreElems =$ sinkElem\n\u003c/pre\u003e",
        "fct-module": "Data.Conduit.Network.Stream",
        "fct-package": "conduit-network-stream",
        "fct-signature": "StreamData m -\u003e (Sink a m () -\u003e Sink b m c) -\u003e Sink b m c",
        "fct-source": "src/Data-Conduit-Network-Stream.html#withElementSink",
        "fct-type": "function",
        "title": "withElementSink"
      },
      "index": {
        "description": "Sink single elements inside the same conduit block Example receive streamData withElementSink sinkElem do yield singleElem sinkElem mapM yield moreElems sinkElem",
        "hierarchy": "Data Conduit Network Stream",
        "module": "Data.Conduit.Network.Stream",
        "name": "withElementSink",
        "normalized": "StreamData a-\u003e(Sink b a()-\u003eSink c a d)-\u003eSink c a d",
        "package": "conduit-network-stream",
        "partial": "Element Sink",
        "signature": "StreamData m-\u003e(Sink a m()-\u003eSink b m c)-\u003eSink b m c"
      }
    }
  }
]
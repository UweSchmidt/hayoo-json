[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-All.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides convenience re-exports of all the standard\n Data.Derive derivations.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.All",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-All.html",
        "fct-type": "module",
        "title": "All"
      },
      "index": {
        "description": "This module provides convenience re-exports of all the standard Data.Derive derivations",
        "hierarchy": "Data Derive All",
        "module": "Data.Derive.All",
        "name": "All",
        "normalized": "",
        "package": "derive",
        "partial": "All",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-All.html#t:Derivation",
      "description": {
        "fct-module": "Data.Derive.All",
        "fct-package": "derive",
        "fct-signature": "data",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#Derivation",
        "fct-type": "data",
        "title": "Derivation"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive All",
        "module": "Data.Derive.All",
        "name": "Derivation",
        "normalized": "",
        "package": "derive",
        "partial": "Derivation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-All.html#v:derivations",
      "description": {
        "fct-module": "Data.Derive.All",
        "fct-package": "derive",
        "fct-signature": "[Derivation]",
        "fct-source": "src/Data-Derive-All.html#derivations",
        "fct-type": "function",
        "title": "derivations"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive All",
        "module": "Data.Derive.All",
        "name": "derivations",
        "normalized": "[Derivation]",
        "package": "derive",
        "partial": "",
        "signature": "[Derivation]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arbitrary.html#",
      "description": {
        "fct-module": "Data.Derive.Arbitrary",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Arbitrary.html",
        "fct-type": "module",
        "title": "Arbitrary"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Arbitrary",
        "module": "Data.Derive.Arbitrary",
        "name": "Arbitrary",
        "normalized": "",
        "package": "derive",
        "partial": "Arbitrary",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arbitrary.html#v:makeArbitrary",
      "description": {
        "fct-module": "Data.Derive.Arbitrary",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Arbitrary.html#makeArbitrary",
        "fct-type": "function",
        "title": "makeArbitrary"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Arbitrary",
        "module": "Data.Derive.Arbitrary",
        "name": "makeArbitrary",
        "normalized": "",
        "package": "derive",
        "partial": "Arbitrary",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-ArbitraryOld.html#",
      "description": {
        "fct-module": "Data.Derive.ArbitraryOld",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-ArbitraryOld.html",
        "fct-type": "module",
        "title": "ArbitraryOld"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive ArbitraryOld",
        "module": "Data.Derive.ArbitraryOld",
        "name": "ArbitraryOld",
        "normalized": "",
        "package": "derive",
        "partial": "Arbitrary Old",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-ArbitraryOld.html#v:dslArbitraryOld",
      "description": {
        "fct-module": "Data.Derive.ArbitraryOld",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-ArbitraryOld.html#dslArbitraryOld",
        "fct-type": "function",
        "title": "dslArbitraryOld"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive ArbitraryOld",
        "module": "Data.Derive.ArbitraryOld",
        "name": "dslArbitraryOld",
        "normalized": "",
        "package": "derive",
        "partial": "Arbitrary Old",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-ArbitraryOld.html#v:makeArbitraryOld",
      "description": {
        "fct-module": "Data.Derive.ArbitraryOld",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-ArbitraryOld.html#makeArbitraryOld",
        "fct-type": "function",
        "title": "makeArbitraryOld"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive ArbitraryOld",
        "module": "Data.Derive.ArbitraryOld",
        "name": "makeArbitraryOld",
        "normalized": "",
        "package": "derive",
        "partial": "Arbitrary Old",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arities.html#",
      "description": {
        "fct-module": "Data.Derive.Arities",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Arities.html",
        "fct-type": "module",
        "title": "Arities"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Arities",
        "module": "Data.Derive.Arities",
        "name": "Arities",
        "normalized": "",
        "package": "derive",
        "partial": "Arities",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arities.html#v:dslArities",
      "description": {
        "fct-module": "Data.Derive.Arities",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Arities.html#dslArities",
        "fct-type": "function",
        "title": "dslArities"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Arities",
        "module": "Data.Derive.Arities",
        "name": "dslArities",
        "normalized": "",
        "package": "derive",
        "partial": "Arities",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arities.html#v:makeArities",
      "description": {
        "fct-module": "Data.Derive.Arities",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Arities.html#makeArities",
        "fct-type": "function",
        "title": "makeArities"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Arities",
        "module": "Data.Derive.Arities",
        "name": "makeArities",
        "normalized": "",
        "package": "derive",
        "partial": "Arities",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Binary.html#",
      "description": {
        "fct-module": "Data.Derive.Binary",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Binary.html",
        "fct-type": "module",
        "title": "Binary"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Binary",
        "module": "Data.Derive.Binary",
        "name": "Binary",
        "normalized": "",
        "package": "derive",
        "partial": "Binary",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Binary.html#v:dslBinary",
      "description": {
        "fct-module": "Data.Derive.Binary",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Binary.html#dslBinary",
        "fct-type": "function",
        "title": "dslBinary"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Binary",
        "module": "Data.Derive.Binary",
        "name": "dslBinary",
        "normalized": "",
        "package": "derive",
        "partial": "Binary",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Binary.html#v:makeBinary",
      "description": {
        "fct-module": "Data.Derive.Binary",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Binary.html#makeBinary",
        "fct-type": "function",
        "title": "makeBinary"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Binary",
        "module": "Data.Derive.Binary",
        "name": "makeBinary",
        "normalized": "",
        "package": "derive",
        "partial": "Binary",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-BinaryDefer.html#",
      "description": {
        "fct-module": "Data.Derive.BinaryDefer",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-BinaryDefer.html",
        "fct-type": "module",
        "title": "BinaryDefer"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive BinaryDefer",
        "module": "Data.Derive.BinaryDefer",
        "name": "BinaryDefer",
        "normalized": "",
        "package": "derive",
        "partial": "Binary Defer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-BinaryDefer.html#v:dslBinaryDefer",
      "description": {
        "fct-module": "Data.Derive.BinaryDefer",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-BinaryDefer.html#dslBinaryDefer",
        "fct-type": "function",
        "title": "dslBinaryDefer"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive BinaryDefer",
        "module": "Data.Derive.BinaryDefer",
        "name": "dslBinaryDefer",
        "normalized": "",
        "package": "derive",
        "partial": "Binary Defer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-BinaryDefer.html#v:makeBinaryDefer",
      "description": {
        "fct-module": "Data.Derive.BinaryDefer",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-BinaryDefer.html#makeBinaryDefer",
        "fct-type": "function",
        "title": "makeBinaryDefer"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive BinaryDefer",
        "module": "Data.Derive.BinaryDefer",
        "name": "makeBinaryDefer",
        "normalized": "",
        "package": "derive",
        "partial": "Binary Defer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Bounded.html#",
      "description": {
        "fct-module": "Data.Derive.Bounded",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Bounded.html",
        "fct-type": "module",
        "title": "Bounded"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Bounded",
        "module": "Data.Derive.Bounded",
        "name": "Bounded",
        "normalized": "",
        "package": "derive",
        "partial": "Bounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Bounded.html#v:dslBounded",
      "description": {
        "fct-module": "Data.Derive.Bounded",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Bounded.html#dslBounded",
        "fct-type": "function",
        "title": "dslBounded"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Bounded",
        "module": "Data.Derive.Bounded",
        "name": "dslBounded",
        "normalized": "",
        "package": "derive",
        "partial": "Bounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Bounded.html#v:makeBounded",
      "description": {
        "fct-module": "Data.Derive.Bounded",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Bounded.html#makeBounded",
        "fct-type": "function",
        "title": "makeBounded"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Bounded",
        "module": "Data.Derive.Bounded",
        "name": "makeBounded",
        "normalized": "",
        "package": "derive",
        "partial": "Bounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Arities.html#",
      "description": {
        "fct-module": "Data.Derive.Class.Arities",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Class-Arities.html",
        "fct-type": "module",
        "title": "Arities"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Class Arities",
        "module": "Data.Derive.Class.Arities",
        "name": "Arities",
        "normalized": "",
        "package": "derive",
        "partial": "Arities",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Arities.html#t:Arities",
      "description": {
        "fct-module": "Data.Derive.Class.Arities",
        "fct-package": "derive",
        "fct-signature": "class",
        "fct-source": "src/Data-Derive-Class-Arities.html#Arities",
        "fct-type": "class",
        "title": "Arities"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Class Arities",
        "module": "Data.Derive.Class.Arities",
        "name": "Arities",
        "normalized": "",
        "package": "derive",
        "partial": "Arities",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Arities.html#v:arities",
      "description": {
        "fct-module": "Data.Derive.Class.Arities",
        "fct-package": "derive",
        "fct-signature": "a -\u003e [Int]",
        "fct-source": "src/Data-Derive-Class-Arities.html#arities",
        "fct-type": "method",
        "title": "arities"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Class Arities",
        "module": "Data.Derive.Class.Arities",
        "name": "arities",
        "normalized": "a-\u003e[Int]",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Default.html#",
      "description": {
        "fct-module": "Data.Derive.Class.Default",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Class-Default.html",
        "fct-type": "module",
        "title": "Default"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Class Default",
        "module": "Data.Derive.Class.Default",
        "name": "Default",
        "normalized": "",
        "package": "derive",
        "partial": "Default",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Default.html#t:Default",
      "description": {
        "fct-module": "Data.Derive.Class.Default",
        "fct-package": "derive",
        "fct-signature": "class",
        "fct-source": "src/Data-Derive-Class-Default.html#Default",
        "fct-type": "class",
        "title": "Default"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Class Default",
        "module": "Data.Derive.Class.Default",
        "name": "Default",
        "normalized": "",
        "package": "derive",
        "partial": "Default",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Default.html#v:def",
      "description": {
        "fct-module": "Data.Derive.Class.Default",
        "fct-package": "derive",
        "fct-signature": "a",
        "fct-source": "src/Data-Derive-Class-Default.html#def",
        "fct-type": "method",
        "title": "def"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Class Default",
        "module": "Data.Derive.Class.Default",
        "name": "def",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#",
      "description": {
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-DSL-Apply.html",
        "fct-type": "module",
        "title": "Apply"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "Apply",
        "normalized": "",
        "package": "derive",
        "partial": "Apply",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#t:Env",
      "description": {
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "data",
        "fct-source": "src/Data-Derive-DSL-Apply.html#Env",
        "fct-type": "data",
        "title": "Env"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "Env",
        "normalized": "",
        "package": "derive",
        "partial": "Env",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:Env",
      "description": {
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "Env",
        "fct-source": "src/Data-Derive-DSL-Apply.html#Env",
        "fct-type": "function",
        "title": "Env"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "Env",
        "normalized": "",
        "package": "derive",
        "partial": "Env",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:apply",
      "description": {
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e Input -\u003e Out",
        "fct-source": "src/Data-Derive-DSL-Apply.html#apply",
        "fct-type": "function",
        "title": "apply"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "apply",
        "normalized": "DSL-\u003eInput-\u003eOut",
        "package": "derive",
        "partial": "",
        "signature": "DSL-\u003eInput-\u003eOut"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:applyEnv",
      "description": {
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e Env -\u003e Output",
        "fct-source": "src/Data-Derive-DSL-Apply.html#applyEnv",
        "fct-type": "function",
        "title": "applyEnv"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "applyEnv",
        "normalized": "DSL-\u003eEnv-\u003eOutput",
        "package": "derive",
        "partial": "Env",
        "signature": "DSL-\u003eEnv-\u003eOutput"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:env",
      "description": {
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "Env",
        "fct-source": "src/Data-Derive-DSL-Apply.html#env",
        "fct-type": "function",
        "title": "env"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "env",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:envCtor",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "Ctor",
        "fct-source": "src/Data-Derive-DSL-Apply.html#Env",
        "fct-type": "function",
        "title": "envCtor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "envCtor",
        "normalized": "",
        "package": "derive",
        "partial": "Ctor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:envField",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "Integer",
        "fct-source": "src/Data-Derive-DSL-Apply.html#Env",
        "fct-type": "function",
        "title": "envField"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "envField",
        "normalized": "",
        "package": "derive",
        "partial": "Field",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:envFold",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "(Output, Output)",
        "fct-source": "src/Data-Derive-DSL-Apply.html#Env",
        "fct-type": "function",
        "title": "envFold"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "envFold",
        "normalized": "(Output,Output)",
        "package": "derive",
        "partial": "Fold",
        "signature": "(Output,Output)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:envInput",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Derive.DSL.Apply",
        "fct-package": "derive",
        "fct-signature": "Input",
        "fct-source": "src/Data-Derive-DSL-Apply.html#Env",
        "fct-type": "function",
        "title": "envInput"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Apply",
        "module": "Data.Derive.DSL.Apply",
        "name": "envInput",
        "normalized": "",
        "package": "derive",
        "partial": "Input",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-DSL-DSL.html",
        "fct-type": "module",
        "title": "DSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "DSL",
        "normalized": "",
        "package": "derive",
        "partial": "DSL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#t:DSL",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "data",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "data",
        "title": "DSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "DSL",
        "normalized": "",
        "package": "derive",
        "partial": "DSL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:App",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "App String DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "App"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "App",
        "normalized": "",
        "package": "derive",
        "partial": "App",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Application",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Application DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "Application"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "Application",
        "normalized": "",
        "package": "derive",
        "partial": "Application",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Concat",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Concat DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "Concat"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "Concat",
        "normalized": "",
        "package": "derive",
        "partial": "Concat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:CtorArity",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "CtorArity",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "CtorArity"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "CtorArity",
        "normalized": "",
        "package": "derive",
        "partial": "Ctor Arity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:CtorIndex",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "CtorIndex",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "CtorIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "CtorIndex",
        "normalized": "",
        "package": "derive",
        "partial": "Ctor Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:CtorName",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "CtorName",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "CtorName"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "CtorName",
        "normalized": "",
        "package": "derive",
        "partial": "Ctor Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:DataName",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "DataName",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "DataName"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "DataName",
        "normalized": "",
        "package": "derive",
        "partial": "Data Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:FieldIndex",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "FieldIndex",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "FieldIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "FieldIndex",
        "normalized": "",
        "package": "derive",
        "partial": "Field Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Fold",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Fold DSL DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "Fold"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "Fold",
        "normalized": "",
        "package": "derive",
        "partial": "Fold",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Head",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Head",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "Head"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "Head",
        "normalized": "",
        "package": "derive",
        "partial": "Head",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Instance",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Instance [String] String DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "Instance"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "Instance",
        "normalized": "Instance[String]String DSL",
        "package": "derive",
        "partial": "Instance",
        "signature": "Instance[String]String DSL"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Int",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Int Integer",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "Int"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "Int",
        "normalized": "",
        "package": "derive",
        "partial": "Int",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:List",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "List [DSL]",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "List"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "List",
        "normalized": "List[DSL]",
        "package": "derive",
        "partial": "List",
        "signature": "List[DSL]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:MapCtor",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "MapCtor DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "MapCtor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "MapCtor",
        "normalized": "",
        "package": "derive",
        "partial": "Map Ctor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:MapField",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "MapField DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "MapField"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "MapField",
        "normalized": "",
        "package": "derive",
        "partial": "Map Field",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Reverse",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Reverse DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "Reverse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "Reverse",
        "normalized": "",
        "package": "derive",
        "partial": "Reverse",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:ShowInt",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "ShowInt DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "ShowInt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "ShowInt",
        "normalized": "",
        "package": "derive",
        "partial": "Show Int",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:String",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "String String",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "String"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "String",
        "normalized": "",
        "package": "derive",
        "partial": "String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Tail",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Tail",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "function",
        "title": "Tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "Tail",
        "normalized": "",
        "package": "derive",
        "partial": "Tail",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:append",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e DSL -\u003e DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#append",
        "fct-type": "function",
        "title": "append"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "append",
        "normalized": "DSL-\u003eDSL-\u003eDSL",
        "package": "derive",
        "partial": "",
        "signature": "DSL-\u003eDSL-\u003eDSL"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:box",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#box",
        "fct-type": "function",
        "title": "box"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "box",
        "normalized": "DSL-\u003eDSL",
        "package": "derive",
        "partial": "",
        "signature": "DSL-\u003eDSL"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:fromOut",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "Output -\u003e DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#fromOut",
        "fct-type": "function",
        "title": "fromOut"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "fromOut",
        "normalized": "Output-\u003eDSL",
        "package": "derive",
        "partial": "Out",
        "signature": "Output-\u003eDSL"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:nil",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#nil",
        "fct-type": "function",
        "title": "nil"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "nil",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:prettyTex",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e String",
        "fct-source": "src/Data-Derive-DSL-DSL.html#prettyTex",
        "fct-type": "function",
        "title": "prettyTex"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "prettyTex",
        "normalized": "DSL-\u003eString",
        "package": "derive",
        "partial": "Tex",
        "signature": "DSL-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:simplifyDSL",
      "description": {
        "fct-module": "Data.Derive.DSL.DSL",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e DSL",
        "fct-source": "src/Data-Derive-DSL-DSL.html#simplifyDSL",
        "fct-type": "function",
        "title": "simplifyDSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL DSL",
        "module": "Data.Derive.DSL.DSL",
        "name": "simplifyDSL",
        "normalized": "DSL-\u003eDSL",
        "package": "derive",
        "partial": "DSL",
        "signature": "DSL-\u003eDSL"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Derive.html#",
      "description": {
        "fct-module": "Data.Derive.DSL.Derive",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-DSL-Derive.html",
        "fct-type": "module",
        "title": "Derive"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Derive",
        "module": "Data.Derive.DSL.Derive",
        "name": "Derive",
        "normalized": "",
        "package": "derive",
        "partial": "Derive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Derive.html#v:derive",
      "description": {
        "fct-module": "Data.Derive.DSL.Derive",
        "fct-package": "derive",
        "fct-signature": "Out -\u003e [DSL]",
        "fct-source": "src/Data-Derive-DSL-Derive.html#derive",
        "fct-type": "function",
        "title": "derive"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL Derive",
        "module": "Data.Derive.DSL.Derive",
        "name": "derive",
        "normalized": "Out-\u003e[DSL]",
        "package": "derive",
        "partial": "",
        "signature": "Out-\u003e[DSL]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-DSL-HSE.html",
        "fct-type": "module",
        "title": "HSE"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "HSE",
        "normalized": "",
        "package": "derive",
        "partial": "HSE",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#t:Ctor",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Ctor",
        "fct-type": "type",
        "title": "Ctor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "Ctor",
        "normalized": "",
        "package": "derive",
        "partial": "Ctor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#t:Input",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Input",
        "fct-type": "type",
        "title": "Input"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "Input",
        "normalized": "",
        "package": "derive",
        "partial": "Input",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#t:Out",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Out",
        "fct-type": "type",
        "title": "Out"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "Out",
        "normalized": "",
        "package": "derive",
        "partial": "Out",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#t:Output",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "data",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Output",
        "fct-type": "data",
        "title": "Output"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "Output",
        "normalized": "",
        "package": "derive",
        "partial": "Output",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OApp",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "OApp String [Output]",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Output",
        "fct-type": "function",
        "title": "OApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "OApp",
        "normalized": "OApp String[Output]",
        "package": "derive",
        "partial": "OApp",
        "signature": "OApp String[Output]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OCustom",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "OCustom String",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Output",
        "fct-type": "function",
        "title": "OCustom"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "OCustom",
        "normalized": "",
        "package": "derive",
        "partial": "OCustom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OIgnore",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "OIgnore",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Output",
        "fct-type": "function",
        "title": "OIgnore"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "OIgnore",
        "normalized": "",
        "package": "derive",
        "partial": "OIgnore",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OInt",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "OInt Integer",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Output",
        "fct-type": "function",
        "title": "OInt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "OInt",
        "normalized": "",
        "package": "derive",
        "partial": "OInt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OList",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "OList [Output]",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Output",
        "fct-type": "function",
        "title": "OList"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "OList",
        "normalized": "OList[Output]",
        "package": "derive",
        "partial": "OList",
        "signature": "OList[Output]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OString",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "OString String",
        "fct-source": "src/Data-Derive-DSL-HSE.html#Output",
        "fct-type": "function",
        "title": "OString"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "OString",
        "normalized": "",
        "package": "derive",
        "partial": "OString",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:coerce",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "a1 -\u003e a",
        "fct-source": "src/Data-Derive-DSL-HSE.html#coerce",
        "fct-type": "function",
        "title": "coerce"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "coerce",
        "normalized": "a-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:ctorArity",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "CtorDecl -\u003e Integer",
        "fct-source": "src/Data-Derive-DSL-HSE.html#ctorArity",
        "fct-type": "function",
        "title": "ctorArity"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "ctorArity",
        "normalized": "CtorDecl-\u003eInteger",
        "package": "derive",
        "partial": "Arity",
        "signature": "CtorDecl-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:ctorIndex",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "Input -\u003e Ctor -\u003e Integer",
        "fct-source": "src/Data-Derive-DSL-HSE.html#ctorIndex",
        "fct-type": "function",
        "title": "ctorIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "ctorIndex",
        "normalized": "Input-\u003eCtor-\u003eInteger",
        "package": "derive",
        "partial": "Index",
        "signature": "Input-\u003eCtor-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:ctorName",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "CtorDecl -\u003e String",
        "fct-source": "src/Data-Derive-DSL-HSE.html#ctorName",
        "fct-type": "function",
        "title": "ctorName"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "ctorName",
        "normalized": "CtorDecl-\u003eString",
        "package": "derive",
        "partial": "Name",
        "signature": "CtorDecl-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:dataCtors",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e [CtorDecl]",
        "fct-source": "src/Data-Derive-DSL-HSE.html#dataCtors",
        "fct-type": "function",
        "title": "dataCtors"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "dataCtors",
        "normalized": "DataDecl-\u003e[CtorDecl]",
        "package": "derive",
        "partial": "Ctors",
        "signature": "DataDecl-\u003e[CtorDecl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:dataName",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e String",
        "fct-source": "src/Data-Derive-DSL-HSE.html#dataName",
        "fct-type": "function",
        "title": "dataName"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "dataName",
        "normalized": "DataDecl-\u003eString",
        "package": "derive",
        "partial": "Name",
        "signature": "DataDecl-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:dataVars",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e Int",
        "fct-source": "src/Data-Derive-DSL-HSE.html#dataVars",
        "fct-type": "function",
        "title": "dataVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "dataVars",
        "normalized": "DataDecl-\u003eInt",
        "package": "derive",
        "partial": "Vars",
        "signature": "DataDecl-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:fromOutput",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "Output -\u003e a",
        "fct-source": "src/Data-Derive-DSL-HSE.html#fromOutput",
        "fct-type": "function",
        "title": "fromOutput"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "fromOutput",
        "normalized": "Output-\u003ea",
        "package": "derive",
        "partial": "Output",
        "signature": "Output-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:fromState",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "State a x -\u003e x",
        "fct-source": "src/Data-Derive-DSL-HSE.html#fromState",
        "fct-type": "function",
        "title": "fromState"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "fromState",
        "normalized": "State a b-\u003eb",
        "package": "derive",
        "partial": "State",
        "signature": "State a x-\u003ex"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:out",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "a -\u003e Output",
        "fct-source": "src/Data-Derive-DSL-HSE.html#out",
        "fct-type": "function",
        "title": "out"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "out",
        "normalized": "a-\u003eOutput",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003eOutput"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:outEq",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "Out -\u003e Out -\u003e Bool",
        "fct-source": "src/Data-Derive-DSL-HSE.html#outEq",
        "fct-type": "function",
        "title": "outEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "outEq",
        "normalized": "Out-\u003eOut-\u003eBool",
        "package": "derive",
        "partial": "Eq",
        "signature": "Out-\u003eOut-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:readCon",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "DataType -\u003e [Char] -\u003e Constr",
        "fct-source": "src/Data-Derive-DSL-HSE.html#readCon",
        "fct-type": "function",
        "title": "readCon"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "readCon",
        "normalized": "DataType-\u003e[Char]-\u003eConstr",
        "package": "derive",
        "partial": "Con",
        "signature": "DataType-\u003e[Char]-\u003eConstr"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:sample",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "Input",
        "fct-source": "src/Data-Derive-DSL-HSE.html#sample",
        "fct-type": "function",
        "title": "sample"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "sample",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:showOut",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "[a] -\u003e String",
        "fct-source": "src/Data-Derive-DSL-HSE.html#showOut",
        "fct-type": "function",
        "title": "showOut"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "showOut",
        "normalized": "[a]-\u003eString",
        "package": "derive",
        "partial": "Out",
        "signature": "[a]-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:toInput",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e Input",
        "fct-source": "src/Data-Derive-DSL-HSE.html#toInput",
        "fct-type": "function",
        "title": "toInput"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "toInput",
        "normalized": "DataDecl-\u003eInput",
        "package": "derive",
        "partial": "Input",
        "signature": "DataDecl-\u003eInput"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:toOutput",
      "description": {
        "fct-module": "Data.Derive.DSL.HSE",
        "fct-package": "derive",
        "fct-signature": "a -\u003e Output",
        "fct-source": "src/Data-Derive-DSL-HSE.html#toOutput",
        "fct-type": "function",
        "title": "toOutput"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL HSE",
        "module": "Data.Derive.DSL.HSE",
        "name": "toOutput",
        "normalized": "a-\u003eOutput",
        "package": "derive",
        "partial": "Output",
        "signature": "a-\u003eOutput"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-SYB.html#",
      "description": {
        "fct-module": "Data.Derive.DSL.SYB",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-DSL-SYB.html",
        "fct-type": "module",
        "title": "SYB"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL SYB",
        "module": "Data.Derive.DSL.SYB",
        "name": "SYB",
        "normalized": "",
        "package": "derive",
        "partial": "SYB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-SYB.html#v:dslSYB",
      "description": {
        "fct-module": "Data.Derive.DSL.SYB",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e Maybe Out",
        "fct-source": "src/Data-Derive-DSL-SYB.html#dslSYB",
        "fct-type": "function",
        "title": "dslSYB"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DSL SYB",
        "module": "Data.Derive.DSL.SYB",
        "name": "dslSYB",
        "normalized": "DSL-\u003eMaybe Out",
        "package": "derive",
        "partial": "SYB",
        "signature": "DSL-\u003eMaybe Out"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Data.html#",
      "description": {
        "fct-module": "Data.Derive.Data",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Data.html",
        "fct-type": "module",
        "title": "Data"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Data",
        "module": "Data.Derive.Data",
        "name": "Data",
        "normalized": "",
        "package": "derive",
        "partial": "Data",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Data.html#v:makeData",
      "description": {
        "fct-module": "Data.Derive.Data",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Data.html#makeData",
        "fct-type": "function",
        "title": "makeData"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Data",
        "module": "Data.Derive.Data",
        "name": "makeData",
        "normalized": "",
        "package": "derive",
        "partial": "Data",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DataAbstract.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFor deriving Data on abstract data types.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.DataAbstract",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-DataAbstract.html",
        "fct-type": "module",
        "title": "DataAbstract"
      },
      "index": {
        "description": "For deriving Data on abstract data types",
        "hierarchy": "Data Derive DataAbstract",
        "module": "Data.Derive.DataAbstract",
        "name": "DataAbstract",
        "normalized": "",
        "package": "derive",
        "partial": "Data Abstract",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DataAbstract.html#v:makeDataAbstract",
      "description": {
        "fct-module": "Data.Derive.DataAbstract",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-DataAbstract.html#makeDataAbstract",
        "fct-type": "function",
        "title": "makeDataAbstract"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive DataAbstract",
        "module": "Data.Derive.DataAbstract",
        "name": "makeDataAbstract",
        "normalized": "",
        "package": "derive",
        "partial": "Data Abstract",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Default.html#",
      "description": {
        "fct-module": "Data.Derive.Default",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Default.html",
        "fct-type": "module",
        "title": "Default"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Default",
        "module": "Data.Derive.Default",
        "name": "Default",
        "normalized": "",
        "package": "derive",
        "partial": "Default",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Default.html#v:dslDefault",
      "description": {
        "fct-module": "Data.Derive.Default",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Default.html#dslDefault",
        "fct-type": "function",
        "title": "dslDefault"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Default",
        "module": "Data.Derive.Default",
        "name": "dslDefault",
        "normalized": "",
        "package": "derive",
        "partial": "Default",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Default.html#v:makeDefault",
      "description": {
        "fct-module": "Data.Derive.Default",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Default.html#makeDefault",
        "fct-type": "function",
        "title": "makeDefault"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Default",
        "module": "Data.Derive.Default",
        "name": "makeDefault",
        "normalized": "",
        "package": "derive",
        "partial": "Default",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Enum.html#",
      "description": {
        "fct-module": "Data.Derive.Enum",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Enum.html",
        "fct-type": "module",
        "title": "Enum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Enum",
        "module": "Data.Derive.Enum",
        "name": "Enum",
        "normalized": "",
        "package": "derive",
        "partial": "Enum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Enum.html#v:dslEnum",
      "description": {
        "fct-module": "Data.Derive.Enum",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Enum.html#dslEnum",
        "fct-type": "function",
        "title": "dslEnum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Enum",
        "module": "Data.Derive.Enum",
        "name": "dslEnum",
        "normalized": "",
        "package": "derive",
        "partial": "Enum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Enum.html#v:makeEnum",
      "description": {
        "fct-module": "Data.Derive.Enum",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Enum.html#makeEnum",
        "fct-type": "function",
        "title": "makeEnum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Enum",
        "module": "Data.Derive.Enum",
        "name": "makeEnum",
        "normalized": "",
        "package": "derive",
        "partial": "Enum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-EnumCyclic.html#",
      "description": {
        "fct-module": "Data.Derive.EnumCyclic",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-EnumCyclic.html",
        "fct-type": "module",
        "title": "EnumCyclic"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive EnumCyclic",
        "module": "Data.Derive.EnumCyclic",
        "name": "EnumCyclic",
        "normalized": "",
        "package": "derive",
        "partial": "Enum Cyclic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-EnumCyclic.html#v:dslEnumCyclic",
      "description": {
        "fct-module": "Data.Derive.EnumCyclic",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-EnumCyclic.html#dslEnumCyclic",
        "fct-type": "function",
        "title": "dslEnumCyclic"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive EnumCyclic",
        "module": "Data.Derive.EnumCyclic",
        "name": "dslEnumCyclic",
        "normalized": "",
        "package": "derive",
        "partial": "Enum Cyclic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-EnumCyclic.html#v:makeEnumCyclic",
      "description": {
        "fct-module": "Data.Derive.EnumCyclic",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-EnumCyclic.html#makeEnumCyclic",
        "fct-type": "function",
        "title": "makeEnumCyclic"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive EnumCyclic",
        "module": "Data.Derive.EnumCyclic",
        "name": "makeEnumCyclic",
        "normalized": "",
        "package": "derive",
        "partial": "Enum Cyclic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Eq.html#",
      "description": {
        "fct-module": "Data.Derive.Eq",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Eq.html",
        "fct-type": "module",
        "title": "Eq"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Eq",
        "module": "Data.Derive.Eq",
        "name": "Eq",
        "normalized": "",
        "package": "derive",
        "partial": "Eq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Eq.html#v:dslEq",
      "description": {
        "fct-module": "Data.Derive.Eq",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Eq.html#dslEq",
        "fct-type": "function",
        "title": "dslEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Eq",
        "module": "Data.Derive.Eq",
        "name": "dslEq",
        "normalized": "",
        "package": "derive",
        "partial": "Eq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Eq.html#v:makeEq",
      "description": {
        "fct-module": "Data.Derive.Eq",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Eq.html#makeEq",
        "fct-type": "function",
        "title": "makeEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Eq",
        "module": "Data.Derive.Eq",
        "name": "makeEq",
        "normalized": "",
        "package": "derive",
        "partial": "Eq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Fold.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  Derive a (non-recursive) fold function for \n    the type which takes one function per alternative constructor.  Each\n    function takes the same arguments as the constructor and returns\n    a value.  When applied to a value the fold function applies the\n    function for the matching constructor to the constructor fields.\n    This provides a first-class alternative to pattern matching to\n    deconstruct the data type.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Fold",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Fold.html",
        "fct-type": "module",
        "title": "Fold"
      },
      "index": {
        "description": "pseudo derivation Derive non-recursive fold function for the type which takes one function per alternative constructor Each function takes the same arguments as the constructor and returns value When applied to value the fold function applies the function for the matching constructor to the constructor fields This provides first-class alternative to pattern matching to deconstruct the data type",
        "hierarchy": "Data Derive Fold",
        "module": "Data.Derive.Fold",
        "name": "Fold",
        "normalized": "",
        "package": "derive",
        "partial": "Fold",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Fold.html#v:makeFold",
      "description": {
        "fct-module": "Data.Derive.Fold",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Fold.html#makeFold",
        "fct-type": "function",
        "title": "makeFold"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Fold",
        "module": "Data.Derive.Fold",
        "name": "makeFold",
        "normalized": "",
        "package": "derive",
        "partial": "Fold",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Foldable.html#",
      "description": {
        "fct-module": "Data.Derive.Foldable",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Foldable.html",
        "fct-type": "module",
        "title": "Foldable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Foldable",
        "module": "Data.Derive.Foldable",
        "name": "Foldable",
        "normalized": "",
        "package": "derive",
        "partial": "Foldable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Foldable.html#v:makeFoldable",
      "description": {
        "fct-module": "Data.Derive.Foldable",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Foldable.html#makeFoldable",
        "fct-type": "function",
        "title": "makeFoldable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Foldable",
        "module": "Data.Derive.Foldable",
        "name": "makeFoldable",
        "normalized": "",
        "package": "derive",
        "partial": "Foldable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Foldable.html#v:makeFoldableN",
      "description": {
        "fct-module": "Data.Derive.Foldable",
        "fct-package": "derive",
        "fct-signature": "Int -\u003e Derivation",
        "fct-source": "src/Data-Derive-Foldable.html#makeFoldableN",
        "fct-type": "function",
        "title": "makeFoldableN"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Foldable",
        "module": "Data.Derive.Foldable",
        "name": "makeFoldableN",
        "normalized": "Int-\u003eDerivation",
        "package": "derive",
        "partial": "Foldable",
        "signature": "Int-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-From.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each constructor in the data type,\n    deriving \u003ccode\u003eFrom\u003c/code\u003e generates \u003ccode\u003efrom\u003c/code\u003e\u003cem\u003eCtorName\u003c/em\u003e which extracts the\n    components if given the appropriate constructor, and crashes\n    otherwise.  Unlike the DrIFT \u003ccode\u003e\"From\"\u003c/code\u003e derivation, our version\n    works for all constructors - zero-arity constructors always return\n    \u003ccode\u003e()\u003c/code\u003e, arity-one constructors return the contained value, and all\n    others return a tuple with all the components.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.From",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-From.html",
        "fct-type": "module",
        "title": "From"
      },
      "index": {
        "description": "pseudo derivation For each constructor in the data type deriving From generates from CtorName which extracts the components if given the appropriate constructor and crashes otherwise Unlike the DrIFT From derivation our version works for all constructors zero-arity constructors always return arity-one constructors return the contained value and all others return tuple with all the components",
        "hierarchy": "Data Derive From",
        "module": "Data.Derive.From",
        "name": "From",
        "normalized": "",
        "package": "derive",
        "partial": "From",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-From.html#v:makeFrom",
      "description": {
        "fct-module": "Data.Derive.From",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-From.html#makeFrom",
        "fct-type": "function",
        "title": "makeFrom"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive From",
        "module": "Data.Derive.From",
        "name": "makeFrom",
        "normalized": "",
        "package": "derive",
        "partial": "From",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Functor.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerives \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, as discussed on the Haskell-prime mailing list:\n \u003ca\u003ehttp://www.mail-archive.com/haskell-prime@haskell.org/msg02116.html\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Functor",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Functor.html",
        "fct-type": "module",
        "title": "Functor"
      },
      "index": {
        "description": "Derives Functor as discussed on the Haskell-prime mailing list http www.mail-archive.com haskell-prime@haskell.org msg02116.html",
        "hierarchy": "Data Derive Functor",
        "module": "Data.Derive.Functor",
        "name": "Functor",
        "normalized": "",
        "package": "derive",
        "partial": "Functor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Functor.html#v:makeFunctor",
      "description": {
        "fct-module": "Data.Derive.Functor",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Functor.html#makeFunctor",
        "fct-type": "function",
        "title": "makeFunctor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Functor",
        "module": "Data.Derive.Functor",
        "name": "makeFunctor",
        "normalized": "",
        "package": "derive",
        "partial": "Functor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Functor.html#v:makeFunctorN",
      "description": {
        "fct-module": "Data.Derive.Functor",
        "fct-package": "derive",
        "fct-signature": "Int -\u003e Derivation",
        "fct-source": "src/Data-Derive-Functor.html#makeFunctorN",
        "fct-type": "function",
        "title": "makeFunctorN"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Functor",
        "module": "Data.Derive.Functor",
        "name": "makeFunctorN",
        "normalized": "Int-\u003eDerivation",
        "package": "derive",
        "partial": "Functor",
        "signature": "Int-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Has.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHas is a pseudo derivation.  For each field of any constructor of\n    the data type, Has generates \u003ccode\u003ehas\u003c/code\u003e\u003cem\u003eFieldName\u003c/em\u003e which returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n    if given the the given field is a member of the constructor of the\n    passed object, and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Has",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Has.html",
        "fct-type": "module",
        "title": "Has"
      },
      "index": {
        "description": "Has is pseudo derivation For each field of any constructor of the data type Has generates has FieldName which returns True if given the the given field is member of the constructor of the passed object and False otherwise",
        "hierarchy": "Data Derive Has",
        "module": "Data.Derive.Has",
        "name": "Has",
        "normalized": "",
        "package": "derive",
        "partial": "Has",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Has.html#v:makeHas",
      "description": {
        "fct-module": "Data.Derive.Has",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Has.html#makeHas",
        "fct-type": "function",
        "title": "makeHas"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Has",
        "module": "Data.Derive.Has",
        "name": "makeHas",
        "normalized": "",
        "package": "derive",
        "partial": "Has",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Instance-Arities.html#",
      "description": {
        "fct-module": "Data.Derive.Instance.Arities",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Instance-Arities.html",
        "fct-type": "module",
        "title": "Arities"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Instance Arities",
        "module": "Data.Derive.Instance.Arities",
        "name": "Arities",
        "normalized": "",
        "package": "derive",
        "partial": "Arities",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Internal-Derivation.html",
        "fct-type": "module",
        "title": "Derivation"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "Derivation",
        "normalized": "",
        "package": "derive",
        "partial": "Derivation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#t:Derivation",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "data",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#Derivation",
        "fct-type": "data",
        "title": "Derivation"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "Derivation",
        "normalized": "",
        "package": "derive",
        "partial": "Derivation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:Derivation",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#Derivation",
        "fct-type": "function",
        "title": "Derivation"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "Derivation",
        "normalized": "",
        "package": "derive",
        "partial": "Derivation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:customContext",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "(FullDataDecl -\u003e Context -\u003e Context) -\u003e FullDataDecl -\u003e [Decl] -\u003e [Decl]",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#customContext",
        "fct-type": "function",
        "title": "customContext"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "customContext",
        "normalized": "(FullDataDecl-\u003eContext-\u003eContext)-\u003eFullDataDecl-\u003e[Decl]-\u003e[Decl]",
        "package": "derive",
        "partial": "Context",
        "signature": "(FullDataDecl-\u003eContext-\u003eContext)-\u003eFullDataDecl-\u003e[Decl]-\u003e[Decl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:customSplice",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "(FullDataDecl -\u003e Exp -\u003e Exp) -\u003e FullDataDecl -\u003e [Decl] -\u003e [Decl]",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#customSplice",
        "fct-type": "function",
        "title": "customSplice"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "customSplice",
        "normalized": "(FullDataDecl-\u003eExp-\u003eExp)-\u003eFullDataDecl-\u003e[Decl]-\u003e[Decl]",
        "package": "derive",
        "partial": "Splice",
        "signature": "(FullDataDecl-\u003eExp-\u003eExp)-\u003eFullDataDecl-\u003e[Decl]-\u003e[Decl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationCustom",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "String -\u003e (FullDataDecl -\u003e Either String [Decl]) -\u003e Derivation",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#derivationCustom",
        "fct-type": "function",
        "title": "derivationCustom"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "derivationCustom",
        "normalized": "String-\u003e(FullDataDecl-\u003eEither String[Decl])-\u003eDerivation",
        "package": "derive",
        "partial": "Custom",
        "signature": "String-\u003e(FullDataDecl-\u003eEither String[Decl])-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationCustomDSL",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "String -\u003e (FullDataDecl -\u003e [Decl] -\u003e [Decl]) -\u003e DSL -\u003e Derivation",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#derivationCustomDSL",
        "fct-type": "function",
        "title": "derivationCustomDSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "derivationCustomDSL",
        "normalized": "String-\u003e(FullDataDecl-\u003e[Decl]-\u003e[Decl])-\u003eDSL-\u003eDerivation",
        "package": "derive",
        "partial": "Custom DSL",
        "signature": "String-\u003e(FullDataDecl-\u003e[Decl]-\u003e[Decl])-\u003eDSL-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationDSL",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "String -\u003e DSL -\u003e Derivation",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#derivationDSL",
        "fct-type": "function",
        "title": "derivationDSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "derivationDSL",
        "normalized": "String-\u003eDSL-\u003eDerivation",
        "package": "derive",
        "partial": "DSL",
        "signature": "String-\u003eDSL-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationName",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "String",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#Derivation",
        "fct-type": "function",
        "title": "derivationName"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "derivationName",
        "normalized": "",
        "package": "derive",
        "partial": "Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationOp",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e (String -\u003e Decl) -\u003e FullDataDecl -\u003e Either String [Decl]",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#Derivation",
        "fct-type": "function",
        "title": "derivationOp"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "derivationOp",
        "normalized": "Type-\u003e(String-\u003eDecl)-\u003eFullDataDecl-\u003eEither String[Decl]",
        "package": "derive",
        "partial": "Op",
        "signature": "Type-\u003e(String-\u003eDecl)-\u003eFullDataDecl-\u003eEither String[Decl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationParams",
      "description": {
        "fct-module": "Data.Derive.Internal.Derivation",
        "fct-package": "derive",
        "fct-signature": "String -\u003e ([Type] -\u003e (String -\u003e Decl) -\u003e FullDataDecl -\u003e Either String [Decl]) -\u003e Derivation",
        "fct-source": "src/Data-Derive-Internal-Derivation.html#derivationParams",
        "fct-type": "function",
        "title": "derivationParams"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Internal Derivation",
        "module": "Data.Derive.Internal.Derivation",
        "name": "derivationParams",
        "normalized": "String-\u003e([Type]-\u003e(String-\u003eDecl)-\u003eFullDataDecl-\u003eEither String[Decl])-\u003eDerivation",
        "package": "derive",
        "partial": "Params",
        "signature": "String-\u003e([Type]-\u003e(String-\u003eDecl)-\u003eFullDataDecl-\u003eEither String[Decl])-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Is.html#",
      "description": {
        "fct-module": "Data.Derive.Is",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Is.html",
        "fct-type": "module",
        "title": "Is"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Is",
        "module": "Data.Derive.Is",
        "name": "Is",
        "normalized": "",
        "package": "derive",
        "partial": "Is",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Is.html#v:makeIs",
      "description": {
        "fct-module": "Data.Derive.Is",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Is.html#makeIs",
        "fct-type": "function",
        "title": "makeIs"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Is",
        "module": "Data.Derive.Is",
        "name": "makeIs",
        "normalized": "",
        "package": "derive",
        "partial": "Is",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-JSON.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerive \u003ccode\u003e\u003ca\u003eJSON\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003cp\u003eUnlike Text.JSON.Generics, single constructor types are \u003cem\u003enot\u003c/em\u003e handled\n specially. Every value is encoded as an object with a single field,\n with the constructor name as key and the values as its contents.\n\u003c/p\u003e\u003cp\u003eIf the constructor is a record, the contents is an Object with the\n field names as keys. Otherwise, the contents is an array.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.JSON",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-JSON.html",
        "fct-type": "module",
        "title": "JSON"
      },
      "index": {
        "description": "Derive JSON instances Unlike Text.JSON.Generics single constructor types are not handled specially Every value is encoded as an object with single field with the constructor name as key and the values as its contents If the constructor is record the contents is an Object with the field names as keys Otherwise the contents is an array",
        "hierarchy": "Data Derive JSON",
        "module": "Data.Derive.JSON",
        "name": "JSON",
        "normalized": "",
        "package": "derive",
        "partial": "JSON",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-JSON.html#v:makeJSON",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDerivation\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003eJSON\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Derive.JSON",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-JSON.html#makeJSON",
        "fct-type": "function",
        "title": "makeJSON"
      },
      "index": {
        "description": "Derivation for JSON",
        "hierarchy": "Data Derive JSON",
        "module": "Data.Derive.JSON",
        "name": "makeJSON",
        "normalized": "",
        "package": "derive",
        "partial": "JSON",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-LazySet.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each field in the data type, deriving\n    \u003ccode\u003eLazySet\u003c/code\u003e generates a function like a record updator, but lazy where possible.\n    This is very useful in certain situations to improve laziness\n    properties.  A setter is only lazy if that field is present in one constructor.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.LazySet",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-LazySet.html",
        "fct-type": "module",
        "title": "LazySet"
      },
      "index": {
        "description": "pseudo derivation For each field in the data type deriving LazySet generates function like record updator but lazy where possible This is very useful in certain situations to improve laziness properties setter is only lazy if that field is present in one constructor",
        "hierarchy": "Data Derive LazySet",
        "module": "Data.Derive.LazySet",
        "name": "LazySet",
        "normalized": "",
        "package": "derive",
        "partial": "Lazy Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-LazySet.html#v:makeLazySet",
      "description": {
        "fct-module": "Data.Derive.LazySet",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-LazySet.html#makeLazySet",
        "fct-type": "function",
        "title": "makeLazySet"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive LazySet",
        "module": "Data.Derive.LazySet",
        "name": "makeLazySet",
        "normalized": "",
        "package": "derive",
        "partial": "Lazy Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Lens.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each field in the data type, deriving\n    \u003ccode\u003eLens\u003c/code\u003e generates \u003ccode\u003elens\u003c/code\u003e\u003cem\u003eFieldName\u003c/em\u003e\u003ccode\u003e = lens \u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e\n    ( x v -\u003e v { \u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e = x })\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis works with the \u003ccode\u003edata-lens\u003c/code\u003e package.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Lens",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Lens.html",
        "fct-type": "module",
        "title": "Lens"
      },
      "index": {
        "description": "pseudo derivation For each field in the data type deriving Lens generates lens FieldName lens fieldName fieldName This works with the data-lens package",
        "hierarchy": "Data Derive Lens",
        "module": "Data.Derive.Lens",
        "name": "Lens",
        "normalized": "",
        "package": "derive",
        "partial": "Lens",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Lens.html#v:makeLens",
      "description": {
        "fct-module": "Data.Derive.Lens",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Lens.html#makeLens",
        "fct-type": "function",
        "title": "makeLens"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Lens",
        "module": "Data.Derive.Lens",
        "name": "makeLens",
        "normalized": "",
        "package": "derive",
        "partial": "Lens",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Monoid.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerives an instance of \u003ccode\u003eMonoid\u003c/code\u003e. It uses the product\n    construction of monoids. \u003ccode\u003emappend\u003c/code\u003e on two different constructors\n    is undefined.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Monoid",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Monoid.html",
        "fct-type": "module",
        "title": "Monoid"
      },
      "index": {
        "description": "Derives an instance of Monoid It uses the product construction of monoids mappend on two different constructors is undefined",
        "hierarchy": "Data Derive Monoid",
        "module": "Data.Derive.Monoid",
        "name": "Monoid",
        "normalized": "",
        "package": "derive",
        "partial": "Monoid",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Monoid.html#v:makeMonoid",
      "description": {
        "fct-module": "Data.Derive.Monoid",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Monoid.html#makeMonoid",
        "fct-type": "function",
        "title": "makeMonoid"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Monoid",
        "module": "Data.Derive.Monoid",
        "name": "makeMonoid",
        "normalized": "",
        "package": "derive",
        "partial": "Monoid",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-NFData.html#",
      "description": {
        "fct-module": "Data.Derive.NFData",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-NFData.html",
        "fct-type": "module",
        "title": "NFData"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive NFData",
        "module": "Data.Derive.NFData",
        "name": "NFData",
        "normalized": "",
        "package": "derive",
        "partial": "NFData",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-NFData.html#v:dslNFData",
      "description": {
        "fct-module": "Data.Derive.NFData",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-NFData.html#dslNFData",
        "fct-type": "function",
        "title": "dslNFData"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive NFData",
        "module": "Data.Derive.NFData",
        "name": "dslNFData",
        "normalized": "",
        "package": "derive",
        "partial": "NFData",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-NFData.html#v:makeNFData",
      "description": {
        "fct-module": "Data.Derive.NFData",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-NFData.html#makeNFData",
        "fct-type": "function",
        "title": "makeNFData"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive NFData",
        "module": "Data.Derive.NFData",
        "name": "makeNFData",
        "normalized": "",
        "package": "derive",
        "partial": "NFData",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ord.html#",
      "description": {
        "fct-module": "Data.Derive.Ord",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Ord.html",
        "fct-type": "module",
        "title": "Ord"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Ord",
        "module": "Data.Derive.Ord",
        "name": "Ord",
        "normalized": "",
        "package": "derive",
        "partial": "Ord",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ord.html#v:dslOrd",
      "description": {
        "fct-module": "Data.Derive.Ord",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Ord.html#dslOrd",
        "fct-type": "function",
        "title": "dslOrd"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Ord",
        "module": "Data.Derive.Ord",
        "name": "dslOrd",
        "normalized": "",
        "package": "derive",
        "partial": "Ord",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ord.html#v:makeOrd",
      "description": {
        "fct-module": "Data.Derive.Ord",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Ord.html#makeOrd",
        "fct-type": "function",
        "title": "makeOrd"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Ord",
        "module": "Data.Derive.Ord",
        "name": "makeOrd",
        "normalized": "",
        "package": "derive",
        "partial": "Ord",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Read.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerives \u003ccode\u003eRead\u003c/code\u003e.  This is as defined by the Haskell report, except\n    there is no support for infix constructors.  If you attempt to\n    derive \u003ccode\u003eRead\u003c/code\u003e for a data type with infix constructors, the\n    constructors are handled as if they were prefix constructors, using\n    the \u003ccode\u003e(\u003c/code\u003e\u003cem\u003econsym\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e syntax.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Read",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Read.html",
        "fct-type": "module",
        "title": "Read"
      },
      "index": {
        "description": "Derives Read This is as defined by the Haskell report except there is no support for infix constructors If you attempt to derive Read for data type with infix constructors the constructors are handled as if they were prefix constructors using the consym syntax",
        "hierarchy": "Data Derive Read",
        "module": "Data.Derive.Read",
        "name": "Read",
        "normalized": "",
        "package": "derive",
        "partial": "Read",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Read.html#v:makeRead",
      "description": {
        "fct-module": "Data.Derive.Read",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Read.html#makeRead",
        "fct-type": "function",
        "title": "makeRead"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Read",
        "module": "Data.Derive.Read",
        "name": "makeRead",
        "normalized": "",
        "package": "derive",
        "partial": "Read",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ref.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each field in the data type, deriving\n    \u003ccode\u003eRef\u003c/code\u003e generates \u003ccode\u003eref\u003c/code\u003e\u003cem\u003eFieldName\u003c/em\u003e\u003ccode\u003e = Ref { select = \u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e , update =\n     f v -\u003e v { \u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e = f (\u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e v) } }\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is intended for use with the compositional functional references\n    described in\n    \u003ca\u003ehttp://www.haskell.org/pipermail/haskell-cafe/2007-June/026477.html\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Ref",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Ref.html",
        "fct-type": "module",
        "title": "Ref"
      },
      "index": {
        "description": "pseudo derivation For each field in the data type deriving Ref generates ref FieldName Ref select fieldName update fieldName fieldName This is intended for use with the compositional functional references described in http www.haskell.org pipermail haskell-cafe June html",
        "hierarchy": "Data Derive Ref",
        "module": "Data.Derive.Ref",
        "name": "Ref",
        "normalized": "",
        "package": "derive",
        "partial": "Ref",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ref.html#v:makeRef",
      "description": {
        "fct-module": "Data.Derive.Ref",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Ref.html#makeRef",
        "fct-type": "function",
        "title": "makeRef"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Ref",
        "module": "Data.Derive.Ref",
        "name": "makeRef",
        "normalized": "",
        "package": "derive",
        "partial": "Ref",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serial.html#",
      "description": {
        "fct-module": "Data.Derive.Serial",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Serial.html",
        "fct-type": "module",
        "title": "Serial"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Serial",
        "module": "Data.Derive.Serial",
        "name": "Serial",
        "normalized": "",
        "package": "derive",
        "partial": "Serial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serial.html#v:dslSerial",
      "description": {
        "fct-module": "Data.Derive.Serial",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Serial.html#dslSerial",
        "fct-type": "function",
        "title": "dslSerial"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Serial",
        "module": "Data.Derive.Serial",
        "name": "dslSerial",
        "normalized": "",
        "package": "derive",
        "partial": "Serial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serial.html#v:makeSerial",
      "description": {
        "fct-module": "Data.Derive.Serial",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Serial.html#makeSerial",
        "fct-type": "function",
        "title": "makeSerial"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Serial",
        "module": "Data.Derive.Serial",
        "name": "makeSerial",
        "normalized": "",
        "package": "derive",
        "partial": "Serial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serialize.html#",
      "description": {
        "fct-module": "Data.Derive.Serialize",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Serialize.html",
        "fct-type": "module",
        "title": "Serialize"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Serialize",
        "module": "Data.Derive.Serialize",
        "name": "Serialize",
        "normalized": "",
        "package": "derive",
        "partial": "Serialize",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serialize.html#v:dslSerialize",
      "description": {
        "fct-module": "Data.Derive.Serialize",
        "fct-package": "derive",
        "fct-signature": "DSL",
        "fct-source": "src/Data-Derive-Serialize.html#dslSerialize",
        "fct-type": "function",
        "title": "dslSerialize"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Serialize",
        "module": "Data.Derive.Serialize",
        "name": "dslSerialize",
        "normalized": "",
        "package": "derive",
        "partial": "Serialize",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serialize.html#v:makeSerialize",
      "description": {
        "fct-module": "Data.Derive.Serialize",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Serialize.html#makeSerialize",
        "fct-type": "function",
        "title": "makeSerialize"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Serialize",
        "module": "Data.Derive.Serialize",
        "name": "makeSerialize",
        "normalized": "",
        "package": "derive",
        "partial": "Serialize",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Set.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each field in the data type, deriving\n    \u003ccode\u003eSet\u003c/code\u003e generates \u003ccode\u003eset\u003c/code\u003e\u003cem\u003eFieldName\u003c/em\u003e\u003ccode\u003e v x = x{\u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e = v}\u003c/code\u003e.\n    This derivation is intended to work around the fact that in Haskell\n    assigning to a field is not a first class object (although\n    extracting from a field is).\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Set",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Set.html",
        "fct-type": "module",
        "title": "Set"
      },
      "index": {
        "description": "pseudo derivation For each field in the data type deriving Set generates set FieldName fieldName This derivation is intended to work around the fact that in Haskell assigning to field is not first class object although extracting from field is",
        "hierarchy": "Data Derive Set",
        "module": "Data.Derive.Set",
        "name": "Set",
        "normalized": "",
        "package": "derive",
        "partial": "Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Set.html#v:makeSet",
      "description": {
        "fct-module": "Data.Derive.Set",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Set.html#makeSet",
        "fct-type": "function",
        "title": "makeSet"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Set",
        "module": "Data.Derive.Set",
        "name": "makeSet",
        "normalized": "",
        "package": "derive",
        "partial": "Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Show.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerives \u003ccode\u003eShow\u003c/code\u003e.  This is as defined by the Haskell report, except\n there is no support for infix constructors.  If you attempt to\n derive \u003ccode\u003eShow\u003c/code\u003e for a data type with infix constructors, the\n constructors are handled as if they were prefix constructors, using\n the \u003ccode\u003e(\u003c/code\u003e\u003cem\u003econsym\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e syntax.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Show",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Show.html",
        "fct-type": "module",
        "title": "Show"
      },
      "index": {
        "description": "Derives Show This is as defined by the Haskell report except there is no support for infix constructors If you attempt to derive Show for data type with infix constructors the constructors are handled as if they were prefix constructors using the consym syntax",
        "hierarchy": "Data Derive Show",
        "module": "Data.Derive.Show",
        "name": "Show",
        "normalized": "",
        "package": "derive",
        "partial": "Show",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Show.html#v:makeShow",
      "description": {
        "fct-module": "Data.Derive.Show",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Show.html#makeShow",
        "fct-type": "function",
        "title": "makeShow"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Show",
        "module": "Data.Derive.Show",
        "name": "makeShow",
        "normalized": "",
        "package": "derive",
        "partial": "Show",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Traversable.html#",
      "description": {
        "fct-module": "Data.Derive.Traversable",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Traversable.html",
        "fct-type": "module",
        "title": "Traversable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Traversable",
        "module": "Data.Derive.Traversable",
        "name": "Traversable",
        "normalized": "",
        "package": "derive",
        "partial": "Traversable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Traversable.html#v:makeTraversable",
      "description": {
        "fct-module": "Data.Derive.Traversable",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Traversable.html#makeTraversable",
        "fct-type": "function",
        "title": "makeTraversable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Traversable",
        "module": "Data.Derive.Traversable",
        "name": "makeTraversable",
        "normalized": "",
        "package": "derive",
        "partial": "Traversable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Traversable.html#v:makeTraversableN",
      "description": {
        "fct-module": "Data.Derive.Traversable",
        "fct-package": "derive",
        "fct-signature": "Int -\u003e Derivation",
        "fct-source": "src/Data-Derive-Traversable.html#makeTraversableN",
        "fct-type": "function",
        "title": "makeTraversableN"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Traversable",
        "module": "Data.Derive.Traversable",
        "name": "makeTraversableN",
        "normalized": "Int-\u003eDerivation",
        "package": "derive",
        "partial": "Traversable",
        "signature": "Int-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Typeable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerivation for the \u003ccode\u003eTypeable\u003c/code\u003e class, as described in the Scrap\n    Your Boilerplate papers.  This derivation generates instances for\n    all kinds of TypeableK classes; as such we do NOT require the\n    GHC-specific generic downkinding instances to provide lower kind\n    instances.\n\u003c/p\u003e\u003cp\u003eAlso creates a \u003ccode\u003etypename_\u003cthe type name\u003e\u003c/code\u003e value to hold the\n    \u003ccode\u003eTypeRep\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Typeable",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Typeable.html",
        "fct-type": "module",
        "title": "Typeable"
      },
      "index": {
        "description": "Derivation for the Typeable class as described in the Scrap Your Boilerplate papers This derivation generates instances for all kinds of TypeableK classes as such we do NOT require the GHC-specific generic downkinding instances to provide lower kind instances Also creates typename the type name value to hold the TypeRep",
        "hierarchy": "Data Derive Typeable",
        "module": "Data.Derive.Typeable",
        "name": "Typeable",
        "normalized": "",
        "package": "derive",
        "partial": "Typeable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Typeable.html#v:makeTypeable",
      "description": {
        "fct-module": "Data.Derive.Typeable",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Typeable.html#makeTypeable",
        "fct-type": "function",
        "title": "makeTypeable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Typeable",
        "module": "Data.Derive.Typeable",
        "name": "makeTypeable",
        "normalized": "",
        "package": "derive",
        "partial": "Typeable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateDirect.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerive Uniplate and Biplate using the Direct combinators.\n   You must request monomorphic instances, i.e:\n\u003c/p\u003e\u003cpre\u003e data Foo a = Foo a (Bool, a)\n\n {-!\n deriving instance UniplateDirect (Foo Int)\n deriving instance UniplateDirect (Bool, Int) Int\n deriving instance UniplateDirect (Foo Int) Int\n !-}\n\u003c/pre\u003e\u003cp\u003eThis will generate the instances \u003ccode\u003eUniplate (Foo Int)\u003c/code\u003e,\n   \u003ccode\u003eBiplate (Bool, Int) Int\u003c/code\u003e and \u003ccode\u003eBiplate (Foo Int) Int\u003c/code\u003e.\n   Generally, start with the instance you are after (e.g. \u003ccode\u003eUniplateDirect (Foo Int)\u003c/code\u003e),\n   try to compile and add further instances as necessary. \u003ccode\u003eUniplateDirect\u003c/code\u003e with\n   one argument derives Uniplate, and with two arguments derives Biplate.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ederiving UniplateDirect\u003c/code\u003e on a data type with no arguments derives Uniplate\n   with all type parameters defaulting to \u003ccode\u003e()\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.UniplateDirect",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-UniplateDirect.html",
        "fct-type": "module",
        "title": "UniplateDirect"
      },
      "index": {
        "description": "Derive Uniplate and Biplate using the Direct combinators You must request monomorphic instances i.e data Foo Foo Bool deriving instance UniplateDirect Foo Int deriving instance UniplateDirect Bool Int Int deriving instance UniplateDirect Foo Int Int This will generate the instances Uniplate Foo Int Biplate Bool Int Int and Biplate Foo Int Int Generally start with the instance you are after e.g UniplateDirect Foo Int try to compile and add further instances as necessary UniplateDirect with one argument derives Uniplate and with two arguments derives Biplate deriving UniplateDirect on data type with no arguments derives Uniplate with all type parameters defaulting to",
        "hierarchy": "Data Derive UniplateDirect",
        "module": "Data.Derive.UniplateDirect",
        "name": "UniplateDirect",
        "normalized": "",
        "package": "derive",
        "partial": "Uniplate Direct",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateDirect.html#v:makeUniplateDirect",
      "description": {
        "fct-module": "Data.Derive.UniplateDirect",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-UniplateDirect.html#makeUniplateDirect",
        "fct-type": "function",
        "title": "makeUniplateDirect"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive UniplateDirect",
        "module": "Data.Derive.UniplateDirect",
        "name": "makeUniplateDirect",
        "normalized": "",
        "package": "derive",
        "partial": "Uniplate Direct",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateTypeable.html#",
      "description": {
        "fct-module": "Data.Derive.UniplateTypeable",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-UniplateTypeable.html",
        "fct-type": "module",
        "title": "UniplateTypeable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive UniplateTypeable",
        "module": "Data.Derive.UniplateTypeable",
        "name": "UniplateTypeable",
        "normalized": "",
        "package": "derive",
        "partial": "Uniplate Typeable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateTypeable.html#v:custom",
      "description": {
        "fct-module": "Data.Derive.UniplateTypeable",
        "fct-package": "derive",
        "fct-signature": "(t, Decl) -\u003e [Decl] -\u003e [Decl]",
        "fct-source": "src/Data-Derive-UniplateTypeable.html#custom",
        "fct-type": "function",
        "title": "custom"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive UniplateTypeable",
        "module": "Data.Derive.UniplateTypeable",
        "name": "custom",
        "normalized": "(a,Decl)-\u003e[Decl]-\u003e[Decl]",
        "package": "derive",
        "partial": "",
        "signature": "(t,Decl)-\u003e[Decl]-\u003e[Decl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateTypeable.html#v:makeUniplateTypeable",
      "description": {
        "fct-module": "Data.Derive.UniplateTypeable",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-UniplateTypeable.html#makeUniplateTypeable",
        "fct-type": "function",
        "title": "makeUniplateTypeable"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive UniplateTypeable",
        "module": "Data.Derive.UniplateTypeable",
        "name": "makeUniplateTypeable",
        "normalized": "",
        "package": "derive",
        "partial": "Uniplate Typeable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Update.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Pseudo derivation. For every label, creates a function\n    foo_u and foo_s which updates and sets the label respectively,\n    e.g. 'foo_u (+1) bar' or 'foo_s 10 baz'\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Derive.Update",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-Derive-Update.html",
        "fct-type": "module",
        "title": "Update"
      },
      "index": {
        "description": "Pseudo derivation For every label creates function foo and foo which updates and sets the label respectively e.g foo bar or foo baz",
        "hierarchy": "Data Derive Update",
        "module": "Data.Derive.Update",
        "name": "Update",
        "normalized": "",
        "package": "derive",
        "partial": "Update",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Update.html#v:makeUpdate",
      "description": {
        "fct-module": "Data.Derive.Update",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Data-Derive-Update.html#makeUpdate",
        "fct-type": "function",
        "title": "makeUpdate"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Derive Update",
        "module": "Data.Derive.Update",
        "name": "makeUpdate",
        "normalized": "",
        "package": "derive",
        "partial": "Update",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#",
      "description": {
        "fct-module": "Data.DeriveDSL",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-DeriveDSL.html",
        "fct-type": "module",
        "title": "DeriveDSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data DeriveDSL",
        "module": "Data.DeriveDSL",
        "name": "DeriveDSL",
        "normalized": "",
        "package": "derive",
        "partial": "Derive DSL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#t:DSL",
      "description": {
        "fct-module": "Data.DeriveDSL",
        "fct-package": "derive",
        "fct-signature": "data",
        "fct-source": "src/Data-Derive-DSL-DSL.html#DSL",
        "fct-type": "data",
        "title": "DSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data DeriveDSL",
        "module": "Data.DeriveDSL",
        "name": "DSL",
        "normalized": "",
        "package": "derive",
        "partial": "DSL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#v:applyDSL",
      "description": {
        "fct-module": "Data.DeriveDSL",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e DataDecl -\u003e Either String [Decl]",
        "fct-source": "src/Data-DeriveDSL.html#applyDSL",
        "fct-type": "function",
        "title": "applyDSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data DeriveDSL",
        "module": "Data.DeriveDSL",
        "name": "applyDSL",
        "normalized": "DSL-\u003eDataDecl-\u003eEither String[Decl]",
        "package": "derive",
        "partial": "DSL",
        "signature": "DSL-\u003eDataDecl-\u003eEither String[Decl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#v:deriveDSL",
      "description": {
        "fct-module": "Data.DeriveDSL",
        "fct-package": "derive",
        "fct-signature": "[Decl] -\u003e Maybe DSL",
        "fct-source": "src/Data-DeriveDSL.html#deriveDSL",
        "fct-type": "function",
        "title": "deriveDSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data DeriveDSL",
        "module": "Data.DeriveDSL",
        "name": "deriveDSL",
        "normalized": "[Decl]-\u003eMaybe DSL",
        "package": "derive",
        "partial": "DSL",
        "signature": "[Decl]-\u003eMaybe DSL"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#v:dynamicDSL",
      "description": {
        "fct-module": "Data.DeriveDSL",
        "fct-package": "derive",
        "fct-signature": "DSL -\u003e Maybe [Decl]",
        "fct-source": "src/Data-DeriveDSL.html#dynamicDSL",
        "fct-type": "function",
        "title": "dynamicDSL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data DeriveDSL",
        "module": "Data.DeriveDSL",
        "name": "dynamicDSL",
        "normalized": "DSL-\u003eMaybe[Decl]",
        "package": "derive",
        "partial": "DSL",
        "signature": "DSL-\u003eMaybe[Decl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveMain.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUse this module to create your own derive program, supporting custom derivations.\n   As an example:\n\u003c/p\u003e\u003cpre\u003e\n   import \u003ca\u003eData.DeriveMain\u003c/a\u003e        (\u003ccode\u003e\u003ca\u003ederiveMain\u003c/a\u003e\u003c/code\u003e)\n   import \u003ca\u003eData.Derive.All\u003c/a\u003e        (\u003ccode\u003e\u003ca\u003ederivations\u003c/a\u003e\u003c/code\u003e)\n   import MyProject.MyDerivation (myDerivation)\n\u003c/pre\u003e\u003cpre\u003e\n   main :: IO\n   main = \u003ccode\u003e\u003ca\u003ederiveMain\u003c/a\u003e\u003c/code\u003e $ [myDerivation] ++ \u003ccode\u003e\u003ca\u003ederivations\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003c/div\u003e",
        "fct-module": "Data.DeriveMain",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-DeriveMain.html",
        "fct-type": "module",
        "title": "DeriveMain"
      },
      "index": {
        "description": "Use this module to create your own derive program supporting custom derivations As an example import Data.DeriveMain deriveMain import Data.Derive.All derivations import MyProject.MyDerivation myDerivation main IO main deriveMain myDerivation derivations",
        "hierarchy": "Data DeriveMain",
        "module": "Data.DeriveMain",
        "name": "DeriveMain",
        "normalized": "",
        "package": "derive",
        "partial": "Derive Main",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveMain.html#v:deriveMain",
      "description": {
        "fct-module": "Data.DeriveMain",
        "fct-package": "derive",
        "fct-signature": "[Derivation] -\u003e IO ()",
        "fct-source": "src/Derive-Main.html#deriveMain",
        "fct-type": "function",
        "title": "deriveMain"
      },
      "index": {
        "description": "",
        "hierarchy": "Data DeriveMain",
        "module": "Data.DeriveMain",
        "name": "deriveMain",
        "normalized": "[Derivation]-\u003eIO()",
        "package": "derive",
        "partial": "Main",
        "signature": "[Derivation]-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveTH.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe main TH driver module.  It is intended that this need be the\n only module imported by user code; it takes care of all data\n threading issues such that all one needs to do is:\n\u003c/p\u003e\u003cpre\u003e\n   data Foo = Foo ; $( derive makeEq ''Foo )\n\u003c/pre\u003e\u003c/div\u003e",
        "fct-module": "Data.DeriveTH",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Data-DeriveTH.html",
        "fct-type": "module",
        "title": "DeriveTH"
      },
      "index": {
        "description": "The main TH driver module It is intended that this need be the only module imported by user code it takes care of all data threading issues such that all one needs to do is data Foo Foo derive makeEq Foo",
        "hierarchy": "Data DeriveTH",
        "module": "Data.DeriveTH",
        "name": "DeriveTH",
        "normalized": "",
        "package": "derive",
        "partial": "Derive TH",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveTH.html#v:derive",
      "description": {
        "fct-descr": "\u003cp\u003eDerive an instance of some class. \u003ccode\u003ederive\u003c/code\u003e only derives instances\n for the type of the argument.\n\u003c/p\u003e",
        "fct-module": "Data.DeriveTH",
        "fct-package": "derive",
        "fct-signature": "Derivation -\u003e Name -\u003e Q [Dec]",
        "fct-source": "src/Data-DeriveTH.html#derive",
        "fct-type": "function",
        "title": "derive"
      },
      "index": {
        "description": "Derive an instance of some class derive only derives instances for the type of the argument",
        "hierarchy": "Data DeriveTH",
        "module": "Data.DeriveTH",
        "name": "derive",
        "normalized": "Derivation-\u003eName-\u003eQ[Dec]",
        "package": "derive",
        "partial": "",
        "signature": "Derivation-\u003eName-\u003eQ[Dec]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveTH.html#v:deriveFromDec",
      "description": {
        "fct-descr": "\u003cp\u003eDerive an instance of some class. \u003ccode\u003ederiveFromDec\u003c/code\u003e only derives instances\n for the type of the argument.\n\u003c/p\u003e",
        "fct-module": "Data.DeriveTH",
        "fct-package": "derive",
        "fct-signature": "Derivation -\u003e Dec -\u003e Q [Dec]",
        "fct-source": "src/Data-DeriveTH.html#deriveFromDec",
        "fct-type": "function",
        "title": "deriveFromDec"
      },
      "index": {
        "description": "Derive an instance of some class deriveFromDec only derives instances for the type of the argument",
        "hierarchy": "Data DeriveTH",
        "module": "Data.DeriveTH",
        "name": "deriveFromDec",
        "normalized": "Derivation-\u003eDec-\u003eQ[Dec]",
        "package": "derive",
        "partial": "From Dec",
        "signature": "Derivation-\u003eDec-\u003eQ[Dec]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveTH.html#v:derives",
      "description": {
        "fct-module": "Data.DeriveTH",
        "fct-package": "derive",
        "fct-signature": "[Derivation] -\u003e [Name] -\u003e Q [Dec]",
        "fct-source": "src/Data-DeriveTH.html#derives",
        "fct-type": "function",
        "title": "derives"
      },
      "index": {
        "description": "",
        "hierarchy": "Data DeriveTH",
        "module": "Data.DeriveTH",
        "name": "derives",
        "normalized": "[Derivation]-\u003e[Name]-\u003eQ[Dec]",
        "package": "derive",
        "partial": "",
        "signature": "[Derivation]-\u003e[Name]-\u003eQ[Dec]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-Convert.html#",
      "description": {
        "fct-module": "Language.Haskell.Convert",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-Convert.html",
        "fct-type": "module",
        "title": "Convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell Convert",
        "module": "Language.Haskell.Convert",
        "name": "Convert",
        "normalized": "",
        "package": "derive",
        "partial": "Convert",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-Convert.html#t:Convert",
      "description": {
        "fct-module": "Language.Haskell.Convert",
        "fct-package": "derive",
        "fct-signature": "class",
        "fct-source": "src/Language-Haskell-Convert.html#Convert",
        "fct-type": "class",
        "title": "Convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell Convert",
        "module": "Language.Haskell.Convert",
        "name": "Convert",
        "normalized": "",
        "package": "derive",
        "partial": "Convert",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-Convert.html#v:convert",
      "description": {
        "fct-module": "Language.Haskell.Convert",
        "fct-package": "derive",
        "fct-signature": "a -\u003e b",
        "fct-source": "src/Language-Haskell-Convert.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell Convert",
        "module": "Language.Haskell.Convert",
        "name": "convert",
        "normalized": "a-\u003eb",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#",
      "description": {
        "fct-module": "Language.Haskell.TH.All",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-TH-All.html",
        "fct-type": "module",
        "title": "All"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH All",
        "module": "Language.Haskell.TH.All",
        "name": "All",
        "normalized": "",
        "package": "derive",
        "partial": "All",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#t:Derivation",
      "description": {
        "fct-descr": "\u003cp\u003eThe type of ways to derive classes.\n   Should not really be in this module!\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.All",
        "fct-package": "derive",
        "fct-signature": "data",
        "fct-source": "src/Language-Haskell-TH-All.html#Derivation",
        "fct-type": "data",
        "title": "Derivation"
      },
      "index": {
        "description": "The type of ways to derive classes Should not really be in this module",
        "hierarchy": "Language Haskell TH All",
        "module": "Language.Haskell.TH.All",
        "name": "Derivation",
        "normalized": "",
        "package": "derive",
        "partial": "Derivation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:Derivation",
      "description": {
        "fct-module": "Language.Haskell.TH.All",
        "fct-package": "derive",
        "fct-signature": "Derivation",
        "fct-source": "src/Language-Haskell-TH-All.html#Derivation",
        "fct-type": "function",
        "title": "Derivation"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH All",
        "module": "Language.Haskell.TH.All",
        "name": "Derivation",
        "normalized": "",
        "package": "derive",
        "partial": "Derivation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:derivation",
      "description": {
        "fct-module": "Language.Haskell.TH.All",
        "fct-package": "derive",
        "fct-signature": "(DataDef -\u003e [Dec]) -\u003e String -\u003e Derivation",
        "fct-source": "src/Language-Haskell-TH-All.html#derivation",
        "fct-type": "function",
        "title": "derivation"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH All",
        "module": "Language.Haskell.TH.All",
        "name": "derivation",
        "normalized": "(DataDef-\u003e[Dec])-\u003eString-\u003eDerivation",
        "package": "derive",
        "partial": "",
        "signature": "(DataDef-\u003e[Dec])-\u003eString-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:derivationDeriver",
      "description": {
        "fct-descr": "\u003cp\u003eThe derivation function proper\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.All",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e Q [Dec]",
        "fct-source": "src/Language-Haskell-TH-All.html#Derivation",
        "fct-type": "function",
        "title": "derivationDeriver"
      },
      "index": {
        "description": "The derivation function proper",
        "hierarchy": "Language Haskell TH All",
        "module": "Language.Haskell.TH.All",
        "name": "derivationDeriver",
        "normalized": "DataDef-\u003eQ[Dec]",
        "package": "derive",
        "partial": "Deriver",
        "signature": "DataDef-\u003eQ[Dec]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:derivationName",
      "description": {
        "fct-descr": "\u003cp\u003eThe name of the derivation\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.All",
        "fct-package": "derive",
        "fct-signature": "String",
        "fct-source": "src/Language-Haskell-TH-All.html#Derivation",
        "fct-type": "function",
        "title": "derivationName"
      },
      "index": {
        "description": "The name of the derivation",
        "hierarchy": "Language Haskell TH All",
        "module": "Language.Haskell.TH.All",
        "name": "derivationName",
        "normalized": "",
        "package": "derive",
        "partial": "Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:derivationQ",
      "description": {
        "fct-module": "Language.Haskell.TH.All",
        "fct-package": "derive",
        "fct-signature": "(DataDef -\u003e Q [Dec]) -\u003e String -\u003e Derivation",
        "fct-source": "src/Language-Haskell-TH-All.html#derivationQ",
        "fct-type": "function",
        "title": "derivationQ"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH All",
        "module": "Language.Haskell.TH.All",
        "name": "derivationQ",
        "normalized": "(DataDef-\u003eQ[Dec])-\u003eString-\u003eDerivation",
        "package": "derive",
        "partial": "",
        "signature": "(DataDef-\u003eQ[Dec])-\u003eString-\u003eDerivation"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Compat.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompatibility definitions to paper over differences between 6.10 and 6.12.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Language.Haskell.TH.Compat",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-TH-Compat.html",
        "fct-type": "module",
        "title": "Compat"
      },
      "index": {
        "description": "Compatibility definitions to paper over differences between and",
        "hierarchy": "Language Haskell TH Compat",
        "module": "Language.Haskell.TH.Compat",
        "name": "Compat",
        "normalized": "",
        "package": "derive",
        "partial": "Compat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Compat.html#v:dataDefinitionTypeArgs",
      "description": {
        "fct-module": "Language.Haskell.TH.Compat",
        "fct-package": "derive",
        "fct-signature": "Dec -\u003e [Name]",
        "fct-source": "src/Language-Haskell-TH-Compat.html#dataDefinitionTypeArgs",
        "fct-type": "function",
        "title": "dataDefinitionTypeArgs"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Compat",
        "module": "Language.Haskell.TH.Compat",
        "name": "dataDefinitionTypeArgs",
        "normalized": "Dec-\u003e[Name]",
        "package": "derive",
        "partial": "Definition Type Args",
        "signature": "Dec-\u003e[Name]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Compat.html#v:fromTyVar",
      "description": {
        "fct-module": "Language.Haskell.TH.Compat",
        "fct-package": "derive",
        "fct-signature": "TyVarBndr -\u003e Name",
        "fct-source": "src/Language-Haskell-TH-Compat.html#fromTyVar",
        "fct-type": "function",
        "title": "fromTyVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Compat",
        "module": "Language.Haskell.TH.Compat",
        "name": "fromTyVar",
        "normalized": "TyVarBndr-\u003eName",
        "package": "derive",
        "partial": "Ty Var",
        "signature": "TyVarBndr-\u003eName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Compat.html#v:typeToPred",
      "description": {
        "fct-module": "Language.Haskell.TH.Compat",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Pred",
        "fct-source": "src/Language-Haskell-TH-Compat.html#typeToPred",
        "fct-type": "function",
        "title": "typeToPred"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Compat",
        "module": "Language.Haskell.TH.Compat",
        "name": "typeToPred",
        "normalized": "Type-\u003ePred",
        "package": "derive",
        "partial": "To Pred",
        "signature": "Type-\u003ePred"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe core module of the Data.Derive system.  This module contains\n the data types used for communication between the extractors and\n the derivors.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-TH-Data.html",
        "fct-type": "module",
        "title": "Data"
      },
      "index": {
        "description": "The core module of the Data.Derive system This module contains the data types used for communication between the extractors and the derivors",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "Data",
        "normalized": "",
        "package": "derive",
        "partial": "Data",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#t:CtorDef",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Language-Haskell-TH-Data.html#CtorDef",
        "fct-type": "type",
        "title": "CtorDef"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "CtorDef",
        "normalized": "",
        "package": "derive",
        "partial": "Ctor Def",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#t:DataDef",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Language-Haskell-TH-Data.html#DataDef",
        "fct-type": "type",
        "title": "DataDef"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "DataDef",
        "normalized": "",
        "package": "derive",
        "partial": "Data Def",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorArity",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e Int",
        "fct-source": "src/Language-Haskell-TH-Data.html#ctorArity",
        "fct-type": "function",
        "title": "ctorArity"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "ctorArity",
        "normalized": "CtorDef-\u003eInt",
        "package": "derive",
        "partial": "Arity",
        "signature": "CtorDef-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorFields",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e [String]",
        "fct-source": "src/Language-Haskell-TH-Data.html#ctorFields",
        "fct-type": "function",
        "title": "ctorFields"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "ctorFields",
        "normalized": "CtorDef-\u003e[String]",
        "package": "derive",
        "partial": "Fields",
        "signature": "CtorDef-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorName",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e String",
        "fct-source": "src/Language-Haskell-TH-Data.html#ctorName",
        "fct-type": "function",
        "title": "ctorName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "ctorName",
        "normalized": "CtorDef-\u003eString",
        "package": "derive",
        "partial": "Name",
        "signature": "CtorDef-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorStrictTypes",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e [StrictType]",
        "fct-source": "src/Language-Haskell-TH-Data.html#ctorStrictTypes",
        "fct-type": "function",
        "title": "ctorStrictTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "ctorStrictTypes",
        "normalized": "CtorDef-\u003e[StrictType]",
        "package": "derive",
        "partial": "Strict Types",
        "signature": "CtorDef-\u003e[StrictType]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorTypes",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e [Type]",
        "fct-source": "src/Language-Haskell-TH-Data.html#ctorTypes",
        "fct-type": "function",
        "title": "ctorTypes"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "ctorTypes",
        "normalized": "CtorDef-\u003e[Type]",
        "package": "derive",
        "partial": "Types",
        "signature": "CtorDef-\u003e[Type]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dataArgs",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e [Name]",
        "fct-source": "src/Language-Haskell-TH-Data.html#dataArgs",
        "fct-type": "function",
        "title": "dataArgs"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "dataArgs",
        "normalized": "DataDef-\u003e[Name]",
        "package": "derive",
        "partial": "Args",
        "signature": "DataDef-\u003e[Name]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dataArity",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e Int",
        "fct-source": "src/Language-Haskell-TH-Data.html#dataArity",
        "fct-type": "function",
        "title": "dataArity"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "dataArity",
        "normalized": "DataDef-\u003eInt",
        "package": "derive",
        "partial": "Arity",
        "signature": "DataDef-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dataCtors",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e [CtorDef]",
        "fct-source": "src/Language-Haskell-TH-Data.html#dataCtors",
        "fct-type": "function",
        "title": "dataCtors"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "dataCtors",
        "normalized": "DataDef-\u003e[CtorDef]",
        "package": "derive",
        "partial": "Ctors",
        "signature": "DataDef-\u003e[CtorDef]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dataName",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e String",
        "fct-source": "src/Language-Haskell-TH-Data.html#dataName",
        "fct-type": "function",
        "title": "dataName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "dataName",
        "normalized": "DataDef-\u003eString",
        "package": "derive",
        "partial": "Name",
        "signature": "DataDef-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dropModule",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/Language-Haskell-TH-Data.html#dropModule",
        "fct-type": "function",
        "title": "dropModule"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "dropModule",
        "normalized": "String-\u003eString",
        "package": "derive",
        "partial": "Module",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dropNumber",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/Language-Haskell-TH-Data.html#dropNumber",
        "fct-type": "function",
        "title": "dropNumber"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "dropNumber",
        "normalized": "String-\u003eString",
        "package": "derive",
        "partial": "Number",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:eqConT",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "String -\u003e Type -\u003e Bool",
        "fct-source": "src/Language-Haskell-TH-Data.html#eqConT",
        "fct-type": "function",
        "title": "eqConT"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "eqConT",
        "normalized": "String-\u003eType-\u003eBool",
        "package": "derive",
        "partial": "Con",
        "signature": "String-\u003eType-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:isTupleT",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Bool",
        "fct-source": "src/Language-Haskell-TH-Data.html#isTupleT",
        "fct-type": "function",
        "title": "isTupleT"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "isTupleT",
        "normalized": "Type-\u003eBool",
        "package": "derive",
        "partial": "Tuple",
        "signature": "Type-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:normData",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e DataDef",
        "fct-source": "src/Language-Haskell-TH-Data.html#normData",
        "fct-type": "function",
        "title": "normData"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "normData",
        "normalized": "DataDef-\u003eDataDef",
        "package": "derive",
        "partial": "Data",
        "signature": "DataDef-\u003eDataDef"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:qualifiedCtorName",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e Name",
        "fct-source": "src/Language-Haskell-TH-Data.html#qualifiedCtorName",
        "fct-type": "function",
        "title": "qualifiedCtorName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "qualifiedCtorName",
        "normalized": "CtorDef-\u003eName",
        "package": "derive",
        "partial": "Ctor Name",
        "signature": "CtorDef-\u003eName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:qualifiedDataName",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e Name",
        "fct-source": "src/Language-Haskell-TH-Data.html#qualifiedDataName",
        "fct-type": "function",
        "title": "qualifiedDataName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "qualifiedDataName",
        "normalized": "DataDef-\u003eName",
        "package": "derive",
        "partial": "Data Name",
        "signature": "DataDef-\u003eName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:typeApp",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e (Type, [Type])",
        "fct-source": "src/Language-Haskell-TH-Data.html#typeApp",
        "fct-type": "function",
        "title": "typeApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "typeApp",
        "normalized": "Type-\u003e(Type,[Type])",
        "package": "derive",
        "partial": "App",
        "signature": "Type-\u003e(Type,[Type])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:unqualifiedName",
      "description": {
        "fct-module": "Language.Haskell.TH.Data",
        "fct-package": "derive",
        "fct-signature": "Name -\u003e String",
        "fct-source": "src/Language-Haskell-TH-Data.html#unqualifiedName",
        "fct-type": "function",
        "title": "unqualifiedName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Data",
        "module": "Language.Haskell.TH.Data",
        "name": "unqualifiedName",
        "normalized": "Name-\u003eString",
        "package": "derive",
        "partial": "Name",
        "signature": "Name-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-ExpandSynonym.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExpand type synonyms in data declarations.\n\u003c/p\u003e\u003cp\u003eThis is needed for some type based derivations.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Language.Haskell.TH.ExpandSynonym",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-TH-ExpandSynonym.html",
        "fct-type": "module",
        "title": "ExpandSynonym"
      },
      "index": {
        "description": "Expand type synonyms in data declarations This is needed for some type based derivations",
        "hierarchy": "Language Haskell TH ExpandSynonym",
        "module": "Language.Haskell.TH.ExpandSynonym",
        "name": "ExpandSynonym",
        "normalized": "",
        "package": "derive",
        "partial": "Expand Synonym",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-ExpandSynonym.html#v:expandData",
      "description": {
        "fct-descr": "\u003cp\u003eExpand type synonyms in a data declaration\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.ExpandSynonym",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e Q DataDef",
        "fct-source": "src/Language-Haskell-TH-ExpandSynonym.html#expandData",
        "fct-type": "function",
        "title": "expandData"
      },
      "index": {
        "description": "Expand type synonyms in data declaration",
        "hierarchy": "Language Haskell TH ExpandSynonym",
        "module": "Language.Haskell.TH.ExpandSynonym",
        "name": "expandData",
        "normalized": "DataDef-\u003eQ DataDef",
        "package": "derive",
        "partial": "Data",
        "signature": "DataDef-\u003eQ DataDef"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html",
        "fct-type": "module",
        "title": "FixedPpr"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "FixedPpr",
        "normalized": "",
        "package": "derive",
        "partial": "Fixed Ppr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#t:Ppr",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "class",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#Ppr",
        "fct-type": "class",
        "title": "Ppr"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "Ppr",
        "normalized": "",
        "package": "derive",
        "partial": "Ppr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#t:Precedence",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#Precedence",
        "fct-type": "type",
        "title": "Precedence"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "Precedence",
        "normalized": "",
        "package": "derive",
        "partial": "Precedence",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:appPrec",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Precedence",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#appPrec",
        "fct-type": "function",
        "title": "appPrec"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "appPrec",
        "normalized": "",
        "package": "derive",
        "partial": "Prec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:deQualLhsHead",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Dec -\u003e Dec",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#deQualLhsHead",
        "fct-type": "function",
        "title": "deQualLhsHead"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "deQualLhsHead",
        "normalized": "Dec-\u003eDec",
        "package": "derive",
        "partial": "Qual Lhs Head",
        "signature": "Dec-\u003eDec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:deQualName",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Name -\u003e Name",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#deQualName",
        "fct-type": "function",
        "title": "deQualName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "deQualName",
        "normalized": "Name-\u003eName",
        "package": "derive",
        "partial": "Qual Name",
        "signature": "Name-\u003eName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:isPrefixName",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Name -\u003e Bool",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#isPrefixName",
        "fct-type": "function",
        "title": "isPrefixName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "isPrefixName",
        "normalized": "Name-\u003eBool",
        "package": "derive",
        "partial": "Prefix Name",
        "signature": "Name-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:nestDepth",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Int",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#nestDepth",
        "fct-type": "function",
        "title": "nestDepth"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "nestDepth",
        "normalized": "",
        "package": "derive",
        "partial": "Depth",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:noPrec",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Precedence",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#noPrec",
        "fct-type": "function",
        "title": "noPrec"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "noPrec",
        "normalized": "",
        "package": "derive",
        "partial": "Prec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:opPrec",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Precedence",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#opPrec",
        "fct-type": "function",
        "title": "opPrec"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "opPrec",
        "normalized": "",
        "package": "derive",
        "partial": "Prec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:parensIf",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Bool -\u003e Doc -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#parensIf",
        "fct-type": "function",
        "title": "parensIf"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "parensIf",
        "normalized": "Bool-\u003eDoc-\u003eDoc",
        "package": "derive",
        "partial": "If",
        "signature": "Bool-\u003eDoc-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:ppr",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "a -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#ppr",
        "fct-type": "method",
        "title": "ppr"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "ppr",
        "normalized": "a-\u003eDoc",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprBody",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Bool -\u003e Body -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprBody",
        "fct-type": "function",
        "title": "pprBody"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprBody",
        "normalized": "Bool-\u003eBody-\u003eDoc",
        "package": "derive",
        "partial": "Body",
        "signature": "Bool-\u003eBody-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprCxt",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Cxt -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprCxt",
        "fct-type": "function",
        "title": "pprCxt"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprCxt",
        "normalized": "Cxt-\u003eDoc",
        "package": "derive",
        "partial": "Cxt",
        "signature": "Cxt-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprExp",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Precedence -\u003e Exp -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprExp",
        "fct-type": "function",
        "title": "pprExp"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprExp",
        "normalized": "Precedence-\u003eExp-\u003eDoc",
        "package": "derive",
        "partial": "Exp",
        "signature": "Precedence-\u003eExp-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprExpInfix",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprExpInfix",
        "fct-type": "function",
        "title": "pprExpInfix"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprExpInfix",
        "normalized": "Exp-\u003eDoc",
        "package": "derive",
        "partial": "Exp Infix",
        "signature": "Exp-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprFields",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "[(Name, Exp)] -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprFields",
        "fct-type": "function",
        "title": "pprFields"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprFields",
        "normalized": "[(Name,Exp)]-\u003eDoc",
        "package": "derive",
        "partial": "Fields",
        "signature": "[(Name,Exp)]-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprFixity",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Name -\u003e Fixity -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprFixity",
        "fct-type": "function",
        "title": "pprFixity"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprFixity",
        "normalized": "Name-\u003eFixity-\u003eDoc",
        "package": "derive",
        "partial": "Fixity",
        "signature": "Name-\u003eFixity-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprLit",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Precedence -\u003e Lit -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprLit",
        "fct-type": "function",
        "title": "pprLit"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprLit",
        "normalized": "Precedence-\u003eLit-\u003eDoc",
        "package": "derive",
        "partial": "Lit",
        "signature": "Precedence-\u003eLit-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprMaybeExp",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Precedence -\u003e Maybe Exp -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprMaybeExp",
        "fct-type": "function",
        "title": "pprMaybeExp"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprMaybeExp",
        "normalized": "Precedence-\u003eMaybe Exp-\u003eDoc",
        "package": "derive",
        "partial": "Maybe Exp",
        "signature": "Precedence-\u003eMaybe Exp-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprName_",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Bool -\u003e Name -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprName_",
        "fct-type": "function",
        "title": "pprName_"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprName_",
        "normalized": "Bool-\u003eName-\u003eDoc",
        "package": "derive",
        "partial": "Name",
        "signature": "Bool-\u003eName-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprParendType",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprParendType",
        "fct-type": "function",
        "title": "pprParendType"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprParendType",
        "normalized": "Type-\u003eDoc",
        "package": "derive",
        "partial": "Parend Type",
        "signature": "Type-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprPat",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Precedence -\u003e Pat -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprPat",
        "fct-type": "function",
        "title": "pprPat"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprPat",
        "normalized": "Precedence-\u003ePat-\u003eDoc",
        "package": "derive",
        "partial": "Pat",
        "signature": "Precedence-\u003ePat-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprStrictType",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "(Strict, Type) -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprStrictType",
        "fct-type": "function",
        "title": "pprStrictType"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprStrictType",
        "normalized": "(Strict,Type)-\u003eDoc",
        "package": "derive",
        "partial": "Strict Type",
        "signature": "(Strict,Type)-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprTyApp",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "(Type, [Type]) -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprTyApp",
        "fct-type": "function",
        "title": "pprTyApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprTyApp",
        "normalized": "(Type,[Type])-\u003eDoc",
        "package": "derive",
        "partial": "Ty App",
        "signature": "(Type,[Type])-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprVarStrictType",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "(Name, Strict, Type) -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprVarStrictType",
        "fct-type": "function",
        "title": "pprVarStrictType"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprVarStrictType",
        "normalized": "(Name,Strict,Type)-\u003eDoc",
        "package": "derive",
        "partial": "Var Strict Type",
        "signature": "(Name,Strict,Type)-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:ppr_list",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "[a] -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#ppr_list",
        "fct-type": "method",
        "title": "ppr_list"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "ppr_list",
        "normalized": "[a]-\u003eDoc",
        "package": "derive",
        "partial": "",
        "signature": "[a]-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:ppr_sig",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "a -\u003e a1 -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#ppr_sig",
        "fct-type": "function",
        "title": "ppr_sig"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "ppr_sig",
        "normalized": "a-\u003ea-\u003eDoc",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003ea-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprint",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#pprint",
        "fct-type": "function",
        "title": "pprint"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "pprint",
        "normalized": "a-\u003eString",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:showNameRaw",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Name -\u003e String",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#showNameRaw",
        "fct-type": "function",
        "title": "showNameRaw"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "showNameRaw",
        "normalized": "Name-\u003eString",
        "package": "derive",
        "partial": "Name Raw",
        "signature": "Name-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:showtextl",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "a -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#showtextl",
        "fct-type": "function",
        "title": "showtextl"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "showtextl",
        "normalized": "a-\u003eDoc",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:split",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e (Type, [Type])",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#split",
        "fct-type": "function",
        "title": "split"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "split",
        "normalized": "Type-\u003e(Type,[Type])",
        "package": "derive",
        "partial": "",
        "signature": "Type-\u003e(Type,[Type])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:where_clause",
      "description": {
        "fct-module": "Language.Haskell.TH.FixedPpr",
        "fct-package": "derive",
        "fct-signature": "[Dec] -\u003e Doc",
        "fct-source": "src/Language-Haskell-TH-FixedPpr.html#where_clause",
        "fct-type": "function",
        "title": "where_clause"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH FixedPpr",
        "module": "Language.Haskell.TH.FixedPpr",
        "name": "where_clause",
        "normalized": "[Dec]-\u003eDoc",
        "package": "derive",
        "partial": "",
        "signature": "[Dec]-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThese small short-named functions are intended to make the\n   construction of abstranct syntax trees less tedious.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-TH-Helper.html",
        "fct-type": "module",
        "title": "Helper"
      },
      "index": {
        "description": "These small short-named functions are intended to make the construction of abstranct syntax trees less tedious",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "Helper",
        "normalized": "",
        "package": "derive",
        "partial": "Helper",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#t:LitC",
      "description": {
        "fct-descr": "\u003cp\u003eThis class is used to overload literal construction based on the\n type of the literal.\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "class",
        "fct-source": "src/Language-Haskell-TH-Helper.html#LitC",
        "fct-type": "class",
        "title": "LitC"
      },
      "index": {
        "description": "This class is used to overload literal construction based on the type of the literal",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "LitC",
        "normalized": "",
        "package": "derive",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#t:NameLike",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "class",
        "fct-source": "src/Language-Haskell-TH-Helper.html#NameLike",
        "fct-type": "class",
        "title": "NameLike"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "NameLike",
        "normalized": "",
        "package": "derive",
        "partial": "Name Like",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#t:Valcon",
      "description": {
        "fct-descr": "\u003cp\u003eThe class used to overload lifting operations.  To reduce code\n duplication, we overload the wrapped constructors (and everything\n else, but that's irrelevant) to work in patterns, expressions, and\n types.\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "class",
        "fct-source": "src/Language-Haskell-TH-Helper.html#Valcon",
        "fct-type": "class",
        "title": "Valcon"
      },
      "index": {
        "description": "The class used to overload lifting operations To reduce code duplication we overload the wrapped constructors and everything else but that irrelevant to work in patterns expressions and types",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "Valcon",
        "normalized": "",
        "package": "derive",
        "partial": "Valcon",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-38--38-:",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%26%26%3A",
        "fct-type": "function",
        "title": "(&&:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(&&:) &&:",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-38--38-::",
      "description": {
        "fct-descr": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%26%26%3A%3A",
        "fct-type": "function",
        "title": "(&&::)"
      },
      "index": {
        "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(&&::) &&::",
        "normalized": "[Exp]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-43--43-:",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%2B%2B%3A",
        "fct-type": "function",
        "title": "(++:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(++:) ++:",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-43--43-::",
      "description": {
        "fct-descr": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%2B%2B%3A%3A",
        "fct-type": "function",
        "title": "(++::)"
      },
      "index": {
        "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(++::) ++::",
        "normalized": "[Exp]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-45--62-:",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "String -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#-%3E%3A",
        "fct-type": "function",
        "title": "(-\u003e:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(-\u003e:) -\u003e:",
        "normalized": "String-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-61--61-:",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%3D%3D%3A",
        "fct-type": "function",
        "title": "(==:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(==:) ==:",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-62--62--61-:",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%3E%3E%3D%3A",
        "fct-type": "function",
        "title": "(\u003e\u003e=:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(\u003e\u003e=:) \u003e\u003e=:",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-62--62-:",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%3E%3E%3A",
        "fct-type": "function",
        "title": "(\u003e\u003e:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(\u003e\u003e:) \u003e\u003e:",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-62--62-::",
      "description": {
        "fct-descr": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%3E%3E%3A%3A",
        "fct-type": "function",
        "title": "(\u003e\u003e::)"
      },
      "index": {
        "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(\u003e\u003e::) \u003e\u003e::",
        "normalized": "[Exp]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-62-:",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#%3E%3A",
        "fct-type": "function",
        "title": "(\u003e:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(\u003e:) \u003e:",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:.:",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#.%3A",
        "fct-type": "function",
        "title": "(.:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(.:) .:",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:.::",
      "description": {
        "fct-descr": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#.%3A%3A",
        "fct-type": "function",
        "title": "(.::)"
      },
      "index": {
        "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "(.::) .::",
        "normalized": "[Exp]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:ap-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#ap%27",
        "fct-type": "function",
        "title": "ap'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "ap'",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:app",
      "description": {
        "fct-descr": "\u003cp\u003eBuild an application node without a given head\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e [Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#app",
        "fct-type": "function",
        "title": "app"
      },
      "index": {
        "description": "Build an application node without given head",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "app",
        "normalized": "Exp-\u003e[Exp]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003e[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:applyWith",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e [Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#applyWith",
        "fct-type": "function",
        "title": "applyWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "applyWith",
        "normalized": "Exp-\u003e[Exp]-\u003eExp",
        "package": "derive",
        "partial": "With",
        "signature": "Exp-\u003e[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:box",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "a -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#box",
        "fct-type": "function",
        "title": "box"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "box",
        "normalized": "a-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:case-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e [(Pat, Exp)] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#case%27",
        "fct-type": "function",
        "title": "case'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "case'",
        "normalized": "Exp-\u003e[(Pat,Exp)]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003e[(Pat,Exp)]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:cons",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "a -\u003e a -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "cons",
        "normalized": "a-\u003ea-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:const-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#const%27",
        "fct-type": "function",
        "title": "const'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "const'",
        "normalized": "Exp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:ctc",
      "description": {
        "fct-descr": "\u003cp\u003eReference the constructor itself\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#ctc",
        "fct-type": "function",
        "title": "ctc"
      },
      "index": {
        "description": "Reference the constructor itself",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "ctc",
        "normalized": "CtorDef-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "CtorDef-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:ctp",
      "description": {
        "fct-descr": "\u003cp\u003eMake a simple pattern to bind a constructor\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e Char -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#ctp",
        "fct-type": "function",
        "title": "ctp"
      },
      "index": {
        "description": "Make simple pattern to bind constructor",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "ctp",
        "normalized": "CtorDef-\u003eChar-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "CtorDef-\u003eChar-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:ctv",
      "description": {
        "fct-descr": "\u003cp\u003eMake a list of variables, one for each argument to a constructor\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "CtorDef -\u003e Char -\u003e [a]",
        "fct-source": "src/Language-Haskell-TH-Helper.html#ctv",
        "fct-type": "function",
        "title": "ctv"
      },
      "index": {
        "description": "Make list of variables one for each argument to constructor",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "ctv",
        "normalized": "CtorDef-\u003eChar-\u003e[a]",
        "package": "derive",
        "partial": "",
        "signature": "CtorDef-\u003eChar-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:dataVars",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "DataDef -\u003e [Type]",
        "fct-source": "src/Language-Haskell-TH-Helper.html#dataVars",
        "fct-type": "function",
        "title": "dataVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "dataVars",
        "normalized": "DataDef-\u003e[Type]",
        "package": "derive",
        "partial": "Vars",
        "signature": "DataDef-\u003e[Type]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:defclause",
      "description": {
        "fct-descr": "\u003cp\u003eA default clause with N arguments.\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Int -\u003e Exp -\u003e Clause",
        "fct-source": "src/Language-Haskell-TH-Helper.html#defclause",
        "fct-type": "function",
        "title": "defclause"
      },
      "index": {
        "description": "default clause with arguments",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "defclause",
        "normalized": "Int-\u003eExp-\u003eClause",
        "package": "derive",
        "partial": "",
        "signature": "Int-\u003eExp-\u003eClause"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:false",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#false",
        "fct-type": "function",
        "title": "false"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "false",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:foldl1With",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e [Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#foldl1With",
        "fct-type": "function",
        "title": "foldl1With"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "foldl1With",
        "normalized": "Exp-\u003e[Exp]-\u003eExp",
        "package": "derive",
        "partial": "With",
        "signature": "Exp-\u003e[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:foldr1With",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e [Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#foldr1With",
        "fct-type": "function",
        "title": "foldr1With"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "foldr1With",
        "normalized": "Exp-\u003e[Exp]-\u003eExp",
        "package": "derive",
        "partial": "With",
        "signature": "Exp-\u003e[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:funN",
      "description": {
        "fct-descr": "\u003cp\u003eBuild a fundecl with a string name\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "String -\u003e [Clause] -\u003e Dec",
        "fct-source": "src/Language-Haskell-TH-Helper.html#funN",
        "fct-type": "function",
        "title": "funN"
      },
      "index": {
        "description": "Build fundecl with string name",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "funN",
        "normalized": "String-\u003e[Clause]-\u003eDec",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003e[Clause]-\u003eDec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:generic_instance",
      "description": {
        "fct-descr": "\u003cp\u003eBuild an instance of a class for a data type, using the class at the given types\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "String -\u003e DataDef -\u003e [Type] -\u003e [Dec] -\u003e [Dec]",
        "fct-source": "src/Language-Haskell-TH-Helper.html#generic_instance",
        "fct-type": "function",
        "title": "generic_instance"
      },
      "index": {
        "description": "Build an instance of class for data type using the class at the given types",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "generic_instance",
        "normalized": "String-\u003eDataDef-\u003e[Type]-\u003e[Dec]-\u003e[Dec]",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eDataDef-\u003e[Type]-\u003e[Dec]-\u003e[Dec]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:hCons-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Type -\u003e Type",
        "fct-source": "src/Language-Haskell-TH-Helper.html#hCons%27",
        "fct-type": "function",
        "title": "hCons'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "hCons'",
        "normalized": "Type-\u003eType-\u003eType",
        "package": "derive",
        "partial": "Cons'",
        "signature": "Type-\u003eType-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:hNil-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Type",
        "fct-source": "src/Language-Haskell-TH-Helper.html#hNil%27",
        "fct-type": "function",
        "title": "hNil'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "hNil'",
        "normalized": "",
        "package": "derive",
        "partial": "Nil'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:hSucc-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Type",
        "fct-source": "src/Language-Haskell-TH-Helper.html#hSucc%27",
        "fct-type": "function",
        "title": "hSucc'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "hSucc'",
        "normalized": "Type-\u003eType",
        "package": "derive",
        "partial": "Succ'",
        "signature": "Type-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:hZero-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Type",
        "fct-source": "src/Language-Haskell-TH-Helper.html#hZero%27",
        "fct-type": "function",
        "title": "hZero'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "hZero'",
        "normalized": "",
        "package": "derive",
        "partial": "Zero'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:id-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#id%27",
        "fct-type": "function",
        "title": "id'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "id'",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:instance_context",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[String] -\u003e String -\u003e DataDef -\u003e [Dec] -\u003e Dec",
        "fct-source": "src/Language-Haskell-TH-Helper.html#instance_context",
        "fct-type": "function",
        "title": "instance_context"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "instance_context",
        "normalized": "[String]-\u003eString-\u003eDataDef-\u003e[Dec]-\u003eDec",
        "package": "derive",
        "partial": "",
        "signature": "[String]-\u003eString-\u003eDataDef-\u003e[Dec]-\u003eDec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:instance_default",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "String -\u003e DataDef -\u003e [Dec] -\u003e Dec",
        "fct-source": "src/Language-Haskell-TH-Helper.html#instance_default",
        "fct-type": "function",
        "title": "instance_default"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "instance_default",
        "normalized": "String-\u003eDataDef-\u003e[Dec]-\u003eDec",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eDataDef-\u003e[Dec]-\u003eDec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:instance_none",
      "description": {
        "fct-descr": "\u003cp\u003eWe provide 3 standard instance constructors\n   instance_default requires C for each free type variable\n   instance_none requires no context\n   instance_context requires a given context\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "String -\u003e DataDef -\u003e [Dec] -\u003e Dec",
        "fct-source": "src/Language-Haskell-TH-Helper.html#instance_none",
        "fct-type": "function",
        "title": "instance_none"
      },
      "index": {
        "description": "We provide standard instance constructors instance default requires for each free type variable instance none requires no context instance context requires given context",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "instance_none",
        "normalized": "String-\u003eDataDef-\u003e[Dec]-\u003eDec",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eDataDef-\u003e[Dec]-\u003eDec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:l0",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "nm -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#l0",
        "fct-type": "function",
        "title": "l0"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "l0",
        "normalized": "a-\u003eb",
        "package": "derive",
        "partial": "",
        "signature": "nm-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:l1",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "nm -\u003e a -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#l1",
        "fct-type": "function",
        "title": "l1"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "l1",
        "normalized": "a-\u003eb-\u003eb",
        "package": "derive",
        "partial": "",
        "signature": "nm-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:l2",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "nm -\u003e a -\u003e a -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#l2",
        "fct-type": "function",
        "title": "l2"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "l2",
        "normalized": "a-\u003eb-\u003eb-\u003eb",
        "package": "derive",
        "partial": "",
        "signature": "nm-\u003ea-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:lK",
      "description": {
        "fct-descr": "\u003cp\u003eBuild an application node, with a name for a head and a\n provided list of arguments.\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "nm -\u003e [a] -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#lK",
        "fct-type": "method",
        "title": "lK"
      },
      "index": {
        "description": "Build an application node with name for head and provided list of arguments",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "lK",
        "normalized": "a-\u003e[b]-\u003eb",
        "package": "derive",
        "partial": "",
        "signature": "nm-\u003e[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:liftmk",
      "description": {
        "fct-descr": "\u003cp\u003eK-way liftM\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e [Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#liftmk",
        "fct-type": "function",
        "title": "liftmk"
      },
      "index": {
        "description": "K-way liftM",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "liftmk",
        "normalized": "Exp-\u003e[Exp]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003e[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:lit",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "a -\u003e p",
        "fct-source": "src/Language-Haskell-TH-Helper.html#lit",
        "fct-type": "method",
        "title": "lit"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "lit",
        "normalized": "a-\u003eb",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003ep"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:lst",
      "description": {
        "fct-descr": "\u003cp\u003eListing\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[a] -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#lst",
        "fct-type": "method",
        "title": "lst"
      },
      "index": {
        "description": "Listing",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "lst",
        "normalized": "[a]-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:nil",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#nil",
        "fct-type": "function",
        "title": "nil"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "nil",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:raw_lit",
      "description": {
        "fct-descr": "\u003cp\u003eLift a TH \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Lit -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#raw_lit",
        "fct-type": "method",
        "title": "raw_lit"
      },
      "index": {
        "description": "Lift TH Lit",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "raw_lit",
        "normalized": "Lit-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "Lit-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:return-39-",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#return%27",
        "fct-type": "function",
        "title": "return'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "return'",
        "normalized": "Exp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:sclause",
      "description": {
        "fct-descr": "\u003cp\u003eA simple clause, without where or guards.\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[Pat] -\u003e Exp -\u003e Clause",
        "fct-source": "src/Language-Haskell-TH-Helper.html#sclause",
        "fct-type": "function",
        "title": "sclause"
      },
      "index": {
        "description": "simple clause without where or guards",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "sclause",
        "normalized": "[Pat]-\u003eExp-\u003eClause",
        "package": "derive",
        "partial": "",
        "signature": "[Pat]-\u003eExp-\u003eClause"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:sequence__",
      "description": {
        "fct-descr": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#sequence__",
        "fct-type": "function",
        "title": "sequence__"
      },
      "index": {
        "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "sequence__",
        "normalized": "[Exp]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:sigN",
      "description": {
        "fct-descr": "\u003cp\u003eBuild a type signature declaration with a string name\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "String -\u003e Type -\u003e Dec",
        "fct-source": "src/Language-Haskell-TH-Helper.html#sigN",
        "fct-type": "function",
        "title": "sigN"
      },
      "index": {
        "description": "Build type signature declaration with string name",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "sigN",
        "normalized": "String-\u003eType-\u003eDec",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eType-\u003eDec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:simple_instance",
      "description": {
        "fct-descr": "\u003cp\u003eBuild an instance of a class for a data type, using the heuristic\n that the type is itself required on all type arguments.\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "String -\u003e DataDef -\u003e [Dec] -\u003e [Dec]",
        "fct-source": "src/Language-Haskell-TH-Helper.html#simple_instance",
        "fct-type": "function",
        "title": "simple_instance"
      },
      "index": {
        "description": "Build an instance of class for data type using the heuristic that the type is itself required on all type arguments",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "simple_instance",
        "normalized": "String-\u003eDataDef-\u003e[Dec]-\u003e[Dec]",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eDataDef-\u003e[Dec]-\u003e[Dec]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:sval",
      "description": {
        "fct-descr": "\u003cp\u003eA simple Val clause\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Pat -\u003e Exp -\u003e Dec",
        "fct-source": "src/Language-Haskell-TH-Helper.html#sval",
        "fct-type": "function",
        "title": "sval"
      },
      "index": {
        "description": "simple Val clause",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "sval",
        "normalized": "Pat-\u003eExp-\u003eDec",
        "package": "derive",
        "partial": "",
        "signature": "Pat-\u003eExp-\u003eDec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:toName",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "nm -\u003e Name",
        "fct-source": "src/Language-Haskell-TH-Helper.html#toName",
        "fct-type": "method",
        "title": "toName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "toName",
        "normalized": "a-\u003eName",
        "package": "derive",
        "partial": "Name",
        "signature": "nm-\u003eName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:true",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#true",
        "fct-type": "function",
        "title": "true"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "true",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:tup",
      "description": {
        "fct-descr": "\u003cp\u003eTupling\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "[a] -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#tup",
        "fct-type": "method",
        "title": "tup"
      },
      "index": {
        "description": "Tupling",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "tup",
        "normalized": "[a]-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:unit",
      "description": {
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Exp",
        "fct-source": "src/Language-Haskell-TH-Helper.html#unit",
        "fct-type": "function",
        "title": "unit"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "unit",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:vars",
      "description": {
        "fct-descr": "\u003cp\u003eCommon pattern: list of a familiy of variables\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Char -\u003e Int -\u003e [a]",
        "fct-source": "src/Language-Haskell-TH-Helper.html#vars",
        "fct-type": "function",
        "title": "vars"
      },
      "index": {
        "description": "Common pattern list of familiy of variables",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "vars",
        "normalized": "Char-\u003eInt-\u003e[a]",
        "package": "derive",
        "partial": "",
        "signature": "Char-\u003eInt-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:vr",
      "description": {
        "fct-descr": "\u003cp\u003eReference a named variable.\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "nm -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#vr",
        "fct-type": "method",
        "title": "vr"
      },
      "index": {
        "description": "Reference named variable",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "vr",
        "normalized": "a-\u003eb",
        "package": "derive",
        "partial": "",
        "signature": "nm-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:vrn",
      "description": {
        "fct-descr": "\u003cp\u003eVariable based on a letter + number\n\u003c/p\u003e",
        "fct-module": "Language.Haskell.TH.Helper",
        "fct-package": "derive",
        "fct-signature": "Char -\u003e Int -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Helper.html#vrn",
        "fct-type": "function",
        "title": "vrn"
      },
      "index": {
        "description": "Variable based on letter number",
        "hierarchy": "Language Haskell TH Helper",
        "module": "Language.Haskell.TH.Helper",
        "name": "vrn",
        "normalized": "Char-\u003eInt-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "Char-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Peephole.html#",
      "description": {
        "fct-module": "Language.Haskell.TH.Peephole",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell-TH-Peephole.html",
        "fct-type": "module",
        "title": "Peephole"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Peephole",
        "module": "Language.Haskell.TH.Peephole",
        "name": "Peephole",
        "normalized": "",
        "package": "derive",
        "partial": "Peephole",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Peephole.html#v:peephole",
      "description": {
        "fct-module": "Language.Haskell.TH.Peephole",
        "fct-package": "derive",
        "fct-signature": "a -\u003e a",
        "fct-source": "src/Language-Haskell-TH-Peephole.html#peephole",
        "fct-type": "function",
        "title": "peephole"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Peephole",
        "module": "Language.Haskell.TH.Peephole",
        "name": "peephole",
        "normalized": "a-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Peephole.html#v:replaceVar",
      "description": {
        "fct-module": "Language.Haskell.TH.Peephole",
        "fct-package": "derive",
        "fct-signature": "Name -\u003e Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Peephole.html#replaceVar",
        "fct-type": "function",
        "title": "replaceVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Peephole",
        "module": "Language.Haskell.TH.Peephole",
        "name": "replaceVar",
        "normalized": "Name-\u003eExp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "Var",
        "signature": "Name-\u003eExp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Peephole.html#v:replaceVars",
      "description": {
        "fct-module": "Language.Haskell.TH.Peephole",
        "fct-package": "derive",
        "fct-signature": "[(Name, Exp)] -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell-TH-Peephole.html#replaceVars",
        "fct-type": "function",
        "title": "replaceVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell TH Peephole",
        "module": "Language.Haskell.TH.Peephole",
        "name": "replaceVars",
        "normalized": "[(Name,Exp)]-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "Vars",
        "signature": "[(Name,Exp)]-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "module",
        "fct-source": "src/Language-Haskell.html",
        "fct-type": "module",
        "title": "Haskell"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "Haskell",
        "normalized": "",
        "package": "derive",
        "partial": "Haskell",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#t:CtorDecl",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Language-Haskell.html#CtorDecl",
        "fct-type": "type",
        "title": "CtorDecl"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "CtorDecl",
        "normalized": "",
        "package": "derive",
        "partial": "Ctor Decl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#t:DataDecl",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Language-Haskell.html#DataDecl",
        "fct-type": "type",
        "title": "DataDecl"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "DataDecl",
        "normalized": "",
        "package": "derive",
        "partial": "Data Decl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#t:FieldDecl",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Language-Haskell.html#FieldDecl",
        "fct-type": "type",
        "title": "FieldDecl"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "FieldDecl",
        "normalized": "",
        "package": "derive",
        "partial": "Field Decl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#t:FullDataDecl",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "type",
        "fct-source": "src/Language-Haskell.html#FullDataDecl",
        "fct-type": "type",
        "title": "FullDataDecl"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "FullDataDecl",
        "normalized": "",
        "package": "derive",
        "partial": "Full Data Decl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:-126--61-",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "a -\u003e String -\u003e Bool",
        "fct-source": "src/Language-Haskell.html#~%3D",
        "fct-type": "function",
        "title": "(~=)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "(~=) ~=",
        "normalized": "a-\u003eString-\u003eBool",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003eString-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:-63-",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Bool -\u003e a -\u003e a -\u003e a",
        "fct-source": "src/Language-Haskell.html#%3F",
        "fct-type": "function",
        "title": "(?)"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "(?) ?",
        "normalized": "Bool-\u003ea-\u003ea-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "Bool-\u003ea-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:appP",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell.html#appP",
        "fct-type": "function",
        "title": "appP"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "appP",
        "normalized": "Exp-\u003eExp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:apps",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e [Exp] -\u003e Exp",
        "fct-source": "src/Language-Haskell.html#apps",
        "fct-type": "function",
        "title": "apps"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "apps",
        "normalized": "Exp-\u003e[Exp]-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003e[Exp]-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:bind",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e [Pat] -\u003e Exp -\u003e Decl",
        "fct-source": "src/Language-Haskell.html#bind",
        "fct-type": "function",
        "title": "bind"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "bind",
        "normalized": "String-\u003e[Pat]-\u003eExp-\u003eDecl",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003e[Pat]-\u003eExp-\u003eDecl"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:binds",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e [([Pat], Exp)] -\u003e Decl",
        "fct-source": "src/Language-Haskell.html#binds",
        "fct-type": "function",
        "title": "binds"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "binds",
        "normalized": "String-\u003e[([Pat],Exp)]-\u003eDecl",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003e[([Pat],Exp)]-\u003eDecl"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:con",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e Exp",
        "fct-source": "src/Language-Haskell.html#con",
        "fct-type": "function",
        "title": "con"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "con",
        "normalized": "String-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:ctorDeclArity",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "CtorDecl -\u003e Int",
        "fct-source": "src/Language-Haskell.html#ctorDeclArity",
        "fct-type": "function",
        "title": "ctorDeclArity"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "ctorDeclArity",
        "normalized": "CtorDecl-\u003eInt",
        "package": "derive",
        "partial": "Decl Arity",
        "signature": "CtorDecl-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:ctorDeclFields",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "CtorDecl -\u003e FieldDecl",
        "fct-source": "src/Language-Haskell.html#ctorDeclFields",
        "fct-type": "function",
        "title": "ctorDeclFields"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "ctorDeclFields",
        "normalized": "CtorDecl-\u003eFieldDecl",
        "package": "derive",
        "partial": "Decl Fields",
        "signature": "CtorDecl-\u003eFieldDecl"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:ctorDeclName",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "CtorDecl -\u003e String",
        "fct-source": "src/Language-Haskell.html#ctorDeclName",
        "fct-type": "function",
        "title": "ctorDeclName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "ctorDeclName",
        "normalized": "CtorDecl-\u003eString",
        "package": "derive",
        "partial": "Decl Name",
        "signature": "CtorDecl-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:ctorDeclName-39-",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "CtorDecl -\u003e Name",
        "fct-source": "src/Language-Haskell.html#ctorDeclName%27",
        "fct-type": "function",
        "title": "ctorDeclName'"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "ctorDeclName'",
        "normalized": "CtorDecl-\u003eName",
        "package": "derive",
        "partial": "Decl Name'",
        "signature": "CtorDecl-\u003eName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclArity",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e Int",
        "fct-source": "src/Language-Haskell.html#dataDeclArity",
        "fct-type": "function",
        "title": "dataDeclArity"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "dataDeclArity",
        "normalized": "DataDecl-\u003eInt",
        "package": "derive",
        "partial": "Decl Arity",
        "signature": "DataDecl-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclContext",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e Context",
        "fct-source": "src/Language-Haskell.html#dataDeclContext",
        "fct-type": "function",
        "title": "dataDeclContext"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "dataDeclContext",
        "normalized": "DataDecl-\u003eContext",
        "package": "derive",
        "partial": "Decl Context",
        "signature": "DataDecl-\u003eContext"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclCtors",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e [CtorDecl]",
        "fct-source": "src/Language-Haskell.html#dataDeclCtors",
        "fct-type": "function",
        "title": "dataDeclCtors"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "dataDeclCtors",
        "normalized": "DataDecl-\u003e[CtorDecl]",
        "package": "derive",
        "partial": "Decl Ctors",
        "signature": "DataDecl-\u003e[CtorDecl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclFields",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e [String]",
        "fct-source": "src/Language-Haskell.html#dataDeclFields",
        "fct-type": "function",
        "title": "dataDeclFields"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "dataDeclFields",
        "normalized": "DataDecl-\u003e[String]",
        "package": "derive",
        "partial": "Decl Fields",
        "signature": "DataDecl-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclName",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e String",
        "fct-source": "src/Language-Haskell.html#dataDeclName",
        "fct-type": "function",
        "title": "dataDeclName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "dataDeclName",
        "normalized": "DataDecl-\u003eString",
        "package": "derive",
        "partial": "Decl Name",
        "signature": "DataDecl-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclSrcLoc",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e SrcLoc",
        "fct-source": "src/Language-Haskell.html#dataDeclSrcLoc",
        "fct-type": "function",
        "title": "dataDeclSrcLoc"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "dataDeclSrcLoc",
        "normalized": "DataDecl-\u003eSrcLoc",
        "package": "derive",
        "partial": "Decl Src Loc",
        "signature": "DataDecl-\u003eSrcLoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclType",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e Type",
        "fct-source": "src/Language-Haskell.html#dataDeclType",
        "fct-type": "function",
        "title": "dataDeclType"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "dataDeclType",
        "normalized": "DataDecl-\u003eType",
        "package": "derive",
        "partial": "Decl Type",
        "signature": "DataDecl-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclVars",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "DataDecl -\u003e [String]",
        "fct-source": "src/Language-Haskell.html#dataDeclVars",
        "fct-type": "function",
        "title": "dataDeclVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "dataDeclVars",
        "normalized": "DataDecl-\u003e[String]",
        "package": "derive",
        "partial": "Decl Vars",
        "signature": "DataDecl-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:declName",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Decl -\u003e String",
        "fct-source": "src/Language-Haskell.html#declName",
        "fct-type": "function",
        "title": "declName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "declName",
        "normalized": "Decl-\u003eString",
        "package": "derive",
        "partial": "Name",
        "signature": "Decl-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:foralls",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Type",
        "fct-source": "src/Language-Haskell.html#foralls",
        "fct-type": "function",
        "title": "foralls"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "foralls",
        "normalized": "Type-\u003eType",
        "package": "derive",
        "partial": "",
        "signature": "Type-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromBangType",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "BangType -\u003e Type",
        "fct-source": "src/Language-Haskell.html#fromBangType",
        "fct-type": "function",
        "title": "fromBangType"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "fromBangType",
        "normalized": "BangType-\u003eType",
        "package": "derive",
        "partial": "Bang Type",
        "signature": "BangType-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyApps",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e (Type, [Type])",
        "fct-source": "src/Language-Haskell.html#fromTyApps",
        "fct-type": "function",
        "title": "fromTyApps"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "fromTyApps",
        "normalized": "Type-\u003e(Type,[Type])",
        "package": "derive",
        "partial": "Ty Apps",
        "signature": "Type-\u003e(Type,[Type])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyList",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Maybe Type",
        "fct-source": "src/Language-Haskell.html#fromTyList",
        "fct-type": "function",
        "title": "fromTyList"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "fromTyList",
        "normalized": "Type-\u003eMaybe Type",
        "package": "derive",
        "partial": "Ty List",
        "signature": "Type-\u003eMaybe Type"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyParen",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Type",
        "fct-source": "src/Language-Haskell.html#fromTyParen",
        "fct-type": "function",
        "title": "fromTyParen"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "fromTyParen",
        "normalized": "Type-\u003eType",
        "package": "derive",
        "partial": "Ty Paren",
        "signature": "Type-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyParens",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Type",
        "fct-source": "src/Language-Haskell.html#fromTyParens",
        "fct-type": "function",
        "title": "fromTyParens"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "fromTyParens",
        "normalized": "Type-\u003eType",
        "package": "derive",
        "partial": "Ty Parens",
        "signature": "Type-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyTuple",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e [Type]",
        "fct-source": "src/Language-Haskell.html#fromTyTuple",
        "fct-type": "function",
        "title": "fromTyTuple"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "fromTyTuple",
        "normalized": "Type-\u003e[Type]",
        "package": "derive",
        "partial": "Ty Tuple",
        "signature": "Type-\u003e[Type]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isAtom",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Bool",
        "fct-source": "src/Language-Haskell.html#isAtom",
        "fct-type": "function",
        "title": "isAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "isAtom",
        "normalized": "Exp-\u003eBool",
        "package": "derive",
        "partial": "Atom",
        "signature": "Exp-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isDataDecl",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Decl -\u003e Bool",
        "fct-source": "src/Language-Haskell.html#isDataDecl",
        "fct-type": "function",
        "title": "isDataDecl"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "isDataDecl",
        "normalized": "Decl-\u003eBool",
        "package": "derive",
        "partial": "Data Decl",
        "signature": "Decl-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isGuardFalse",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Match -\u003e Bool",
        "fct-source": "src/Language-Haskell.html#isGuardFalse",
        "fct-type": "function",
        "title": "isGuardFalse"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "isGuardFalse",
        "normalized": "Match-\u003eBool",
        "package": "derive",
        "partial": "Guard False",
        "signature": "Match-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isTyFun",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Bool",
        "fct-source": "src/Language-Haskell.html#isTyFun",
        "fct-type": "function",
        "title": "isTyFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "isTyFun",
        "normalized": "Type-\u003eBool",
        "package": "derive",
        "partial": "Ty Fun",
        "signature": "Type-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isTyParen",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e Bool",
        "fct-source": "src/Language-Haskell.html#isTyParen",
        "fct-type": "function",
        "title": "isTyParen"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "isTyParen",
        "normalized": "Type-\u003eBool",
        "package": "derive",
        "partial": "Ty Paren",
        "signature": "Type-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:moduleDecls",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Module -\u003e [Decl]",
        "fct-source": "src/Language-Haskell.html#moduleDecls",
        "fct-type": "function",
        "title": "moduleDecls"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "moduleDecls",
        "normalized": "Module-\u003e[Decl]",
        "package": "derive",
        "partial": "Decls",
        "signature": "Module-\u003e[Decl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:moduleImports",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Module -\u003e [ImportDecl]",
        "fct-source": "src/Language-Haskell.html#moduleImports",
        "fct-type": "function",
        "title": "moduleImports"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "moduleImports",
        "normalized": "Module-\u003e[ImportDecl]",
        "package": "derive",
        "partial": "Imports",
        "signature": "Module-\u003e[ImportDecl]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:moduleName",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Module -\u003e ModuleName",
        "fct-source": "src/Language-Haskell.html#moduleName",
        "fct-type": "function",
        "title": "moduleName"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "moduleName",
        "normalized": "Module-\u003eModuleName",
        "package": "derive",
        "partial": "Name",
        "signature": "Module-\u003eModuleName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:modulePragmas",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Module -\u003e [ModulePragma]",
        "fct-source": "src/Language-Haskell.html#modulePragmas",
        "fct-type": "function",
        "title": "modulePragmas"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "modulePragmas",
        "normalized": "Module-\u003e[ModulePragma]",
        "package": "derive",
        "partial": "Pragmas",
        "signature": "Module-\u003e[ModulePragma]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:noSl",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "from -\u003e from",
        "fct-source": "src/Language-Haskell.html#noSl",
        "fct-type": "function",
        "title": "noSl"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "noSl",
        "normalized": "a-\u003ea",
        "package": "derive",
        "partial": "Sl",
        "signature": "from-\u003efrom"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:pVar",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e Pat",
        "fct-source": "src/Language-Haskell.html#pVar",
        "fct-type": "function",
        "title": "pVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "pVar",
        "normalized": "String-\u003ePat",
        "package": "derive",
        "partial": "Var",
        "signature": "String-\u003ePat"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:paren",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Exp -\u003e Exp",
        "fct-source": "src/Language-Haskell.html#paren",
        "fct-type": "function",
        "title": "paren"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "paren",
        "normalized": "Exp-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "Exp-\u003eExp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:qname",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e QName",
        "fct-source": "src/Language-Haskell.html#qname",
        "fct-type": "function",
        "title": "qname"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "qname",
        "normalized": "String-\u003eQName",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eQName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:qvop",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e QOp",
        "fct-source": "src/Language-Haskell.html#qvop",
        "fct-type": "function",
        "title": "qvop"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "qvop",
        "normalized": "String-\u003eQOp",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eQOp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:rename",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "QName -\u003e QName",
        "fct-source": "src/Language-Haskell.html#rename",
        "fct-type": "function",
        "title": "rename"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "rename",
        "normalized": "QName-\u003eQName",
        "package": "derive",
        "partial": "",
        "signature": "QName-\u003eQName"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:showDecls",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "[a] -\u003e String",
        "fct-source": "src/Language-Haskell.html#showDecls",
        "fct-type": "function",
        "title": "showDecls"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "showDecls",
        "normalized": "[a]-\u003eString",
        "package": "derive",
        "partial": "Decls",
        "signature": "[a]-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:simplify",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "a -\u003e a",
        "fct-source": "src/Language-Haskell.html#simplify",
        "fct-type": "function",
        "title": "simplify"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "simplify",
        "normalized": "a-\u003ea",
        "package": "derive",
        "partial": "",
        "signature": "a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:sl",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "SrcLoc",
        "fct-source": "src/Language-Haskell.html#sl",
        "fct-type": "function",
        "title": "sl"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "sl",
        "normalized": "",
        "package": "derive",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:title",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "[Char] -\u003e [Char]",
        "fct-source": "src/Language-Haskell.html#title",
        "fct-type": "function",
        "title": "title"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "title",
        "normalized": "[Char]-\u003e[Char]",
        "package": "derive",
        "partial": "",
        "signature": "[Char]-\u003e[Char]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyApp",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e [Type] -\u003e Type",
        "fct-source": "src/Language-Haskell.html#tyApp",
        "fct-type": "function",
        "title": "tyApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "tyApp",
        "normalized": "Type-\u003e[Type]-\u003eType",
        "package": "derive",
        "partial": "App",
        "signature": "Type-\u003e[Type]-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyApps",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e [Type] -\u003e Type",
        "fct-source": "src/Language-Haskell.html#tyApps",
        "fct-type": "function",
        "title": "tyApps"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "tyApps",
        "normalized": "Type-\u003e[Type]-\u003eType",
        "package": "derive",
        "partial": "Apps",
        "signature": "Type-\u003e[Type]-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyCon",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e Type",
        "fct-source": "src/Language-Haskell.html#tyCon",
        "fct-type": "function",
        "title": "tyCon"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "tyCon",
        "normalized": "String-\u003eType",
        "package": "derive",
        "partial": "Con",
        "signature": "String-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyFun",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "[Type] -\u003e Type",
        "fct-source": "src/Language-Haskell.html#tyFun",
        "fct-type": "function",
        "title": "tyFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "tyFun",
        "normalized": "[Type]-\u003eType",
        "package": "derive",
        "partial": "Fun",
        "signature": "[Type]-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyRoot",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "Type -\u003e String",
        "fct-source": "src/Language-Haskell.html#tyRoot",
        "fct-type": "function",
        "title": "tyRoot"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "tyRoot",
        "normalized": "Type-\u003eString",
        "package": "derive",
        "partial": "Root",
        "signature": "Type-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyVar",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e Type",
        "fct-source": "src/Language-Haskell.html#tyVar",
        "fct-type": "function",
        "title": "tyVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "tyVar",
        "normalized": "String-\u003eType",
        "package": "derive",
        "partial": "Var",
        "signature": "String-\u003eType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyVarBind",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e TyVarBind",
        "fct-source": "src/Language-Haskell.html#tyVarBind",
        "fct-type": "function",
        "title": "tyVarBind"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "tyVarBind",
        "normalized": "String-\u003eTyVarBind",
        "package": "derive",
        "partial": "Var Bind",
        "signature": "String-\u003eTyVarBind"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:var",
      "description": {
        "fct-module": "Language.Haskell",
        "fct-package": "derive",
        "fct-signature": "String -\u003e Exp",
        "fct-source": "src/Language-Haskell.html#var",
        "fct-type": "function",
        "title": "var"
      },
      "index": {
        "description": "",
        "hierarchy": "Language Haskell",
        "module": "Language.Haskell",
        "name": "var",
        "normalized": "String-\u003eExp",
        "package": "derive",
        "partial": "",
        "signature": "String-\u003eExp"
      }
    }
  }
]
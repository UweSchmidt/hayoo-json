[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#",
      "description": {
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Bit.html",
        "fct-type": "module",
        "title": "Bit"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "Bit",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#t:Bit",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e provides a reference to a possibly indeterminate boolean\n value that can be determined by an external SAT solver.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "newtype",
        "fct-source": "src/Ersatz-Bit.html#Bit",
        "fct-type": "newtype",
        "title": "Bit"
      },
      "index": {
        "description": "Bit provides reference to possibly indeterminate boolean value that can be determined by an external SAT solver",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "Bit",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#t:Boolean",
      "description": {
        "fct-descr": "\u003cp\u003eThe normal \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e operators in Haskell are not overloaded. This\n provides a richer set that are.\n\u003c/p\u003e\u003cp\u003eInstances for this class for product-like types can be automatically derived\n for any type that is an instance of \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Bit.html#Boolean",
        "fct-type": "class",
        "title": "Boolean"
      },
      "index": {
        "description": "The normal Bool operators in Haskell are not overloaded This provides richer set that are Instances for this class for product-like types can be automatically derived for any type that is an instance of Generic",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "Boolean",
        "normalized": "",
        "package": "ersatz",
        "partial": "Boolean",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:-124--124-",
      "description": {
        "fct-descr": "\u003cp\u003eLogical disjunction (inclusive or).\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#%7C%7C",
        "fct-type": "method",
        "title": "(||)"
      },
      "index": {
        "description": "Logical disjunction inclusive or",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "(||) ||",
        "normalized": "a-\u003ea-\u003ea",
        "package": "ersatz",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:-38--38-",
      "description": {
        "fct-descr": "\u003cp\u003eLogical conjunction.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#%26%26",
        "fct-type": "method",
        "title": "(&&)"
      },
      "index": {
        "description": "Logical conjunction",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "(&&) &&",
        "normalized": "a-\u003ea-\u003ea",
        "package": "ersatz",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:-61--61--62-",
      "description": {
        "fct-descr": "\u003cp\u003eLogical implication.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#%3D%3D%3E",
        "fct-type": "method",
        "title": "(==\u003e)"
      },
      "index": {
        "description": "Logical implication",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "(==\u003e) ==\u003e",
        "normalized": "a-\u003ea-\u003ea",
        "package": "ersatz",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:Bit",
      "description": {
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "Bit (Circuit Bit)",
        "fct-source": "src/Ersatz-Bit.html#Bit",
        "fct-type": "function",
        "title": "Bit"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "Bit",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003eThe logical conjunction of the mapping of a function over several values.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "(a -\u003e b) -\u003e t a -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#all",
        "fct-type": "method",
        "title": "all"
      },
      "index": {
        "description": "The logical conjunction of the mapping of function over several values",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "all",
        "normalized": "(a-\u003eb)-\u003ec a-\u003eb",
        "package": "ersatz",
        "partial": "",
        "signature": "(a-\u003eb)-\u003et a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003eThe logical conjunction of several values.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "t b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#and",
        "fct-type": "method",
        "title": "and"
      },
      "index": {
        "description": "The logical conjunction of several values",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "and",
        "normalized": "a b-\u003eb",
        "package": "ersatz",
        "partial": "",
        "signature": "t b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003eThe logical disjunction of the mapping of a function over several values.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "(a -\u003e b) -\u003e t a -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#any",
        "fct-type": "method",
        "title": "any"
      },
      "index": {
        "description": "The logical disjunction of the mapping of function over several values",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "any",
        "normalized": "(a-\u003eb)-\u003ec a-\u003eb",
        "package": "ersatz",
        "partial": "",
        "signature": "(a-\u003eb)-\u003et a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:assert",
      "description": {
        "fct-descr": "\u003cp\u003eAssert claims that \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e must be \u003ccode\u003e\u003ca\u003etrue\u003c/a\u003e\u003c/code\u003e in any satisfying interpretation\n of the current problem.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "Bit -\u003e m ()",
        "fct-source": "src/Ersatz-Bit.html#assert",
        "fct-type": "function",
        "title": "assert"
      },
      "index": {
        "description": "Assert claims that Bit must be true in any satisfying interpretation of the current problem",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "assert",
        "normalized": "Bit-\u003ea()",
        "package": "ersatz",
        "partial": "",
        "signature": "Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:bool",
      "description": {
        "fct-descr": "\u003cp\u003eLift a \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "Bool -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#bool",
        "fct-type": "method",
        "title": "bool"
      },
      "index": {
        "description": "Lift Bool",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "bool",
        "normalized": "Bool-\u003ea",
        "package": "ersatz",
        "partial": "",
        "signature": "Bool-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:choose",
      "description": {
        "fct-descr": "\u003cp\u003eChoose between two alternatives based on a selector bit.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "choose",
        "fct-source": "src/Ersatz-Bit.html#choose",
        "fct-type": "method",
        "title": "choose"
      },
      "index": {
        "description": "Choose between two alternatives based on selector bit",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "choose",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:false",
      "description": {
        "fct-descr": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003efalse\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ebool\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "b",
        "fct-source": "src/Ersatz-Bit.html#false",
        "fct-type": "method",
        "title": "false"
      },
      "index": {
        "description": "false bool False",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "false",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:nand",
      "description": {
        "fct-descr": "\u003cp\u003eThe negated logical conjunction of several values.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enand\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eand\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "t b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#nand",
        "fct-type": "method",
        "title": "nand"
      },
      "index": {
        "description": "The negated logical conjunction of several values nand not and",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "nand",
        "normalized": "a b-\u003eb",
        "package": "ersatz",
        "partial": "",
        "signature": "t b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:nor",
      "description": {
        "fct-descr": "\u003cp\u003eThe negated logical disjunction of several values.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enor\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eor\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "t b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#nor",
        "fct-type": "method",
        "title": "nor"
      },
      "index": {
        "description": "The negated logical disjunction of several values nor not or",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "nor",
        "normalized": "a b-\u003eb",
        "package": "ersatz",
        "partial": "",
        "signature": "t b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:not",
      "description": {
        "fct-descr": "\u003cp\u003eLogical negation\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#not",
        "fct-type": "method",
        "title": "not"
      },
      "index": {
        "description": "Logical negation",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "not",
        "normalized": "a-\u003ea",
        "package": "ersatz",
        "partial": "",
        "signature": "b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003eThe logical disjunction of several values.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "t b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#or",
        "fct-type": "method",
        "title": "or"
      },
      "index": {
        "description": "The logical disjunction of several values",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "or",
        "normalized": "a b-\u003eb",
        "package": "ersatz",
        "partial": "",
        "signature": "t b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:true",
      "description": {
        "fct-descr": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003etrue\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ebool\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "b",
        "fct-source": "src/Ersatz-Bit.html#true",
        "fct-type": "method",
        "title": "true"
      },
      "index": {
        "description": "true bool True",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "true",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bit.html#v:xor",
      "description": {
        "fct-descr": "\u003cp\u003eExclusive-or\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bit",
        "fct-package": "ersatz",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Ersatz-Bit.html#xor",
        "fct-type": "method",
        "title": "xor"
      },
      "index": {
        "description": "Exclusive-or",
        "hierarchy": "Ersatz Bit",
        "module": "Ersatz.Bit",
        "name": "xor",
        "normalized": "a-\u003ea-\u003ea",
        "package": "ersatz",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Bits.html",
        "fct-type": "module",
        "title": "Bits"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bits",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bits",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit1",
      "description": {
        "fct-descr": "\u003cp\u003eA container of 1 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "newtype",
        "fct-source": "src/Ersatz-Bits.html#Bit1",
        "fct-type": "newtype",
        "title": "Bit1"
      },
      "index": {
        "description": "container of Bit that encode from and decode to Word8",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit1",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit2",
      "description": {
        "fct-descr": "\u003cp\u003eA container of 2 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Bits.html#Bit2",
        "fct-type": "data",
        "title": "Bit2"
      },
      "index": {
        "description": "container of Bit that encode from and decode to Word8",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit2",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit3",
      "description": {
        "fct-descr": "\u003cp\u003eA container of 3 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Bits.html#Bit3",
        "fct-type": "data",
        "title": "Bit3"
      },
      "index": {
        "description": "container of Bit that encode from and decode to Word8",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit3",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit4",
      "description": {
        "fct-descr": "\u003cp\u003eA container of 4 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Bits.html#Bit4",
        "fct-type": "data",
        "title": "Bit4"
      },
      "index": {
        "description": "container of Bit that encode from and decode to Word8",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit4",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit5",
      "description": {
        "fct-descr": "\u003cp\u003eA container of 5 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Bits.html#Bit5",
        "fct-type": "data",
        "title": "Bit5"
      },
      "index": {
        "description": "container of Bit that encode from and decode to Word8",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit5",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit6",
      "description": {
        "fct-descr": "\u003cp\u003eA container of 6 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Bits.html#Bit6",
        "fct-type": "data",
        "title": "Bit6"
      },
      "index": {
        "description": "container of Bit that encode from and decode to Word8",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit6",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit7",
      "description": {
        "fct-descr": "\u003cp\u003eA container of 7 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Bits.html#Bit7",
        "fct-type": "data",
        "title": "Bit7"
      },
      "index": {
        "description": "container of Bit that encode from and decode to Word8",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit7",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#t:Bit8",
      "description": {
        "fct-descr": "\u003cp\u003eA container of 8 \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es that \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003es from and \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Bits.html#Bit8",
        "fct-type": "data",
        "title": "Bit8"
      },
      "index": {
        "description": "container of Bit that encode from and decode to Word8",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit8",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit1",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "Bit1 Bit",
        "fct-source": "src/Ersatz-Bits.html#Bit1",
        "fct-type": "function",
        "title": "Bit1"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit1",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit2",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "Bit2 Bit Bit",
        "fct-source": "src/Ersatz-Bits.html#Bit2",
        "fct-type": "function",
        "title": "Bit2"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit2",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit3",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "Bit3 Bit Bit Bit",
        "fct-source": "src/Ersatz-Bits.html#Bit3",
        "fct-type": "function",
        "title": "Bit3"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit3",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit4",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "Bit4 Bit Bit Bit Bit",
        "fct-source": "src/Ersatz-Bits.html#Bit4",
        "fct-type": "function",
        "title": "Bit4"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit4",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit5",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "Bit5 Bit Bit Bit Bit Bit",
        "fct-source": "src/Ersatz-Bits.html#Bit5",
        "fct-type": "function",
        "title": "Bit5"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit5",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit6",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "Bit6 Bit Bit Bit Bit Bit Bit",
        "fct-source": "src/Ersatz-Bits.html#Bit6",
        "fct-type": "function",
        "title": "Bit6"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit6",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit7",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "Bit7 Bit Bit Bit Bit Bit Bit Bit",
        "fct-source": "src/Ersatz-Bits.html#Bit7",
        "fct-type": "function",
        "title": "Bit7"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit7",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Bits.html#v:Bit8",
      "description": {
        "fct-module": "Ersatz.Bits",
        "fct-package": "ersatz",
        "fct-signature": "Bit8 Bit Bit Bit Bit Bit Bit Bit Bit",
        "fct-source": "src/Ersatz-Bits.html#Bit8",
        "fct-type": "function",
        "title": "Bit8"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Bits",
        "module": "Ersatz.Bits",
        "name": "Bit8",
        "normalized": "",
        "package": "ersatz",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Decoding.html#",
      "description": {
        "fct-module": "Ersatz.Decoding",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Decoding.html",
        "fct-type": "module",
        "title": "Decoding"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Decoding",
        "module": "Ersatz.Decoding",
        "name": "Decoding",
        "normalized": "",
        "package": "ersatz",
        "partial": "Decoding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Decoding.html#t:Decoding",
      "description": {
        "fct-module": "Ersatz.Decoding",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Decoding.html#Decoding",
        "fct-type": "class",
        "title": "Decoding"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Decoding",
        "module": "Ersatz.Decoding",
        "name": "Decoding",
        "normalized": "",
        "package": "ersatz",
        "partial": "Decoding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Decoding.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eReturn a value based on the solution if one can be determined.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Decoding",
        "fct-package": "ersatz",
        "fct-signature": "Solution -\u003e a -\u003e Maybe (Decoded a)",
        "fct-source": "src/Ersatz-Decoding.html#decode",
        "fct-type": "method",
        "title": "decode"
      },
      "index": {
        "description": "Return value based on the solution if one can be determined",
        "hierarchy": "Ersatz Decoding",
        "module": "Ersatz.Decoding",
        "name": "decode",
        "normalized": "Solution-\u003ea-\u003eMaybe(Decoded a)",
        "package": "ersatz",
        "partial": "",
        "signature": "Solution-\u003ea-\u003eMaybe(Decoded a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Encoding.html#",
      "description": {
        "fct-module": "Ersatz.Encoding",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Encoding.html",
        "fct-type": "module",
        "title": "Encoding"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Encoding",
        "module": "Ersatz.Encoding",
        "name": "Encoding",
        "normalized": "",
        "package": "ersatz",
        "partial": "Encoding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Encoding.html#t:Encoding",
      "description": {
        "fct-module": "Ersatz.Encoding",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Encoding.html#Encoding",
        "fct-type": "class",
        "title": "Encoding"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Encoding",
        "module": "Ersatz.Encoding",
        "name": "Encoding",
        "normalized": "",
        "package": "ersatz",
        "partial": "Encoding",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Encoding.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eA counterpart to \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003e. Can encode e.g. a \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e as a\n \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e, a \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e as a \u003ccode\u003e\u003ca\u003eBit8\u003c/a\u003e\u003c/code\u003e, or a\n \u003ccode\u003e[Word8]\u003c/code\u003e as a \u003ccode\u003e[Bit8]\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Encoding",
        "fct-package": "ersatz",
        "fct-signature": "Encoded a -\u003e a",
        "fct-source": "src/Ersatz-Encoding.html#encode",
        "fct-type": "method",
        "title": "encode"
      },
      "index": {
        "description": "counterpart to decode Can encode e.g Bool as Bit Word8 as Bit8 or Word8 as Bit8",
        "hierarchy": "Ersatz Encoding",
        "module": "Ersatz.Encoding",
        "name": "encode",
        "normalized": "Encoded a-\u003ea",
        "package": "ersatz",
        "partial": "",
        "signature": "Encoded a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Equatable.html#",
      "description": {
        "fct-module": "Ersatz.Equatable",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Equatable.html",
        "fct-type": "module",
        "title": "Equatable"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Equatable",
        "module": "Ersatz.Equatable",
        "name": "Equatable",
        "normalized": "",
        "package": "ersatz",
        "partial": "Equatable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Equatable.html#t:Equatable",
      "description": {
        "fct-descr": "\u003cp\u003eInstances for this class for arbitrary types can be automatically derived from \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Equatable",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Equatable.html#Equatable",
        "fct-type": "class",
        "title": "Equatable"
      },
      "index": {
        "description": "Instances for this class for arbitrary types can be automatically derived from Generic",
        "hierarchy": "Ersatz Equatable",
        "module": "Ersatz.Equatable",
        "name": "Equatable",
        "normalized": "",
        "package": "ersatz",
        "partial": "Equatable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Equatable.html#v:-47--61--61-",
      "description": {
        "fct-descr": "\u003cp\u003eCompare for inequality within the SAT problem.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Equatable",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e t -\u003e Bit",
        "fct-source": "src/Ersatz-Equatable.html#%2F%3D%3D",
        "fct-type": "method",
        "title": "(/==)"
      },
      "index": {
        "description": "Compare for inequality within the SAT problem",
        "hierarchy": "Ersatz Equatable",
        "module": "Ersatz.Equatable",
        "name": "(/==) /==",
        "normalized": "a-\u003ea-\u003eBit",
        "package": "ersatz",
        "partial": "",
        "signature": "t-\u003et-\u003eBit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Equatable.html#v:-61--61--61-",
      "description": {
        "fct-descr": "\u003cp\u003eCompare for equality within the SAT problem.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Equatable",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e t -\u003e Bit",
        "fct-source": "src/Ersatz-Equatable.html#%3D%3D%3D",
        "fct-type": "method",
        "title": "(===)"
      },
      "index": {
        "description": "Compare for equality within the SAT problem",
        "hierarchy": "Ersatz Equatable",
        "module": "Ersatz.Equatable",
        "name": "(===) ===",
        "normalized": "a-\u003ea-\u003eBit",
        "package": "ersatz",
        "partial": "",
        "signature": "t-\u003et-\u003eBit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Circuit.html#",
      "description": {
        "fct-module": "Ersatz.Internal.Circuit",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Internal-Circuit.html",
        "fct-type": "module",
        "title": "Circuit"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Circuit",
        "module": "Ersatz.Internal.Circuit",
        "name": "Circuit",
        "normalized": "",
        "package": "ersatz",
        "partial": "Circuit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Circuit.html#t:Circuit",
      "description": {
        "fct-descr": "\u003cp\u003eThis is used to observe the directed graph with sharing of how multiple\n \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003e values are related.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Circuit",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Internal-Circuit.html#Circuit",
        "fct-type": "data",
        "title": "Circuit"
      },
      "index": {
        "description": "This is used to observe the directed graph with sharing of how multiple Bit values are related",
        "hierarchy": "Ersatz Internal Circuit",
        "module": "Ersatz.Internal.Circuit",
        "name": "Circuit",
        "normalized": "",
        "package": "ersatz",
        "partial": "Circuit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Circuit.html#v:And",
      "description": {
        "fct-module": "Ersatz.Internal.Circuit",
        "fct-package": "ersatz",
        "fct-signature": "And (Seq c)",
        "fct-source": "src/Ersatz-Internal-Circuit.html#Circuit",
        "fct-type": "function",
        "title": "And"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Circuit",
        "module": "Ersatz.Internal.Circuit",
        "name": "And",
        "normalized": "",
        "package": "ersatz",
        "partial": "And",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Circuit.html#v:Mux",
      "description": {
        "fct-descr": "\u003cp\u003eFalse branch, true branch, predicate/selector branch\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Circuit",
        "fct-package": "ersatz",
        "fct-signature": "Mux c c c",
        "fct-source": "src/Ersatz-Internal-Circuit.html#Circuit",
        "fct-type": "function",
        "title": "Mux"
      },
      "index": {
        "description": "False branch true branch predicate selector branch",
        "hierarchy": "Ersatz Internal Circuit",
        "module": "Ersatz.Internal.Circuit",
        "name": "Mux",
        "normalized": "",
        "package": "ersatz",
        "partial": "Mux",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Circuit.html#v:Not",
      "description": {
        "fct-module": "Ersatz.Internal.Circuit",
        "fct-package": "ersatz",
        "fct-signature": "Not c",
        "fct-source": "src/Ersatz-Internal-Circuit.html#Circuit",
        "fct-type": "function",
        "title": "Not"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Circuit",
        "module": "Ersatz.Internal.Circuit",
        "name": "Not",
        "normalized": "",
        "package": "ersatz",
        "partial": "Not",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Circuit.html#v:Or",
      "description": {
        "fct-module": "Ersatz.Internal.Circuit",
        "fct-package": "ersatz",
        "fct-signature": "Or (Seq c)",
        "fct-source": "src/Ersatz-Internal-Circuit.html#Circuit",
        "fct-type": "function",
        "title": "Or"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Circuit",
        "module": "Ersatz.Internal.Circuit",
        "name": "Or",
        "normalized": "",
        "package": "ersatz",
        "partial": "Or",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Circuit.html#v:Var",
      "description": {
        "fct-module": "Ersatz.Internal.Circuit",
        "fct-package": "ersatz",
        "fct-signature": "Var !Literal",
        "fct-source": "src/Ersatz-Internal-Circuit.html#Circuit",
        "fct-type": "function",
        "title": "Var"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Circuit",
        "module": "Ersatz.Internal.Circuit",
        "name": "Var",
        "normalized": "",
        "package": "ersatz",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Circuit.html#v:Xor",
      "description": {
        "fct-module": "Ersatz.Internal.Circuit",
        "fct-package": "ersatz",
        "fct-signature": "Xor c c",
        "fct-source": "src/Ersatz-Internal-Circuit.html#Circuit",
        "fct-type": "function",
        "title": "Xor"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Circuit",
        "module": "Ersatz.Internal.Circuit",
        "name": "Xor",
        "normalized": "",
        "package": "ersatz",
        "partial": "Xor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#",
      "description": {
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Internal-Formula.html",
        "fct-type": "module",
        "title": "Formula"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "Formula",
        "normalized": "",
        "package": "ersatz",
        "partial": "Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#t:Clause",
      "description": {
        "fct-descr": "\u003cp\u003eA disjunction of possibly negated atoms. Negated atoms are represented\n by negating the identifier.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "newtype",
        "fct-source": "src/Ersatz-Internal-Formula.html#Clause",
        "fct-type": "newtype",
        "title": "Clause"
      },
      "index": {
        "description": "disjunction of possibly negated atoms Negated atoms are represented by negating the identifier",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "Clause",
        "normalized": "",
        "package": "ersatz",
        "partial": "Clause",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#t:Formula",
      "description": {
        "fct-descr": "\u003cp\u003eA conjunction of clauses\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "newtype",
        "fct-source": "src/Ersatz-Internal-Formula.html#Formula",
        "fct-type": "newtype",
        "title": "Formula"
      },
      "index": {
        "description": "conjunction of clauses",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "Formula",
        "normalized": "",
        "package": "ersatz",
        "partial": "Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:Clause",
      "description": {
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Clause",
        "fct-source": "src/Ersatz-Internal-Formula.html#Clause",
        "fct-type": "function",
        "title": "Clause"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "Clause",
        "normalized": "",
        "package": "ersatz",
        "partial": "Clause",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:Formula",
      "description": {
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Formula",
        "fct-source": "src/Ersatz-Internal-Formula.html#Formula",
        "fct-type": "function",
        "title": "Formula"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "Formula",
        "normalized": "",
        "package": "ersatz",
        "partial": "Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:clauseLiterals",
      "description": {
        "fct-descr": "\u003cp\u003eExtract the (possibly negated) atoms referenced by a \u003ccode\u003e\u003ca\u003eClause\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Clause -\u003e [Literal]",
        "fct-source": "src/Ersatz-Internal-Formula.html#clauseLiterals",
        "fct-type": "function",
        "title": "clauseLiterals"
      },
      "index": {
        "description": "Extract the possibly negated atoms referenced by Clause",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "clauseLiterals",
        "normalized": "Clause-\u003e[Literal]",
        "package": "ersatz",
        "partial": "Literals",
        "signature": "Clause-\u003e[Literal]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:clauseSet",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "IntSet",
        "fct-source": "src/Ersatz-Internal-Formula.html#Clause",
        "fct-type": "function",
        "title": "clauseSet"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "clauseSet",
        "normalized": "",
        "package": "ersatz",
        "partial": "Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaAnd",
      "description": {
        "fct-descr": "\u003cp\u003eThe boolean \u003cem\u003eand\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; (A & B & C)\n (O &#8594; (A & B & C)) & (&#172;O &#8594; &#172;(A & B & C))\n (&#172;O | (A & B & C)) & (O | &#172;(A & B & C))\n (&#172;O | A) & (&#172;O | B) & (&#172;O | C) & (O | &#172;A | &#172;B | &#172;C)\n\u003c/pre\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Literal-\u003e [Literal]-\u003e Formula",
        "fct-type": "function",
        "title": "formulaAnd"
      },
      "index": {
        "description": "The boolean and operation Derivation of the Tseitin transformation",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "formulaAnd",
        "normalized": "Literal-\u003e[Literal]-\u003eFormula",
        "package": "ersatz",
        "partial": "And",
        "signature": "Literal-\u003e[Literal]-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaEmpty",
      "description": {
        "fct-descr": "\u003cp\u003eA formula with no clauses\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Formula",
        "fct-source": "src/Ersatz-Internal-Formula.html#formulaEmpty",
        "fct-type": "function",
        "title": "formulaEmpty"
      },
      "index": {
        "description": "formula with no clauses",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "formulaEmpty",
        "normalized": "",
        "package": "ersatz",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaLiteral",
      "description": {
        "fct-descr": "\u003cp\u003eAssert a literal\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Literal -\u003e Formula",
        "fct-source": "src/Ersatz-Internal-Formula.html#formulaLiteral",
        "fct-type": "function",
        "title": "formulaLiteral"
      },
      "index": {
        "description": "Assert literal",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "formulaLiteral",
        "normalized": "Literal-\u003eFormula",
        "package": "ersatz",
        "partial": "Literal",
        "signature": "Literal-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaMux",
      "description": {
        "fct-descr": "\u003cp\u003eThe boolean \u003cem\u003eelse-then-if\u003c/em\u003e or \u003cem\u003emux\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; (F & &#172;P) | (T & P)\n (O &#8594; ((F & &#172;P) | (T & P))) & (&#172;O &#8594; &#172;((F & &#172;P) | (T & P)))\n\u003c/pre\u003e\u003cp\u003eLeft hand side:\n\u003c/p\u003e\u003cpre\u003e\n O &#8594; ((F & &#172;P) | (T & P))\n &#172;O | ((F & &#172;P) | (T & P))\n &#172;O | ((F | T) & (F | P) & (T | &#172;P) & (&#172;P | P))\n &#172;O | ((F | T) & (F | P) & (T | &#172;P))\n (&#172;O | F | T) & (&#172;O | F | P) & (&#172;O | T | &#172;P)\n\u003c/pre\u003e\u003cp\u003eRight hand side:\n\u003c/p\u003e\u003cpre\u003e\n &#172;O &#8594; &#172;((F & &#172;P) | (T & P))\n O | &#172;((F & &#172;P) | (T & P))\n O | (&#172;(F & &#172;P) & &#172;(T & P))\n O | ((&#172;F | P) & (&#172;T | &#172;P))\n (O | &#172;F | P) & (O | &#172;T | &#172;P)\n\u003c/pre\u003e\u003cp\u003eResult:\n\u003c/p\u003e\u003cpre\u003e\n (&#172;O | F | T) & (&#172;O | F | P) & (&#172;O | T | &#172;P) & (O | &#172;F | P) & (O | &#172;T | &#172;P)\n\u003c/pre\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Literal-\u003e Literal-\u003e Literal-\u003e Literal-\u003e Formula",
        "fct-type": "function",
        "title": "formulaMux"
      },
      "index": {
        "description": "The boolean else-then-if or mux operation Derivation of the Tseitin transformation Left hand side Right hand side Result",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "formulaMux",
        "normalized": "Literal-\u003eLiteral-\u003eLiteral-\u003eLiteral-\u003eFormula",
        "package": "ersatz",
        "partial": "Mux",
        "signature": "Literal-\u003eLiteral-\u003eLiteral-\u003eLiteral-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaNot",
      "description": {
        "fct-descr": "\u003cp\u003eThe boolean \u003cem\u003enot\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; &#172;A\n (O &#8594; &#172;A) & (&#172;O &#8594; A)\n (&#172;O | &#172;A) & (O | A)\n\u003c/pre\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Literal-\u003e Literal-\u003e Formula",
        "fct-type": "function",
        "title": "formulaNot"
      },
      "index": {
        "description": "The boolean not operation Derivation of the Tseitin transformation",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "formulaNot",
        "normalized": "Literal-\u003eLiteral-\u003eFormula",
        "package": "ersatz",
        "partial": "Not",
        "signature": "Literal-\u003eLiteral-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaOr",
      "description": {
        "fct-descr": "\u003cp\u003eThe boolean \u003cem\u003eor\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; (A | B | C)\n (O &#8594; (A | B | C)) & (&#172;O &#8594; &#172;(A | B | C))\n (&#172;O | (A | B | C)) & (O | &#172;(A | B | C))\n (&#172;O | A | B | C) & (O | (&#172;A & &#172;B & &#172;C))\n (&#172;O | A | B | C) & (O | &#172;A) & (O | &#172;B) & (O | &#172;C)\n\u003c/pre\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Literal-\u003e [Literal]-\u003e Formula",
        "fct-type": "function",
        "title": "formulaOr"
      },
      "index": {
        "description": "The boolean or operation Derivation of the Tseitin transformation",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "formulaOr",
        "normalized": "Literal-\u003e[Literal]-\u003eFormula",
        "package": "ersatz",
        "partial": "Or",
        "signature": "Literal-\u003e[Literal]-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaSet",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Set Clause",
        "fct-source": "src/Ersatz-Internal-Formula.html#Formula",
        "fct-type": "function",
        "title": "formulaSet"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "formulaSet",
        "normalized": "",
        "package": "ersatz",
        "partial": "Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Formula.html#v:formulaXor",
      "description": {
        "fct-descr": "\u003cp\u003eThe boolean \u003cem\u003exor\u003c/em\u003e operation\n\u003c/p\u003e\u003cp\u003eDerivation of the Tseitin transformation:\n\u003c/p\u003e\u003cpre\u003e\n O &#8801; A &#8853; B\n O &#8801; ((&#172;A & B) | (A & &#172;B))\n (O &#8594; ((&#172;A & B) | (A & &#172;B))) & (&#172;O &#8594; &#172;((&#172;A & B) | (A & &#172;B)))\n\u003c/pre\u003e\u003cp\u003eLeft hand side:\n\u003c/p\u003e\u003cpre\u003e\n O &#8594; ((&#172;A & B) | (A & &#172;B))\n &#172;O | ((&#172;A & B) | (A & &#172;B))\n &#172;O | ((&#172;A | A) & (&#172;A | &#172;B) & (A | B) & (&#172;B | B))\n &#172;O | ((&#172;A | &#172;B) & (A | B))\n (&#172;O | &#172;A | &#172;B) & (&#172;O | A | B)\n\u003c/pre\u003e\u003cp\u003eRight hand side:\n\u003c/p\u003e\u003cpre\u003e\n &#172;O &#8594; &#172;((&#172;A & B) | (A & &#172;B))\n O | &#172;((&#172;A & B) | (A & &#172;B))\n O | (&#172;(&#172;A & B) & &#172;(A & &#172;B))\n O | ((A | &#172;B) & (&#172;A | B))\n (O | &#172;A | B) & (O | A | &#172;B)\n\u003c/pre\u003e\u003cp\u003eResult:\n\u003c/p\u003e\u003cpre\u003e\n (&#172;O | &#172;A | &#172;B) & (&#172;O | A | B) & (O | &#172;A | B) & (O | A | &#172;B)\n\u003c/pre\u003e",
        "fct-module": "Ersatz.Internal.Formula",
        "fct-package": "ersatz",
        "fct-signature": "Literal-\u003e Literal-\u003e Literal-\u003e Formula",
        "fct-type": "function",
        "title": "formulaXor"
      },
      "index": {
        "description": "The boolean xor operation Derivation of the Tseitin transformation Left hand side Right hand side Result",
        "hierarchy": "Ersatz Internal Formula",
        "module": "Ersatz.Internal.Formula",
        "name": "formulaXor",
        "normalized": "Literal-\u003eLiteral-\u003eLiteral-\u003eFormula",
        "package": "ersatz",
        "partial": "Xor",
        "signature": "Literal-\u003eLiteral-\u003eLiteral-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#",
      "description": {
        "fct-module": "Ersatz.Internal.Literal",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Internal-Literal.html",
        "fct-type": "module",
        "title": "Literal"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Literal",
        "module": "Ersatz.Internal.Literal",
        "name": "Literal",
        "normalized": "",
        "package": "ersatz",
        "partial": "Literal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#t:Literal",
      "description": {
        "fct-descr": "\u003cp\u003eA naked possibly-negated Atom, present in the target \u003ccode\u003e\u003ca\u003eSolver\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe literals \u003ccode\u003e-1\u003c/code\u003e and \u003ccode\u003e1\u003c/code\u003e are dedicated for the constant \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e and the\n constant \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e respectively.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Literal",
        "fct-package": "ersatz",
        "fct-signature": "newtype",
        "fct-source": "src/Ersatz-Internal-Literal.html#Literal",
        "fct-type": "newtype",
        "title": "Literal"
      },
      "index": {
        "description": "naked possibly-negated Atom present in the target Solver The literals and are dedicated for the constant False and the constant True respectively",
        "hierarchy": "Ersatz Internal Literal",
        "module": "Ersatz.Internal.Literal",
        "name": "Literal",
        "normalized": "",
        "package": "ersatz",
        "partial": "Literal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:Literal",
      "description": {
        "fct-module": "Ersatz.Internal.Literal",
        "fct-package": "ersatz",
        "fct-signature": "Literal",
        "fct-source": "src/Ersatz-Internal-Literal.html#Literal",
        "fct-type": "function",
        "title": "Literal"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Literal",
        "module": "Ersatz.Internal.Literal",
        "name": "Literal",
        "normalized": "",
        "package": "ersatz",
        "partial": "Literal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:literalFalse",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e constant. The literal \u003ccode\u003e-1\u003c/code\u003e is dedicated for it.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Literal",
        "fct-package": "ersatz",
        "fct-signature": "Literal",
        "fct-source": "src/Ersatz-Internal-Literal.html#literalFalse",
        "fct-type": "function",
        "title": "literalFalse"
      },
      "index": {
        "description": "The False constant The literal is dedicated for it",
        "hierarchy": "Ersatz Internal Literal",
        "module": "Ersatz.Internal.Literal",
        "name": "literalFalse",
        "normalized": "",
        "package": "ersatz",
        "partial": "False",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:literalId",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Ersatz.Internal.Literal",
        "fct-package": "ersatz",
        "fct-signature": "Int",
        "fct-source": "src/Ersatz-Internal-Literal.html#Literal",
        "fct-type": "function",
        "title": "literalId"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Literal",
        "module": "Ersatz.Internal.Literal",
        "name": "literalId",
        "normalized": "",
        "package": "ersatz",
        "partial": "Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:literalTrue",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e constant. The literal \u003ccode\u003e1\u003c/code\u003e is dedicated for it.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Internal.Literal",
        "fct-package": "ersatz",
        "fct-signature": "Literal",
        "fct-source": "src/Ersatz-Internal-Literal.html#literalTrue",
        "fct-type": "function",
        "title": "literalTrue"
      },
      "index": {
        "description": "The True constant The literal is dedicated for it",
        "hierarchy": "Ersatz Internal Literal",
        "module": "Ersatz.Internal.Literal",
        "name": "literalTrue",
        "normalized": "",
        "package": "ersatz",
        "partial": "True",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Internal-Literal.html#v:negateLiteral",
      "description": {
        "fct-module": "Ersatz.Internal.Literal",
        "fct-package": "ersatz",
        "fct-signature": "Literal -\u003e Literal",
        "fct-source": "src/Ersatz-Internal-Literal.html#negateLiteral",
        "fct-type": "function",
        "title": "negateLiteral"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Internal Literal",
        "module": "Ersatz.Internal.Literal",
        "name": "negateLiteral",
        "normalized": "Literal-\u003eLiteral",
        "package": "ersatz",
        "partial": "Literal",
        "signature": "Literal-\u003eLiteral"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Problem.html",
        "fct-type": "module",
        "title": "Problem"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "Problem",
        "normalized": "",
        "package": "ersatz",
        "partial": "Problem",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:DIMACS",
      "description": {
        "fct-descr": "\u003cp\u003eDIMACS file format pretty printer\n\u003c/p\u003e\u003cp\u003eThis is used to generate the problem statement for a given \u003ccode\u003e\u003ca\u003eSAT\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSolver\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Problem.html#DIMACS",
        "fct-type": "class",
        "title": "DIMACS"
      },
      "index": {
        "description": "DIMACS file format pretty printer This is used to generate the problem statement for given SAT Solver",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "DIMACS",
        "normalized": "",
        "package": "ersatz",
        "partial": "DIMACS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:HasQSAT",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Problem.html#HasQSAT",
        "fct-type": "class",
        "title": "HasQSAT"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "HasQSAT",
        "normalized": "",
        "package": "ersatz",
        "partial": "Has QSAT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:HasSAT",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Problem.html#HasSAT",
        "fct-type": "class",
        "title": "HasSAT"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "HasSAT",
        "normalized": "",
        "package": "ersatz",
        "partial": "Has SAT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:QDIMACS",
      "description": {
        "fct-descr": "\u003cp\u003eQDIMACS file format pretty printer\n\u003c/p\u003e\u003cp\u003eThis is used to generate the problem statement for a given \u003ccode\u003e\u003ca\u003eQSAT\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSolver\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Problem.html#QDIMACS",
        "fct-type": "class",
        "title": "QDIMACS"
      },
      "index": {
        "description": "QDIMACS file format pretty printer This is used to generate the problem statement for given QSAT Solver",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "QDIMACS",
        "normalized": "",
        "package": "ersatz",
        "partial": "QDIMACS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:QSAT",
      "description": {
        "fct-descr": "\u003cp\u003eA (quantified) boolean formula.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Problem.html#QSAT",
        "fct-type": "data",
        "title": "QSAT"
      },
      "index": {
        "description": "quantified boolean formula",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "QSAT",
        "normalized": "",
        "package": "ersatz",
        "partial": "QSAT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:SAT",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Problem.html#SAT",
        "fct-type": "data",
        "title": "SAT"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "SAT",
        "normalized": "",
        "package": "ersatz",
        "partial": "SAT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#t:WDIMACS",
      "description": {
        "fct-descr": "\u003cp\u003eWDIMACS file format pretty printer\n\u003c/p\u003e\u003cp\u003eThis is used to generate the problem statement for a given \u003ccode\u003eMaxSAT\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSolver\u003c/a\u003e\u003c/code\u003e (TODO).\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Problem.html#WDIMACS",
        "fct-type": "class",
        "title": "WDIMACS"
      },
      "index": {
        "description": "WDIMACS file format pretty printer This is used to generate the problem statement for given MaxSAT Solver TODO",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "WDIMACS",
        "normalized": "",
        "package": "ersatz",
        "partial": "WDIMACS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:QSAT",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "QSAT !IntSet SAT",
        "fct-source": "src/Ersatz-Problem.html#QSAT",
        "fct-type": "function",
        "title": "QSAT"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "QSAT",
        "normalized": "",
        "package": "ersatz",
        "partial": "QSAT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:SAT",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "SAT !Int !Formula !(HashMap (StableName ()) Literal)",
        "fct-source": "src/Ersatz-Problem.html#SAT",
        "fct-type": "function",
        "title": "SAT"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "SAT",
        "normalized": "SAT Int Formula(HashMap(StableName())Literal)",
        "package": "ersatz",
        "partial": "SAT",
        "signature": "SAT Int Formula(HashMap(StableName())Literal)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:assertFormula",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "Formula -\u003e m ()",
        "fct-source": "src/Ersatz-Problem.html#assertFormula",
        "fct-type": "function",
        "title": "assertFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "assertFormula",
        "normalized": "Formula-\u003ea()",
        "package": "ersatz",
        "partial": "Formula",
        "signature": "Formula-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacs",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e out of a \u003ccode\u003e\u003ca\u003eDIMACS\u003c/a\u003e\u003c/code\u003e problem.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Builder",
        "fct-source": "src/Ersatz-Problem.html#dimacs",
        "fct-type": "function",
        "title": "dimacs"
      },
      "index": {
        "description": "Generate Builder out of DIMACS problem",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "dimacs",
        "normalized": "a-\u003eBuilder",
        "package": "ersatz",
        "partial": "",
        "signature": "t-\u003eBuilder"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacsClauses",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Set IntSet",
        "fct-source": "src/Ersatz-Problem.html#dimacsClauses",
        "fct-type": "method",
        "title": "dimacsClauses"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "dimacsClauses",
        "normalized": "a-\u003eSet IntSet",
        "package": "ersatz",
        "partial": "Clauses",
        "signature": "t-\u003eSet IntSet"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacsComments",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e [ByteString]",
        "fct-source": "src/Ersatz-Problem.html#dimacsComments",
        "fct-type": "method",
        "title": "dimacsComments"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "dimacsComments",
        "normalized": "a-\u003e[ByteString]",
        "package": "ersatz",
        "partial": "Comments",
        "signature": "t-\u003e[ByteString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacsNumVariables",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Int",
        "fct-source": "src/Ersatz-Problem.html#dimacsNumVariables",
        "fct-type": "method",
        "title": "dimacsNumVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "dimacsNumVariables",
        "normalized": "a-\u003eInt",
        "package": "ersatz",
        "partial": "Num Variables",
        "signature": "t-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:dimacsSAT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eSAT\u003c/a\u003e\u003c/code\u003e-generating state computation and return the respective\n \u003ccode\u003e\u003ca\u003eDIMACS\u003c/a\u003e\u003c/code\u003e output. Useful for testing and debugging.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "StateT SAT Identity a -\u003e ByteString",
        "fct-source": "src/Ersatz-Problem.html#dimacsSAT",
        "fct-type": "function",
        "title": "dimacsSAT"
      },
      "index": {
        "description": "Run SAT generating state computation and return the respective DIMACS output Useful for testing and debugging",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "dimacsSAT",
        "normalized": "StateT SAT Identity a-\u003eByteString",
        "package": "ersatz",
        "partial": "SAT",
        "signature": "StateT SAT Identity a-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:formula",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "Lens' t Formula",
        "fct-source": "src/Ersatz-Problem.html#formula",
        "fct-type": "method",
        "title": "formula"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "formula",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:generateLiteral",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "a -\u003e (Literal -\u003e m ()) -\u003e m Literal",
        "fct-source": "src/Ersatz-Problem.html#generateLiteral",
        "fct-type": "function",
        "title": "generateLiteral"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "generateLiteral",
        "normalized": "a-\u003e(Literal-\u003eb())-\u003eb Literal",
        "package": "ersatz",
        "partial": "Literal",
        "signature": "a-\u003e(Literal-\u003em())-\u003em Literal"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:lastAtom",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "Lens' t Int",
        "fct-source": "src/Ersatz-Problem.html#lastAtom",
        "fct-type": "method",
        "title": "lastAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "lastAtom",
        "normalized": "",
        "package": "ersatz",
        "partial": "Atom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:literalExists",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "m Literal",
        "fct-source": "src/Ersatz-Problem.html#literalExists",
        "fct-type": "function",
        "title": "literalExists"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "literalExists",
        "normalized": "",
        "package": "ersatz",
        "partial": "Exists",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:literalForall",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "m Literal",
        "fct-source": "src/Ersatz-Problem.html#literalForall",
        "fct-type": "function",
        "title": "literalForall"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "literalForall",
        "normalized": "",
        "package": "ersatz",
        "partial": "Forall",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacs",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e out of a \u003ccode\u003e\u003ca\u003eQDIMACS\u003c/a\u003e\u003c/code\u003e problem.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Builder",
        "fct-source": "src/Ersatz-Problem.html#qdimacs",
        "fct-type": "function",
        "title": "qdimacs"
      },
      "index": {
        "description": "Generate Builder out of QDIMACS problem",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "qdimacs",
        "normalized": "a-\u003eBuilder",
        "package": "ersatz",
        "partial": "",
        "signature": "t-\u003eBuilder"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsClauses",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Set IntSet",
        "fct-source": "src/Ersatz-Problem.html#qdimacsClauses",
        "fct-type": "method",
        "title": "qdimacsClauses"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "qdimacsClauses",
        "normalized": "a-\u003eSet IntSet",
        "package": "ersatz",
        "partial": "Clauses",
        "signature": "t-\u003eSet IntSet"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsComments",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e [ByteString]",
        "fct-source": "src/Ersatz-Problem.html#qdimacsComments",
        "fct-type": "method",
        "title": "qdimacsComments"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "qdimacsComments",
        "normalized": "a-\u003e[ByteString]",
        "package": "ersatz",
        "partial": "Comments",
        "signature": "t-\u003e[ByteString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsNumVariables",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Int",
        "fct-source": "src/Ersatz-Problem.html#qdimacsNumVariables",
        "fct-type": "method",
        "title": "qdimacsNumVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "qdimacsNumVariables",
        "normalized": "a-\u003eInt",
        "package": "ersatz",
        "partial": "Num Variables",
        "signature": "t-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsQSAT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eQSAT\u003c/a\u003e\u003c/code\u003e-generating state computation and return the respective\n \u003ccode\u003e\u003ca\u003eQDIMACS\u003c/a\u003e\u003c/code\u003e output. Useful for testing and debugging.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "StateT QSAT Identity a -\u003e ByteString",
        "fct-source": "src/Ersatz-Problem.html#qdimacsQSAT",
        "fct-type": "function",
        "title": "qdimacsQSAT"
      },
      "index": {
        "description": "Run QSAT generating state computation and return the respective QDIMACS output Useful for testing and debugging",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "qdimacsQSAT",
        "normalized": "StateT QSAT Identity a-\u003eByteString",
        "package": "ersatz",
        "partial": "QSAT",
        "signature": "StateT QSAT Identity a-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qdimacsQuantified",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e [Quant]",
        "fct-source": "src/Ersatz-Problem.html#qdimacsQuantified",
        "fct-type": "method",
        "title": "qdimacsQuantified"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "qdimacsQuantified",
        "normalized": "a-\u003e[Quant]",
        "package": "ersatz",
        "partial": "Quantified",
        "signature": "t-\u003e[Quant]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:qsat",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "Lens' t QSAT",
        "fct-source": "src/Ersatz-Problem.html#qsat",
        "fct-type": "method",
        "title": "qsat"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "qsat",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:runQSAT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eQSAT\u003c/a\u003e\u003c/code\u003e-generating state computation. Useful e.g. in ghci for\n disambiguating the type of a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eHasQSAT\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "StateT QSAT m a -\u003e m (a, QSAT)",
        "fct-source": "src/Ersatz-Problem.html#runQSAT",
        "fct-type": "function",
        "title": "runQSAT"
      },
      "index": {
        "description": "Run QSAT generating state computation Useful e.g in ghci for disambiguating the type of MonadState HasQSAT value",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "runQSAT",
        "normalized": "StateT QSAT a b-\u003ea(b,QSAT)",
        "package": "ersatz",
        "partial": "QSAT",
        "signature": "StateT QSAT m a-\u003em(a,QSAT)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:runQSAT-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eQSAT\u003c/a\u003e\u003c/code\u003e-generating state computation in the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e monad. Useful\n e.g. in ghci for disambiguating the type of a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eHasQSAT\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "StateT QSAT Identity a -\u003e (a, QSAT)",
        "fct-source": "src/Ersatz-Problem.html#runQSAT%27",
        "fct-type": "function",
        "title": "runQSAT'"
      },
      "index": {
        "description": "Run QSAT generating state computation in the Identity monad Useful e.g in ghci for disambiguating the type of MonadState HasQSAT value",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "runQSAT'",
        "normalized": "StateT QSAT Identity a-\u003e(a,QSAT)",
        "package": "ersatz",
        "partial": "QSAT'",
        "signature": "StateT QSAT Identity a-\u003e(a,QSAT)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:runSAT",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eSAT\u003c/a\u003e\u003c/code\u003e-generating state computation. Useful e.g. in ghci for\n disambiguating the type of a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eHasSAT\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "StateT SAT m a -\u003e m (a, SAT)",
        "fct-source": "src/Ersatz-Problem.html#runSAT",
        "fct-type": "function",
        "title": "runSAT"
      },
      "index": {
        "description": "Run SAT generating state computation Useful e.g in ghci for disambiguating the type of MonadState HasSAT value",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "runSAT",
        "normalized": "StateT SAT a b-\u003ea(b,SAT)",
        "package": "ersatz",
        "partial": "SAT",
        "signature": "StateT SAT m a-\u003em(a,SAT)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:runSAT-39-",
      "description": {
        "fct-descr": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eSAT\u003c/a\u003e\u003c/code\u003e-generating state computation in the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e monad. Useful\n e.g. in ghci for disambiguating the type of a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eHasSAT\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "StateT SAT Identity a -\u003e (a, SAT)",
        "fct-source": "src/Ersatz-Problem.html#runSAT%27",
        "fct-type": "function",
        "title": "runSAT'"
      },
      "index": {
        "description": "Run SAT generating state computation in the Identity monad Useful e.g in ghci for disambiguating the type of MonadState HasSAT value",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "runSAT'",
        "normalized": "StateT SAT Identity a-\u003e(a,SAT)",
        "package": "ersatz",
        "partial": "SAT'",
        "signature": "StateT SAT Identity a-\u003e(a,SAT)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:sat",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "Lens' t SAT",
        "fct-source": "src/Ersatz-Problem.html#sat",
        "fct-type": "method",
        "title": "sat"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "sat",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:stableMap",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "Lens' t (HashMap (StableName ()) Literal)",
        "fct-source": "src/Ersatz-Problem.html#stableMap",
        "fct-type": "method",
        "title": "stableMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "stableMap",
        "normalized": "Lens' a(HashMap(StableName())Literal)",
        "package": "ersatz",
        "partial": "Map",
        "signature": "Lens' t(HashMap(StableName())Literal)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:universals",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "Lens' t IntSet",
        "fct-source": "src/Ersatz-Problem.html#universals",
        "fct-type": "method",
        "title": "universals"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "universals",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacs",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e out of a \u003ccode\u003e\u003ca\u003eWDIMACS\u003c/a\u003e\u003c/code\u003e problem.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Builder",
        "fct-source": "src/Ersatz-Problem.html#wdimacs",
        "fct-type": "function",
        "title": "wdimacs"
      },
      "index": {
        "description": "Generate Builder out of WDIMACS problem",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "wdimacs",
        "normalized": "a-\u003eBuilder",
        "package": "ersatz",
        "partial": "",
        "signature": "t-\u003eBuilder"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacsClauses",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Set (Int64, IntSet)",
        "fct-source": "src/Ersatz-Problem.html#wdimacsClauses",
        "fct-type": "method",
        "title": "wdimacsClauses"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "wdimacsClauses",
        "normalized": "a-\u003eSet(Int,IntSet)",
        "package": "ersatz",
        "partial": "Clauses",
        "signature": "t-\u003eSet(Int,IntSet)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacsComments",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e [ByteString]",
        "fct-source": "src/Ersatz-Problem.html#wdimacsComments",
        "fct-type": "method",
        "title": "wdimacsComments"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "wdimacsComments",
        "normalized": "a-\u003e[ByteString]",
        "package": "ersatz",
        "partial": "Comments",
        "signature": "t-\u003e[ByteString]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacsNumVariables",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "t -\u003e Int",
        "fct-source": "src/Ersatz-Problem.html#wdimacsNumVariables",
        "fct-type": "method",
        "title": "wdimacsNumVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "wdimacsNumVariables",
        "normalized": "a-\u003eInt",
        "package": "ersatz",
        "partial": "Num Variables",
        "signature": "t-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Problem.html#v:wdimacsTopWeight",
      "description": {
        "fct-module": "Ersatz.Problem",
        "fct-package": "ersatz",
        "fct-signature": "wdimacsTopWeight",
        "fct-source": "src/Ersatz-Problem.html#wdimacsTopWeight",
        "fct-type": "method",
        "title": "wdimacsTopWeight"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Problem",
        "module": "Ersatz.Problem",
        "name": "wdimacsTopWeight",
        "normalized": "",
        "package": "ersatz",
        "partial": "Top Weight",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Solution.html",
        "fct-type": "module",
        "title": "Solution"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "Solution",
        "normalized": "",
        "package": "ersatz",
        "partial": "Solution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#t:Result",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Solution.html#Result",
        "fct-type": "data",
        "title": "Result"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "Result",
        "normalized": "",
        "package": "ersatz",
        "partial": "Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#t:Solution",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "data",
        "fct-source": "src/Ersatz-Solution.html#Solution",
        "fct-type": "data",
        "title": "Solution"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "Solution",
        "normalized": "",
        "package": "ersatz",
        "partial": "Solution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#t:Solver",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "type",
        "fct-source": "src/Ersatz-Solution.html#Solver",
        "fct-type": "type",
        "title": "Solver"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "Solver",
        "normalized": "",
        "package": "ersatz",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:Satisfied",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "Satisfied",
        "fct-source": "src/Ersatz-Solution.html#Result",
        "fct-type": "function",
        "title": "Satisfied"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "Satisfied",
        "normalized": "",
        "package": "ersatz",
        "partial": "Satisfied",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:Solution",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "Solution",
        "fct-source": "src/Ersatz-Solution.html#Solution",
        "fct-type": "function",
        "title": "Solution"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "Solution",
        "normalized": "",
        "package": "ersatz",
        "partial": "Solution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:Unsatisfied",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "Unsatisfied",
        "fct-source": "src/Ersatz-Solution.html#Result",
        "fct-type": "function",
        "title": "Unsatisfied"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "Unsatisfied",
        "normalized": "",
        "package": "ersatz",
        "partial": "Unsatisfied",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:Unsolved",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "Unsolved",
        "fct-source": "src/Ersatz-Solution.html#Result",
        "fct-type": "function",
        "title": "Unsolved"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "Unsolved",
        "normalized": "",
        "package": "ersatz",
        "partial": "Unsolved",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:solutionFrom",
      "description": {
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "IntMap Bool -\u003e s -\u003e Solution",
        "fct-source": "src/Ersatz-Solution.html#solutionFrom",
        "fct-type": "function",
        "title": "solutionFrom"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "solutionFrom",
        "normalized": "IntMap Bool-\u003ea-\u003eSolution",
        "package": "ersatz",
        "partial": "From",
        "signature": "IntMap Bool-\u003es-\u003eSolution"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:solutionLiteral",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "Literal -\u003e Maybe Bool",
        "fct-source": "src/Ersatz-Solution.html#Solution",
        "fct-type": "function",
        "title": "solutionLiteral"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "solutionLiteral",
        "normalized": "Literal-\u003eMaybe Bool",
        "package": "ersatz",
        "partial": "Literal",
        "signature": "Literal-\u003eMaybe Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solution.html#v:solutionStableName",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Ersatz.Solution",
        "fct-package": "ersatz",
        "fct-signature": "StableName () -\u003e Maybe Bool",
        "fct-source": "src/Ersatz-Solution.html#Solution",
        "fct-type": "function",
        "title": "solutionStableName"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solution",
        "module": "Ersatz.Solution",
        "name": "solutionStableName",
        "normalized": "StableName()-\u003eMaybe Bool",
        "package": "ersatz",
        "partial": "Stable Name",
        "signature": "StableName()-\u003eMaybe Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-DepQBF.html#",
      "description": {
        "fct-module": "Ersatz.Solver.DepQBF",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Solver-DepQBF.html",
        "fct-type": "module",
        "title": "DepQBF"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver DepQBF",
        "module": "Ersatz.Solver.DepQBF",
        "name": "DepQBF",
        "normalized": "",
        "package": "ersatz",
        "partial": "Dep QBF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-DepQBF.html#v:depqbf",
      "description": {
        "fct-module": "Ersatz.Solver.DepQBF",
        "fct-package": "ersatz",
        "fct-signature": "Solver QSAT m",
        "fct-source": "src/Ersatz-Solver-DepQBF.html#depqbf",
        "fct-type": "function",
        "title": "depqbf"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver DepQBF",
        "module": "Ersatz.Solver.DepQBF",
        "name": "depqbf",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-DepQBF.html#v:depqbfPath",
      "description": {
        "fct-module": "Ersatz.Solver.DepQBF",
        "fct-package": "ersatz",
        "fct-signature": "FilePath -\u003e Solver QSAT m",
        "fct-source": "src/Ersatz-Solver-DepQBF.html#depqbfPath",
        "fct-type": "function",
        "title": "depqbfPath"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver DepQBF",
        "module": "Ersatz.Solver.DepQBF",
        "name": "depqbfPath",
        "normalized": "FilePath-\u003eSolver QSAT a",
        "package": "ersatz",
        "partial": "Path",
        "signature": "FilePath-\u003eSolver QSAT m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-Minisat.html#",
      "description": {
        "fct-module": "Ersatz.Solver.Minisat",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Solver-Minisat.html",
        "fct-type": "module",
        "title": "Minisat"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver Minisat",
        "module": "Ersatz.Solver.Minisat",
        "name": "Minisat",
        "normalized": "",
        "package": "ersatz",
        "partial": "Minisat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-Minisat.html#v:cryptominisat",
      "description": {
        "fct-module": "Ersatz.Solver.Minisat",
        "fct-package": "ersatz",
        "fct-signature": "Solver SAT m",
        "fct-source": "src/Ersatz-Solver-Minisat.html#cryptominisat",
        "fct-type": "function",
        "title": "cryptominisat"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver Minisat",
        "module": "Ersatz.Solver.Minisat",
        "name": "cryptominisat",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-Minisat.html#v:minisat",
      "description": {
        "fct-module": "Ersatz.Solver.Minisat",
        "fct-package": "ersatz",
        "fct-signature": "Solver SAT m",
        "fct-source": "src/Ersatz-Solver-Minisat.html#minisat",
        "fct-type": "function",
        "title": "minisat"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver Minisat",
        "module": "Ersatz.Solver.Minisat",
        "name": "minisat",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver-Minisat.html#v:minisatPath",
      "description": {
        "fct-module": "Ersatz.Solver.Minisat",
        "fct-package": "ersatz",
        "fct-signature": "FilePath -\u003e Solver SAT m",
        "fct-source": "src/Ersatz-Solver-Minisat.html#minisatPath",
        "fct-type": "function",
        "title": "minisatPath"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver Minisat",
        "module": "Ersatz.Solver.Minisat",
        "name": "minisatPath",
        "normalized": "FilePath-\u003eSolver SAT a",
        "package": "ersatz",
        "partial": "Path",
        "signature": "FilePath-\u003eSolver SAT m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver.html#",
      "description": {
        "fct-module": "Ersatz.Solver",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Solver.html",
        "fct-type": "module",
        "title": "Solver"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver",
        "module": "Ersatz.Solver",
        "name": "Solver",
        "normalized": "",
        "package": "ersatz",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Solver.html#v:solveWith",
      "description": {
        "fct-module": "Ersatz.Solver",
        "fct-package": "ersatz",
        "fct-signature": "Solver s m -\u003e StateT s m a -\u003e m (Result, Maybe (Decoded a))",
        "fct-source": "src/Ersatz-Solver.html#solveWith",
        "fct-type": "function",
        "title": "solveWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Solver",
        "module": "Ersatz.Solver",
        "name": "solveWith",
        "normalized": "Solver a b-\u003eStateT a b c-\u003eb(Result,Maybe(Decoded c))",
        "package": "ersatz",
        "partial": "With",
        "signature": "Solver s m-\u003eStateT s m a-\u003em(Result,Maybe(Decoded a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Variable.html#",
      "description": {
        "fct-module": "Ersatz.Variable",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz-Variable.html",
        "fct-type": "module",
        "title": "Variable"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Variable",
        "module": "Ersatz.Variable",
        "name": "Variable",
        "normalized": "",
        "package": "ersatz",
        "partial": "Variable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Variable.html#t:Variable",
      "description": {
        "fct-descr": "\u003cp\u003eInstances for this class for product-like types can be automatically derived\n for any type that is an instance of \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Ersatz.Variable",
        "fct-package": "ersatz",
        "fct-signature": "class",
        "fct-source": "src/Ersatz-Variable.html#Variable",
        "fct-type": "class",
        "title": "Variable"
      },
      "index": {
        "description": "Instances for this class for product-like types can be automatically derived for any type that is an instance of Generic",
        "hierarchy": "Ersatz Variable",
        "module": "Ersatz.Variable",
        "name": "Variable",
        "normalized": "",
        "package": "ersatz",
        "partial": "Variable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Variable.html#v:exists",
      "description": {
        "fct-module": "Ersatz.Variable",
        "fct-package": "ersatz",
        "fct-signature": "m t",
        "fct-source": "src/Ersatz-Variable.html#exists",
        "fct-type": "method",
        "title": "exists"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Variable",
        "module": "Ersatz.Variable",
        "name": "exists",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz-Variable.html#v:forall",
      "description": {
        "fct-module": "Ersatz.Variable",
        "fct-package": "ersatz",
        "fct-signature": "m t",
        "fct-source": "src/Ersatz-Variable.html#forall",
        "fct-type": "method",
        "title": "forall"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz Variable",
        "module": "Ersatz.Variable",
        "name": "forall",
        "normalized": "",
        "package": "ersatz",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ersatz/docs/Ersatz.html#",
      "description": {
        "fct-module": "Ersatz",
        "fct-package": "ersatz",
        "fct-signature": "module",
        "fct-source": "src/Ersatz.html",
        "fct-type": "module",
        "title": "Ersatz"
      },
      "index": {
        "description": "",
        "hierarchy": "Ersatz",
        "module": "Ersatz",
        "name": "Ersatz",
        "normalized": "",
        "package": "ersatz",
        "partial": "Ersatz",
        "signature": ""
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#",
      "description": {
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "module",
        "fct-source": "src/ReadArgs.html",
        "fct-type": "module",
        "title": "ReadArgs"
      },
      "index": {
        "description": "",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "ReadArgs",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "Read Args",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t::-38-",
      "description": {
        "fct-descr": "\u003cp\u003euse :& to construct arbitrary length tuples of any parsable arguments\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "data",
        "fct-source": "src/ReadArgs.html#%3A%26",
        "fct-type": "data",
        "title": ":&"
      },
      "index": {
        "description": "use to construct arbitrary length tuples of any parsable arguments",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": ":&",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t:Arguable",
      "description": {
        "fct-descr": "\u003cp\u003ea class for types that can be parsed from exactly one command line argument\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "class",
        "fct-source": "src/ReadArgs.html#Arguable",
        "fct-type": "class",
        "title": "Arguable"
      },
      "index": {
        "description": "class for types that can be parsed from exactly one command line argument",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "Arguable",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "Arguable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t:Argument",
      "description": {
        "fct-descr": "\u003cp\u003ea class for types that can be parsed from some number of command line\n arguments\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "class",
        "fct-source": "src/ReadArgs.html#Argument",
        "fct-type": "class",
        "title": "Argument"
      },
      "index": {
        "description": "class for types that can be parsed from some number of command line arguments",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "Argument",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "Argument",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t:ArgumentTuple",
      "description": {
        "fct-descr": "\u003cp\u003ea class for tuples of types that can be parsed from the entire list\n of arguments\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "class",
        "fct-source": "src/ReadArgs.html#ArgumentTuple",
        "fct-type": "class",
        "title": "ArgumentTuple"
      },
      "index": {
        "description": "class for tuples of types that can be parsed from the entire list of arguments",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "ArgumentTuple",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "Argument Tuple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t:NonGreedy",
      "description": {
        "fct-descr": "\u003cp\u003ea wrapper type to indicate a non-greedy list or maybe\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "newtype",
        "fct-source": "src/ReadArgs.html#NonGreedy",
        "fct-type": "newtype",
        "title": "NonGreedy"
      },
      "index": {
        "description": "wrapper type to indicate non-greedy list or maybe",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "NonGreedy",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "Non Greedy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v::-38-",
      "description": {
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "a :& b",
        "fct-source": "src/ReadArgs.html#%3A%26",
        "fct-type": "function",
        "title": ":&"
      },
      "index": {
        "description": "",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": ":&",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:NonGreedy",
      "description": {
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "NonGreedy",
        "fct-source": "src/ReadArgs.html#NonGreedy",
        "fct-type": "function",
        "title": "NonGreedy"
      },
      "index": {
        "description": "",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "NonGreedy",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "Non Greedy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:argName",
      "description": {
        "fct-descr": "\u003cp\u003eargName's argument will usually be undefined, so when defining instances of\n Arguable, it should be lazy in its argument\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/ReadArgs.html#argName",
        "fct-type": "method",
        "title": "argName"
      },
      "index": {
        "description": "argName argument will usually be undefined so when defining instances of Arguable it should be lazy in its argument",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "argName",
        "normalized": "a-\u003eString",
        "package": "ReadArgs",
        "partial": "Name",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:name",
      "description": {
        "fct-descr": "\u003cp\u003ename's argument will usually be undefined, so when defining instances of\n Arguable, it should be lazy in its argument\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/ReadArgs.html#name",
        "fct-type": "method",
        "title": "name"
      },
      "index": {
        "description": "name argument will usually be undefined so when defining instances of Arguable it should be lazy in its argument",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "name",
        "normalized": "a-\u003eString",
        "package": "ReadArgs",
        "partial": "",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:parse",
      "description": {
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "String -\u003e Maybe a",
        "fct-source": "src/ReadArgs.html#parse",
        "fct-type": "method",
        "title": "parse"
      },
      "index": {
        "description": "",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "parse",
        "normalized": "String-\u003eMaybe a",
        "package": "ReadArgs",
        "partial": "",
        "signature": "String-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:parseArg",
      "description": {
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "[String] -\u003e [(a, [String])]",
        "fct-source": "src/ReadArgs.html#parseArg",
        "fct-type": "method",
        "title": "parseArg"
      },
      "index": {
        "description": "",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "parseArg",
        "normalized": "[String]-\u003e[(a,[String])]",
        "package": "ReadArgs",
        "partial": "Arg",
        "signature": "[String]-\u003e[(a,[String])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:parseArgsFrom",
      "description": {
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "[String] -\u003e Maybe a",
        "fct-source": "src/ReadArgs.html#parseArgsFrom",
        "fct-type": "method",
        "title": "parseArgsFrom"
      },
      "index": {
        "description": "",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "parseArgsFrom",
        "normalized": "[String]-\u003eMaybe a",
        "package": "ReadArgs",
        "partial": "Args From",
        "signature": "[String]-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:readArgs",
      "description": {
        "fct-descr": "\u003cp\u003eparse the desired argument tuple from the command line or \n  print a simple usage statment and quit\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "IO a",
        "fct-source": "src/ReadArgs.html#readArgs",
        "fct-type": "function",
        "title": "readArgs"
      },
      "index": {
        "description": "parse the desired argument tuple from the command line or print simple usage statment and quit",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "readArgs",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "Args",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:readArgsFrom",
      "description": {
        "fct-descr": "\u003cp\u003eread args from the given strings or \n  print a simple usage statment and quit\n  (so you can do option parsing first)\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "[String] -\u003e IO a",
        "fct-source": "src/ReadArgs.html#readArgsFrom",
        "fct-type": "function",
        "title": "readArgsFrom"
      },
      "index": {
        "description": "read args from the given strings or print simple usage statment and quit so you can do option parsing first",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "readArgsFrom",
        "normalized": "[String]-\u003eIO a",
        "package": "ReadArgs",
        "partial": "Args From",
        "signature": "[String]-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:unNonGreedy",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "m a",
        "fct-source": "src/ReadArgs.html#NonGreedy",
        "fct-type": "function",
        "title": "unNonGreedy"
      },
      "index": {
        "description": "",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "unNonGreedy",
        "normalized": "",
        "package": "ReadArgs",
        "partial": "Non Greedy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:usageFor",
      "description": {
        "fct-descr": "\u003cp\u003eusageFor's argument will usually be undefined, so when defining instances of\n Arguable, it should be lazy in its argument\n\u003c/p\u003e",
        "fct-module": "ReadArgs",
        "fct-package": "ReadArgs",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/ReadArgs.html#usageFor",
        "fct-type": "method",
        "title": "usageFor"
      },
      "index": {
        "description": "usageFor argument will usually be undefined so when defining instances of Arguable it should be lazy in its argument",
        "hierarchy": "ReadArgs",
        "module": "ReadArgs",
        "name": "usageFor",
        "normalized": "a-\u003eString",
        "package": "ReadArgs",
        "partial": "For",
        "signature": "a-\u003eString"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Automaton.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFinite state automatons\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.Automaton",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-Automaton.html",
        "fct-type": "module",
        "title": "Automaton"
      },
      "index": {
        "description": "Finite state automatons",
        "hierarchy": "FST Automaton",
        "module": "FST.Automaton",
        "name": "Automaton",
        "normalized": "",
        "package": "fst",
        "partial": "Automaton",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Automaton.html#t:Automaton",
      "description": {
        "fct-descr": "\u003cp\u003eData type for an automaton\n\u003c/p\u003e",
        "fct-module": "FST.Automaton",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-Automaton.html#Automaton",
        "fct-type": "data",
        "title": "Automaton"
      },
      "index": {
        "description": "Data type for an automaton",
        "hierarchy": "FST Automaton",
        "module": "FST.Automaton",
        "name": "Automaton",
        "normalized": "",
        "package": "fst",
        "partial": "Automaton",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Automaton.html#t:Convertable",
      "description": {
        "fct-descr": "\u003cp\u003eType class for conversion to/from an automaton\n\u003c/p\u003e",
        "fct-module": "FST.Automaton",
        "fct-package": "fst",
        "fct-signature": "class",
        "fct-source": "src/FST-Automaton.html#Convertable",
        "fct-type": "class",
        "title": "Convertable"
      },
      "index": {
        "description": "Type class for conversion to from an automaton",
        "hierarchy": "FST Automaton",
        "module": "FST.Automaton",
        "name": "Convertable",
        "normalized": "",
        "package": "fst",
        "partial": "Convertable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Automaton.html#v:construct",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct an automaton\n\u003c/p\u003e",
        "fct-module": "FST.Automaton",
        "fct-package": "fst",
        "fct-signature": "(FirstState, LastState) -\u003e TransitionTable a -\u003e Sigma a -\u003e InitialStates -\u003e FinalStates -\u003e Automaton a",
        "fct-source": "src/FST-Automaton.html#construct",
        "fct-type": "function",
        "title": "construct"
      },
      "index": {
        "description": "Construct an automaton",
        "hierarchy": "FST Automaton",
        "module": "FST.Automaton",
        "name": "construct",
        "normalized": "(FirstState,LastState)-\u003eTransitionTable a-\u003eSigma a-\u003eInitialStates-\u003eFinalStates-\u003eAutomaton a",
        "package": "fst",
        "partial": "",
        "signature": "(FirstState,LastState)-\u003eTransitionTable a-\u003eSigma a-\u003eInitialStates-\u003eFinalStates-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Automaton.html#v:decode",
      "description": {
        "fct-module": "FST.Automaton",
        "fct-package": "fst",
        "fct-signature": "decode",
        "fct-source": "src/FST-Automaton.html#decode",
        "fct-type": "method",
        "title": "decode"
      },
      "index": {
        "description": "",
        "hierarchy": "FST Automaton",
        "module": "FST.Automaton",
        "name": "decode",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Automaton.html#v:encode",
      "description": {
        "fct-module": "FST.Automaton",
        "fct-package": "fst",
        "fct-signature": "encode",
        "fct-source": "src/FST-Automaton.html#encode",
        "fct-type": "method",
        "title": "encode"
      },
      "index": {
        "description": "",
        "hierarchy": "FST Automaton",
        "module": "FST.Automaton",
        "name": "encode",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Automaton.html#v:rename",
      "description": {
        "fct-descr": "\u003cp\u003eConvert automaton labelled with something other than\n   states to an \u003ccode\u003e\u003ca\u003eAutomaton\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "FST.Automaton",
        "fct-package": "fst",
        "fct-signature": "[(b, [(a, b)])] -\u003e Sigma a -\u003e [b] -\u003e [b] -\u003e StateTy -\u003e Automaton a",
        "fct-source": "src/FST-Automaton.html#rename",
        "fct-type": "function",
        "title": "rename"
      },
      "index": {
        "description": "Convert automaton labelled with something other than states to an Automaton",
        "hierarchy": "FST Automaton",
        "module": "FST.Automaton",
        "name": "rename",
        "normalized": "[(a,[(b,a)])]-\u003eSigma b-\u003e[a]-\u003e[a]-\u003eStateTy-\u003eAutomaton b",
        "package": "fst",
        "partial": "",
        "signature": "[(b,[(a,b)])]-\u003eSigma a-\u003e[b]-\u003e[b]-\u003eStateTy-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Automaton.html#v:showAutomaton",
      "description": {
        "fct-descr": "\u003cp\u003eDisplay the automaton\n\u003c/p\u003e",
        "fct-module": "FST.Automaton",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e String",
        "fct-source": "src/FST-Automaton.html#showAutomaton",
        "fct-type": "function",
        "title": "showAutomaton"
      },
      "index": {
        "description": "Display the automaton",
        "hierarchy": "FST Automaton",
        "module": "FST.Automaton",
        "name": "showAutomaton",
        "normalized": "Automaton a-\u003eString",
        "package": "fst",
        "partial": "Automaton",
        "signature": "Automaton a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAPI for finite state automatons\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-AutomatonInterface.html",
        "fct-type": "module",
        "title": "AutomatonInterface"
      },
      "index": {
        "description": "API for finite state automatons",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "AutomatonInterface",
        "normalized": "",
        "package": "fst",
        "partial": "Automaton Interface",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#t:Automaton",
      "description": {
        "fct-descr": "\u003cp\u003eData type for an automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-Automaton.html#Automaton",
        "fct-type": "data",
        "title": "Automaton"
      },
      "index": {
        "description": "Data type for an automaton",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "Automaton",
        "normalized": "",
        "package": "fst",
        "partial": "Automaton",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:compile",
      "description": {
        "fct-descr": "\u003cp\u003eCompile a minimized non-deterministic finite-state automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Sigma a -\u003e StateTy -\u003e Automaton a",
        "fct-source": "src/FST-AutomatonInterface.html#compile",
        "fct-type": "function",
        "title": "compile"
      },
      "index": {
        "description": "Compile minimized non-deterministic finite-state automaton",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "compile",
        "normalized": "Reg a-\u003eSigma a-\u003eStateTy-\u003eAutomaton a",
        "package": "fst",
        "partial": "",
        "signature": "Reg a-\u003eSigma a-\u003eStateTy-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:compileNFA",
      "description": {
        "fct-descr": "\u003cp\u003eCompile a non-deterministic finite-state automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Sigma a -\u003e StateTy -\u003e Automaton a",
        "fct-source": "src/FST-AutomatonInterface.html#compileNFA",
        "fct-type": "function",
        "title": "compileNFA"
      },
      "index": {
        "description": "Compile non-deterministic finite-state automaton",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "compileNFA",
        "normalized": "Reg a-\u003eSigma a-\u003eStateTy-\u003eAutomaton a",
        "package": "fst",
        "partial": "NFA",
        "signature": "Reg a-\u003eSigma a-\u003eStateTy-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:complete",
      "description": {
        "fct-descr": "\u003cp\u003eMake a automaton complete (transition on every symbol at every state)\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e Automaton a",
        "fct-source": "src/FST-Complete.html#complete",
        "fct-type": "function",
        "title": "complete"
      },
      "index": {
        "description": "Make automaton complete transition on every symbol at every state",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "complete",
        "normalized": "Automaton a-\u003eAutomaton a",
        "package": "fst",
        "partial": "",
        "signature": "Automaton a-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:determinize",
      "description": {
        "fct-descr": "\u003cp\u003eMake a non-deterministic finite-state automaton deterministic\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e Automaton a",
        "fct-source": "src/FST-AutomatonInterface.html#determinize",
        "fct-type": "function",
        "title": "determinize"
      },
      "index": {
        "description": "Make non-deterministic finite-state automaton deterministic",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "determinize",
        "normalized": "Automaton a-\u003eAutomaton a",
        "package": "fst",
        "partial": "",
        "signature": "Automaton a-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:initial",
      "description": {
        "fct-descr": "\u003cp\u003eGet the initial state of a finite-state automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e StateTy",
        "fct-source": "src/FST-AutomatonInterface.html#initial",
        "fct-type": "function",
        "title": "initial"
      },
      "index": {
        "description": "Get the initial state of finite-state automaton",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "initial",
        "normalized": "Automaton a-\u003eStateTy",
        "package": "fst",
        "partial": "",
        "signature": "Automaton a-\u003eStateTy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:minimize",
      "description": {
        "fct-descr": "\u003cp\u003eMinimize an automaton using the Brzozowski algorithm. Note that\n the determinize function must construct an automaton with the\n usefulS property.\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e Automaton a",
        "fct-source": "src/FST-AutomatonInterface.html#minimize",
        "fct-type": "function",
        "title": "minimize"
      },
      "index": {
        "description": "Minimize an automaton using the Brzozowski algorithm Note that the determinize function must construct an automaton with the usefulS property",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "minimize",
        "normalized": "Automaton a-\u003eAutomaton a",
        "package": "fst",
        "partial": "",
        "signature": "Automaton a-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:numberOfStates",
      "description": {
        "fct-descr": "\u003cp\u003eCount the number of states in a finite-state automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e Int",
        "fct-source": "src/FST-AutomatonInterface.html#numberOfStates",
        "fct-type": "function",
        "title": "numberOfStates"
      },
      "index": {
        "description": "Count the number of states in finite-state automaton",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "numberOfStates",
        "normalized": "Automaton a-\u003eInt",
        "package": "fst",
        "partial": "Of States",
        "signature": "Automaton a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:numberOfTransitions",
      "description": {
        "fct-descr": "\u003cp\u003eCount the number of transitions in a finite-state automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e Int",
        "fct-source": "src/FST-AutomatonInterface.html#numberOfTransitions",
        "fct-type": "function",
        "title": "numberOfTransitions"
      },
      "index": {
        "description": "Count the number of transitions in finite-state automaton",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "numberOfTransitions",
        "normalized": "Automaton a-\u003eInt",
        "package": "fst",
        "partial": "Of Transitions",
        "signature": "Automaton a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonInterface.html#v:showAutomaton",
      "description": {
        "fct-descr": "\u003cp\u003eDisplay the automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonInterface",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e String",
        "fct-source": "src/FST-Automaton.html#showAutomaton",
        "fct-type": "function",
        "title": "showAutomaton"
      },
      "index": {
        "description": "Display the automaton",
        "hierarchy": "FST AutomatonInterface",
        "module": "FST.AutomatonInterface",
        "name": "showAutomaton",
        "normalized": "Automaton a-\u003eString",
        "package": "fst",
        "partial": "Automaton",
        "signature": "Automaton a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes for Automaton\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-AutomatonTypes.html",
        "fct-type": "module",
        "title": "AutomatonTypes"
      },
      "index": {
        "description": "Types for Automaton",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "AutomatonTypes",
        "normalized": "",
        "package": "fst",
        "partial": "Automaton Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:AutomatonFunctions",
      "description": {
        "fct-descr": "\u003cp\u003eClass of AutomatonFunctions\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "class",
        "fct-source": "src/FST-AutomatonTypes.html#AutomatonFunctions",
        "fct-type": "class",
        "title": "AutomatonFunctions"
      },
      "index": {
        "description": "Class of AutomatonFunctions",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "AutomatonFunctions",
        "normalized": "",
        "package": "fst",
        "partial": "Automaton Functions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:FinalStates",
      "description": {
        "fct-descr": "\u003cp\u003eFinal states\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#FinalStates",
        "fct-type": "type",
        "title": "FinalStates"
      },
      "index": {
        "description": "Final states",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "FinalStates",
        "normalized": "",
        "package": "fst",
        "partial": "Final States",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:FirstState",
      "description": {
        "fct-descr": "\u003cp\u003eFirst state\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#FirstState",
        "fct-type": "type",
        "title": "FirstState"
      },
      "index": {
        "description": "First state",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "FirstState",
        "normalized": "",
        "package": "fst",
        "partial": "First State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:InitialStates",
      "description": {
        "fct-descr": "\u003cp\u003eInitial states\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#InitialStates",
        "fct-type": "type",
        "title": "InitialStates"
      },
      "index": {
        "description": "Initial states",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "InitialStates",
        "normalized": "",
        "package": "fst",
        "partial": "Initial States",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:LastState",
      "description": {
        "fct-descr": "\u003cp\u003eLast state\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#LastState",
        "fct-type": "type",
        "title": "LastState"
      },
      "index": {
        "description": "Last state",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "LastState",
        "normalized": "",
        "package": "fst",
        "partial": "Last State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:Sigma",
      "description": {
        "fct-descr": "\u003cp\u003eThe alphabet of an automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#Sigma",
        "fct-type": "type",
        "title": "Sigma"
      },
      "index": {
        "description": "The alphabet of an automaton",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "Sigma",
        "normalized": "",
        "package": "fst",
        "partial": "Sigma",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:StateTy",
      "description": {
        "fct-descr": "\u003cp\u003eA state\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#StateTy",
        "fct-type": "type",
        "title": "StateTy"
      },
      "index": {
        "description": "state",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "StateTy",
        "normalized": "",
        "package": "fst",
        "partial": "State Ty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:TransitionTable",
      "description": {
        "fct-descr": "\u003cp\u003eTable of transitions\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#TransitionTable",
        "fct-type": "type",
        "title": "TransitionTable"
      },
      "index": {
        "description": "Table of transitions",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "TransitionTable",
        "normalized": "",
        "package": "fst",
        "partial": "Transition Table",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#t:Transitions",
      "description": {
        "fct-descr": "\u003cp\u003eTransitions\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#Transitions",
        "fct-type": "type",
        "title": "Transitions"
      },
      "index": {
        "description": "Transitions",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "Transitions",
        "normalized": "",
        "package": "fst",
        "partial": "Transitions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:alphabet",
      "description": {
        "fct-descr": "\u003cp\u003eGet the alphabet of an automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e Sigma a",
        "fct-source": "src/FST-AutomatonTypes.html#alphabet",
        "fct-type": "method",
        "title": "alphabet"
      },
      "index": {
        "description": "Get the alphabet of an automaton",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "alphabet",
        "normalized": "a b-\u003eSigma b",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003eSigma a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:finals",
      "description": {
        "fct-descr": "\u003cp\u003eGet the final states of an automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e FinalStates",
        "fct-source": "src/FST-AutomatonTypes.html#finals",
        "fct-type": "method",
        "title": "finals"
      },
      "index": {
        "description": "Get the final states of an automaton",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "finals",
        "normalized": "a b-\u003eFinalStates",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003eFinalStates"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:firstState",
      "description": {
        "fct-descr": "\u003cp\u003eGet the first state of a automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e StateTy",
        "fct-source": "src/FST-AutomatonTypes.html#firstState",
        "fct-type": "method",
        "title": "firstState"
      },
      "index": {
        "description": "Get the first state of automaton",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "firstState",
        "normalized": "a b-\u003eStateTy",
        "package": "fst",
        "partial": "State",
        "signature": "f a-\u003eStateTy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:initials",
      "description": {
        "fct-descr": "\u003cp\u003eGet the initial states of an automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e InitialStates",
        "fct-source": "src/FST-AutomatonTypes.html#initials",
        "fct-type": "method",
        "title": "initials"
      },
      "index": {
        "description": "Get the initial states of an automaton",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "initials",
        "normalized": "a b-\u003eInitialStates",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003eInitialStates"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:isFinal",
      "description": {
        "fct-descr": "\u003cp\u003eIs the given state a final state?\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e StateTy -\u003e Bool",
        "fct-source": "src/FST-AutomatonTypes.html#isFinal",
        "fct-type": "method",
        "title": "isFinal"
      },
      "index": {
        "description": "Is the given state final state",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "isFinal",
        "normalized": "a b-\u003eStateTy-\u003eBool",
        "package": "fst",
        "partial": "Final",
        "signature": "f a-\u003eStateTy-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:lastState",
      "description": {
        "fct-descr": "\u003cp\u003eGet the last state of a automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e StateTy",
        "fct-source": "src/FST-AutomatonTypes.html#lastState",
        "fct-type": "method",
        "title": "lastState"
      },
      "index": {
        "description": "Get the last state of automaton",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "lastState",
        "normalized": "a b-\u003eStateTy",
        "package": "fst",
        "partial": "State",
        "signature": "f a-\u003eStateTy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:states",
      "description": {
        "fct-descr": "\u003cp\u003eGet the states of an automaton\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e [StateTy]",
        "fct-source": "src/FST-AutomatonTypes.html#states",
        "fct-type": "method",
        "title": "states"
      },
      "index": {
        "description": "Get the states of an automaton",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "states",
        "normalized": "a b-\u003e[StateTy]",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003e[StateTy]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:transitionList",
      "description": {
        "fct-descr": "\u003cp\u003eGet the transitions w.r.t. a state\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e StateTy -\u003e Transitions a",
        "fct-source": "src/FST-AutomatonTypes.html#transitionList",
        "fct-type": "method",
        "title": "transitionList"
      },
      "index": {
        "description": "Get the transitions w.r.t state",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "transitionList",
        "normalized": "a b-\u003eStateTy-\u003eTransitions b",
        "package": "fst",
        "partial": "List",
        "signature": "f a-\u003eStateTy-\u003eTransitions a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:transitionTable",
      "description": {
        "fct-descr": "\u003cp\u003eGet the transitionTable\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e TransitionTable a",
        "fct-source": "src/FST-AutomatonTypes.html#transitionTable",
        "fct-type": "method",
        "title": "transitionTable"
      },
      "index": {
        "description": "Get the transitionTable",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "transitionTable",
        "normalized": "a b-\u003eTransitionTable b",
        "package": "fst",
        "partial": "Table",
        "signature": "f a-\u003eTransitionTable a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-AutomatonTypes.html#v:transitions",
      "description": {
        "fct-descr": "\u003cp\u003eGet the transitions  w.r.t. a state and a symbol\n\u003c/p\u003e",
        "fct-module": "FST.AutomatonTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e (StateTy, a) -\u003e [StateTy]",
        "fct-source": "src/FST-AutomatonTypes.html#transitions",
        "fct-type": "method",
        "title": "transitions"
      },
      "index": {
        "description": "Get the transitions w.r.t state and symbol",
        "hierarchy": "FST AutomatonTypes",
        "module": "FST.AutomatonTypes",
        "name": "transitions",
        "normalized": "a b-\u003e(StateTy,b)-\u003e[StateTy]",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003e(StateTy,a)-\u003e[StateTy]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Complete.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunction for making an automaton complete (transition on every symbol at every state)\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.Complete",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-Complete.html",
        "fct-type": "module",
        "title": "Complete"
      },
      "index": {
        "description": "Function for making an automaton complete transition on every symbol at every state",
        "hierarchy": "FST Complete",
        "module": "FST.Complete",
        "name": "Complete",
        "normalized": "",
        "package": "fst",
        "partial": "Complete",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Complete.html#v:complete",
      "description": {
        "fct-descr": "\u003cp\u003eMake a automaton complete (transition on every symbol at every state)\n\u003c/p\u003e",
        "fct-module": "FST.Complete",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e Automaton a",
        "fct-source": "src/FST-Complete.html#complete",
        "fct-type": "function",
        "title": "complete"
      },
      "index": {
        "description": "Make automaton complete transition on every symbol at every state",
        "hierarchy": "FST Complete",
        "module": "FST.Complete",
        "name": "complete",
        "normalized": "Automaton a-\u003eAutomaton a",
        "package": "fst",
        "partial": "",
        "signature": "Automaton a-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Deterministic.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunction for making automatons deterministic\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.Deterministic",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-Deterministic.html",
        "fct-type": "module",
        "title": "Deterministic"
      },
      "index": {
        "description": "Function for making automatons deterministic",
        "hierarchy": "FST Deterministic",
        "module": "FST.Deterministic",
        "name": "Deterministic",
        "normalized": "",
        "package": "fst",
        "partial": "Deterministic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Deterministic.html#v:determinize",
      "description": {
        "fct-descr": "\u003cp\u003eMake an automaton deterministic and usefulS\n\u003c/p\u003e",
        "fct-module": "FST.Deterministic",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e Automaton a",
        "fct-source": "src/FST-Deterministic.html#determinize",
        "fct-type": "function",
        "title": "determinize"
      },
      "index": {
        "description": "Make an automaton deterministic and usefulS",
        "hierarchy": "FST Deterministic",
        "module": "FST.Deterministic",
        "name": "determinize",
        "normalized": "Automaton a-\u003eAutomaton a",
        "package": "fst",
        "partial": "",
        "signature": "Automaton a-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-DeterministicT.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunction for making transducers deterministic\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.DeterministicT",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-DeterministicT.html",
        "fct-type": "module",
        "title": "DeterministicT"
      },
      "index": {
        "description": "Function for making transducers deterministic",
        "hierarchy": "FST DeterministicT",
        "module": "FST.DeterministicT",
        "name": "DeterministicT",
        "normalized": "",
        "package": "fst",
        "partial": "Deterministic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-DeterministicT.html#v:determinize",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a deterministic, usefulS transducer\n\u003c/p\u003e",
        "fct-module": "FST.DeterministicT",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-DeterministicT.html#determinize",
        "fct-type": "function",
        "title": "determinize"
      },
      "index": {
        "description": "Construct deterministic usefulS transducer",
        "hierarchy": "FST DeterministicT",
        "module": "FST.DeterministicT",
        "name": "determinize",
        "normalized": "Transducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-EpsilonFreeT.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunction for constructing an epsilon-free transducer\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.EpsilonFreeT",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-EpsilonFreeT.html",
        "fct-type": "module",
        "title": "EpsilonFreeT"
      },
      "index": {
        "description": "Function for constructing an epsilon-free transducer",
        "hierarchy": "FST EpsilonFreeT",
        "module": "FST.EpsilonFreeT",
        "name": "EpsilonFreeT",
        "normalized": "",
        "package": "fst",
        "partial": "Epsilon Free",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-EpsilonFreeT.html#v:epsilonfree",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct an epsilon-free, usefulS transducer\n\u003c/p\u003e",
        "fct-module": "FST.EpsilonFreeT",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-EpsilonFreeT.html#epsilonfree",
        "fct-type": "function",
        "title": "epsilonfree"
      },
      "index": {
        "description": "Construct an epsilon-free usefulS transducer",
        "hierarchy": "FST EpsilonFreeT",
        "module": "FST.EpsilonFreeT",
        "name": "epsilonfree",
        "normalized": "Transducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-FSTStudio.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003efstStudio takes a program consisting of regular relations that denotes\nthe relation between two regular languages and constructs a\ntransducer. If a regular expression, not a relation, is given, then it\nis interpreted as the identity relation. The syntax is very similar to\nXerox's finite state transducer syntax with two fundamental\ndifferences: a distinction is made between functions (definitions) and\nstrings, and fststudio allows functional definitions.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003e\"a\"\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e A symbol. Example: \u003ccode\u003e[\"b\"]\u003c/code\u003e denotes the language \u003ccode\u003e{\"b\"}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003ea\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e A variable. A symbol without quotes is a variable.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\"a\":\"b\"\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Describes a relation between the symbol \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e.\nThis relation is ordered and \u003ccode\u003ea\u003c/code\u003e is said to be a part of the /upper\nlanguage\u003cem\u003e and @b@ is said to be part of the \u003c/em\u003elower language/.\nExample: \u003ccode\u003e[\"a\":\"b\"]\u003c/code\u003e denotes the relation \u003ccode\u003e{(\"a\",\"b\")}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Epsilon symbol. The epsilon symbol denotes the string with no\nsymbols.  Example: \u003ccode\u003e[0]\u003c/code\u003e denotes the language \u003ccode\u003e{\"\"}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e?\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e All symbol. The all symbol denotes the union of all symbols in\nthe alphabet. Example: \u003ccode\u003e[?]\u003c/code\u003e and an alphabet \u003ccode\u003e{a,b,c}\u003c/code\u003e denotes the\nlanguage \u003ccode\u003e{\"a\",\"b\",\"c\"}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\"\"\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e quotes cancel every special meaning of the symbols. Example:\n\u003ccode\u003e[\"? 0\"]\u003c/code\u003e denotes the language \u003ccode\u003e{\"? 0\"}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e[A]\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e brackets are used to change the precedence of a regular\nrelation.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e(A)\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e parenthesis expresses optionality, and has the same meaning as\n\u003ccode\u003e[A|0]\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA B\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Concatenation of the expressions or relations A and\nB. Example: \u003ccode\u003e[[a b] [c d]]\u003c/code\u003e denotes the language \u003ccode\u003e{\"ac\", \"ad\", \"bc\",\n\"bd\"}\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA^n\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Concatenation of \u003ccode\u003eA\u003c/code\u003e \u003cem\u003en\u003c/em\u003e times.  \u003ccode\u003eA^0\u003c/code\u003e is defined as the empty\nstring. Example: \u003ccode\u003e[a]^3\u003c/code\u003e describes the language \u003ccode\u003e{\"aaa\"}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA|B\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Union of the languages or relations \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e. Example: \u003ccode\u003e[a|b]\u003c/code\u003e\ndescribes the language \u003ccode\u003e{\"a\",\"b\"}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA & B\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Intersection of the languages \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e.  Example: \u003ccode\u003e[a b]\n& [a]\u003c/code\u003e describes the language \u003ccode\u003e{\"a\"}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA - B\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Minus of the languages \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e, and has the same meaning as\n\u003ccode\u003e[A & B]\u003c/code\u003e.  Example: \u003ccode\u003e[a b] - [a]\u003c/code\u003e describes the language \u003ccode\u003e{\"b\"}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e~A\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Describes the complement of an expression, and has the same\nmeaning as \u003ccode\u003e[?* - A]\u003c/code\u003e.  Note that complement is always defined over\nan alphabet. The expression \u003ccode\u003e[A]\u003c/code\u003e is only unambiguous with respect to\nan alphabet. Example: \u003ccode\u003e[a]\u003c/code\u003e denotes the language that doesn't contain\nthe string \u003ccode\u003e\"a\"\u003c/code\u003e. If the alphabet is \u003ccode\u003e{\"a\",\"b\"}\u003c/code\u003e then \u003ccode\u003e[a]\u003c/code\u003e\ndenotes the language \u003ccode\u003e{\"\",\"b\",\"aa\",\"ba\",...}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA+\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Repetition (Kleenes plus).  A concatenated with itself an\narbitrary number of times, including zero times. Example: \u003ccode\u003e[a]+\u003c/code\u003e denotes\nthe infinite language \u003ccode\u003e{\"a\",\"aa\",\"aaa\",...}\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA*\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Kleene&#8217;s star: \u003ccode\u003e[A+ | 0]\u003c/code\u003e.  Example: \u003ccode\u003e[a]*\u003c/code\u003e denotes the infinite\nlanguage \u003ccode\u003e{\"\",\"a\",\"aa\",...}\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e$A\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Containment.  The set of strings where \u003ccode\u003eA\u003c/code\u003e appear at least once\nas a substring. Containment is the same thing as \u003ccode\u003e[?* A ?*]\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA .x. B\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Cross product of the languages \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e.  Example: \u003ccode\u003e[[a b]\n.x. c]\u003c/code\u003e describes the relations \u003ccode\u003e{(\"a\",\"c\"), (\"b\",\"c\")}\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eA .o. B\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Composition of the relations \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e.  Example: \u003ccode\u003e[a:b c:d]\n.o. [d:e]\u003c/code\u003e describes the relation \u003ccode\u003e{(\"c\",\"e\")}\u003c/code\u003e.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eThe precedence of the operators is as follows, where 4 is the highest\nprecedence:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e \u003ccode\u003e.x.\u003c/code\u003e \u003ccode\u003e.o.\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e&\u003c/code\u003e \u003ccode\u003e-\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eConcatenation\u003c/em\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e~\u003c/code\u003e \u003ccode\u003e^\u003c/code\u003e \u003ccode\u003e*\u003c/code\u003e \u003ccode\u003e+\u003c/code\u003e \u003ccode\u003e$\u003c/code\u003e\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eA file containing a program must end with \u003ccode\u003e.fst\u003c/code\u003e, and an input file\nmustend with \u003ccode\u003e.dat\u003c/code\u003e.  A program is a collection of functions defining\nregular relations. A function with zero arguments is called a\ndefinition or a macro.  A definition, or a macro, can for example look\nlike this:\n\u003c/p\u003e\u003cpre\u003e \u003cdigits\u003e ::= \"1\" | \"2\" | \"3\" | \"4\" | \"5\" |\n              \"6\" | \"7\" | \"8\" | \"9\" | \"0\" ;\n\u003c/pre\u003e\u003cp\u003eand a function can look like this:\n\u003c/p\u003e\u003cpre\u003e \u003cswap,a,b\u003e ::= b a ;\n\u003c/pre\u003e\u003cp\u003eNote that strings are marked with quotes, and variables have no\nquotes. Every program must contain a \u003ccode\u003e\u003cmain\u003e\u003c/code\u003e definition (a program\nwithout one will result in a parse error).\n\u003c/p\u003e\u003cpre\u003e \u003cmain\u003e ::= ... ;\n\u003c/pre\u003e\u003cp\u003eThe alphabet of a program is the symbols in the regular relation\ndefined in the program.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eExample program\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e \u003cnickel\u003e  ::= [\"n\" .x. \"c\"^5];\n \u003cdime\u003e    ::= [\"d\" .x. \"c\"^10];\n \u003cquarter\u003e ::= [\"q\" .x. \"c\"^25];\n \u003ccent\u003e    ::= [\"c\" .x. \"c\"];\n \u003cmoney\u003e   ::= [ \u003cnickel\u003e | \u003cdime\u003e | \u003cquarter\u003e | \u003ccent\u003e]*;\n \u003cdrink\u003e   ::= [\"c\"^65 .x. \"PLONK\"];\n \u003cmain\u003e    ::= [ \u003cmoney\u003e .o. \u003cdrink\u003e ];\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eBatch mode\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eUsage: \u003ccode\u003efst FILE [Options]\u003c/code\u003e.  FILE must end with \u003ccode\u003e.fst\u003c/code\u003e, which defines\nan FstStudio program, or \u003ccode\u003e.net\u003c/code\u003e, which defines a saved transducer. If\nno options are given, then input is taken from standard input, the\ntransducer is applied down, and the output, if any, is produced on\nstandard output.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003e-u\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Apply the transducer up\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e-d\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Apply the transducer down\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e-i FILE\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Take input from FILE\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e-o FILE\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Write output to FILE\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003e\u003cem\u003eInteractive mode - list of commands\u003c/em\u003e\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003er REG\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Read a regular relation from standard input. If a regular\nexpression is typed, then it is interpreted as the identity relation.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eb\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Build an epsilon-free, deterministic, minimal transducer from a\nloaded/typed regular relation.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003ebn\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Build an epsilon-free, possibly non-deterministic, non-minimal\ntransducer from a load/typed regular relation.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003em\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Minimize a built transducer.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003edet\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Determinize a built transducer.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003es FILE\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Save to \u003ccode\u003eFILE\u003c/code\u003e. If \u003ccode\u003eFILE\u003c/code\u003e ends with \u003ccode\u003e.net\u003c/code\u003e, then the built\ntransducer is saved. Any other suffix saves the produced output in the\nsystem to \u003ccode\u003eFILE\u003c/code\u003e, if any.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003el FILE\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Load from \u003ccode\u003eFILE\u003c/code\u003e. \u003ccode\u003eFILE\u003c/code\u003e must end with \u003ccode\u003e.fst\u003c/code\u003e, \u003ccode\u003e.net\u003c/code\u003e or\n\u003ccode\u003e.dat\u003c/code\u003e. If \u003ccode\u003eFILE\u003c/code\u003e ends with \u003ccode\u003e.fst\u003c/code\u003e, then a FstStudio program is loaded\ninto FstStudio. If \u003ccode\u003eFILE\u003c/code\u003e ends with \u003ccode\u003e.net\u003c/code\u003e, then a transducer is loaded\ninto FstStudio. If \u003ccode\u003eFILE\u003c/code\u003e ends with \u003ccode\u003e.dat\u003c/code\u003e, then input is loaded into\nFstStudio.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003el a | b\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Load and union two transducers. a and b must either be a\nfile ending with \u003ccode\u003e.net\u003c/code\u003e or the symbol \u003ccode\u003e*\u003c/code\u003e, which refers to the interior\ntransducer. The produced transducer is possibly non-deterministic and\nnon-minimal.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003el a b\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Load and concatenate two transducers. a and b must either be\nale ending with \u003ccode\u003e.net\u003c/code\u003e or the symbol \u003ccode\u003e*\u003c/code\u003e, which refers to the interior\ntransducer. The produced transducer is possibly non-deterministicand\nnon-minimal.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003el a*\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Load and apply Kleene&#8217;s star on a transducer. a must either\nbe a file ending with \u003ccode\u003e.net\u003c/code\u003e or the symbol \u003ccode\u003e*\u003c/code\u003e, which refers to the\ninterior transducer. The produced transducer is possibly\nnon-deterministicand non-minimal.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003el a .o. b\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Load and compose two transducers. a and b must either be\na file ending with \u003ccode\u003e.net\u003c/code\u003e or the symbol \u003ccode\u003e*\u003c/code\u003e, which refers to the\ninterior transducer. The produced transducer is possibly\nnon-deterministic andnon-minimal.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003evt\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e View loaded/built transducer.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003evr\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e View loaded/typed regular relation.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003evi\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e View loaded input.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003evo\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e View produced output.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003ed\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Apply transducer down with loaded input.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eu\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Apply transducer up with loaded input.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003ed SYMBOLS\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Apply tranducer down with \u003ccode\u003eSYMBOLS\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eu SYMBOLS\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Apply transducer up with \u003ccode\u003eSYMBOLS\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003ec\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Clear memory.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eh\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e List commands.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eq\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e End session.\n\u003c/dd\u003e\u003c/dl\u003e\u003c/div\u003e",
        "fct-module": "FST.FSTStudio",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-FSTStudio.html",
        "fct-type": "module",
        "title": "FSTStudio"
      },
      "index": {
        "description": "fstStudio takes program consisting of regular relations that denotes the relation between two regular languages and constructs transducer If regular expression not relation is given then it is interpreted as the identity relation The syntax is very similar to Xerox finite state transducer syntax with two fundamental differences distinction is made between functions definitions and strings and fststudio allows functional definitions symbol Example denotes the language variable symbol without quotes is variable Describes relation between the symbol and This relation is ordered and is said to be part of the upper language and is said to be part of the lower language Example denotes the relation Epsilon symbol The epsilon symbol denotes the string with no symbols Example denotes the language All symbol The all symbol denotes the union of all symbols in the alphabet Example and an alphabet denotes the language quotes cancel every special meaning of the symbols Example denotes the language brackets are used to change the precedence of regular relation parenthesis expresses optionality and has the same meaning as Concatenation of the expressions or relations and Example denotes the language ac ad bc bd Concatenation of times is defined as the empty string Example describes the language aaa Union of the languages or relations and Example describes the language Intersection of the languages and Example describes the language Minus of the languages and and has the same meaning as Example describes the language Describes the complement of an expression and has the same meaning as Note that complement is always defined over an alphabet The expression is only unambiguous with respect to an alphabet Example denotes the language that doesn contain the string If the alphabet is then denotes the language aa ba Repetition Kleenes plus concatenated with itself an arbitrary number of times including zero times Example denotes the infinite language aa aaa Kleene star Example denotes the infinite language aa Containment The set of strings where appear at least once as substring Containment is the same thing as Cross product of the languages and Example describes the relations Composition of the relations and Example describes the relation The precedence of the operators is as follows where is the highest precedence Concatenation file containing program must end with fst and an input file mustend with dat program is collection of functions defining regular relations function with zero arguments is called definition or macro definition or macro can for example look like this digits and function can look like this swap Note that strings are marked with quotes and variables have no quotes Every program must contain main definition program without one will result in parse error main The alphabet of program is the symbols in the regular relation defined in the program Example program nickel dime quarter cent money nickel dime quarter cent drink PLONK main money drink Batch mode Usage fst FILE Options FILE must end with fst which defines an FstStudio program or net which defines saved transducer If no options are given then input is taken from standard input the transducer is applied down and the output if any is produced on standard output Apply the transducer up Apply the transducer down FILE Take input from FILE FILE Write output to FILE Interactive mode list of commands REG Read regular relation from standard input If regular expression is typed then it is interpreted as the identity relation Build an epsilon-free deterministic minimal transducer from loaded typed regular relation bn Build an epsilon-free possibly non-deterministic non-minimal transducer from load typed regular relation Minimize built transducer det Determinize built transducer FILE Save to FILE If FILE ends with net then the built transducer is saved Any other suffix saves the produced output in the system to FILE if any FILE Load from FILE FILE must end with fst net or dat If FILE ends with fst then FstStudio program is loaded into FstStudio If FILE ends with net then transducer is loaded into FstStudio If FILE ends with dat then input is loaded into FstStudio Load and union two transducers and must either be file ending with net or the symbol which refers to the interior transducer The produced transducer is possibly non-deterministic and non-minimal Load and concatenate two transducers and must either be ale ending with net or the symbol which refers to the interior transducer The produced transducer is possibly non-deterministicand non-minimal Load and apply Kleene star on transducer must either be file ending with net or the symbol which refers to the interior transducer The produced transducer is possibly non-deterministicand non-minimal Load and compose two transducers and must either be file ending with net or the symbol which refers to the interior transducer The produced transducer is possibly non-deterministic andnon-minimal vt View loaded built transducer vr View loaded typed regular relation vi View loaded input vo View produced output Apply transducer down with loaded input Apply transducer up with loaded input SYMBOLS Apply tranducer down with SYMBOLS SYMBOLS Apply transducer up with SYMBOLS Clear memory List commands End session",
        "hierarchy": "FST FSTStudio",
        "module": "FST.FSTStudio",
        "name": "FSTStudio",
        "normalized": "",
        "package": "fst",
        "partial": "FSTStudio",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFA.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLeft-biased finite automata\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.LBFA",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-LBFA.html",
        "fct-type": "module",
        "title": "LBFA"
      },
      "index": {
        "description": "Left-biased finite automata",
        "hierarchy": "FST LBFA",
        "module": "FST.LBFA",
        "name": "LBFA",
        "normalized": "",
        "package": "fst",
        "partial": "LBFA",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFA.html#t:LBFA",
      "description": {
        "fct-descr": "\u003cp\u003eData type for LBFA (left-biased finite automata)\n\u003c/p\u003e",
        "fct-module": "FST.LBFA",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-LBFA.html#LBFA",
        "fct-type": "data",
        "title": "LBFA"
      },
      "index": {
        "description": "Data type for LBFA left-biased finite automata",
        "hierarchy": "FST LBFA",
        "module": "FST.LBFA",
        "name": "LBFA",
        "normalized": "",
        "package": "fst",
        "partial": "LBFA",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFA.html#v:compileToAutomaton",
      "description": {
        "fct-descr": "\u003cp\u003eCompile a regular expression to an minimal, useful and\n deterministic automaton, using the LBFA algorithm while building.\n\u003c/p\u003e",
        "fct-module": "FST.LBFA",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Sigma a -\u003e StateTy -\u003e Automaton a",
        "fct-source": "src/FST-LBFA.html#compileToAutomaton",
        "fct-type": "function",
        "title": "compileToAutomaton"
      },
      "index": {
        "description": "Compile regular expression to an minimal useful and deterministic automaton using the LBFA algorithm while building",
        "hierarchy": "FST LBFA",
        "module": "FST.LBFA",
        "name": "compileToAutomaton",
        "normalized": "Reg a-\u003eSigma a-\u003eStateTy-\u003eAutomaton a",
        "package": "fst",
        "partial": "To Automaton",
        "signature": "Reg a-\u003eSigma a-\u003eStateTy-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFA.html#v:compileToLBFA",
      "description": {
        "fct-descr": "\u003cp\u003eCompile a regular expression to a LBFA\n\u003c/p\u003e",
        "fct-module": "FST.LBFA",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Sigma a -\u003e StateTy -\u003e LBFA a",
        "fct-source": "src/FST-LBFA.html#compileToLBFA",
        "fct-type": "function",
        "title": "compileToLBFA"
      },
      "index": {
        "description": "Compile regular expression to LBFA",
        "hierarchy": "FST LBFA",
        "module": "FST.LBFA",
        "name": "compileToLBFA",
        "normalized": "Reg a-\u003eSigma a-\u003eStateTy-\u003eLBFA a",
        "package": "fst",
        "partial": "To LBFA",
        "signature": "Reg a-\u003eSigma a-\u003eStateTy-\u003eLBFA a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFA.html#v:initial",
      "description": {
        "fct-descr": "\u003cp\u003eGet the initial state of a LBFA\n\u003c/p\u003e",
        "fct-module": "FST.LBFA",
        "fct-package": "fst",
        "fct-signature": "LBFA a -\u003e StateTy",
        "fct-source": "src/FST-LBFA.html#initial",
        "fct-type": "function",
        "title": "initial"
      },
      "index": {
        "description": "Get the initial state of LBFA",
        "hierarchy": "FST LBFA",
        "module": "FST.LBFA",
        "name": "initial",
        "normalized": "LBFA a-\u003eStateTy",
        "package": "fst",
        "partial": "",
        "signature": "LBFA a-\u003eStateTy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLeft-biased finite transducers\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-LBFT.html",
        "fct-type": "module",
        "title": "LBFT"
      },
      "index": {
        "description": "Left-biased finite transducers",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "LBFT",
        "normalized": "",
        "package": "fst",
        "partial": "LBFT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#t:LBFT",
      "description": {
        "fct-descr": "\u003cp\u003eData type for a LBFT (left-biased finite transducer)\n\u003c/p\u003e",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-LBFT.html#LBFT",
        "fct-type": "data",
        "title": "LBFT"
      },
      "index": {
        "description": "Data type for LBFT left-biased finite transducer",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "LBFT",
        "normalized": "",
        "package": "fst",
        "partial": "LBFT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#v:LBFT",
      "description": {
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "LBFT",
        "fct-source": "src/FST-LBFT.html#LBFT",
        "fct-type": "function",
        "title": "LBFT"
      },
      "index": {
        "description": "",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "LBFT",
        "normalized": "",
        "package": "fst",
        "partial": "LBFT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#v:alpha",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "Sigma a",
        "fct-source": "src/FST-LBFT.html#LBFT",
        "fct-type": "function",
        "title": "alpha"
      },
      "index": {
        "description": "",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "alpha",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#v:compileToLBFT",
      "description": {
        "fct-descr": "\u003cp\u003eCompile a regular relation to a LBFT\n\u003c/p\u003e",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "RReg a -\u003e Sigma a -\u003e LBFT a",
        "fct-source": "src/FST-LBFT.html#compileToLBFT",
        "fct-type": "function",
        "title": "compileToLBFT"
      },
      "index": {
        "description": "Compile regular relation to LBFT",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "compileToLBFT",
        "normalized": "RReg a-\u003eSigma a-\u003eLBFT a",
        "package": "fst",
        "partial": "To LBFT",
        "signature": "RReg a-\u003eSigma a-\u003eLBFT a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#v:compileToTransducer",
      "description": {
        "fct-descr": "\u003cp\u003eCompile a regular relation to an minimal, useful and\n deterministic transducer, using the LBFT algorithm while building.\n\u003c/p\u003e",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "RReg a -\u003e Sigma a -\u003e Transducer a",
        "fct-source": "src/FST-LBFT.html#compileToTransducer",
        "fct-type": "function",
        "title": "compileToTransducer"
      },
      "index": {
        "description": "Compile regular relation to an minimal useful and deterministic transducer using the LBFT algorithm while building",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "compileToTransducer",
        "normalized": "RReg a-\u003eSigma a-\u003eTransducer a",
        "package": "fst",
        "partial": "To Transducer",
        "signature": "RReg a-\u003eSigma a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#v:finalS",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "[StateTy]",
        "fct-source": "src/FST-LBFT.html#LBFT",
        "fct-type": "function",
        "title": "finalS"
      },
      "index": {
        "description": "",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "finalS",
        "normalized": "[StateTy]",
        "package": "fst",
        "partial": "",
        "signature": "[StateTy]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#v:initS",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "StateTy",
        "fct-source": "src/FST-LBFT.html#LBFT",
        "fct-type": "function",
        "title": "initS"
      },
      "index": {
        "description": "",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "initS",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#v:lastS",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "StateTy",
        "fct-source": "src/FST-LBFT.html#LBFT",
        "fct-type": "function",
        "title": "lastS"
      },
      "index": {
        "description": "",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "lastS",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-LBFT.html#v:trans",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "FST.LBFT",
        "fct-package": "fst",
        "fct-signature": "TTransitionTable a",
        "fct-source": "src/FST-LBFT.html#LBFT",
        "fct-type": "function",
        "title": "trans"
      },
      "index": {
        "description": "",
        "hierarchy": "FST LBFT",
        "module": "FST.LBFT",
        "name": "trans",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNeutral regular expressions\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-NReg.html",
        "fct-type": "module",
        "title": "NReg"
      },
      "index": {
        "description": "Neutral regular expressions",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NReg",
        "normalized": "",
        "package": "fst",
        "partial": "NReg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#t:NReg",
      "description": {
        "fct-descr": "\u003cp\u003eNeutral regular expressions\n\u003c/p\u003e",
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "data",
        "title": "NReg"
      },
      "index": {
        "description": "Neutral regular expressions",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NReg",
        "normalized": "",
        "package": "fst",
        "partial": "NReg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:Fun",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "Fun String [NReg a]",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "Fun"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "Fun",
        "normalized": "Fun String[NReg a]",
        "package": "fst",
        "partial": "Fun",
        "signature": "Fun String[NReg a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NAll",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NAll",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NAll"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NAll",
        "normalized": "",
        "package": "fst",
        "partial": "NAll",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NComp",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NComp (NReg a) (NReg a)",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NComp"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NComp",
        "normalized": "",
        "package": "fst",
        "partial": "NComp",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NComplement",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NComplement (NReg a)",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NComplement"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NComplement",
        "normalized": "",
        "package": "fst",
        "partial": "NComplement",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NCross",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NCross (NReg a) (NReg a)",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NCross"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NCross",
        "normalized": "",
        "package": "fst",
        "partial": "NCross",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NEmptySet",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NEmptySet",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NEmptySet"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NEmptySet",
        "normalized": "",
        "package": "fst",
        "partial": "NEmpty Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NEpsilon",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NEpsilon",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NEpsilon"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NEpsilon",
        "normalized": "",
        "package": "fst",
        "partial": "NEpsilon",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NIntersect",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NIntersect (NReg a) (NReg a)",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NIntersect"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NIntersect",
        "normalized": "",
        "package": "fst",
        "partial": "NIntersect",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NProduct",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NProduct (NReg a) (NReg a)",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NProduct"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NProduct",
        "normalized": "",
        "package": "fst",
        "partial": "NProduct",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NRelation",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NRelation a a",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NRelation"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NRelation",
        "normalized": "",
        "package": "fst",
        "partial": "NRelation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NStar",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NStar (NReg a)",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NStar"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NStar",
        "normalized": "",
        "package": "fst",
        "partial": "NStar",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NSymbol",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NSymbol a",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NSymbol"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NSymbol",
        "normalized": "",
        "package": "fst",
        "partial": "NSymbol",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NUnion",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NUnion (NReg a) (NReg a)",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NUnion"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NUnion",
        "normalized": "",
        "package": "fst",
        "partial": "NUnion",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:NVar",
      "description": {
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NVar String",
        "fct-source": "src/FST-NReg.html#NReg",
        "fct-type": "function",
        "title": "NVar"
      },
      "index": {
        "description": "",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "NVar",
        "normalized": "",
        "package": "fst",
        "partial": "NVar",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:nVarToSymbol",
      "description": {
        "fct-descr": "\u003cp\u003eConvert variables to symbols\n\u003c/p\u003e",
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NReg String -\u003e NReg String",
        "fct-source": "src/FST-NReg.html#nVarToSymbol",
        "fct-type": "function",
        "title": "nVarToSymbol"
      },
      "index": {
        "description": "Convert variables to symbols",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "nVarToSymbol",
        "normalized": "NReg String-\u003eNReg String",
        "package": "fst",
        "partial": "Var To Symbol",
        "signature": "NReg String-\u003eNReg String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:toRReg",
      "description": {
        "fct-descr": "\u003cp\u003eIf possible, build a regular expression instead of a regular relation\n\u003c/p\u003e",
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NReg a -\u003e Maybe (RReg a)",
        "fct-source": "src/FST-NReg.html#toRReg",
        "fct-type": "function",
        "title": "toRReg"
      },
      "index": {
        "description": "If possible build regular expression instead of regular relation",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "toRReg",
        "normalized": "NReg a-\u003eMaybe(RReg a)",
        "package": "fst",
        "partial": "RReg",
        "signature": "NReg a-\u003eMaybe(RReg a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-NReg.html#v:toReg",
      "description": {
        "fct-descr": "\u003cp\u003eIf possible, converts NReg to Reg\n\u003c/p\u003e",
        "fct-module": "FST.NReg",
        "fct-package": "fst",
        "fct-signature": "NReg a -\u003e Maybe (Reg a)",
        "fct-source": "src/FST-NReg.html#toReg",
        "fct-type": "function",
        "title": "toReg"
      },
      "index": {
        "description": "If possible converts NReg to Reg",
        "hierarchy": "FST NReg",
        "module": "FST.NReg",
        "name": "toReg",
        "normalized": "NReg a-\u003eMaybe(Reg a)",
        "package": "fst",
        "partial": "Reg",
        "signature": "NReg a-\u003eMaybe(Reg a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions for constructing a simplified regular relation.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-RRegTypes.html",
        "fct-type": "module",
        "title": "RRegTypes"
      },
      "index": {
        "description": "Functions for constructing simplified regular relation",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "RRegTypes",
        "normalized": "",
        "package": "fst",
        "partial": "RReg Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#t:RReg",
      "description": {
        "fct-descr": "\u003cp\u003eDatatype for a regular relations\n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "data",
        "title": "RReg"
      },
      "index": {
        "description": "Datatype for regular relations",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "RReg",
        "normalized": "",
        "package": "fst",
        "partial": "RReg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:-60--42--62-",
      "description": {
        "fct-descr": "\u003cp\u003eCross product operator\n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Reg a -\u003e RReg a",
        "fct-source": "src/FST-RRegTypes.html#%3C%2A%3E",
        "fct-type": "function",
        "title": "(\u003c*\u003e)"
      },
      "index": {
        "description": "Cross product operator",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "(\u003c*\u003e) \u003c*\u003e",
        "normalized": "Reg a-\u003eReg a-\u003eRReg a",
        "package": "fst",
        "partial": "",
        "signature": "Reg a-\u003eReg a-\u003eRReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:-60-.-62-",
      "description": {
        "fct-descr": "\u003cp\u003eComposition operator\n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "RReg a -\u003e RReg a -\u003e RReg a",
        "fct-source": "src/FST-RRegTypes.html#%3C.%3E",
        "fct-type": "function",
        "title": "(\u003c.\u003e)"
      },
      "index": {
        "description": "Composition operator",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "(\u003c.\u003e) \u003c.\u003e",
        "normalized": "RReg a-\u003eRReg a-\u003eRReg a",
        "package": "fst",
        "partial": "",
        "signature": "RReg a-\u003eRReg a-\u003eRReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:Comp",
      "description": {
        "fct-descr": "\u003cp\u003eComposition       \n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "Comp (RReg a) (RReg a)",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "function",
        "title": "Comp"
      },
      "index": {
        "description": "Composition",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "Comp",
        "normalized": "",
        "package": "fst",
        "partial": "Comp",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:Cross",
      "description": {
        "fct-descr": "\u003cp\u003eCross product     \n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "Cross (Reg a) (Reg a)",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "function",
        "title": "Cross"
      },
      "index": {
        "description": "Cross product",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "Cross",
        "normalized": "",
        "package": "fst",
        "partial": "Cross",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:EmptyR",
      "description": {
        "fct-descr": "\u003cp\u003eEmpty language    \n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "EmptyR",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "function",
        "title": "EmptyR"
      },
      "index": {
        "description": "Empty language",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "EmptyR",
        "normalized": "",
        "package": "fst",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:Identity",
      "description": {
        "fct-descr": "\u003cp\u003eIdentity relation \n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "Identity (Reg a)",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "function",
        "title": "Identity"
      },
      "index": {
        "description": "Identity relation",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "Identity",
        "normalized": "",
        "package": "fst",
        "partial": "Identity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:ProductR",
      "description": {
        "fct-descr": "\u003cp\u003eConcatenation     \n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "ProductR (RReg a) (RReg a)",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "function",
        "title": "ProductR"
      },
      "index": {
        "description": "Concatenation",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "ProductR",
        "normalized": "",
        "package": "fst",
        "partial": "Product",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:Relation",
      "description": {
        "fct-descr": "\u003cp\u003e(a:b)             \n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "Relation (Symbol a) (Symbol a)",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "function",
        "title": "Relation"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "Relation",
        "normalized": "",
        "package": "fst",
        "partial": "Relation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:StarR",
      "description": {
        "fct-descr": "\u003cp\u003eKleene star       \n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "StarR (RReg a)",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "function",
        "title": "StarR"
      },
      "index": {
        "description": "Kleene star",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "StarR",
        "normalized": "",
        "package": "fst",
        "partial": "Star",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:UnionR",
      "description": {
        "fct-descr": "\u003cp\u003eUnion             \n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "UnionR (RReg a) (RReg a)",
        "fct-source": "src/FST-RRegTypes.html#RReg",
        "fct-type": "function",
        "title": "UnionR"
      },
      "index": {
        "description": "Union",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "UnionR",
        "normalized": "",
        "package": "fst",
        "partial": "Union",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:idR",
      "description": {
        "fct-descr": "\u003cp\u003eIdentity relation\n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e RReg a",
        "fct-source": "src/FST-RRegTypes.html#idR",
        "fct-type": "function",
        "title": "idR"
      },
      "index": {
        "description": "Identity relation",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "idR",
        "normalized": "Reg a-\u003eRReg a",
        "package": "fst",
        "partial": "",
        "signature": "Reg a-\u003eRReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RRegTypes.html#v:r",
      "description": {
        "fct-descr": "\u003cp\u003eRelation\n\u003c/p\u003e",
        "fct-module": "FST.RRegTypes",
        "fct-package": "fst",
        "fct-signature": "a -\u003e a -\u003e RReg a",
        "fct-source": "src/FST-RRegTypes.html#r",
        "fct-type": "function",
        "title": "r"
      },
      "index": {
        "description": "Relation",
        "hierarchy": "FST RRegTypes",
        "module": "FST.RRegTypes",
        "name": "r",
        "normalized": "a-\u003ea-\u003eRReg a",
        "package": "fst",
        "partial": "",
        "signature": "a-\u003ea-\u003eRReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions for constructing a simplified regular expression.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-RegTypes.html",
        "fct-type": "module",
        "title": "RegTypes"
      },
      "index": {
        "description": "Functions for constructing simplified regular expression",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "RegTypes",
        "normalized": "",
        "package": "fst",
        "partial": "Reg Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#t:Combinators",
      "description": {
        "fct-descr": "\u003cp\u003eCombinators. The regular expressions are simplified while combined.\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "class",
        "fct-source": "src/FST-RegTypes.html#Combinators",
        "fct-type": "class",
        "title": "Combinators"
      },
      "index": {
        "description": "Combinators The regular expressions are simplified while combined",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "Combinators",
        "normalized": "",
        "package": "fst",
        "partial": "Combinators",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#t:Reg",
      "description": {
        "fct-descr": "\u003cp\u003eData type for a regular expression.\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "data",
        "title": "Reg"
      },
      "index": {
        "description": "Data type for regular expression",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "Reg",
        "normalized": "",
        "package": "fst",
        "partial": "Reg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#t:Symbols",
      "description": {
        "fct-descr": "\u003cp\u003eType class for the collection of symbols in an expression.\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "class",
        "fct-source": "src/FST-RegTypes.html#Symbols",
        "fct-type": "class",
        "title": "Symbols"
      },
      "index": {
        "description": "Type class for the collection of symbols in an expression",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "Symbols",
        "normalized": "",
        "package": "fst",
        "partial": "Symbols",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:-124--62-",
      "description": {
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "(|\u003e)",
        "fct-source": "src/FST-RegTypes.html#%7C%3E",
        "fct-type": "method",
        "title": "(|\u003e)"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "(|\u003e) |\u003e",
        "normalized": "()",
        "package": "fst",
        "partial": "",
        "signature": "()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:-60--124--62-",
      "description": {
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "(\u003c|\u003e)",
        "fct-source": "src/FST-RegTypes.html#%3C%7C%3E",
        "fct-type": "method",
        "title": "(\u003c|\u003e)"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "(\u003c|\u003e) \u003c|\u003e",
        "normalized": "()",
        "package": "fst",
        "partial": "",
        "signature": "()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:-60--38--62-",
      "description": {
        "fct-descr": "\u003cp\u003eIntersection \n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Reg a -\u003e Reg a",
        "fct-source": "src/FST-RegTypes.html#%3C%26%3E",
        "fct-type": "function",
        "title": "(\u003c&\u003e)"
      },
      "index": {
        "description": "Intersection",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "(\u003c&\u003e) \u003c&\u003e",
        "normalized": "Reg a-\u003eReg a-\u003eReg a",
        "package": "fst",
        "partial": "",
        "signature": "Reg a-\u003eReg a-\u003eReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:-60--45--62-",
      "description": {
        "fct-descr": "\u003cp\u003eMinus. Definition A - B = A & ~B \n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Reg a -\u003e Reg a",
        "fct-source": "src/FST-RegTypes.html#%3C-%3E",
        "fct-type": "function",
        "title": "(\u003c-\u003e)"
      },
      "index": {
        "description": "Minus Definition",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "(\u003c-\u003e) \u003c-\u003e",
        "normalized": "Reg a-\u003eReg a-\u003eReg a",
        "package": "fst",
        "partial": "",
        "signature": "Reg a-\u003eReg a-\u003eReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v::-124-:",
      "description": {
        "fct-descr": "\u003cdl\u003e\u003cdt\u003e r1 | r2 \u003c/dt\u003e\u003cdd\u003e\n\u003c/dd\u003e\u003c/dl\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "(Reg a) :|: (Reg a)",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": ":|:"
      },
      "index": {
        "description": "r1 r2",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": ":|:",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v::-38-:",
      "description": {
        "fct-descr": "\u003cdl\u003e\u003cdt\u003e r1 & r2 \u003c/dt\u003e\u003cdd\u003e\n\u003c/dd\u003e\u003c/dl\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "(Reg a) :&: (Reg a)",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": ":&:"
      },
      "index": {
        "description": "r1 r2",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": ":&:",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v::.:",
      "description": {
        "fct-descr": "\u003cdl\u003e\u003cdt\u003e r1 r2 \u003c/dt\u003e\u003cdd\u003e\n\u003c/dd\u003e\u003c/dl\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "(Reg a) :.: (Reg a)",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": ":.:"
      },
      "index": {
        "description": "r1 r2",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": ":.:",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:All",
      "description": {
        "fct-descr": "\u003cp\u003e?\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "All",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": "All"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "All",
        "normalized": "",
        "package": "fst",
        "partial": "All",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:Complement",
      "description": {
        "fct-descr": "\u003cp\u003e~[ r1 ]\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Complement (Reg a)",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": "Complement"
      },
      "index": {
        "description": "r1",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "Complement",
        "normalized": "",
        "package": "fst",
        "partial": "Complement",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:Empty",
      "description": {
        "fct-descr": "\u003cdl\u003e\u003cdt\u003e \u003c/dt\u003e\u003cdd\u003e\n\u003c/dd\u003e\u003c/dl\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Empty",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": "Empty"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "Empty",
        "normalized": "",
        "package": "fst",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:Epsilon",
      "description": {
        "fct-descr": "\u003cp\u003e0\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Epsilon",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": "Epsilon"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "Epsilon",
        "normalized": "",
        "package": "fst",
        "partial": "Epsilon",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:Star",
      "description": {
        "fct-descr": "\u003cdl\u003e\u003cdt\u003e r2 \u003c/dt\u003e\u003cdd\u003e*\n\u003c/dd\u003e\u003c/dl\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Star (Reg a)",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": "Star"
      },
      "index": {
        "description": "r2",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "Star",
        "normalized": "",
        "package": "fst",
        "partial": "Star",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:Symbol",
      "description": {
        "fct-descr": "\u003cp\u003ea\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Symbol a",
        "fct-source": "src/FST-RegTypes.html#Reg",
        "fct-type": "function",
        "title": "Symbol"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "Symbol",
        "normalized": "",
        "package": "fst",
        "partial": "Symbol",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:acceptEps",
      "description": {
        "fct-descr": "\u003cp\u003eExamines if a regular expression accepts the empty string.\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Bool",
        "fct-source": "src/FST-RegTypes.html#acceptEps",
        "fct-type": "function",
        "title": "acceptEps"
      },
      "index": {
        "description": "Examines if regular expression accepts the empty string",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "acceptEps",
        "normalized": "Reg a-\u003eBool",
        "package": "fst",
        "partial": "Eps",
        "signature": "Reg a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:allFree",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a ?-free regular expression with respect to an alphabet [a]\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e [a] -\u003e Reg a",
        "fct-source": "src/FST-RegTypes.html#allFree",
        "fct-type": "function",
        "title": "allFree"
      },
      "index": {
        "description": "Construct free regular expression with respect to an alphabet",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "allFree",
        "normalized": "Reg a-\u003e[a]-\u003eReg a",
        "package": "fst",
        "partial": "Free",
        "signature": "Reg a-\u003e[a]-\u003eReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:allS",
      "description": {
        "fct-descr": "\u003cp\u003eAll symbol\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a",
        "fct-source": "src/FST-RegTypes.html#allS",
        "fct-type": "function",
        "title": "allS"
      },
      "index": {
        "description": "All symbol",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "allS",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:allToSymbols",
      "description": {
        "fct-descr": "\u003cp\u003eTransform the \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e symbol to union over alphabet. ? -\u003e [a|..] with respect to an alphabet [a]\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "[a] -\u003e Reg a",
        "fct-source": "src/FST-RegTypes.html#allToSymbols",
        "fct-type": "function",
        "title": "allToSymbols"
      },
      "index": {
        "description": "Transform the all symbol to union over alphabet with respect to an alphabet",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "allToSymbols",
        "normalized": "[a]-\u003eReg a",
        "package": "fst",
        "partial": "To Symbols",
        "signature": "[a]-\u003eReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:complement",
      "description": {
        "fct-descr": "\u003cp\u003eComplement\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Reg a",
        "fct-source": "src/FST-RegTypes.html#complement",
        "fct-type": "function",
        "title": "complement"
      },
      "index": {
        "description": "Complement",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "complement",
        "normalized": "Reg a-\u003eReg a",
        "package": "fst",
        "partial": "",
        "signature": "Reg a-\u003eReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:empty",
      "description": {
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "empty",
        "fct-source": "src/FST-RegTypes.html#empty",
        "fct-type": "method",
        "title": "empty"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "empty",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:eps",
      "description": {
        "fct-descr": "\u003cp\u003eEpsilon\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a",
        "fct-source": "src/FST-RegTypes.html#eps",
        "fct-type": "function",
        "title": "eps"
      },
      "index": {
        "description": "Epsilon",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "eps",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:plus",
      "description": {
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "plus",
        "fct-source": "src/FST-RegTypes.html#plus",
        "fct-type": "method",
        "title": "plus"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "plus",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:reversal",
      "description": {
        "fct-descr": "\u003cp\u003eReverse the language denoted by the regular expression.\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "Reg a -\u003e Reg a",
        "fct-source": "src/FST-RegTypes.html#reversal",
        "fct-type": "function",
        "title": "reversal"
      },
      "index": {
        "description": "Reverse the language denoted by the regular expression",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "reversal",
        "normalized": "Reg a-\u003eReg a",
        "package": "fst",
        "partial": "",
        "signature": "Reg a-\u003eReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:s",
      "description": {
        "fct-descr": "\u003cp\u003eSymbol\n\u003c/p\u003e",
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "a -\u003e Reg a",
        "fct-source": "src/FST-RegTypes.html#s",
        "fct-type": "function",
        "title": "s"
      },
      "index": {
        "description": "Symbol",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "s",
        "normalized": "a-\u003eReg a",
        "package": "fst",
        "partial": "",
        "signature": "a-\u003eReg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:star",
      "description": {
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "star",
        "fct-source": "src/FST-RegTypes.html#star",
        "fct-type": "method",
        "title": "star"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "star",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RegTypes.html#v:symbols",
      "description": {
        "fct-module": "FST.RegTypes",
        "fct-package": "fst",
        "fct-signature": "symbols",
        "fct-source": "src/FST-RegTypes.html#symbols",
        "fct-type": "method",
        "title": "symbols"
      },
      "index": {
        "description": "",
        "hierarchy": "FST RegTypes",
        "module": "FST.RegTypes",
        "name": "symbols",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Reversal.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReverse an automaton\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.Reversal",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-Reversal.html",
        "fct-type": "module",
        "title": "Reversal"
      },
      "index": {
        "description": "Reverse an automaton",
        "hierarchy": "FST Reversal",
        "module": "FST.Reversal",
        "name": "Reversal",
        "normalized": "",
        "package": "fst",
        "partial": "Reversal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Reversal.html#v:reversal",
      "description": {
        "fct-descr": "\u003cp\u003eReverse an automaton\n\u003c/p\u003e",
        "fct-module": "FST.Reversal",
        "fct-package": "fst",
        "fct-signature": "Automaton a -\u003e Automaton a",
        "fct-source": "src/FST-Reversal.html#reversal",
        "fct-type": "function",
        "title": "reversal"
      },
      "index": {
        "description": "Reverse an automaton",
        "hierarchy": "FST Reversal",
        "module": "FST.Reversal",
        "name": "reversal",
        "normalized": "Automaton a-\u003eAutomaton a",
        "package": "fst",
        "partial": "",
        "signature": "Automaton a-\u003eAutomaton a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-ReversalT.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReverse an transducer\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.ReversalT",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-ReversalT.html",
        "fct-type": "module",
        "title": "ReversalT"
      },
      "index": {
        "description": "Reverse an transducer",
        "hierarchy": "FST ReversalT",
        "module": "FST.ReversalT",
        "name": "ReversalT",
        "normalized": "",
        "package": "fst",
        "partial": "Reversal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-ReversalT.html#v:reversal",
      "description": {
        "fct-descr": "\u003cp\u003eReverse a transducer\n\u003c/p\u003e",
        "fct-module": "FST.ReversalT",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-ReversalT.html#reversal",
        "fct-type": "function",
        "title": "reversal"
      },
      "index": {
        "description": "Reverse transducer",
        "hierarchy": "FST ReversalT",
        "module": "FST.ReversalT",
        "name": "reversal",
        "normalized": "Transducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RunTransducer.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRunning a transducer with some input\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.RunTransducer",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-RunTransducer.html",
        "fct-type": "module",
        "title": "RunTransducer"
      },
      "index": {
        "description": "Running transducer with some input",
        "hierarchy": "FST RunTransducer",
        "module": "FST.RunTransducer",
        "name": "RunTransducer",
        "normalized": "",
        "package": "fst",
        "partial": "Run Transducer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RunTransducer.html#v:applyDown",
      "description": {
        "fct-descr": "\u003cp\u003eApply a transducer downwards\n\u003c/p\u003e",
        "fct-module": "FST.RunTransducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e [a] -\u003e Maybe [[a]]",
        "fct-source": "src/FST-RunTransducer.html#applyDown",
        "fct-type": "function",
        "title": "applyDown"
      },
      "index": {
        "description": "Apply transducer downwards",
        "hierarchy": "FST RunTransducer",
        "module": "FST.RunTransducer",
        "name": "applyDown",
        "normalized": "Transducer a-\u003e[a]-\u003eMaybe[[a]]",
        "package": "fst",
        "partial": "Down",
        "signature": "Transducer a-\u003e[a]-\u003eMaybe[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-RunTransducer.html#v:applyUp",
      "description": {
        "fct-descr": "\u003cp\u003eApply a transducer upwards\n\u003c/p\u003e",
        "fct-module": "FST.RunTransducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e [a] -\u003e Maybe [[a]]",
        "fct-source": "src/FST-RunTransducer.html#applyUp",
        "fct-type": "function",
        "title": "applyUp"
      },
      "index": {
        "description": "Apply transducer upwards",
        "hierarchy": "FST RunTransducer",
        "module": "FST.RunTransducer",
        "name": "applyUp",
        "normalized": "Transducer a-\u003e[a]-\u003eMaybe[[a]]",
        "package": "fst",
        "partial": "Up",
        "signature": "Transducer a-\u003e[a]-\u003eMaybe[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTransducers and their functions\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-Transducer.html",
        "fct-type": "module",
        "title": "Transducer"
      },
      "index": {
        "description": "Transducers and their functions",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "Transducer",
        "normalized": "",
        "package": "fst",
        "partial": "Transducer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#t:TConvertable",
      "description": {
        "fct-descr": "\u003cp\u003eType class TConvertable\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "class",
        "fct-source": "src/FST-Transducer.html#TConvertable",
        "fct-type": "class",
        "title": "TConvertable"
      },
      "index": {
        "description": "Type class TConvertable",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "TConvertable",
        "normalized": "",
        "package": "fst",
        "partial": "TConvertable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#t:Transducer",
      "description": {
        "fct-descr": "\u003cp\u003eData type for a transducer\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-Transducer.html#Transducer",
        "fct-type": "data",
        "title": "Transducer"
      },
      "index": {
        "description": "Data type for transducer",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "Transducer",
        "normalized": "",
        "package": "fst",
        "partial": "Transducer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:compositionT",
      "description": {
        "fct-descr": "\u003cp\u003eCompose two transducers\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#compositionT",
        "fct-type": "function",
        "title": "compositionT"
      },
      "index": {
        "description": "Compose two transducers",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "compositionT",
        "normalized": "Transducer a-\u003eTransducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:construct",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a transducer\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "(StateTy, StateTy) -\u003e TTransitionTable a -\u003e Sigma a -\u003e InitialStates -\u003e FinalStates -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#construct",
        "fct-type": "function",
        "title": "construct"
      },
      "index": {
        "description": "Construct transducer",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "construct",
        "normalized": "(StateTy,StateTy)-\u003eTTransitionTable a-\u003eSigma a-\u003eInitialStates-\u003eFinalStates-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "(StateTy,StateTy)-\u003eTTransitionTable a-\u003eSigma a-\u003eInitialStates-\u003eFinalStates-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:decode",
      "description": {
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e f a",
        "fct-source": "src/FST-Transducer.html#decode",
        "fct-type": "method",
        "title": "decode"
      },
      "index": {
        "description": "",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "decode",
        "normalized": "Transducer a-\u003eb a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:encode",
      "description": {
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#encode",
        "fct-type": "method",
        "title": "encode"
      },
      "index": {
        "description": "",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "encode",
        "normalized": "a b-\u003eTransducer b",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:initial",
      "description": {
        "fct-descr": "\u003cp\u003eInitial state\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e StateTy",
        "fct-source": "src/FST-Transducer.html#initial",
        "fct-type": "function",
        "title": "initial"
      },
      "index": {
        "description": "Initial state",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "initial",
        "normalized": "Transducer a-\u003eStateTy",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eStateTy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:nullFirstState",
      "description": {
        "fct-descr": "\u003cp\u003eSet first state to null\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#nullFirstState",
        "fct-type": "function",
        "title": "nullFirstState"
      },
      "index": {
        "description": "Set first state to null",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "nullFirstState",
        "normalized": "Transducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "First State",
        "signature": "Transducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:productT",
      "description": {
        "fct-descr": "\u003cp\u003eProduct of two transducers\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#productT",
        "fct-type": "function",
        "title": "productT"
      },
      "index": {
        "description": "Product of two transducers",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "productT",
        "normalized": "Transducer a-\u003eTransducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:rename",
      "description": {
        "fct-descr": "\u003cp\u003eConvert transducer labelled with something other than states to a Transducer\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "[(b, [(Relation a, b)])] -\u003e Sigma a -\u003e [b] -\u003e [b] -\u003e StateTy -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#rename",
        "fct-type": "function",
        "title": "rename"
      },
      "index": {
        "description": "Convert transducer labelled with something other than states to Transducer",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "rename",
        "normalized": "[(a,[(Relation b,a)])]-\u003eSigma b-\u003e[a]-\u003e[a]-\u003eStateTy-\u003eTransducer b",
        "package": "fst",
        "partial": "",
        "signature": "[(b,[(Relation a,b)])]-\u003eSigma a-\u003e[b]-\u003e[b]-\u003eStateTy-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:showTransducer",
      "description": {
        "fct-descr": "\u003cp\u003eShow a transducer\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e String",
        "fct-source": "src/FST-Transducer.html#showTransducer",
        "fct-type": "function",
        "title": "showTransducer"
      },
      "index": {
        "description": "Show transducer",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "showTransducer",
        "normalized": "Transducer a-\u003eString",
        "package": "fst",
        "partial": "Transducer",
        "signature": "Transducer a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:starT",
      "description": {
        "fct-descr": "\u003cp\u003eKleene star of two transducers\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#starT",
        "fct-type": "function",
        "title": "starT"
      },
      "index": {
        "description": "Kleene star of two transducers",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "starT",
        "normalized": "Transducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:transitions",
      "description": {
        "fct-descr": "\u003cp\u003eGet transition as a list of states\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e (StateTy, Relation a) -\u003e [StateTy]",
        "fct-source": "src/FST-Transducer.html#transitions",
        "fct-type": "function",
        "title": "transitions"
      },
      "index": {
        "description": "Get transition as list of states",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "transitions",
        "normalized": "Transducer a-\u003e(StateTy,Relation a)-\u003e[StateTy]",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003e(StateTy,Relation a)-\u003e[StateTy]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-Transducer.html#v:unionT",
      "description": {
        "fct-descr": "\u003cp\u003eUnion of two transducers\n\u003c/p\u003e",
        "fct-module": "FST.Transducer",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#unionT",
        "fct-type": "function",
        "title": "unionT"
      },
      "index": {
        "description": "Union of two transducers",
        "hierarchy": "FST Transducer",
        "module": "FST.Transducer",
        "name": "unionT",
        "normalized": "Transducer a-\u003eTransducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMain API for finite-state transducer library.\nImporting this module gives you access to the folllowing functions.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eRegular expressions\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eFunctions for constructing a simplified regular expression.\n\u003c/p\u003e\u003cpre\u003e s          :: a -\u003e Reg a              -- symbol\n eps        :: Reg a                   -- epsilon\n empty      :: Reg a                   -- empty set\n allS       :: Reg a                   -- all symbol\n star       :: Reg a -\u003e Reg a          -- kleene&#8217;s star\n plus       :: Reg a -\u003e Reg a          -- kleene&#8217;s plus\n complement :: Reg a -\u003e Reg a          -- complement\n (\u003c|\u003e)      :: Reg a -\u003e Reg a -\u003e Reg a -- union\n (|\u003e)       :: Reg a -\u003e Reg a -\u003e Reg a -- product\n (\u003c&\u003e)      :: Reg a -\u003e Reg a -\u003e Reg a -- intersection\n (\u003c-\u003e)      :: Reg a -\u003e Reg a -\u003e Reg a -- set minus\n symbols    :: Reg a -\u003e a              -- collect all symbols.\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eRegular relations\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eFunctions for constructing a simplified regular relation.\n\u003c/p\u003e\u003cpre\u003e r       :: a -\u003e a -\u003e Reg a            -- relation\n empty   :: RReg a                     -- empty set\n idR     :: Reg a -\u003e RReg a            -- identity\n star    :: RReg a -\u003e RReg a           -- kleene&#8217;s star\n plus    :: RReg a -\u003e RReg a           -- kleene&#8217;s plus\n (\u003c|\u003e)   :: RReg a -\u003e RReg a -\u003e RReg a -- union\n (|\u003e)    :: RReg a -\u003e RReg a -\u003e RReg a -- product\n (\u003c*\u003e)   :: Reg a -\u003e Reg a -\u003e RReg a   -- cross product\n (\u003c.\u003e)   :: RReg a -\u003e RReg a -\u003e RReg a -- composition\n symbols :: RReg a -\u003e a                -- collect all symbols\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eParsing regular relations\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eFunctions for parsing regular relations.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eparseProgram\u003c/a\u003e\u003c/code\u003e takes a string containing a fstStudio program, and try\nto parse it - if unsuccessful, it returns a error message. \u003ccode\u003e\u003ca\u003eparseExp\u003c/a\u003e\u003c/code\u003e parses a\nstring containing a regular relation.\n\u003c/p\u003e\u003cpre\u003e parseProgram :: String -\u003e Either String (RReg String)\n parseExp     :: String -\u003e Either String (RReg String)\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eConstruction and running\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eFunctions for constructing and running a nite state transducer.\nThe function \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e construct a deterministic, epsilonfree, minimal\ntransducer, and \u003ccode\u003e\u003ca\u003ecompileN\u003c/a\u003e\u003c/code\u003e construct a epsilonfree, possibly non-deterministic,\nnon-minimal transducer. The \u003ccode\u003e\u003ca\u003eSigma\u003c/a\u003e\u003c/code\u003e type provides a way to add symbols\nthat is not present in the regular relation. \u003ccode\u003e\u003ca\u003eapplyDown\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eapplyUp\u003c/a\u003e\u003c/code\u003e are\nused to run the transducer.\n\u003c/p\u003e\u003cpre\u003e type Sigma a = [a]\n\n compile         :: Ord a =\u003e RReg a -\u003e Sigma a -\u003e Transducer a\n compileN        :: Ord a =\u003e RReg a -\u003e Sigma a -\u003e Transducer a\n determinize     :: Ord a =\u003e Transducer a -\u003e Transducer a\n minimize        :: Ord a =\u003e Transducer a -\u003e Transducer a\n unionT          :: Ord a =\u003e Transducer a -\u003e Transducer a -\u003e Transducer a\n productT        :: Ord a =\u003e Transducer a -\u003e Transducer a -\u003e Transducer a\n starT           :: Ord a =\u003e Transducer a -\u003e Transducer a\n compositionT    :: Ord a =\u003e Transducer a -\u003e Transducer a -\u003e Transducer a\n emptyTransducer :: Transducer a\n applyDown       :: Ord a =\u003e Transducer a -\u003e [a] -\u003e Maybe [[a]]\n applyUp         :: Ord a =\u003e Transducer a -\u003e [a] -\u003e Maybe [[a]]\n load            :: FilePath -\u003e IO (Either String (Transducer String))\n save            :: FilePath -\u003e Transducer String -\u003e IO (Either String ())\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eTransducer Information\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eFunctions for getting information about a built transducer.\n\u003c/p\u003e\u003cp\u003etype StateTy = Int\n\u003c/p\u003e\u003cpre\u003e states              :: Transducer a -\u003e [StateTy]\n isFinal             :: Transducer a -\u003e StateTy -\u003e Bool\n initial             :: Transducer a -\u003e StateTy\n finals              :: Transducer a -\u003e [StateTy]\n transitonsU         :: Transducer a -\u003e (StateTy,a) -\u003e [(a,StateTy)]\n transitionsD        :: Transducer a -\u003e (StateTy,a) -\u003e [(a,StateTy)]\n showTransducer      :: Transducer a -\u003e String\n numberOfStates      :: Transducer a -\u003e Int\n numberOfTransitions :: Transducer a -\u003e Int\n\u003c/pre\u003e\u003c/div\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-TransducerInterface.html",
        "fct-type": "module",
        "title": "TransducerInterface"
      },
      "index": {
        "description": "Main API for finite-state transducer library Importing this module gives you access to the folllowing functions Regular expressions Functions for constructing simplified regular expression Reg symbol eps Reg epsilon empty Reg empty set allS Reg all symbol star Reg Reg kleene star plus Reg Reg kleene plus complement Reg Reg complement Reg Reg Reg union Reg Reg Reg product Reg Reg Reg intersection Reg Reg Reg set minus symbols Reg collect all symbols Regular relations Functions for constructing simplified regular relation Reg relation empty RReg empty set idR Reg RReg identity star RReg RReg kleene star plus RReg RReg kleene plus RReg RReg RReg union RReg RReg RReg product Reg Reg RReg cross product RReg RReg RReg composition symbols RReg collect all symbols Parsing regular relations Functions for parsing regular relations parseProgram takes string containing fstStudio program and try to parse it if unsuccessful it returns error message parseExp parses string containing regular relation parseProgram String Either String RReg String parseExp String Either String RReg String Construction and running Functions for constructing and running nite state transducer The function compile construct deterministic epsilonfree minimal transducer and compileN construct epsilonfree possibly non-deterministic non-minimal transducer The Sigma type provides way to add symbols that is not present in the regular relation applyDown and applyUp are used to run the transducer type Sigma compile Ord RReg Sigma Transducer compileN Ord RReg Sigma Transducer determinize Ord Transducer Transducer minimize Ord Transducer Transducer unionT Ord Transducer Transducer Transducer productT Ord Transducer Transducer Transducer starT Ord Transducer Transducer compositionT Ord Transducer Transducer Transducer emptyTransducer Transducer applyDown Ord Transducer Maybe applyUp Ord Transducer Maybe load FilePath IO Either String Transducer String save FilePath Transducer String IO Either String Transducer Information Functions for getting information about built transducer type StateTy Int states Transducer StateTy isFinal Transducer StateTy Bool initial Transducer StateTy finals Transducer StateTy transitonsU Transducer StateTy StateTy transitionsD Transducer StateTy StateTy showTransducer Transducer String numberOfStates Transducer Int numberOfTransitions Transducer Int",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "TransducerInterface",
        "normalized": "",
        "package": "fst",
        "partial": "Transducer Interface",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#t:Transducer",
      "description": {
        "fct-descr": "\u003cp\u003eData type for a transducer\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-Transducer.html#Transducer",
        "fct-type": "data",
        "title": "Transducer"
      },
      "index": {
        "description": "Data type for transducer",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "Transducer",
        "normalized": "",
        "package": "fst",
        "partial": "Transducer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:applyDown",
      "description": {
        "fct-descr": "\u003cp\u003eApply a transducer downwards\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e [a] -\u003e Maybe [[a]]",
        "fct-source": "src/FST-RunTransducer.html#applyDown",
        "fct-type": "function",
        "title": "applyDown"
      },
      "index": {
        "description": "Apply transducer downwards",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "applyDown",
        "normalized": "Transducer a-\u003e[a]-\u003eMaybe[[a]]",
        "package": "fst",
        "partial": "Down",
        "signature": "Transducer a-\u003e[a]-\u003eMaybe[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:applyUp",
      "description": {
        "fct-descr": "\u003cp\u003eApply a transducer upwards\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e [a] -\u003e Maybe [[a]]",
        "fct-source": "src/FST-RunTransducer.html#applyUp",
        "fct-type": "function",
        "title": "applyUp"
      },
      "index": {
        "description": "Apply transducer upwards",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "applyUp",
        "normalized": "Transducer a-\u003e[a]-\u003eMaybe[[a]]",
        "package": "fst",
        "partial": "Up",
        "signature": "Transducer a-\u003e[a]-\u003eMaybe[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:compile",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a deterministic, epsilon-free, minimal transducer\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "RReg a -\u003e Sigma a -\u003e Transducer a",
        "fct-source": "src/FST-TransducerInterface.html#compile",
        "fct-type": "function",
        "title": "compile"
      },
      "index": {
        "description": "Construct deterministic epsilon-free minimal transducer",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "compile",
        "normalized": "RReg a-\u003eSigma a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "RReg a-\u003eSigma a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:compileN",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct an epsilon-free, possibly non-deterministic, non-minimal transducer\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "RReg a -\u003e Sigma a -\u003e Transducer a",
        "fct-source": "src/FST-TransducerInterface.html#compileN",
        "fct-type": "function",
        "title": "compileN"
      },
      "index": {
        "description": "Construct an epsilon-free possibly non-deterministic non-minimal transducer",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "compileN",
        "normalized": "RReg a-\u003eSigma a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "RReg a-\u003eSigma a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:compositionT",
      "description": {
        "fct-descr": "\u003cp\u003eCompose two transducers\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#compositionT",
        "fct-type": "function",
        "title": "compositionT"
      },
      "index": {
        "description": "Compose two transducers",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "compositionT",
        "normalized": "Transducer a-\u003eTransducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:determinize",
      "description": {
        "fct-descr": "\u003cp\u003eMake a transducer deterministic\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-TransducerInterface.html#determinize",
        "fct-type": "function",
        "title": "determinize"
      },
      "index": {
        "description": "Make transducer deterministic",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "determinize",
        "normalized": "Transducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:emptyTransducer",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty transucer\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a",
        "fct-source": "src/FST-TransducerInterface.html#emptyTransducer",
        "fct-type": "function",
        "title": "emptyTransducer"
      },
      "index": {
        "description": "The empty transucer",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "emptyTransducer",
        "normalized": "",
        "package": "fst",
        "partial": "Transducer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:load",
      "description": {
        "fct-descr": "\u003cp\u003eLoad a transducer from file\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "FilePath -\u003e ErrorT String IO (Transducer String)",
        "fct-source": "src/FST-TransducerInterface.html#load",
        "fct-type": "function",
        "title": "load"
      },
      "index": {
        "description": "Load transducer from file",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "load",
        "normalized": "FilePath-\u003eErrorT String IO(Transducer String)",
        "package": "fst",
        "partial": "",
        "signature": "FilePath-\u003eErrorT String IO(Transducer String)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:minimize",
      "description": {
        "fct-descr": "\u003cp\u003eMake a transducer minimal\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-TransducerInterface.html#minimize",
        "fct-type": "function",
        "title": "minimize"
      },
      "index": {
        "description": "Make transducer minimal",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "minimize",
        "normalized": "Transducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:numberOfStates",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the number of states in a transducer\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Int",
        "fct-source": "src/FST-TransducerInterface.html#numberOfStates",
        "fct-type": "function",
        "title": "numberOfStates"
      },
      "index": {
        "description": "Return the number of states in transducer",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "numberOfStates",
        "normalized": "Transducer a-\u003eInt",
        "package": "fst",
        "partial": "Of States",
        "signature": "Transducer a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:numberOfTransitions",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the number of transitions in a transducer\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Int",
        "fct-source": "src/FST-TransducerInterface.html#numberOfTransitions",
        "fct-type": "function",
        "title": "numberOfTransitions"
      },
      "index": {
        "description": "Return the number of transitions in transducer",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "numberOfTransitions",
        "normalized": "Transducer a-\u003eInt",
        "package": "fst",
        "partial": "Of Transitions",
        "signature": "Transducer a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:open",
      "description": {
        "fct-descr": "\u003cp\u003eOpen a file and return contents as string\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "FilePath -\u003e ErrorT String IO String",
        "fct-source": "src/FST-TransducerInterface.html#open",
        "fct-type": "function",
        "title": "open"
      },
      "index": {
        "description": "Open file and return contents as string",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "open",
        "normalized": "FilePath-\u003eErrorT String IO String",
        "package": "fst",
        "partial": "",
        "signature": "FilePath-\u003eErrorT String IO String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:parseExp",
      "description": {
        "fct-descr": "\u003cp\u003eParse a regular expression from a string\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "String -\u003e Either String (RReg String)",
        "fct-source": "src/FST-Parse.html#parseExp",
        "fct-type": "function",
        "title": "parseExp"
      },
      "index": {
        "description": "Parse regular expression from string",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "parseExp",
        "normalized": "String-\u003eEither String(RReg String)",
        "package": "fst",
        "partial": "Exp",
        "signature": "String-\u003eEither String(RReg String)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:parseProgram",
      "description": {
        "fct-descr": "\u003cp\u003eParse a program from a string\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "String -\u003e Either String (RReg String)",
        "fct-source": "src/FST-Parse.html#parseProgram",
        "fct-type": "function",
        "title": "parseProgram"
      },
      "index": {
        "description": "Parse program from string",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "parseProgram",
        "normalized": "String-\u003eEither String(RReg String)",
        "package": "fst",
        "partial": "Program",
        "signature": "String-\u003eEither String(RReg String)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:productT",
      "description": {
        "fct-descr": "\u003cp\u003eProduct of two transducers\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#productT",
        "fct-type": "function",
        "title": "productT"
      },
      "index": {
        "description": "Product of two transducers",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "productT",
        "normalized": "Transducer a-\u003eTransducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:save",
      "description": {
        "fct-descr": "\u003cp\u003eSave a transducer from file\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "FilePath -\u003e Transducer String -\u003e ErrorT String IO ()",
        "fct-source": "src/FST-TransducerInterface.html#save",
        "fct-type": "function",
        "title": "save"
      },
      "index": {
        "description": "Save transducer from file",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "save",
        "normalized": "FilePath-\u003eTransducer String-\u003eErrorT String IO()",
        "package": "fst",
        "partial": "",
        "signature": "FilePath-\u003eTransducer String-\u003eErrorT String IO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:saveToFile",
      "description": {
        "fct-descr": "\u003cp\u003eSave contents (as string) to a file\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "FilePath -\u003e String -\u003e ErrorT String IO ()",
        "fct-source": "src/FST-TransducerInterface.html#saveToFile",
        "fct-type": "function",
        "title": "saveToFile"
      },
      "index": {
        "description": "Save contents as string to file",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "saveToFile",
        "normalized": "FilePath-\u003eString-\u003eErrorT String IO()",
        "package": "fst",
        "partial": "To File",
        "signature": "FilePath-\u003eString-\u003eErrorT String IO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:showTransducer",
      "description": {
        "fct-descr": "\u003cp\u003eShow a transducer\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e String",
        "fct-source": "src/FST-Transducer.html#showTransducer",
        "fct-type": "function",
        "title": "showTransducer"
      },
      "index": {
        "description": "Show transducer",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "showTransducer",
        "normalized": "Transducer a-\u003eString",
        "package": "fst",
        "partial": "Transducer",
        "signature": "Transducer a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:starT",
      "description": {
        "fct-descr": "\u003cp\u003eKleene star of two transducers\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#starT",
        "fct-type": "function",
        "title": "starT"
      },
      "index": {
        "description": "Kleene star of two transducers",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "starT",
        "normalized": "Transducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:transitions",
      "description": {
        "fct-descr": "\u003cp\u003eGet transition as a list of states\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e (StateTy, Relation a) -\u003e [StateTy]",
        "fct-source": "src/FST-Transducer.html#transitions",
        "fct-type": "function",
        "title": "transitions"
      },
      "index": {
        "description": "Get transition as list of states",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "transitions",
        "normalized": "Transducer a-\u003e(StateTy,Relation a)-\u003e[StateTy]",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003e(StateTy,Relation a)-\u003e[StateTy]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerInterface.html#v:unionT",
      "description": {
        "fct-descr": "\u003cp\u003eUnion of two transducers\n\u003c/p\u003e",
        "fct-module": "FST.TransducerInterface",
        "fct-package": "fst",
        "fct-signature": "Transducer a -\u003e Transducer a -\u003e Transducer a",
        "fct-source": "src/FST-Transducer.html#unionT",
        "fct-type": "function",
        "title": "unionT"
      },
      "index": {
        "description": "Union of two transducers",
        "hierarchy": "FST TransducerInterface",
        "module": "FST.TransducerInterface",
        "name": "unionT",
        "normalized": "Transducer a-\u003eTransducer a-\u003eTransducer a",
        "package": "fst",
        "partial": "",
        "signature": "Transducer a-\u003eTransducer a-\u003eTransducer a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType system for transducers\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "module",
        "fct-source": "src/FST-TransducerTypes.html",
        "fct-type": "module",
        "title": "TransducerTypes"
      },
      "index": {
        "description": "Type system for transducers",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "TransducerTypes",
        "normalized": "",
        "package": "fst",
        "partial": "Transducer Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:FinalStates",
      "description": {
        "fct-descr": "\u003cp\u003eFinal states\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#FinalStates",
        "fct-type": "type",
        "title": "FinalStates"
      },
      "index": {
        "description": "Final states",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "FinalStates",
        "normalized": "",
        "package": "fst",
        "partial": "Final States",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:FirstState",
      "description": {
        "fct-descr": "\u003cp\u003eFirst state\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#FirstState",
        "fct-type": "type",
        "title": "FirstState"
      },
      "index": {
        "description": "First state",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "FirstState",
        "normalized": "",
        "package": "fst",
        "partial": "First State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:InitialStates",
      "description": {
        "fct-descr": "\u003cp\u003eInitial states\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#InitialStates",
        "fct-type": "type",
        "title": "InitialStates"
      },
      "index": {
        "description": "Initial states",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "InitialStates",
        "normalized": "",
        "package": "fst",
        "partial": "Initial States",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:LastState",
      "description": {
        "fct-descr": "\u003cp\u003eLast state\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#LastState",
        "fct-type": "type",
        "title": "LastState"
      },
      "index": {
        "description": "Last state",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "LastState",
        "normalized": "",
        "package": "fst",
        "partial": "Last State",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:Lower",
      "description": {
        "fct-descr": "\u003cp\u003eLower language\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-TransducerTypes.html#Lower",
        "fct-type": "type",
        "title": "Lower"
      },
      "index": {
        "description": "Lower language",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "Lower",
        "normalized": "",
        "package": "fst",
        "partial": "Lower",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:Relation",
      "description": {
        "fct-descr": "\u003cp\u003eA relation between upper/lower languages\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-TransducerTypes.html#Relation",
        "fct-type": "type",
        "title": "Relation"
      },
      "index": {
        "description": "relation between upper lower languages",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "Relation",
        "normalized": "",
        "package": "fst",
        "partial": "Relation",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:Sigma",
      "description": {
        "fct-descr": "\u003cp\u003eThe alphabet of an automaton\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#Sigma",
        "fct-type": "type",
        "title": "Sigma"
      },
      "index": {
        "description": "The alphabet of an automaton",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "Sigma",
        "normalized": "",
        "package": "fst",
        "partial": "Sigma",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:StateTy",
      "description": {
        "fct-descr": "\u003cp\u003eA state\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-AutomatonTypes.html#StateTy",
        "fct-type": "type",
        "title": "StateTy"
      },
      "index": {
        "description": "state",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "StateTy",
        "normalized": "",
        "package": "fst",
        "partial": "State Ty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:Symbol",
      "description": {
        "fct-descr": "\u003cp\u003eA symbol\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "data",
        "fct-source": "src/FST-TransducerTypes.html#Symbol",
        "fct-type": "data",
        "title": "Symbol"
      },
      "index": {
        "description": "symbol",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "Symbol",
        "normalized": "",
        "package": "fst",
        "partial": "Symbol",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:TTransitionTable",
      "description": {
        "fct-descr": "\u003cp\u003eTransducer transition table\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-TransducerTypes.html#TTransitionTable",
        "fct-type": "type",
        "title": "TTransitionTable"
      },
      "index": {
        "description": "Transducer transition table",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "TTransitionTable",
        "normalized": "",
        "package": "fst",
        "partial": "TTransition Table",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:TTransitions",
      "description": {
        "fct-descr": "\u003cp\u003eTransducer transitions\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-TransducerTypes.html#TTransitions",
        "fct-type": "type",
        "title": "TTransitions"
      },
      "index": {
        "description": "Transducer transitions",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "TTransitions",
        "normalized": "",
        "package": "fst",
        "partial": "TTransitions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:TransducerFunctions",
      "description": {
        "fct-descr": "\u003cp\u003eClass of TransducerFunctions\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "class",
        "fct-source": "src/FST-TransducerTypes.html#TransducerFunctions",
        "fct-type": "class",
        "title": "TransducerFunctions"
      },
      "index": {
        "description": "Class of TransducerFunctions",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "TransducerFunctions",
        "normalized": "",
        "package": "fst",
        "partial": "Transducer Functions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#t:Upper",
      "description": {
        "fct-descr": "\u003cp\u003eUpper language\n\u003c/p\u003e",
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "type",
        "fct-source": "src/FST-TransducerTypes.html#Upper",
        "fct-type": "type",
        "title": "Upper"
      },
      "index": {
        "description": "Upper language",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "Upper",
        "normalized": "",
        "package": "fst",
        "partial": "Upper",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:Eps",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "Eps",
        "fct-source": "src/FST-TransducerTypes.html#Symbol",
        "fct-type": "function",
        "title": "Eps"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "Eps",
        "normalized": "",
        "package": "fst",
        "partial": "Eps",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:S",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "S a",
        "fct-source": "src/FST-TransducerTypes.html#Symbol",
        "fct-type": "function",
        "title": "S"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "S",
        "normalized": "",
        "package": "fst",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:alphabet",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e Sigma a",
        "fct-source": "src/FST-TransducerTypes.html#alphabet",
        "fct-type": "method",
        "title": "alphabet"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "alphabet",
        "normalized": "a b-\u003eSigma b",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003eSigma a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:finals",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e FinalStates",
        "fct-source": "src/FST-TransducerTypes.html#finals",
        "fct-type": "method",
        "title": "finals"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "finals",
        "normalized": "a b-\u003eFinalStates",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003eFinalStates"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:firstState",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e StateTy",
        "fct-source": "src/FST-TransducerTypes.html#firstState",
        "fct-type": "method",
        "title": "firstState"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "firstState",
        "normalized": "a b-\u003eStateTy",
        "package": "fst",
        "partial": "State",
        "signature": "f a-\u003eStateTy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:initials",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e InitialStates",
        "fct-source": "src/FST-TransducerTypes.html#initials",
        "fct-type": "method",
        "title": "initials"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "initials",
        "normalized": "a b-\u003eInitialStates",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003eInitialStates"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:isFinal",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e StateTy -\u003e Bool",
        "fct-source": "src/FST-TransducerTypes.html#isFinal",
        "fct-type": "method",
        "title": "isFinal"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "isFinal",
        "normalized": "a b-\u003eStateTy-\u003eBool",
        "package": "fst",
        "partial": "Final",
        "signature": "f a-\u003eStateTy-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:lastState",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e StateTy",
        "fct-source": "src/FST-TransducerTypes.html#lastState",
        "fct-type": "method",
        "title": "lastState"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "lastState",
        "normalized": "a b-\u003eStateTy",
        "package": "fst",
        "partial": "State",
        "signature": "f a-\u003eStateTy"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:states",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e [StateTy]",
        "fct-source": "src/FST-TransducerTypes.html#states",
        "fct-type": "method",
        "title": "states"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "states",
        "normalized": "a b-\u003e[StateTy]",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003e[StateTy]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:transitionList",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e StateTy -\u003e TTransitions a",
        "fct-source": "src/FST-TransducerTypes.html#transitionList",
        "fct-type": "method",
        "title": "transitionList"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "transitionList",
        "normalized": "a b-\u003eStateTy-\u003eTTransitions b",
        "package": "fst",
        "partial": "List",
        "signature": "f a-\u003eStateTy-\u003eTTransitions a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:transitionTable",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e TTransitionTable a",
        "fct-source": "src/FST-TransducerTypes.html#transitionTable",
        "fct-type": "method",
        "title": "transitionTable"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "transitionTable",
        "normalized": "a b-\u003eTTransitionTable b",
        "package": "fst",
        "partial": "Table",
        "signature": "f a-\u003eTTransitionTable a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:transitionsD",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e (StateTy, Symbol a) -\u003e [(Symbol a, StateTy)]",
        "fct-source": "src/FST-TransducerTypes.html#transitionsD",
        "fct-type": "method",
        "title": "transitionsD"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "transitionsD",
        "normalized": "a b-\u003e(StateTy,Symbol b)-\u003e[(Symbol b,StateTy)]",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003e(StateTy,Symbol a)-\u003e[(Symbol a,StateTy)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fst/docs/FST-TransducerTypes.html#v:transitionsU",
      "description": {
        "fct-module": "FST.TransducerTypes",
        "fct-package": "fst",
        "fct-signature": "f a -\u003e (StateTy, Symbol a) -\u003e [(Symbol a, StateTy)]",
        "fct-source": "src/FST-TransducerTypes.html#transitionsU",
        "fct-type": "method",
        "title": "transitionsU"
      },
      "index": {
        "description": "",
        "hierarchy": "FST TransducerTypes",
        "module": "FST.TransducerTypes",
        "name": "transitionsU",
        "normalized": "a b-\u003e(StateTy,Symbol b)-\u003e[(Symbol b,StateTy)]",
        "package": "fst",
        "partial": "",
        "signature": "f a-\u003e(StateTy,Symbol a)-\u003e[(Symbol a,StateTy)]"
      }
    }
  }
]
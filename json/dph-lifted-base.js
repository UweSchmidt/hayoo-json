[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDuring testing, we compare the output of each invocation of the lifted\n   combinators in \u003ca\u003eData.Array.Parallel.PArray\u003c/a\u003e with the reference implementations. \n\u003c/p\u003e\u003cp\u003eThis module helps convert the to and from the array representation\n   used by the reference implementation.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "module",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html",
        "fct-type": "module",
        "title": "Convert"
      },
      "index": {
        "description": "During testing we compare the output of each invocation of the lifted combinators in Data.Array.Parallel.PArray with the reference implementations This module helps convert the to and from the array representation used by the reference implementation",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "Convert",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Convert",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#t:PprPhysical1",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "class",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#PprPhysical1",
        "fct-type": "class",
        "title": "PprPhysical1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "PprPhysical1",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Ppr Physical",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#t:Similar",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "class",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#Similar",
        "fct-type": "class",
        "title": "Similar"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "Similar",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Similar",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#v:pprp1",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "a -\u003e Doc",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#pprp1",
        "fct-type": "method",
        "title": "pprp1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "pprp1",
        "normalized": "a-\u003eDoc",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "a-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#v:pprp1v",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Vector a -\u003e Doc",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#pprp1v",
        "fct-type": "method",
        "title": "pprp1v"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "pprp1v",
        "normalized": "Vector a-\u003eDoc",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "Vector a-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#v:similar",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "a -\u003e a -\u003e Bool",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#similar",
        "fct-type": "method",
        "title": "similar"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "similar",
        "normalized": "a-\u003ea-\u003eBool",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "a-\u003ea-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#v:toRef1",
      "description": {
        "fct-descr": "\u003cp\u003eConvert an array to the reference version.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "c a -\u003e r a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#toRef1",
        "fct-type": "function",
        "title": "toRef1"
      },
      "index": {
        "description": "Convert an array to the reference version",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "toRef1",
        "normalized": "a b-\u003ec b",
        "package": "dph-lifted-base",
        "partial": "Ref",
        "signature": "c a-\u003er a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#v:toRef2",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a nested array to the reference version.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "c (c a) -\u003e r (r a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#toRef2",
        "fct-type": "function",
        "title": "toRef2"
      },
      "index": {
        "description": "Convert nested array to the reference version",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "toRef2",
        "normalized": "a(a b)-\u003ec(c b)",
        "package": "dph-lifted-base",
        "partial": "Ref",
        "signature": "c(c a)-\u003er(r a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#v:toRef3",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a doubly nested array to the reference version.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "c (c (c a)) -\u003e r (r (r a))",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#toRef3",
        "fct-type": "function",
        "title": "toRef3"
      },
      "index": {
        "description": "Convert doubly nested array to the reference version",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "toRef3",
        "normalized": "a(a(a b))-\u003ec(c(c b))",
        "package": "dph-lifted-base",
        "partial": "Ref",
        "signature": "c(c(c a))-\u003er(r(r a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#v:withRef1",
      "description": {
        "fct-descr": "\u003cp\u003eCompare the result of some array operator against a reference.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "String -\u003e r a -\u003e c a -\u003e c a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#withRef1",
        "fct-type": "function",
        "title": "withRef1"
      },
      "index": {
        "description": "Compare the result of some array operator against reference",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "withRef1",
        "normalized": "String-\u003ea b-\u003ec b-\u003ec b",
        "package": "dph-lifted-base",
        "partial": "Ref",
        "signature": "String-\u003er a-\u003ec a-\u003ec a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference-Convert.html#v:withRef2",
      "description": {
        "fct-descr": "\u003cp\u003eCompare the nested result of some array operator against a reference.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference.Convert",
        "fct-package": "dph-lifted-base",
        "fct-signature": "String -\u003e r (r a) -\u003e c (c a) -\u003e c (c a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference-Convert.html#withRef2",
        "fct-type": "function",
        "title": "withRef2"
      },
      "index": {
        "description": "Compare the nested result of some array operator against reference",
        "hierarchy": "Data Array Parallel PArray Reference Convert",
        "module": "Data.Array.Parallel.PArray.Reference.Convert",
        "name": "withRef2",
        "normalized": "String-\u003ea(a b)-\u003ec(c b)-\u003ec(c b)",
        "package": "dph-lifted-base",
        "partial": "Ref",
        "signature": "String-\u003er(r a)-\u003ec(c a)-\u003ec(c a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReference implementation of operators on unvectorised parallel arrays.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e In this module we just used boxed vectors as the array representation. \n     This won't be fast, but it means we can write the operators without\n     needing type class dictionaries such as PA. This makes them\n     much easier to use as reference code.\n\u003c/li\u003e\u003cli\u003e The operators should also all do bounds checks, sanity checks, and \n     give nice error messages if something is wrong. The ideas is that\n     this code can be run side-by-side production code during debugging.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "module",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html",
        "fct-type": "module",
        "title": "Reference"
      },
      "index": {
        "description": "Reference implementation of operators on unvectorised parallel arrays In this module we just used boxed vectors as the array representation This won be fast but it means we can write the operators without needing type class dictionaries such as PA This makes them much easier to use as reference code The operators should also all do bounds checks sanity checks and give nice error messages if something is wrong The ideas is that this code can be run side-by-side production code during debugging",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "Reference",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Reference",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#t:PArray",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "type",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#PArray",
        "fct-type": "type",
        "title": "PArray"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "PArray",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "PArray",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:append",
      "description": {
        "fct-descr": "\u003cp\u003eAppend two arrays.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e PArray a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#append",
        "fct-type": "function",
        "title": "append"
      },
      "index": {
        "description": "Append two arrays",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "append",
        "normalized": "PArray a-\u003ePArray a-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003ePArray a-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:appendl",
      "description": {
        "fct-descr": "\u003cp\u003eLifted append.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray a) -\u003e PArray (PArray a) -\u003e PArray (PArray a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#appendl",
        "fct-type": "function",
        "title": "appendl"
      },
      "index": {
        "description": "Lifted append",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "appendl",
        "normalized": "PArray(PArray a)-\u003ePArray(PArray a)-\u003ePArray(PArray a)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray a)-\u003ePArray(PArray a)-\u003ePArray(PArray a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:combine2",
      "description": {
        "fct-descr": "\u003cp\u003eCombine two arrays based on a selector.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Sel2 -\u003e PArray a -\u003e PArray a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#combine2",
        "fct-type": "function",
        "title": "combine2"
      },
      "index": {
        "description": "Combine two arrays based on selector",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "combine2",
        "normalized": "Sel-\u003ePArray a-\u003ePArray a-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "Sel-\u003ePArray a-\u003ePArray a-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003eConcatenation\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray a) -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenation",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "concat",
        "normalized": "PArray(PArray a)-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray a)-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:concatl",
      "description": {
        "fct-descr": "\u003cp\u003eLifted concatenation.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray (PArray a)) -\u003e PArray (PArray a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#concatl",
        "fct-type": "function",
        "title": "concatl"
      },
      "index": {
        "description": "Lifted concatenation",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "concatl",
        "normalized": "PArray(PArray(PArray a))-\u003ePArray(PArray a)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray(PArray a))-\u003ePArray(PArray a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003eO(1). An empty array.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "An empty array",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "empty",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a range of integers\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Int -\u003e Int -\u003e PArray Int",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Construct range of integers",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "enumFromTo",
        "normalized": "Int-\u003eInt-\u003ePArray Int",
        "package": "dph-lifted-base",
        "partial": "From To",
        "signature": "Int-\u003eInt-\u003ePArray Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:enumFromTol",
      "description": {
        "fct-descr": "\u003cp\u003eLifted enumeration\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray Int -\u003e PArray Int -\u003e PArray (PArray Int)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#enumFromTol",
        "fct-type": "function",
        "title": "enumFromTol"
      },
      "index": {
        "description": "Lifted enumeration",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "enumFromTol",
        "normalized": "PArray Int-\u003ePArray Int-\u003ePArray(PArray Int)",
        "package": "dph-lifted-base",
        "partial": "From Tol",
        "signature": "PArray Int-\u003ePArray Int-\u003ePArray(PArray Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:extract",
      "description": {
        "fct-descr": "\u003cp\u003eExtract a range of elements from an array.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e Int -\u003e Int -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#extract",
        "fct-type": "function",
        "title": "extract"
      },
      "index": {
        "description": "Extract range of elements from an array",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "extract",
        "normalized": "PArray a-\u003eInt-\u003eInt-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003eInt-\u003eInt-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:extracts",
      "description": {
        "fct-descr": "\u003cp\u003eSegmented extract.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Vector (PArray a) -\u003e SSegd -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#extracts",
        "fct-type": "function",
        "title": "extracts"
      },
      "index": {
        "description": "Segmented extract",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "extracts",
        "normalized": "Vector(PArray a)-\u003eSSegd-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "Vector(PArray a)-\u003eSSegd-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:extracts-39-",
      "description": {
        "fct-descr": "\u003cp\u003eWrapper for \u003ccode\u003e\u003ca\u003eextracts\u003c/a\u003e\u003c/code\u003e that takes arrays of sources, starts and lengths of\n   the segments, and uses these to build the \u003ccode\u003e\u003ca\u003eSSegd\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Vector (PArray a)-\u003e PArray Int-\u003e PArray Int-\u003e PArray Int-\u003e PArray a",
        "fct-type": "function",
        "title": "extracts'"
      },
      "index": {
        "description": "Wrapper for extracts that takes arrays of sources starts and lengths of the segments and uses these to build the SSegd",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "extracts'",
        "normalized": "Vector(PArray a)-\u003ePArray Int-\u003ePArray Int-\u003ePArray Int-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "Vector(PArray a)-\u003ePArray Int-\u003ePArray Int-\u003ePArray Int-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a list to a \u003ccode\u003e\u003ca\u003ePArray\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "[a] -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to PArray",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "fromList",
        "normalized": "[a]-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "List",
        "signature": "[a]-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:fromUArray",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eArray\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003ePArray\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Array a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#fromUArray",
        "fct-type": "function",
        "title": "fromUArray"
      },
      "index": {
        "description": "Convert Array to PArray",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "fromUArray",
        "normalized": "Array a-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "UArray",
        "signature": "Array a-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:fromUArray2",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eArray\u003c/a\u003e\u003c/code\u003e of tuples to a \u003ccode\u003e\u003ca\u003ePArray\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Array (a, b) -\u003e PArray (a, b)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#fromUArray2",
        "fct-type": "function",
        "title": "fromUArray2"
      },
      "index": {
        "description": "Convert Array of tuples to PArray",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "fromUArray2",
        "normalized": "Array(a,b)-\u003ePArray(a,b)",
        "package": "dph-lifted-base",
        "partial": "UArray",
        "signature": "Array(a,b)-\u003ePArray(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:fromVector",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003ePArray\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Vector a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#fromVector",
        "fct-type": "function",
        "title": "fromVector"
      },
      "index": {
        "description": "Convert Vector to PArray",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "fromVector",
        "normalized": "Vector a-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "Vector",
        "signature": "Vector a-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:index",
      "description": {
        "fct-descr": "\u003cp\u003eLookup a single element from the source array.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#index",
        "fct-type": "function",
        "title": "index"
      },
      "index": {
        "description": "Lookup single element from the source array",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "index",
        "normalized": "PArray a-\u003eInt-\u003ea",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:indexl",
      "description": {
        "fct-descr": "\u003cp\u003eLookup a several elements from several source arrays.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray a) -\u003e PArray Int -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#indexl",
        "fct-type": "function",
        "title": "indexl"
      },
      "index": {
        "description": "Lookup several elements from several source arrays",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "indexl",
        "normalized": "PArray(PArray a)-\u003ePArray Int-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray a)-\u003ePArray Int-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eTake the length of an array\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e Int",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Take the length of an array",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "length",
        "normalized": "PArray a-\u003eInt",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:lengthl",
      "description": {
        "fct-descr": "\u003cp\u003eTake the length of some arrays.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray a) -\u003e PArray Int",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#lengthl",
        "fct-type": "function",
        "title": "lengthl"
      },
      "index": {
        "description": "Take the length of some arrays",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "lengthl",
        "normalized": "PArray(PArray a)-\u003ePArray Int",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray a)-\u003ePArray Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:nestUSegd",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a nested array from a segment descriptor and some flat data.\n   The segment descriptor must represent as many elements as present\n   in the flat data array, else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Segd -\u003e PArray a -\u003e PArray (PArray a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#nestUSegd",
        "fct-type": "function",
        "title": "nestUSegd"
      },
      "index": {
        "description": "Create nested array from segment descriptor and some flat data The segment descriptor must represent as many elements as present in the flat data array else error",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "nestUSegd",
        "normalized": "Segd-\u003ePArray a-\u003ePArray(PArray a)",
        "package": "dph-lifted-base",
        "partial": "USegd",
        "signature": "Segd-\u003ePArray a-\u003ePArray(PArray a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:nf",
      "description": {
        "fct-descr": "\u003cp\u003eForce an array to normal form.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e ()",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#nf",
        "fct-type": "function",
        "title": "nf"
      },
      "index": {
        "description": "Force an array to normal form",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "nf",
        "normalized": "PArray a-\u003e()",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003e()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:pack",
      "description": {
        "fct-descr": "\u003cp\u003eSelect the elements of an array that have their tag set to True.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e PArray Bool -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#pack",
        "fct-type": "function",
        "title": "pack"
      },
      "index": {
        "description": "Select the elements of an array that have their tag set to True",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "pack",
        "normalized": "PArray a-\u003ePArray Bool-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003ePArray Bool-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:packByTag",
      "description": {
        "fct-descr": "\u003cp\u003eFilter an array based on some tags.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e Array Tag -\u003e Tag -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#packByTag",
        "fct-type": "function",
        "title": "packByTag"
      },
      "index": {
        "description": "Filter an array based on some tags",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "packByTag",
        "normalized": "PArray a-\u003eArray Tag-\u003eTag-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "By Tag",
        "signature": "PArray a-\u003eArray Tag-\u003eTag-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:packl",
      "description": {
        "fct-descr": "\u003cp\u003eLifted pack.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray a) -\u003e PArray (PArray Bool) -\u003e PArray (PArray a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#packl",
        "fct-type": "function",
        "title": "packl"
      },
      "index": {
        "description": "Lifted pack",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "packl",
        "normalized": "PArray(PArray a)-\u003ePArray(PArray Bool)-\u003ePArray(PArray a)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray a)-\u003ePArray(PArray Bool)-\u003ePArray(PArray a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eO(n). Define an array of the given size, that maps all elements to the same value.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Int -\u003e a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Define an array of the given size that maps all elements to the same value",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "Int-\u003ea-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:replicatel",
      "description": {
        "fct-descr": "\u003cp\u003eO(sum lengths). Lifted replicate.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray Int -\u003e PArray a -\u003e PArray (PArray a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#replicatel",
        "fct-type": "function",
        "title": "replicatel"
      },
      "index": {
        "description": "sum lengths Lifted replicate",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "replicatel",
        "normalized": "PArray Int-\u003ePArray a-\u003ePArray(PArray a)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray Int-\u003ePArray a-\u003ePArray(PArray a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:replicates",
      "description": {
        "fct-descr": "\u003cp\u003eO(sum lengths). Segmented replicate.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Segd -\u003e PArray a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#replicates",
        "fct-type": "function",
        "title": "replicates"
      },
      "index": {
        "description": "sum lengths Segmented replicate",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "replicates",
        "normalized": "Segd-\u003ePArray a-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "Segd-\u003ePArray a-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:replicates-39-",
      "description": {
        "fct-descr": "\u003cp\u003eO(sum lengths). Wrapper for segmented replicate that takes replication counts\n  and uses them to build the \u003ccode\u003e\u003ca\u003eSegd\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray Int -\u003e PArray a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#replicates%27",
        "fct-type": "function",
        "title": "replicates'"
      },
      "index": {
        "description": "sum lengths Wrapper for segmented replicate that takes replication counts and uses them to build the Segd",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "replicates'",
        "normalized": "PArray Int-\u003ePArray a-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray Int-\u003ePArray a-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003eO(1). Produce an array containing a single element.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Produce an array containing single element",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "singleton",
        "normalized": "a-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "a-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:singletonl",
      "description": {
        "fct-descr": "\u003cp\u003eO(n). Produce an array of singleton arrays.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e PArray (PArray a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#singletonl",
        "fct-type": "function",
        "title": "singletonl"
      },
      "index": {
        "description": "Produce an array of singleton arrays",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "singletonl",
        "normalized": "PArray a-\u003ePArray(PArray a)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003ePArray(PArray a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eExtract a range of elements from an arrary.\n   Like \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e but with the parameters in a different order.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Int -\u003e Int -\u003e PArray a -\u003e PArray a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Extract range of elements from an arrary Like extract but with the parameters in different order",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003ePArray a-\u003ePArray a",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "Int-\u003eInt-\u003ePArray a-\u003ePArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:slicel",
      "description": {
        "fct-descr": "\u003cp\u003eExtract some slices from some arrays.\n   The arrays of starting indices and lengths must themselves\n   have the same length.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray Int -\u003e PArray Int -\u003e PArray (PArray a) -\u003e PArray (PArray a)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#slicel",
        "fct-type": "function",
        "title": "slicel"
      },
      "index": {
        "description": "Extract some slices from some arrays The arrays of starting indices and lengths must themselves have the same length",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "slicel",
        "normalized": "PArray Int-\u003ePArray Int-\u003ePArray(PArray a)-\u003ePArray(PArray a)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray Int-\u003ePArray Int-\u003ePArray(PArray a)-\u003ePArray(PArray a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:takeUSegd",
      "description": {
        "fct-descr": "\u003cp\u003eTake the segment descriptor from a nested array. This can cause index space\n   overflow if the number of elements in the result does not can not be\n   represented by a single machine word.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray a) -\u003e Segd",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#takeUSegd",
        "fct-type": "function",
        "title": "takeUSegd"
      },
      "index": {
        "description": "Take the segment descriptor from nested array This can cause index space overflow if the number of elements in the result does not can not be represented by single machine word",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "takeUSegd",
        "normalized": "PArray(PArray a)-\u003eSegd",
        "package": "dph-lifted-base",
        "partial": "USegd",
        "signature": "PArray(PArray a)-\u003eSegd"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003ePArray\u003c/a\u003e\u003c/code\u003e to a list.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e [a]",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert PArray to list",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "toList",
        "normalized": "PArray a-\u003e[a]",
        "package": "dph-lifted-base",
        "partial": "List",
        "signature": "PArray a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:toUArray",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003ePArray\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eArray\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e Array a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#toUArray",
        "fct-type": "function",
        "title": "toUArray"
      },
      "index": {
        "description": "Convert PArray to Array",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "toUArray",
        "normalized": "PArray a-\u003eArray a",
        "package": "dph-lifted-base",
        "partial": "UArray",
        "signature": "PArray a-\u003eArray a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:toVector",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003ePArray\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e        \n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e Vector a",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#toVector",
        "fct-type": "function",
        "title": "toVector"
      },
      "index": {
        "description": "Convert PArray to Vector",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "toVector",
        "normalized": "PArray a-\u003eVector a",
        "package": "dph-lifted-base",
        "partial": "Vector",
        "signature": "PArray a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:unconcat",
      "description": {
        "fct-descr": "\u003cp\u003eImpose a nesting structure on a flat array\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray a) -\u003e PArray b -\u003e PArray (PArray b)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#unconcat",
        "fct-type": "function",
        "title": "unconcat"
      },
      "index": {
        "description": "Impose nesting structure on flat array",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "unconcat",
        "normalized": "PArray(PArray a)-\u003ePArray b-\u003ePArray(PArray b)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray a)-\u003ePArray b-\u003ePArray(PArray b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003eO(n). Unzip an array of pairs into a pair of arrays.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (a, b) -\u003e (PArray a, PArray b)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "Unzip an array of pairs into pair of arrays",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "unzip",
        "normalized": "PArray(a,b)-\u003e(PArray a,PArray b)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(a,b)-\u003e(PArray a,PArray b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:unzipl",
      "description": {
        "fct-descr": "\u003cp\u003eLifted unzip\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray (a, b)) -\u003e PArray (PArray a, PArray b)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#unzipl",
        "fct-type": "function",
        "title": "unzipl"
      },
      "index": {
        "description": "Lifted unzip",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "unzipl",
        "normalized": "PArray(PArray(a,b))-\u003ePArray(PArray a,PArray b)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray(a,b))-\u003ePArray(PArray a,PArray b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:valid",
      "description": {
        "fct-descr": "\u003cp\u003eCheck that an array has a valid internal representation.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e Bool",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#valid",
        "fct-type": "function",
        "title": "valid"
      },
      "index": {
        "description": "Check that an array has valid internal representation",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "valid",
        "normalized": "PArray a-\u003eBool",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003eO(n). Zip a pair of arrays into an array of pairs.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray a -\u003e PArray b -\u003e PArray (a, b)",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "Zip pair of arrays into an array of pairs",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "zip",
        "normalized": "PArray a-\u003ePArray b-\u003ePArray(a,b)",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray a-\u003ePArray b-\u003ePArray(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Reference.html#v:zipl",
      "description": {
        "fct-descr": "\u003cp\u003eLifted zip\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Reference",
        "fct-package": "dph-lifted-base",
        "fct-signature": "PArray (PArray a) -\u003e PArray (PArray b) -\u003e PArray (PArray (a, b))",
        "fct-source": "src/Data-Array-Parallel-PArray-Reference.html#zipl",
        "fct-type": "function",
        "title": "zipl"
      },
      "index": {
        "description": "Lifted zip",
        "hierarchy": "Data Array Parallel PArray Reference",
        "module": "Data.Array.Parallel.PArray.Reference",
        "name": "zipl",
        "normalized": "PArray(PArray a)-\u003ePArray(PArray b)-\u003ePArray(PArray(a,b))",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": "PArray(PArray a)-\u003ePArray(PArray b)-\u003ePArray(PArray(a,b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDefines the extra types we use when representing algebraic data in\n   parallel arrays. We don't store values of user defined algebraic type\n   directly in PArrays. Instead, we convert these to a generic representation\n   and store that representation.\n\u003c/p\u003e\u003cp\u003eConversion to and from the generic representation is handled by the\n   methods of the PA class defined in \u003ca\u003eData.Array.Parallel.PArray.PRepr\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "module",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html",
        "fct-type": "module",
        "title": "Types"
      },
      "index": {
        "description": "Defines the extra types we use when representing algebraic data in parallel arrays We don store values of user defined algebraic type directly in PArrays Instead we convert these to generic representation and store that representation Conversion to and from the generic representation is handled by the methods of the PA class defined in Data.Array.Parallel.PArray.PRepr",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Types",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#t:Sum2",
      "description": {
        "fct-descr": "\u003cp\u003eSum types used for the generic representation of algebraic data.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "data",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Sum2",
        "fct-type": "data",
        "title": "Sum2"
      },
      "index": {
        "description": "Sum types used for the generic representation of algebraic data",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Sum2",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Sum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#t:Sum3",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "data",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Sum3",
        "fct-type": "data",
        "title": "Sum3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Sum3",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Sum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#t:Void",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eVoid\u003c/a\u003e\u003c/code\u003e type is used when representing enumerations. \n\u003c/p\u003e\u003cp\u003eA type like Bool is represented as \u003ccode\u003eSum2 Void Void\u003c/code\u003e, meaning that we only\n   only care about the tag of the data constructor and not its argumnent.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "data",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Void",
        "fct-type": "data",
        "title": "Void"
      },
      "index": {
        "description": "The Void type is used when representing enumerations type like Bool is represented as Sum2 Void Void meaning that we only only care about the tag of the data constructor and not its argumnent",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Void",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Void",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#t:Wrap",
      "description": {
        "fct-descr": "\u003cp\u003eWhen converting a data type to its generic representation, we use\n   \u003ccode\u003e\u003ca\u003eWrap\u003c/a\u003e\u003c/code\u003e to help us convert only one layer at a time. For example:\n\u003c/p\u003e\u003cpre\u003e\n   data Foo a = Foo Int a\n\ninstance PA a =\u003e PA (Foo a) where\n    type PRepr (Foo a) = (Int, Wrap a)  -- define how (Foo a) is represented\n\u003c/pre\u003e\u003cp\u003eHere we've converted the \u003ccode\u003eFoo\u003c/code\u003e data constructor to a pair, and Int\n   is its own representation type. We have PData/PR instances for pairs and\n   Ints, so we can work with arrays of these types. However, we can't just\n   use (Int, a) as the representation of (Foo a) because \u003ccode\u003ea\u003c/code\u003e might\n   be user defined and we won't have PData/PR instances for it.\n\u003c/p\u003e\u003cp\u003eInstead, we wrap the second element with the Wrap constructor, which tells\n   us that if we want to process this element we still need to convert it\n   to the generic representation (and back). This last part is done by\n   the PR instance of Wrap, who's methods are defined by calls to the *PD \n   functions from \u003ca\u003eData.Array.Parallel.PArray.PRepr\u003c/a\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Wrap",
        "fct-type": "newtype",
        "title": "Wrap"
      },
      "index": {
        "description": "When converting data type to its generic representation we use Wrap to help us convert only one layer at time For example data Foo Foo Int instance PA PA Foo where type PRepr Foo Int Wrap define how Foo is represented Here we ve converted the Foo data constructor to pair and Int is its own representation type We have PData PR instances for pairs and Ints so we can work with arrays of these types However we can just use Int as the representation of Foo because might be user defined and we won have PData PR instances for it Instead we wrap the second element with the Wrap constructor which tells us that if we want to process this element we still need to convert it to the generic representation and back This last part is done by the PR instance of Wrap who methods are defined by calls to the PD functions from Data.Array.Parallel.PArray.PRepr",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Wrap",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Wrap",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:Alt2_1",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Alt2_1 a",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Sum2",
        "fct-type": "function",
        "title": "Alt2_1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Alt2_1",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Alt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:Alt2_2",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Alt2_2 b",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Sum2",
        "fct-type": "function",
        "title": "Alt2_2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Alt2_2",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Alt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:Alt3_1",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Alt3_1 a",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Sum3",
        "fct-type": "function",
        "title": "Alt3_1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Alt3_1",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Alt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:Alt3_2",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Alt3_2 b",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Sum3",
        "fct-type": "function",
        "title": "Alt3_2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Alt3_2",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Alt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:Alt3_3",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Alt3_3 c",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Sum3",
        "fct-type": "function",
        "title": "Alt3_3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Alt3_3",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Alt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:Wrap",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Wrap",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Wrap",
        "fct-type": "function",
        "title": "Wrap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "Wrap",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Wrap",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:fromVoid",
      "description": {
        "fct-descr": "\u003cp\u003eCoerce a \u003ccode\u003e\u003ca\u003eVoid\u003c/a\u003e\u003c/code\u003e to a different type. Used as a placeholder like \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e.\n   Forcing the result yields \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "a",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#fromVoid",
        "fct-type": "function",
        "title": "fromVoid"
      },
      "index": {
        "description": "Coerce Void to different type Used as placeholder like undefined Forcing the result yields error",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "fromVoid",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Void",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:tagOfSum2",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Sum2 a b -\u003e Tag",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#tagOfSum2",
        "fct-type": "function",
        "title": "tagOfSum2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "tagOfSum2",
        "normalized": "Sum a b-\u003eTag",
        "package": "dph-lifted-base",
        "partial": "Of Sum",
        "signature": "Sum a b-\u003eTag"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:tagOfSum3",
      "description": {
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Sum3 a b c -\u003e Tag",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#tagOfSum3",
        "fct-type": "function",
        "title": "tagOfSum3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "tagOfSum3",
        "normalized": "Sum a b c-\u003eTag",
        "package": "dph-lifted-base",
        "partial": "Of Sum",
        "signature": "Sum a b c-\u003eTag"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:unWrap",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "a",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#Wrap",
        "fct-type": "function",
        "title": "unWrap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "unWrap",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "Wrap",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/dph-lifted-base/docs/Data-Array-Parallel-PArray-Types.html#v:void",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003evalue\u003c/code\u003e with the void type. Used as a placholder like \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e.\n   Forcing this yields \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
        "fct-module": "Data.Array.Parallel.PArray.Types",
        "fct-package": "dph-lifted-base",
        "fct-signature": "Void",
        "fct-source": "src/Data-Array-Parallel-PArray-Types.html#void",
        "fct-type": "function",
        "title": "void"
      },
      "index": {
        "description": "value with the void type Used as placholder like undefined Forcing this yields error",
        "hierarchy": "Data Array Parallel PArray Types",
        "module": "Data.Array.Parallel.PArray.Types",
        "name": "void",
        "normalized": "",
        "package": "dph-lifted-base",
        "partial": "",
        "signature": ""
      }
    }
  }
]
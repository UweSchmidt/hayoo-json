[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Empty.html#",
      "description": {
        "fct-module": "Data.Empty",
        "fct-package": "non-empty",
        "fct-signature": "module",
        "fct-source": "src/Data-Empty.html",
        "fct-type": "module",
        "title": "Empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Empty",
        "module": "Data.Empty",
        "name": "Empty",
        "normalized": "",
        "package": "non-empty",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Empty.html#t:T",
      "description": {
        "fct-module": "Data.Empty",
        "fct-package": "non-empty",
        "fct-signature": "data",
        "fct-source": "src/Data-Empty.html#T",
        "fct-type": "data",
        "title": "T"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Empty",
        "module": "Data.Empty",
        "name": "T",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Empty.html#v:Cons",
      "description": {
        "fct-module": "Data.Empty",
        "fct-package": "non-empty",
        "fct-signature": "Cons",
        "fct-source": "src/Data-Empty.html#T",
        "fct-type": "function",
        "title": "Cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Empty",
        "module": "Data.Empty",
        "name": "Cons",
        "normalized": "",
        "package": "non-empty",
        "partial": "Cons",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "module",
        "fct-source": "src/Data-NonEmpty-Class.html",
        "fct-type": "module",
        "title": "Class"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Class",
        "normalized": "",
        "package": "non-empty",
        "partial": "Class",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Append",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Append",
        "fct-type": "class",
        "title": "Append"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Append",
        "normalized": "",
        "package": "non-empty",
        "partial": "Append",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Arbitrary",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Arbitrary",
        "fct-type": "class",
        "title": "Arbitrary"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Arbitrary",
        "normalized": "",
        "package": "non-empty",
        "partial": "Arbitrary",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Cons",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Cons",
        "fct-type": "class",
        "title": "Cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Cons",
        "normalized": "",
        "package": "non-empty",
        "partial": "Cons",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Empty",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Empty",
        "fct-type": "class",
        "title": "Empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Empty",
        "normalized": "",
        "package": "non-empty",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Repeat",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Repeat",
        "fct-type": "class",
        "title": "Repeat"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Repeat",
        "normalized": "",
        "package": "non-empty",
        "partial": "Repeat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Reverse",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Reverse",
        "fct-type": "class",
        "title": "Reverse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Reverse",
        "normalized": "",
        "package": "non-empty",
        "partial": "Reverse",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Show",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Show",
        "fct-type": "class",
        "title": "Show"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Show",
        "normalized": "",
        "package": "non-empty",
        "partial": "Show",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Singleton",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Singleton",
        "fct-type": "class",
        "title": "Singleton"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Singleton",
        "normalized": "",
        "package": "non-empty",
        "partial": "Singleton",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Sort",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Sort",
        "fct-type": "class",
        "title": "Sort"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Sort",
        "normalized": "",
        "package": "non-empty",
        "partial": "Sort",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:View",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#View",
        "fct-type": "class",
        "title": "View"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "View",
        "normalized": "",
        "package": "non-empty",
        "partial": "View",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Zip",
      "description": {
        "fct-descr": "\u003cp\u003eIt must hold:\n\u003c/p\u003e\u003cpre\u003e fmap f xs\n    = zipWith (\\x _ -\u003e f x) xs xs\n    = zipWith (\\_ x -\u003e f x) xs xs\n\u003c/pre\u003e",
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmpty-Class.html#Zip",
        "fct-type": "class",
        "title": "Zip"
      },
      "index": {
        "description": "It must hold fmap xs zipWith xs xs zipWith xs xs",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "Zip",
        "normalized": "",
        "package": "non-empty",
        "partial": "Zip",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:append",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e f a -\u003e f a",
        "fct-source": "src/Data-NonEmpty-Class.html#append",
        "fct-type": "method",
        "title": "append"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "append",
        "normalized": "a b-\u003ea b-\u003ea b",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003ef a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:arbitrary",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "Gen (f a)",
        "fct-source": "src/Data-NonEmpty-Class.html#arbitrary",
        "fct-type": "method",
        "title": "arbitrary"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "arbitrary",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:cons",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "a -\u003e f a -\u003e f a",
        "fct-source": "src/Data-NonEmpty-Class.html#cons",
        "fct-type": "method",
        "title": "cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "cons",
        "normalized": "a-\u003eb a-\u003eb a",
        "package": "non-empty",
        "partial": "",
        "signature": "a-\u003ef a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:empty",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "f a",
        "fct-source": "src/Data-NonEmpty-Class.html#empty",
        "fct-type": "method",
        "title": "empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "empty",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:repeat",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a container with as many copies as possible of a given value.\n   That is, for a container with fixed size \u003ccode\u003en\u003c/code\u003e,\n   the call \u003ccode\u003erepeat x\u003c/code\u003e will generate a container with \u003ccode\u003en\u003c/code\u003e copies of \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "a -\u003e f a",
        "fct-source": "src/Data-NonEmpty-Class.html#repeat",
        "fct-type": "method",
        "title": "repeat"
      },
      "index": {
        "description": "Create container with as many copies as possible of given value That is for container with fixed size the call repeat will generate container with copies of",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "repeat",
        "normalized": "a-\u003eb a",
        "package": "non-empty",
        "partial": "",
        "signature": "a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:reverse",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e f a",
        "fct-source": "src/Data-NonEmpty-Class.html#reverse",
        "fct-type": "method",
        "title": "reverse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "reverse",
        "normalized": "a b-\u003ea b",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:showsPrec",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "Int -\u003e f a -\u003e ShowS",
        "fct-source": "src/Data-NonEmpty-Class.html#showsPrec",
        "fct-type": "method",
        "title": "showsPrec"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "showsPrec",
        "normalized": "Int-\u003ea b-\u003eShowS",
        "package": "non-empty",
        "partial": "Prec",
        "signature": "Int-\u003ef a-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:shrink",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e [f a]",
        "fct-source": "src/Data-NonEmpty-Class.html#shrink",
        "fct-type": "method",
        "title": "shrink"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "shrink",
        "normalized": "a b-\u003e[a b]",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003e[f a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:singleton",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "a -\u003e f a",
        "fct-source": "src/Data-NonEmpty-Class.html#singleton",
        "fct-type": "method",
        "title": "singleton"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "singleton",
        "normalized": "a-\u003eb a",
        "package": "non-empty",
        "partial": "",
        "signature": "a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:sort",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e f a",
        "fct-source": "src/Data-NonEmpty-Class.html#sort",
        "fct-type": "function",
        "title": "sort"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "sort",
        "normalized": "a b-\u003ea b",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:sortBy",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e f a -\u003e f a",
        "fct-source": "src/Data-NonEmpty-Class.html#sortBy",
        "fct-type": "method",
        "title": "sortBy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "sortBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003eb a",
        "package": "non-empty",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ef a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:viewL",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e Maybe (a, f a)",
        "fct-source": "src/Data-NonEmpty-Class.html#viewL",
        "fct-type": "method",
        "title": "viewL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "viewL",
        "normalized": "a b-\u003eMaybe(b,a b)",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003eMaybe(a,f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:zip",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e f b -\u003e f (a, b)",
        "fct-source": "src/Data-NonEmpty-Class.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "zip",
        "normalized": "a b-\u003ea c-\u003ea(b,c)",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003ef b-\u003ef(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:zipWith",
      "description": {
        "fct-module": "Data.NonEmpty.Class",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e f a -\u003e f b -\u003e f c",
        "fct-source": "src/Data-NonEmpty-Class.html#zipWith",
        "fct-type": "method",
        "title": "zipWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Class",
        "module": "Data.NonEmpty.Class",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
        "package": "non-empty",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003ef a-\u003ef b-\u003ef c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions that cope both with plain and non-empty structures.\n\u003c/p\u003e\u003cp\u003eIf there are two versions of a function,\nwhere one works on fixed-length lists,\nthe place the fixed-length list variant to NonEmpty\nand the other one here.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.NonEmpty.Mixed",
        "fct-package": "non-empty",
        "fct-signature": "module",
        "fct-source": "src/Data-NonEmpty-Mixed.html",
        "fct-type": "module",
        "title": "Mixed"
      },
      "index": {
        "description": "Functions that cope both with plain and non-empty structures If there are two versions of function where one works on fixed-length lists the place the fixed-length list variant to NonEmpty and the other one here",
        "hierarchy": "Data NonEmpty Mixed",
        "module": "Data.NonEmpty.Mixed",
        "name": "Mixed",
        "normalized": "",
        "package": "non-empty",
        "partial": "Mixed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:appendLeft",
      "description": {
        "fct-module": "Data.NonEmpty.Mixed",
        "fct-package": "non-empty",
        "fct-signature": "[a] -\u003e f a -\u003e f a",
        "fct-source": "src/Data-NonEmpty-Mixed.html#appendLeft",
        "fct-type": "function",
        "title": "appendLeft"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Mixed",
        "module": "Data.NonEmpty.Mixed",
        "name": "appendLeft",
        "normalized": "[a]-\u003eb a-\u003eb a",
        "package": "non-empty",
        "partial": "Left",
        "signature": "[a]-\u003ef a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:groupBy",
      "description": {
        "fct-module": "Data.NonEmpty.Mixed",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e Bool) -\u003e f a -\u003e [T [] a]",
        "fct-source": "src/Data-NonEmpty-Mixed.html#groupBy",
        "fct-type": "function",
        "title": "groupBy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Mixed",
        "module": "Data.NonEmpty.Mixed",
        "name": "groupBy",
        "normalized": "(a-\u003ea-\u003eBool)-\u003eb a-\u003e[T[]a]",
        "package": "non-empty",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eBool)-\u003ef a-\u003e[T[]a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:inits",
      "description": {
        "fct-module": "Data.NonEmpty.Mixed",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e T [] (f a)",
        "fct-source": "src/Data-NonEmpty-Mixed.html#inits",
        "fct-type": "function",
        "title": "inits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Mixed",
        "module": "Data.NonEmpty.Mixed",
        "name": "inits",
        "normalized": "a b-\u003eT[](a b)",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003eT[](f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:mapAdjacent",
      "description": {
        "fct-module": "Data.NonEmpty.Mixed",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e b) -\u003e T f a -\u003e f b",
        "fct-source": "src/Data-NonEmpty-Mixed.html#mapAdjacent",
        "fct-type": "function",
        "title": "mapAdjacent"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Mixed",
        "module": "Data.NonEmpty.Mixed",
        "name": "mapAdjacent",
        "normalized": "(a-\u003ea-\u003eb)-\u003eT c a-\u003ec b",
        "package": "non-empty",
        "partial": "Adjacent",
        "signature": "(a-\u003ea-\u003eb)-\u003eT f a-\u003ef b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:segmentBefore",
      "description": {
        "fct-module": "Data.NonEmpty.Mixed",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e Bool) -\u003e f a -\u003e ([a], [T [] a])",
        "fct-source": "src/Data-NonEmpty-Mixed.html#segmentBefore",
        "fct-type": "function",
        "title": "segmentBefore"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Mixed",
        "module": "Data.NonEmpty.Mixed",
        "name": "segmentBefore",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003e([a],[T[]a])",
        "package": "non-empty",
        "partial": "Before",
        "signature": "(a-\u003eBool)-\u003ef a-\u003e([a],[T[]a])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:tails",
      "description": {
        "fct-module": "Data.NonEmpty.Mixed",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e T [] (f a)",
        "fct-source": "src/Data-NonEmpty-Mixed.html#tails",
        "fct-type": "function",
        "title": "tails"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty Mixed",
        "module": "Data.NonEmpty.Mixed",
        "name": "tails",
        "normalized": "a b-\u003eT[](a b)",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003eT[](f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "module",
        "fct-source": "src/Data-NonEmpty.html",
        "fct-type": "module",
        "title": "NonEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "NonEmpty",
        "normalized": "",
        "package": "non-empty",
        "partial": "Non Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#t:Insert",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmptyPrivate.html#Insert",
        "fct-type": "class",
        "title": "Insert"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "Insert",
        "normalized": "",
        "package": "non-empty",
        "partial": "Insert",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#t:RemoveEach",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmptyPrivate.html#RemoveEach",
        "fct-type": "class",
        "title": "RemoveEach"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "RemoveEach",
        "normalized": "",
        "package": "non-empty",
        "partial": "Remove Each",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#t:T",
      "description": {
        "fct-descr": "\u003cp\u003eThe type \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e can be used for many kinds of list-like structures\nwith restrictions on the size.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eT [] a\u003c/code\u003e is a lazy list containing at least one element.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT (T []) a\u003c/code\u003e is a lazy list containing at least two elements.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT Vector a\u003c/code\u003e is a vector with at least one element.\n  You may also use unboxed vectors but the first element will be stored in a box\n  and you will not be able to use many functions from this module.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT Maybe a\u003c/code\u003e is a list that contains one or two elements.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eMaybe\u003c/code\u003e is isomorphic to \u003ccode\u003eOptional Empty\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT Empty a\u003c/code\u003e is a list that contains exactly one element.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT (T Empty) a\u003c/code\u003e is a list that contains exactly two elements.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eOptional (T Empty) a\u003c/code\u003e is a list that contains zero or two elements.\n\u003c/li\u003e\u003cli\u003e You can create a list type for every finite set of allowed list length\n  by nesting Optional and NonEmpty constructors.\n  If list length \u003ccode\u003en\u003c/code\u003e is allowed, then place \u003ccode\u003eOptional\u003c/code\u003e at depth \u003ccode\u003en\u003c/code\u003e,\n  if it is disallowed then place \u003ccode\u003eNonEmpty\u003c/code\u003e.\n  The maximm length is marked by \u003ccode\u003eEmpty\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "data",
        "fct-source": "src/Data-NonEmptyPrivate.html#T",
        "fct-type": "data",
        "title": "T"
      },
      "index": {
        "description": "The type can be used for many kinds of list-like structures with restrictions on the size is lazy list containing at least one element is lazy list containing at least two elements Vector is vector with at least one element You may also use unboxed vectors but the first element will be stored in box and you will not be able to use many functions from this module Maybe is list that contains one or two elements Maybe is isomorphic to Optional Empty Empty is list that contains exactly one element Empty is list that contains exactly two elements Optional Empty is list that contains zero or two elements You can create list type for every finite set of allowed list length by nesting Optional and NonEmpty constructors If list length is allowed then place Optional at depth if it is disallowed then place NonEmpty The maximm length is marked by Empty",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "T",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#t:Tails",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "class",
        "fct-source": "src/Data-NonEmptyPrivate.html#Tails",
        "fct-type": "class",
        "title": "Tails"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "Tails",
        "normalized": "",
        "package": "non-empty",
        "partial": "Tails",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:-33-:",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "a -\u003e f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#%21%3A",
        "fct-type": "function",
        "title": "(!:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "(!:) !:",
        "normalized": "a-\u003eb a-\u003eT b a",
        "package": "non-empty",
        "partial": "",
        "signature": "a-\u003ef a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:Cons",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "Cons",
        "fct-source": "src/Data-NonEmptyPrivate.html#T",
        "fct-type": "function",
        "title": "Cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "Cons",
        "normalized": "",
        "package": "non-empty",
        "partial": "Cons",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:append",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#append",
        "fct-type": "function",
        "title": "append"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "append",
        "normalized": "T a b-\u003eT a b-\u003eT a b",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003eT f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:appendLeft",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#appendLeft",
        "fct-type": "function",
        "title": "appendLeft"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "appendLeft",
        "normalized": "a b-\u003eT a b-\u003eT a b",
        "package": "non-empty",
        "partial": "Left",
        "signature": "f a-\u003eT f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:appendRight",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#appendRight",
        "fct-type": "function",
        "title": "appendRight"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "appendRight",
        "normalized": "T a b-\u003ea b-\u003eT a b",
        "package": "non-empty",
        "partial": "Right",
        "signature": "T f a-\u003ef a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:apply",
      "description": {
        "fct-descr": "\u003cp\u003eImplementation of \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e without the \u003ccode\u003e\u003ca\u003eEmpty\u003c/a\u003e\u003c/code\u003e constraint\nthat is needed for \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f (a -\u003e b) -\u003e T f a -\u003e T f b",
        "fct-source": "src/Data-NonEmptyPrivate.html#apply",
        "fct-type": "function",
        "title": "apply"
      },
      "index": {
        "description": "Implementation of without the Empty constraint that is needed for pure",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "apply",
        "normalized": "T a(b-\u003ec)-\u003eT a b-\u003eT a c",
        "package": "non-empty",
        "partial": "",
        "signature": "T f(a-\u003eb)-\u003eT f a-\u003eT f b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:bind",
      "description": {
        "fct-descr": "\u003cp\u003eImplementation of \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e without the \u003ccode\u003e\u003ca\u003eEmpty\u003c/a\u003e\u003c/code\u003e constraint\nthat is needed for \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e (a -\u003e T f b) -\u003e T f b",
        "fct-source": "src/Data-NonEmptyPrivate.html#bind",
        "fct-type": "function",
        "title": "bind"
      },
      "index": {
        "description": "Implementation of without the Empty constraint that is needed for return",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "bind",
        "normalized": "T a b-\u003e(b-\u003eT a c)-\u003eT a c",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003e(a-\u003eT f b)-\u003eT f b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:cons",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "a -\u003e T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "cons",
        "normalized": "a-\u003eT b a-\u003eT b a",
        "package": "non-empty",
        "partial": "",
        "signature": "a-\u003eT f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:cycle",
      "description": {
        "fct-descr": "\u003cp\u003egeneric variants:\n\u003ccode\u003e\u003ca\u003ecycle\u003c/a\u003e\u003c/code\u003e or better \u003ccode\u003eSemigroup.cycle\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#cycle",
        "fct-type": "function",
        "title": "cycle"
      },
      "index": {
        "description": "generic variants cycle or better Semigroup.cycle",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "cycle",
        "normalized": "T a b-\u003eT a b",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:fetch",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e Maybe (T f a)",
        "fct-source": "src/Data-NonEmptyPrivate.html#fetch",
        "fct-type": "function",
        "title": "fetch"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "fetch",
        "normalized": "a b-\u003eMaybe(T a b)",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003eMaybe(T f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:flatten",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#flatten",
        "fct-type": "function",
        "title": "flatten"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "flatten",
        "normalized": "T a b-\u003ea b",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:foldl1",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eT b a-\u003ea",
        "package": "non-empty",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eT f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:force",
      "description": {
        "fct-descr": "\u003cp\u003eForce immediate generation of Cons.\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#force",
        "fct-type": "function",
        "title": "force"
      },
      "index": {
        "description": "Force immediate generation of Cons",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "force",
        "normalized": "T a b-\u003eT a b",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:head",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "a",
        "fct-source": "src/Data-NonEmptyPrivate.html#T",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "head",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:init",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "init",
        "normalized": "T a b-\u003ea b",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:insert",
      "description": {
        "fct-descr": "\u003cp\u003eInsert an element into an ordered list while preserving the order.\nThe first element of the resulting list is returned individually.\nWe need this for construction of a non-empty list.\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "a -\u003e f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#insert",
        "fct-type": "function",
        "title": "insert"
      },
      "index": {
        "description": "Insert an element into an ordered list while preserving the order The first element of the resulting list is returned individually We need this for construction of non-empty list",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "insert",
        "normalized": "a-\u003eb a-\u003eT b a",
        "package": "non-empty",
        "partial": "",
        "signature": "a-\u003ef a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:insertBy",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e a -\u003e f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#insertBy",
        "fct-type": "method",
        "title": "insertBy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "insertBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003eb a-\u003eT b a",
        "package": "non-empty",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003ef a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:last",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "last",
        "normalized": "T a b-\u003eb",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:mapAdjacent",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e b) -\u003e T f a -\u003e f b",
        "fct-source": "src/Data-NonEmptyPrivate.html#mapAdjacent",
        "fct-type": "function",
        "title": "mapAdjacent"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "mapAdjacent",
        "normalized": "(a-\u003ea-\u003eb)-\u003eT c a-\u003ec b",
        "package": "non-empty",
        "partial": "Adjacent",
        "signature": "(a-\u003ea-\u003eb)-\u003eT f a-\u003ef b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:mapHead",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a) -\u003e T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#mapHead",
        "fct-type": "function",
        "title": "mapHead"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "mapHead",
        "normalized": "(a-\u003ea)-\u003eT b a-\u003eT b a",
        "package": "non-empty",
        "partial": "Head",
        "signature": "(a-\u003ea)-\u003eT f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:mapTail",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(f a -\u003e g a) -\u003e T f a -\u003e T g a",
        "fct-source": "src/Data-NonEmptyPrivate.html#mapTail",
        "fct-type": "function",
        "title": "mapTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "mapTail",
        "normalized": "(a b-\u003ec b)-\u003eT a b-\u003eT c b",
        "package": "non-empty",
        "partial": "Tail",
        "signature": "(f a-\u003eg a)-\u003eT f a-\u003eT g a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003emaximum is a total function\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "maximum is total function",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "maximum",
        "normalized": "T a b-\u003eb",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:maximumBy",
      "description": {
        "fct-descr": "\u003cp\u003emaximumBy is a total function\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#maximumBy",
        "fct-type": "function",
        "title": "maximumBy"
      },
      "index": {
        "description": "maximumBy is total function",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "maximumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eT b a-\u003ea",
        "package": "non-empty",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eT f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:maximumKey",
      "description": {
        "fct-descr": "\u003cp\u003emaximumKey is a total function\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e b) -\u003e T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#maximumKey",
        "fct-type": "function",
        "title": "maximumKey"
      },
      "index": {
        "description": "maximumKey is total function",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "maximumKey",
        "normalized": "(a-\u003eb)-\u003eT c a-\u003ea",
        "package": "non-empty",
        "partial": "Key",
        "signature": "(a-\u003eb)-\u003eT f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003eminimum is a total function\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "minimum is total function",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "minimum",
        "normalized": "T a b-\u003eb",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:minimumBy",
      "description": {
        "fct-descr": "\u003cp\u003eminimumBy is a total function\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#minimumBy",
        "fct-type": "function",
        "title": "minimumBy"
      },
      "index": {
        "description": "minimumBy is total function",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "minimumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eT b a-\u003ea",
        "package": "non-empty",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eT f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:minimumKey",
      "description": {
        "fct-descr": "\u003cp\u003eminimumKey is a total function\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e b) -\u003e T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#minimumKey",
        "fct-type": "function",
        "title": "minimumKey"
      },
      "index": {
        "description": "minimumKey is total function",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "minimumKey",
        "normalized": "(a-\u003eb)-\u003eT c a-\u003ea",
        "package": "non-empty",
        "partial": "Key",
        "signature": "(a-\u003eb)-\u003eT f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:product",
      "description": {
        "fct-descr": "\u003cp\u003eproduct does not need a one for initialization\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#product",
        "fct-type": "function",
        "title": "product"
      },
      "index": {
        "description": "product does not need one for initialization",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "product",
        "normalized": "T a b-\u003eb",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:removeEach",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e T f (a, f a)",
        "fct-source": "src/Data-NonEmptyPrivate.html#removeEach",
        "fct-type": "method",
        "title": "removeEach"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "removeEach",
        "normalized": "T a b-\u003eT a(b,a b)",
        "package": "non-empty",
        "partial": "Each",
        "signature": "T f a-\u003eT f(a,f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:reverse",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "reverse",
        "normalized": "T a b-\u003eT a b",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:scanl",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(b -\u003e a -\u003e b) -\u003e b -\u003e f a -\u003e T f b",
        "fct-source": "src/Data-NonEmptyPrivate.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003eT c a",
        "package": "non-empty",
        "partial": "",
        "signature": "(b-\u003ea-\u003eb)-\u003eb-\u003ef a-\u003eT f b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:scanr",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e f a -\u003e T f b",
        "fct-source": "src/Data-NonEmptyPrivate.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "scanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eT c b",
        "package": "non-empty",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ef a-\u003eT f b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:singleton",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "singleton",
        "normalized": "a-\u003eT b a",
        "package": "non-empty",
        "partial": "",
        "signature": "a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:sort",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#sort",
        "fct-type": "function",
        "title": "sort"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "sort",
        "normalized": "T a b-\u003eT a b",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:sortBy",
      "description": {
        "fct-descr": "\u003cp\u003eIf you nest too many non-empty lists\nthen the efficient merge-sort (linear-logarithmic runtime)\nwill degenerate to an inefficient insert-sort (quadratic runtime).\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e T f a -\u003e T f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#sortBy",
        "fct-type": "function",
        "title": "sortBy"
      },
      "index": {
        "description": "If you nest too many non-empty lists then the efficient merge-sort linear-logarithmic runtime will degenerate to an inefficient insert-sort quadratic runtime",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "sortBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eT b a-\u003eT b a",
        "package": "non-empty",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eT f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003esum does not need a zero for initialization\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e a",
        "fct-source": "src/Data-NonEmptyPrivate.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "sum does not need zero for initialization",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "sum",
        "normalized": "T a b-\u003eb",
        "package": "non-empty",
        "partial": "",
        "signature": "T f a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:tail",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "f a",
        "fct-source": "src/Data-NonEmptyPrivate.html#T",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "tail",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:tails",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "f a -\u003e T f (g a)",
        "fct-source": "src/Data-NonEmptyPrivate.html#tails",
        "fct-type": "method",
        "title": "tails"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "tails",
        "normalized": "a b-\u003eT a(c b)",
        "package": "non-empty",
        "partial": "",
        "signature": "f a-\u003eT f(g a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:toList",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e [a]",
        "fct-source": "src/Data-NonEmptyPrivate.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "toList",
        "normalized": "T a b-\u003e[b]",
        "package": "non-empty",
        "partial": "List",
        "signature": "T f a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:transposeClip",
      "description": {
        "fct-descr": "\u003cp\u003eAlways returns a rectangular list\nby clipping all dimensions to the shortest slice.\nBe aware that \u003ccode\u003etranspose [] == repeat []\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "f (g a) -\u003e g (f a)",
        "fct-source": "src/Data-Zip.html#transposeClip",
        "fct-type": "function",
        "title": "transposeClip"
      },
      "index": {
        "description": "Always returns rectangular list by clipping all dimensions to the shortest slice Be aware that transpose repeat",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "transposeClip",
        "normalized": "a(b c)-\u003eb(a c)",
        "package": "non-empty",
        "partial": "Clip",
        "signature": "f(g a)-\u003eg(f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:zipWith",
      "description": {
        "fct-module": "Data.NonEmpty",
        "fct-package": "non-empty",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e T f a -\u003e T f b -\u003e T f c",
        "fct-source": "src/Data-NonEmptyPrivate.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Data NonEmpty",
        "module": "Data.NonEmpty",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003eT d a-\u003eT d b-\u003eT d c",
        "package": "non-empty",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eT f a-\u003eT f b-\u003eT f c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#",
      "description": {
        "fct-module": "Data.Optional",
        "fct-package": "non-empty",
        "fct-signature": "module",
        "fct-source": "src/Data-Optional.html",
        "fct-type": "module",
        "title": "Optional"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Optional",
        "module": "Data.Optional",
        "name": "Optional",
        "normalized": "",
        "package": "non-empty",
        "partial": "Optional",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#t:T",
      "description": {
        "fct-module": "Data.Optional",
        "fct-package": "non-empty",
        "fct-signature": "data",
        "fct-source": "src/Data-Optional.html#T",
        "fct-type": "data",
        "title": "T"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Optional",
        "module": "Data.Optional",
        "name": "T",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:-63-:",
      "description": {
        "fct-module": "Data.Optional",
        "fct-package": "non-empty",
        "fct-signature": "a -\u003e f a -\u003e T f a",
        "fct-source": "src/Data-Optional.html#%3F%3A",
        "fct-type": "function",
        "title": "(?:)"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Optional",
        "module": "Data.Optional",
        "name": "(?:) ?:",
        "normalized": "a-\u003eb a-\u003eT b a",
        "package": "non-empty",
        "partial": "",
        "signature": "a-\u003ef a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:Cons",
      "description": {
        "fct-module": "Data.Optional",
        "fct-package": "non-empty",
        "fct-signature": "Cons a (f a)",
        "fct-source": "src/Data-Optional.html#T",
        "fct-type": "function",
        "title": "Cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Optional",
        "module": "Data.Optional",
        "name": "Cons",
        "normalized": "",
        "package": "non-empty",
        "partial": "Cons",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:Nil",
      "description": {
        "fct-module": "Data.Optional",
        "fct-package": "non-empty",
        "fct-signature": "Nil",
        "fct-source": "src/Data-Optional.html#T",
        "fct-type": "function",
        "title": "Nil"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Optional",
        "module": "Data.Optional",
        "name": "Nil",
        "normalized": "",
        "package": "non-empty",
        "partial": "Nil",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:fromEmpty",
      "description": {
        "fct-module": "Data.Optional",
        "fct-package": "non-empty",
        "fct-signature": "T a -\u003e T f a",
        "fct-source": "src/Data-Optional.html#fromEmpty",
        "fct-type": "function",
        "title": "fromEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Optional",
        "module": "Data.Optional",
        "name": "fromEmpty",
        "normalized": "T a-\u003eT b a",
        "package": "non-empty",
        "partial": "Empty",
        "signature": "T a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:fromNonEmpty",
      "description": {
        "fct-module": "Data.Optional",
        "fct-package": "non-empty",
        "fct-signature": "T f a -\u003e T f a",
        "fct-source": "src/Data-Optional.html#fromNonEmpty",
        "fct-type": "function",
        "title": "fromNonEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Optional",
        "module": "Data.Optional",
        "name": "fromNonEmpty",
        "normalized": "T a b-\u003eT a b",
        "package": "non-empty",
        "partial": "Non Empty",
        "signature": "T f a-\u003eT f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#",
      "description": {
        "fct-module": "Data.Zip",
        "fct-package": "non-empty",
        "fct-signature": "module",
        "fct-source": "src/Data-Zip.html",
        "fct-type": "module",
        "title": "Zip"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Zip",
        "module": "Data.Zip",
        "name": "Zip",
        "normalized": "",
        "package": "non-empty",
        "partial": "Zip",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#t:T",
      "description": {
        "fct-descr": "\u003cp\u003eWrap a container such that its Applicative instance is based on zip.\n\u003c/p\u003e",
        "fct-module": "Data.Zip",
        "fct-package": "non-empty",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Zip.html#T",
        "fct-type": "newtype",
        "title": "T"
      },
      "index": {
        "description": "Wrap container such that its Applicative instance is based on zip",
        "hierarchy": "Data Zip",
        "module": "Data.Zip",
        "name": "T",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#v:Cons",
      "description": {
        "fct-module": "Data.Zip",
        "fct-package": "non-empty",
        "fct-signature": "Cons",
        "fct-source": "src/Data-Zip.html#T",
        "fct-type": "function",
        "title": "Cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Zip",
        "module": "Data.Zip",
        "name": "Cons",
        "normalized": "",
        "package": "non-empty",
        "partial": "Cons",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#v:decons",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Zip",
        "fct-package": "non-empty",
        "fct-signature": "f a",
        "fct-source": "src/Data-Zip.html#T",
        "fct-type": "function",
        "title": "decons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Zip",
        "module": "Data.Zip",
        "name": "decons",
        "normalized": "",
        "package": "non-empty",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#v:transposeClip",
      "description": {
        "fct-descr": "\u003cp\u003eAlways returns a rectangular list\nby clipping all dimensions to the shortest slice.\nBe aware that \u003ccode\u003etranspose [] == repeat []\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Zip",
        "fct-package": "non-empty",
        "fct-signature": "f (g a) -\u003e g (f a)",
        "fct-source": "src/Data-Zip.html#transposeClip",
        "fct-type": "function",
        "title": "transposeClip"
      },
      "index": {
        "description": "Always returns rectangular list by clipping all dimensions to the shortest slice Be aware that transpose repeat",
        "hierarchy": "Data Zip",
        "module": "Data.Zip",
        "name": "transposeClip",
        "normalized": "a(b c)-\u003eb(a c)",
        "package": "non-empty",
        "partial": "Clip",
        "signature": "f(g a)-\u003eg(f a)"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Data-Typeable-Extras.html#",
      "description": {
        "fct-module": "Data.Typeable.Extras",
        "fct-package": "type-settheory",
        "fct-signature": "module",
        "fct-source": "src/Data-Typeable-Extras.html",
        "fct-type": "module",
        "title": "Extras"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Typeable Extras",
        "module": "Data.Typeable.Extras",
        "name": "Extras",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Extras",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Data-Typeable-Extras.html#v:dynCompare",
      "description": {
        "fct-module": "Data.Typeable.Extras",
        "fct-package": "type-settheory",
        "fct-signature": "a -\u003e b -\u003e Ordering",
        "fct-source": "src/Data-Typeable-Extras.html#dynCompare",
        "fct-type": "function",
        "title": "dynCompare"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Typeable Extras",
        "module": "Data.Typeable.Extras",
        "name": "dynCompare",
        "normalized": "a-\u003eb-\u003eOrdering",
        "package": "type-settheory",
        "partial": "Compare",
        "signature": "a-\u003eb-\u003eOrdering"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Data-Typeable-Extras.html#v:dynEq",
      "description": {
        "fct-module": "Data.Typeable.Extras",
        "fct-package": "type-settheory",
        "fct-signature": "a -\u003e b -\u003e Bool",
        "fct-source": "src/Data-Typeable-Extras.html#dynEq",
        "fct-type": "function",
        "title": "dynEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Typeable Extras",
        "module": "Data.Typeable.Extras",
        "name": "dynEq",
        "normalized": "a-\u003eb-\u003eBool",
        "package": "type-settheory",
        "partial": "Eq",
        "signature": "a-\u003eb-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "module",
        "fct-source": "src/Type-Dummies.html",
        "fct-type": "module",
        "title": "Dummies"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Dummies",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Dummies",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:BOOL",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#BOOL",
        "fct-type": "data",
        "title": "BOOL"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "BOOL",
        "normalized": "",
        "package": "type-settheory",
        "partial": "BOOL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Bool0",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#Bool0",
        "fct-type": "data",
        "title": "Bool0"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Bool0",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Bool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Bool1",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#Bool1",
        "fct-type": "data",
        "title": "Bool1"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Bool1",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Bool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Lower",
      "description": {
        "fct-descr": "\u003cp\u003e\"Kind-cast\" \u003ccode\u003e (* -\u003e *) \u003c/code\u003e to \u003ccode\u003e*\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#Lower",
        "fct-type": "data",
        "title": "Lower"
      },
      "index": {
        "description": "Kind-cast to",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Lower",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Lower",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Lower1",
      "description": {
        "fct-descr": "\u003cp\u003e\"Kind-cast\" \u003ccode\u003e ((* -\u003e *) -\u003e *) \u003c/code\u003e to \u003ccode\u003e (* -\u003e *) \u003c/code\u003e. Also lower elements using \u003ccode\u003e\u003ca\u003eLower\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#Lower1",
        "fct-type": "data",
        "title": "Lower1"
      },
      "index": {
        "description": "Kind-cast to Also lower elements using Lower",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Lower1",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Lower",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Lower2",
      "description": {
        "fct-descr": "\u003cp\u003e\"Kind-cast\" \u003ccode\u003e (((* -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e to \u003ccode\u003e ((* -\u003e *) -\u003e *) \u003c/code\u003e. Also lower elements using \u003ccode\u003e\u003ca\u003eLower1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#Lower2",
        "fct-type": "data",
        "title": "Lower2"
      },
      "index": {
        "description": "Kind-cast to Also lower elements using Lower1",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Lower2",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Lower",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Lower3",
      "description": {
        "fct-descr": "\u003cp\u003e\"Kind-cast\" \u003ccode\u003e ((((* -\u003e *) -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e to \u003ccode\u003e (((* -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e. Also lower elements using \u003ccode\u003e\u003ca\u003eLower2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#Lower3",
        "fct-type": "data",
        "title": "Lower3"
      },
      "index": {
        "description": "Kind-cast to Also lower elements using Lower2",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Lower3",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Lower",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:PAIR",
      "description": {
        "fct-descr": "\u003cp\u003ePair of types of kind \u003ccode\u003e (* -\u003e *) \u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#PAIR",
        "fct-type": "data",
        "title": "PAIR"
      },
      "index": {
        "description": "Pair of types of kind",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "PAIR",
        "normalized": "",
        "package": "type-settheory",
        "partial": "PAIR",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:PAIR1",
      "description": {
        "fct-descr": "\u003cp\u003ePair of types of kind \u003ccode\u003e ((* -\u003e *) -\u003e *) \u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#PAIR1",
        "fct-type": "data",
        "title": "PAIR1"
      },
      "index": {
        "description": "Pair of types of kind",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "PAIR1",
        "normalized": "",
        "package": "type-settheory",
        "partial": "PAIR",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:PAIR2",
      "description": {
        "fct-descr": "\u003cp\u003ePair of types of kind \u003ccode\u003e (((* -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#PAIR2",
        "fct-type": "data",
        "title": "PAIR2"
      },
      "index": {
        "description": "Pair of types of kind",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "PAIR2",
        "normalized": "",
        "package": "type-settheory",
        "partial": "PAIR",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:PAIR3",
      "description": {
        "fct-descr": "\u003cp\u003ePair of types of kind \u003ccode\u003e ((((* -\u003e *) -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Dummies.html#PAIR3",
        "fct-type": "data",
        "title": "PAIR3"
      },
      "index": {
        "description": "Pair of types of kind",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "PAIR3",
        "normalized": "",
        "package": "type-settheory",
        "partial": "PAIR",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:Bool0",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "BOOL Bool0",
        "fct-source": "src/Type-Dummies.html#BOOL",
        "fct-type": "function",
        "title": "Bool0"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Bool0",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Bool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:Bool1",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "BOOL Bool1",
        "fct-source": "src/Type-Dummies.html#BOOL",
        "fct-type": "function",
        "title": "Bool1"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Bool1",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Bool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:Lower1Element",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "u x -\u003e Lower2 u (Lower1 x)",
        "fct-source": "src/Type-Dummies.html#Lower2",
        "fct-type": "function",
        "title": "Lower1Element"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Lower1Element",
        "normalized": "a b-\u003eLower a(Lower b)",
        "package": "type-settheory",
        "partial": "Lower Element",
        "signature": "u x-\u003eLower u(Lower x)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:Lower2Element",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "u x -\u003e Lower3 u (Lower2 x)",
        "fct-source": "src/Type-Dummies.html#Lower3",
        "fct-type": "function",
        "title": "Lower2Element"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "Lower2Element",
        "normalized": "a b-\u003eLower a(Lower b)",
        "package": "type-settheory",
        "partial": "Lower Element",
        "signature": "u x-\u003eLower u(Lower x)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:LowerElement",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "u x -\u003e Lower1 u (Lower x)",
        "fct-source": "src/Type-Dummies.html#Lower1",
        "fct-type": "function",
        "title": "LowerElement"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "LowerElement",
        "normalized": "a b-\u003eLower a(Lower b)",
        "package": "type-settheory",
        "partial": "Lower Element",
        "signature": "u x-\u003eLower u(Lower x)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:elimBOOL",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "BOOL a -\u003e r Bool0 -\u003e r Bool1 -\u003e r a",
        "fct-source": "src/Type-Dummies.html#elimBOOL",
        "fct-type": "function",
        "title": "elimBOOL"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "elimBOOL",
        "normalized": "BOOL a-\u003eb Bool-\u003eb Bool-\u003eb a",
        "package": "type-settheory",
        "partial": "BOOL",
        "signature": "BOOL a-\u003er Bool-\u003er Bool-\u003er a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:kelimBOOL",
      "description": {
        "fct-module": "Type.Dummies",
        "fct-package": "type-settheory",
        "fct-signature": "BOOL a -\u003e r -\u003e r -\u003e r",
        "fct-source": "src/Type-Dummies.html#kelimBOOL",
        "fct-type": "function",
        "title": "kelimBOOL"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Dummies",
        "module": "Type.Dummies",
        "name": "kelimBOOL",
        "normalized": "BOOL a-\u003eb-\u003eb-\u003eb",
        "package": "type-settheory",
        "partial": "BOOL",
        "signature": "BOOL a-\u003er-\u003er-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNotes\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Functions are coded as functional relations (in particular, functions are sets)\n\u003c/li\u003e\u003cli\u003e Extensional equality of functions coincedes with extensional equality of sets.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "module",
        "fct-source": "src/Type-Function.html",
        "fct-type": "module",
        "title": "Function"
      },
      "index": {
        "description": "Notes Functions are coded as functional relations in particular functions are sets Extensional equality of functions coincedes with extensional equality of sets",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Function",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Function",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:-928-",
      "description": {
        "fct-descr": "\u003cp\u003eNB: \u003ccode\u003efam\u003c/code\u003e must be a function mapping some set to a set of sets, or the second condition in the constructor is vacuous\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#%3A0",
        "fct-type": "data",
        "title": "Π"
      },
      "index": {
        "description": "NB fam must be function mapping some set to set of sets or the second condition in the constructor is vacuous",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Π",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t::-126--126--62-:",
      "description": {
        "fct-descr": "\u003cp\u003eKind-casted variant (function space as a set)\n\u003c/p\u003e\u003cp\u003eConvention: Instances of \u003ccode\u003e\u003ca\u003eFact\u003c/a\u003e\u003c/code\u003e should always prove \u003ccode\u003e\u003ca\u003e:~\u003e:\u003c/a\u003e\u003c/code\u003e rather than this type.\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Function.html#%3A~~%3E%3A",
        "fct-type": "type",
        "title": ":~~\u003e:"
      },
      "index": {
        "description": "Kind-casted variant function space as set Convention Instances of Fact should always prove rather than this type",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": ":~~\u003e:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t::-126--62-:",
      "description": {
        "fct-descr": "\u003cp\u003eFunctions are encoded as functional relations; the three arguments to the construcor are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Is a relation\n\u003c/li\u003e\u003cli\u003e Totality\n\u003c/li\u003e\u003cli\u003e Single-valuedness (CPS-encoded; using \u003ccode\u003e\u003ca\u003e:=:\u003c/a\u003e\u003c/code\u003e would work just as well. I hope that the CPS variant makes the optimizer more happy, but this is pure speculation)\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#%3A~%3E%3A",
        "fct-type": "data",
        "title": ":~\u003e:"
      },
      "index": {
        "description": "Functions are encoded as functional relations the three arguments to the construcor are Is relation Totality Single-valuedness CPS-encoded using would work just as well hope that the CPS variant makes the optimizer more happy but this is pure speculation",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": ":~\u003e:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t::-42--42--42-:",
      "description": {
        "fct-descr": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003e***\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#%3A%2A%2A%2A%3A",
        "fct-type": "data",
        "title": ":***:"
      },
      "index": {
        "description": "Analogous to",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": ":***:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t::-9675-:",
      "description": {
        "fct-descr": "\u003cp\u003eComposition\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#%3A%25CB%3A",
        "fct-type": "data",
        "title": ":○:"
      },
      "index": {
        "description": "Composition",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": ":○:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:BiGraph",
      "description": {
        "fct-descr": "\u003cp\u003eGraph of a \u003ccode\u003e(* -\u003e * -\u003e *)\u003c/code\u003e type constructor\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#BiGraph",
        "fct-type": "data",
        "title": "BiGraph"
      },
      "index": {
        "description": "Graph of type constructor",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "BiGraph",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Bi Graph",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Const",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Const",
        "fct-type": "data",
        "title": "Const"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Const",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Const",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Equaliser",
      "description": {
        "fct-descr": "\u003cp\u003eEqualisers :D\n\u003c/p\u003e\u003cp\u003eIn our category, the equaliser of two parallel functions \u003ccode\u003ef1\u003c/code\u003e and \u003ccode\u003ef2\u003c/code\u003e is the set of types on which \u003ccode\u003ef1\u003c/code\u003e and \u003ccode\u003ef2\u003c/code\u003e agree; that is:\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eEqualiser f1 f2 = { x | f1 x = f2 x }\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Equaliser",
        "fct-type": "data",
        "title": "Equaliser"
      },
      "index": {
        "description": "Equalisers In our category the equaliser of two parallel functions f1 and f2 is the set of types on which f1 and f2 agree that is Equaliser f1 f2 f1 f2",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Equaliser",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Equaliser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:EqualiserIncl",
      "description": {
        "fct-descr": "\u003cp\u003eInclusion of the equaliser into the domain of the parallel functions\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Function.html#EqualiserIncl",
        "fct-type": "type",
        "title": "EqualiserIncl"
      },
      "index": {
        "description": "Inclusion of the equaliser into the domain of the parallel functions",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "EqualiserIncl",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Equaliser Incl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:ExSnd",
      "description": {
        "fct-descr": "\u003cp\u003eExistential quantification over the first component of a pair\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#ExSnd",
        "fct-type": "data",
        "title": "ExSnd"
      },
      "index": {
        "description": "Existential quantification over the first component of pair",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "ExSnd",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Ex Snd",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Fst",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Fst",
        "fct-type": "data",
        "title": "Fst"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Fst",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Fst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Graph",
      "description": {
        "fct-descr": "\u003cp\u003eGraph of a \u003ccode\u003e(* -\u003e *)\u003c/code\u003e type constructor\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Graph",
        "fct-type": "data",
        "title": "Graph"
      },
      "index": {
        "description": "Graph of type constructor",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Graph",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Graph",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:HaskFun",
      "description": {
        "fct-descr": "\u003cp\u003eThe type-level function:\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eHaskFun(a,b) = (a -\u003e b)\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#HaskFun",
        "fct-type": "data",
        "title": "HaskFun"
      },
      "index": {
        "description": "The type-level function HaskFun",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "HaskFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Hask Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Id",
      "description": {
        "fct-descr": "\u003cp\u003eIdentity function on \u003ccode\u003edom\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Function.html#Id",
        "fct-type": "type",
        "title": "Id"
      },
      "index": {
        "description": "Identity function on dom",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Id",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Image",
      "description": {
        "fct-descr": "\u003cp\u003eImage of a set under the function\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Image",
        "fct-type": "data",
        "title": "Image"
      },
      "index": {
        "description": "Image of set under the function",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Image",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Image",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Incl",
      "description": {
        "fct-descr": "\u003cp\u003eInclusion function of a subset\n\u003c/p\u003e\u003cp\u003eInclusions \u003cem\u003edo\u003c/em\u003e know their codomain (somewhat arbitrary design decision)\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Incl",
        "fct-type": "data",
        "title": "Incl"
      },
      "index": {
        "description": "Inclusion function of subset Inclusions do know their codomain somewhat arbitrary design decision",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Incl",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Incl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Injective",
      "description": {
        "fct-descr": "\u003cp\u003eInjective functions\n\u003c/p\u003e\u003cp\u003e(NB: Surjectivity is meaningless here because our functions don't know their codomain, but we have \u003ccode\u003e\u003ca\u003eImage\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Injective",
        "fct-type": "data",
        "title": "Injective"
      },
      "index": {
        "description": "Injective functions NB Surjectivity is meaningless here because our functions don know their codomain but we have Image",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Injective",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Injective",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Inv",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Inv",
        "fct-type": "data",
        "title": "Inv"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Inv",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Inv",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:KleisliHom",
      "description": {
        "fct-descr": "\u003cp\u003eThe type-level function:\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eKleisliHom(a,b) = (a -\u003e m b)\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#KleisliHom",
        "fct-type": "data",
        "title": "KleisliHom"
      },
      "index": {
        "description": "The type-level function KleisliHom",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "KleisliHom",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Kleisli Hom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Preimage",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Preimage",
        "fct-type": "data",
        "title": "Preimage"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Preimage",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Preimage",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Section",
      "description": {
        "fct-descr": "\u003cp\u003eExpresses that \u003ccode\u003ef\u003c/code\u003e is a section of \u003ccode\u003ebundleMap\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Section",
        "fct-type": "data",
        "title": "Section"
      },
      "index": {
        "description": "Expresses that is section of bundleMap",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Section",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Section",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Snd",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#Snd",
        "fct-type": "data",
        "title": "Snd"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Snd",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Snd",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Sval",
      "description": {
        "fct-descr": "\u003cp\u003eSingle-valuedness (CPS)\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Function.html#Sval",
        "fct-type": "type",
        "title": "Sval"
      },
      "index": {
        "description": "Single-valuedness CPS",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Sval",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Sval",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:ToTyCon",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Function.html#ToTyCon",
        "fct-type": "data",
        "title": "ToTyCon"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "ToTyCon",
        "normalized": "",
        "package": "type-settheory",
        "partial": "To Ty Con",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Total",
      "description": {
        "fct-descr": "\u003cp\u003eTotality\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Function.html#Total",
        "fct-type": "type",
        "title": "Total"
      },
      "index": {
        "description": "Totality",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Total",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Total",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:-928-",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(base :~\u003e: Unions fam) f -\u003e (forall x y s.  ((x, y) :∈: f) -\u003e ((x, Lower s) :∈: fam) -\u003e x :∈: s) -\u003e Π fam f",
        "fct-source": "src/Type-Function.html#%3A0",
        "fct-type": "function",
        "title": "Π"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Π",
        "normalized": "(a Unions b)c-\u003e(d e f g((e,f)c)-\u003e((e,Lower h)b)-\u003ee h)-\u003eΠ b c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(base Unions fam)f-\u003e(forall x y s.((x,y)f)-\u003e((x,Lower s)fam)-\u003ex s)-\u003eΠ fam f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v::-42--42--42-:",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((,) a b1 :∈: f1) -\u003e ((,) a b2 :∈: f2) -\u003e (f1 :***: f2) (a, (,) b1 b2)",
        "fct-source": "src/Type-Function.html#%3A%2A%2A%2A%3A",
        "fct-type": "function",
        "title": ":***:"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": ":***:",
        "normalized": "((,)a b c)-\u003e((,)a b c)-\u003e(c***c)(a,(,)b b)",
        "package": "type-settheory",
        "partial": "",
        "signature": "((,)a b f)-\u003e((,)a b f)-\u003e(f***f)(a,(,)b b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:BiGraph",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "BiGraph f ((a, b), f a b)",
        "fct-source": "src/Type-Function.html#BiGraph",
        "fct-type": "function",
        "title": "BiGraph"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "BiGraph",
        "normalized": "BiGraph a((b,c),a b c)",
        "package": "type-settheory",
        "partial": "Bi Graph",
        "signature": "BiGraph f((a,b),f a b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Compo",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((b, c) :∈: g) -\u003e ((a, b) :∈: f) -\u003e (g :○: f) (a, c)",
        "fct-source": "src/Type-Function.html#%3A%25CB%3A",
        "fct-type": "function",
        "title": "Compo"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Compo",
        "normalized": "((a,b)c)-\u003e((d,a)e)-\u003e(c e)(d,b)",
        "package": "type-settheory",
        "partial": "Compo",
        "signature": "((b,c)g)-\u003e((a,b)f)-\u003e(g f)(a,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Const",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: dom) -\u003e Const dom x (a, x)",
        "fct-source": "src/Type-Function.html#Const",
        "fct-type": "function",
        "title": "Const"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Const",
        "normalized": "(a b)-\u003eConst b c(a,c)",
        "package": "type-settheory",
        "partial": "Const",
        "signature": "(a dom)-\u003eConst dom x(a,x)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Equaliser",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((a, b) :∈: f1) -\u003e ((a, b) :∈: f2) -\u003e Equaliser f1 f2 a",
        "fct-source": "src/Type-Function.html#Equaliser",
        "fct-type": "function",
        "title": "Equaliser"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Equaliser",
        "normalized": "((a,b)c)-\u003e((a,b)c)-\u003eEqualiser c c a",
        "package": "type-settheory",
        "partial": "Equaliser",
        "signature": "((a,b)f)-\u003e((a,b)f)-\u003eEqualiser f f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:ExSnd",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((a, ex) :∈: f) -\u003e ExSnd f a",
        "fct-source": "src/Type-Function.html#ExSnd",
        "fct-type": "function",
        "title": "ExSnd"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "ExSnd",
        "normalized": "((a,b)c)-\u003eExSnd c a",
        "package": "type-settheory",
        "partial": "Ex Snd",
        "signature": "((a,ex)f)-\u003eExSnd f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Fst",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: s1) -\u003e (b :∈: s2) -\u003e Fst s1 s2 ((,) ((,) a b) a)",
        "fct-source": "src/Type-Function.html#Fst",
        "fct-type": "function",
        "title": "Fst"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Fst",
        "normalized": "(a b)-\u003e(c b)-\u003eFst b b((,)((,)a c)a)",
        "package": "type-settheory",
        "partial": "Fst",
        "signature": "(a s)-\u003e(b s)-\u003eFst s s((,)((,)a b)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Graph",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Graph f (a, f a)",
        "fct-source": "src/Type-Function.html#Graph",
        "fct-type": "function",
        "title": "Graph"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Graph",
        "normalized": "Graph a(b,a b)",
        "package": "type-settheory",
        "partial": "Graph",
        "signature": "Graph f(a,f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:HaskFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "HaskFun ((,) ((,) a b) (a -\u003e b))",
        "fct-source": "src/Type-Function.html#HaskFun",
        "fct-type": "function",
        "title": "HaskFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "HaskFun",
        "normalized": "HaskFun((,)((,)a b)(a-\u003eb))",
        "package": "type-settheory",
        "partial": "Hask Fun",
        "signature": "HaskFun((,)((,)a b)(a-\u003eb))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Image",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: s) -\u003e ((a, b) :∈: f) -\u003e Image f s b",
        "fct-source": "src/Type-Function.html#Image",
        "fct-type": "function",
        "title": "Image"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Image",
        "normalized": "(a b)-\u003e((a,c)d)-\u003eImage d b c",
        "package": "type-settheory",
        "partial": "Image",
        "signature": "(a s)-\u003e((a,b)f)-\u003eImage f s b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Incl",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "dom a -\u003e Incl dom cod (a, a)",
        "fct-source": "src/Type-Function.html#Incl",
        "fct-type": "function",
        "title": "Incl"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Incl",
        "normalized": "a b-\u003eIncl a c(b,b)",
        "package": "type-settheory",
        "partial": "Incl",
        "signature": "dom a-\u003eIncl dom cod(a,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Injective",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "r) -\u003e r) -\u003e Injective f",
        "fct-source": "src/Type-Function.html#Injective",
        "fct-type": "function",
        "title": "Injective"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Injective",
        "normalized": "a)-\u003ea)-\u003eInjective b",
        "package": "type-settheory",
        "partial": "Injective",
        "signature": "r)-\u003er)-\u003eInjective f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Inv",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((a, b) :∈: f) -\u003e Inv f (b, a)",
        "fct-source": "src/Type-Function.html#Inv",
        "fct-type": "function",
        "title": "Inv"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Inv",
        "normalized": "((a,b)c)-\u003eInv c(b,a)",
        "package": "type-settheory",
        "partial": "Inv",
        "signature": "((a,b)f)-\u003eInv f(b,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:IsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(f :⊆: (dom :×: cod)) -\u003e Total dom f -\u003e Sval f -\u003e (dom :~\u003e: cod) f",
        "fct-source": "src/Type-Function.html#%3A~%3E%3A",
        "fct-type": "function",
        "title": "IsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "IsFun",
        "normalized": "(a(b c))-\u003eTotal b a-\u003eSval a-\u003e(b c)a",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": "(f(dom cod))-\u003eTotal dom f-\u003eSval f-\u003e(dom cod)f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:KleisliHom",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "KleisliHom m ((,) ((,) a b) (a -\u003e m b))",
        "fct-source": "src/Type-Function.html#KleisliHom",
        "fct-type": "function",
        "title": "KleisliHom"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "KleisliHom",
        "normalized": "KleisliHom a((,)((,)b c)(b-\u003ea c))",
        "package": "type-settheory",
        "partial": "Kleisli Hom",
        "signature": "KleisliHom m((,)((,)a b)(a-\u003em b))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Preimage",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((a, b) :∈: f) -\u003e (b :∈: s) -\u003e Preimage f s a",
        "fct-source": "src/Type-Function.html#Preimage",
        "fct-type": "function",
        "title": "Preimage"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Preimage",
        "normalized": "((a,b)c)-\u003e(b d)-\u003ePreimage c d a",
        "package": "type-settheory",
        "partial": "Preimage",
        "signature": "((a,b)f)-\u003e(b s)-\u003ePreimage f s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Section",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(forall x y.  ((x, y) :∈: f) -\u003e (y, x) :∈: bundleMap) -\u003e Section bundleMap f",
        "fct-source": "src/Type-Function.html#Section",
        "fct-type": "function",
        "title": "Section"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Section",
        "normalized": "(a b c((b,d)e)-\u003e(d,b)f)-\u003eSection f e",
        "package": "type-settheory",
        "partial": "Section",
        "signature": "(forall x y.((x,y)f)-\u003e(y,x)bundleMap)-\u003eSection bundleMap f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Snd",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: s1) -\u003e (b :∈: s2) -\u003e Snd s1 s2 ((,) ((,) a b) b)",
        "fct-source": "src/Type-Function.html#Snd",
        "fct-type": "function",
        "title": "Snd"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "Snd",
        "normalized": "(a b)-\u003e(c b)-\u003eSnd b b((,)((,)a c)c)",
        "package": "type-settheory",
        "partial": "Snd",
        "signature": "(a s)-\u003e(b s)-\u003eSnd s s((,)((,)a b)b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:ToTyCon",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "forall y . ToTyCon ((x, y) :∈: f) y",
        "fct-source": "src/Type-Function.html#ToTyCon",
        "fct-type": "function",
        "title": "ToTyCon"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "ToTyCon",
        "normalized": "a b ToTyCon((c,b)d)b",
        "package": "type-settheory",
        "partial": "To Ty Con",
        "signature": "forall y ToTyCon((x,y)f)y"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:adjustCod",
      "description": {
        "fct-descr": "\u003cp\u003eChange the codomain by proving that the full image is included in the new codomain\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (Image f dom :⊆: cod') -\u003e (dom :~\u003e: cod') f",
        "fct-source": "src/Type-Function.html#adjustCod",
        "fct-type": "function",
        "title": "adjustCod"
      },
      "index": {
        "description": "Change the codomain by proving that the full image is included in the new codomain",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "adjustCod",
        "normalized": "(a b)c-\u003e(Image c a d)-\u003e(a d)c",
        "package": "type-settheory",
        "partial": "Cod",
        "signature": "(dom cod)f-\u003e(Image f dom cod')-\u003e(dom cod')f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:biGraphInjective",
      "description": {
        "fct-descr": "\u003cp\u003eType constructors are injective\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Injective (BiGraph f)",
        "fct-source": "src/Type-Function.html#biGraphInjective",
        "fct-type": "function",
        "title": "biGraphInjective"
      },
      "index": {
        "description": "Type constructors are injective",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "biGraphInjective",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Graph Injective",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:biGraphIsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((Univ :×: Univ) :~\u003e: Univ) (BiGraph f)",
        "fct-source": "src/Type-Function.html#biGraphIsFun",
        "fct-type": "function",
        "title": "biGraphIsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "biGraphIsFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Graph Is Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:biGraph_eq_HaskFun",
      "description": {
        "fct-descr": "\u003cp\u003eExample of an extensional equation between functions\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "BiGraph (-\u003e) :==: HaskFun",
        "fct-source": "src/Type-Function.html#biGraph_eq_HaskFun",
        "fct-type": "function",
        "title": "biGraph_eq_HaskFun"
      },
      "index": {
        "description": "Example of an extensional equation between functions",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "biGraph_eq_HaskFun",
        "normalized": "BiGraph(-\u003e)HaskFun",
        "package": "type-settheory",
        "partial": "Graph Hask Fun",
        "signature": "BiGraph(-\u003e)HaskFun"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compoId_Section",
      "description": {
        "fct-descr": "\u003cp\u003eComposition is \u003cem\u003eid\u003c/em\u003e ==\u003e is section\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(total :~\u003e: base) bun -\u003e (base :~\u003e: total) f -\u003e ((bun :○: f) :==: Id base) -\u003e Section bun f",
        "fct-source": "src/Type-Function.html#compoId_Section",
        "fct-type": "function",
        "title": "compoId_Section"
      },
      "index": {
        "description": "Composition is id is section",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "compoId_Section",
        "normalized": "(a b)c-\u003e(b a)d-\u003e((c d)Id b)-\u003eSection c d",
        "package": "type-settheory",
        "partial": "Id Section",
        "signature": "(total base)bun-\u003e(base total)f-\u003e((bun f)Id base)-\u003eSection bun f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compoIsFun",
      "description": {
        "fct-descr": "\u003cp\u003eThe composition is a function\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(s2 :~\u003e: s3) g -\u003e (s1 :~\u003e: s2) f -\u003e (s1 :~\u003e: s3) (g :○: f)",
        "fct-source": "src/Type-Function.html#compoIsFun",
        "fct-type": "function",
        "title": "compoIsFun"
      },
      "index": {
        "description": "The composition is function",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "compoIsFun",
        "normalized": "(a a)b-\u003e(a a)c-\u003e(a a)(b c)",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": "(s s)g-\u003e(s s)f-\u003e(s s)(g f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compo_assoc",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": ":~\u003e: s2 cod g -\u003e :~\u003e: s21 s2 f -\u003e :~\u003e: dom s21 f1 -\u003e ((g :○: f) :○: f1) :==: (g :○: (f :○: f1))",
        "fct-source": "src/Type-Function.html#compo_assoc",
        "fct-type": "function",
        "title": "compo_assoc"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "compo_assoc",
        "normalized": "a b c-\u003ea a d-\u003ee a d-\u003e((c d)d)(c(d d))",
        "package": "type-settheory",
        "partial": "",
        "signature": "s cod g-\u003es s f-\u003edom s f-\u003e((g f)f)(g(f f))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compo_idl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e is a left identity for composition                            \n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(d :~\u003e: c) f -\u003e (Id c :○: f) :==: f",
        "fct-source": "src/Type-Function.html#compo_idl",
        "fct-type": "function",
        "title": "compo_idl"
      },
      "index": {
        "description": "Id is left identity for composition",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "compo_idl",
        "normalized": "(a b)c-\u003e(Id b c)c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(d c)f-\u003e(Id c f)f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compo_idr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e is a right identity for composition                       \n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(d :~\u003e: c) f -\u003e (f :○: Id d) :==: f",
        "fct-source": "src/Type-Function.html#compo_idr",
        "fct-type": "function",
        "title": "compo_idr"
      },
      "index": {
        "description": "Id is right identity for composition",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "compo_idr",
        "normalized": "(a b)c-\u003e(c Id a)c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(d c)f-\u003e(f Id d)f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:constEq",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Ex dom -\u003e (Const dom x :==: Const dom' x') -\u003e x :=: x'",
        "fct-source": "src/Type-Function.html#constEq",
        "fct-type": "function",
        "title": "constEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "constEq",
        "normalized": "Ex a-\u003e(Const a b Const c d)-\u003eb d",
        "package": "type-settheory",
        "partial": "Eq",
        "signature": "Ex dom-\u003e(Const dom x Const dom' x')-\u003ex x'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:constIsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(x :∈: cod) -\u003e (dom :~\u003e: cod) (Const dom x)",
        "fct-source": "src/Type-Function.html#constIsFun",
        "fct-type": "function",
        "title": "constIsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "constIsFun",
        "normalized": "(a b)-\u003e(c b)(Const c a)",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": "(x cod)-\u003e(dom cod)(Const dom x)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:domUniq",
      "description": {
        "fct-descr": "\u003cp\u003eThe domain of a function is uniquely determined\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (dom2 :~\u003e: cod) f -\u003e dom :==: dom2",
        "fct-source": "src/Type-Function.html#domUniq",
        "fct-type": "function",
        "title": "domUniq"
      },
      "index": {
        "description": "The domain of function is uniquely determined",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "domUniq",
        "normalized": "(a b)c-\u003e(a b)c-\u003ea a",
        "package": "type-settheory",
        "partial": "Uniq",
        "signature": "(dom cod)f-\u003e(dom cod)f-\u003edom dom"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:elimToTyCon",
      "description": {
        "fct-descr": "\u003cp\u003eNB: this is stronger than the straightforward unpacking function -- we can use the single-valuedness\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e ToTyCon f x -\u003e ((x, z) :∈: f) -\u003e z",
        "fct-source": "src/Type-Function.html#elimToTyCon",
        "fct-type": "function",
        "title": "elimToTyCon"
      },
      "index": {
        "description": "NB this is stronger than the straightforward unpacking function we can use the single-valuedness",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "elimToTyCon",
        "normalized": "(a b)c-\u003eToTyCon c d-\u003e((d,e)c)-\u003ee",
        "package": "type-settheory",
        "partial": "To Ty Con",
        "signature": "(dom cod)f-\u003eToTyCon f x-\u003e((x,z)f)-\u003ez"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equal_f",
      "description": {
        "fct-descr": "\u003cp\u003eExpresses the fact that \u003cem\u003ef = f' ==\u003e f x = f' x\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(d :~\u003e: c) f' -\u003e (f :==: f') -\u003e ((x, y) :∈: f) -\u003e ((x, y') :∈: f') -\u003e y :=: y'",
        "fct-source": "src/Type-Function.html#equal_f",
        "fct-type": "function",
        "title": "equal_f"
      },
      "index": {
        "description": "Expresses the fact that",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "equal_f",
        "normalized": "(a b)c-\u003e(d c)-\u003e((e,f)d)-\u003e((e,g)c)-\u003ef g",
        "package": "type-settheory",
        "partial": "",
        "signature": "(d c)f'-\u003e(f f')-\u003e((x,y)f)-\u003e((x,y')f')-\u003ey y'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equal_f_coerce",
      "description": {
        "fct-descr": "\u003cp\u003ePerform coercion using a function equality\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(d :~\u003e: c) f' -\u003e (f :==: f') -\u003e ((x, y) :∈: f) -\u003e ((x, y') :∈: f') -\u003e y -\u003e y'",
        "fct-source": "src/Type-Function.html#equal_f_coerce",
        "fct-type": "function",
        "title": "equal_f_coerce"
      },
      "index": {
        "description": "Perform coercion using function equality",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "equal_f_coerce",
        "normalized": "(a b)c-\u003e(d c)-\u003e((e,f)d)-\u003e((e,g)c)-\u003ef-\u003eg",
        "package": "type-settheory",
        "partial": "",
        "signature": "(d c)f'-\u003e(f f')-\u003e((x,y)f)-\u003e((x,y')f')-\u003ey-\u003ey'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equaliserIsFun",
      "description": {
        "fct-descr": "\u003cp\u003eThe equaliser inclusion is a function\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(s :~\u003e: t) f1 -\u003e (Equaliser f1 f2 :~\u003e: s) (EqualiserIncl s f1 f2)",
        "fct-source": "src/Type-Function.html#equaliserIsFun",
        "fct-type": "function",
        "title": "equaliserIsFun"
      },
      "index": {
        "description": "The equaliser inclusion is function",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "equaliserIsFun",
        "normalized": "(a b)c-\u003e(Equaliser c c a)(EqualiserIncl a c c)",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": "(s t)f-\u003e(Equaliser f f s)(EqualiserIncl s f f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equaliserSubset",
      "description": {
        "fct-descr": "\u003cp\u003eThe equaliser is a subset of the domain of the parallel functions \n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(s :~\u003e: t) f1 -\u003e Equaliser f1 f2 :⊆: s",
        "fct-source": "src/Type-Function.html#equaliserSubset",
        "fct-type": "function",
        "title": "equaliserSubset"
      },
      "index": {
        "description": "The equaliser is subset of the domain of the parallel functions",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "equaliserSubset",
        "normalized": "(a b)c-\u003eEqualiser c c a",
        "package": "type-settheory",
        "partial": "Subset",
        "signature": "(s t)f-\u003eEqualiser f f s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equaliserUni",
      "description": {
        "fct-descr": "\u003cp\u003eUniversal property of equalisers:\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ef1 . g = f2 . g\u003c/code\u003e ==\u003e \u003ccode\u003eg\u003c/code\u003e factors uniquely through \u003ccode\u003eEqualiser f1 f2\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eUniqueness is trivial in our case because the function into the equaliser is\n identical to \u003ccode\u003eg\u003c/code\u003e (our functions don't know their codomain)\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(s0 :~\u003e: s) g -\u003e (s :~\u003e: t) f1 -\u003e ((f1 :○: g) :==: (f2 :○: g)) -\u003e (s0 :~\u003e: Equaliser f1 f2) g",
        "fct-source": "src/Type-Function.html#equaliserUni",
        "fct-type": "function",
        "title": "equaliserUni"
      },
      "index": {
        "description": "Universal property of equalisers f1 f2 factors uniquely through Equaliser f1 f2 Uniqueness is trivial in our case because the function into the equaliser is identical to our functions don know their codomain",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "equaliserUni",
        "normalized": "(a a)b-\u003e(a c)d-\u003e((d b)(d b))-\u003e(a Equaliser d d)b",
        "package": "type-settheory",
        "partial": "Uni",
        "signature": "(s s)g-\u003e(s t)f-\u003e((f g)(f g))-\u003e(s Equaliser f f)g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:extendCod",
      "description": {
        "fct-descr": "\u003cp\u003eEnlargen the codomain\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (cod :⊆: cod') -\u003e (dom :~\u003e: cod') f",
        "fct-source": "src/Type-Function.html#extendCod",
        "fct-type": "function",
        "title": "extendCod"
      },
      "index": {
        "description": "Enlargen the codomain",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "extendCod",
        "normalized": "(a b)c-\u003e(b d)-\u003e(a d)c",
        "package": "type-settheory",
        "partial": "Cod",
        "signature": "(dom cod)f-\u003e(cod cod')-\u003e(dom cod')f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:fromTCG",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "ToTyCon (Graph f) x -\u003e f x",
        "fct-source": "src/Type-Function.html#fromTCG",
        "fct-type": "function",
        "title": "fromTCG"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "fromTCG",
        "normalized": "ToTyCon(Graph a)b-\u003ea b",
        "package": "type-settheory",
        "partial": "TCG",
        "signature": "ToTyCon(Graph f)x-\u003ef x"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:fstIsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((s1 :×: s2) :~\u003e: s1) (Fst s1 s2)",
        "fct-source": "src/Type-Function.html#fstIsFun",
        "fct-type": "function",
        "title": "fstIsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "fstIsFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:fst_tupling",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod1) f1 -\u003e (dom :~\u003e: cod2) f2 -\u003e (Fst cod1 cod2 :○: (f1 :***: f2)) :==: f1",
        "fct-source": "src/Type-Function.html#fst_tupling",
        "fct-type": "function",
        "title": "fst_tupling"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "fst_tupling",
        "normalized": "(a b)c-\u003e(a b)c-\u003e(Fst b b(c***c))c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(dom cod)f-\u003e(dom cod)f-\u003e(Fst cod cod(f***f))f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:fullImageOfInclusion",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :⊆: cod) -\u003e Image (Incl dom cod) dom :==: dom",
        "fct-source": "src/Type-Function.html#fullImageOfInclusion",
        "fct-type": "function",
        "title": "fullImageOfInclusion"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "fullImageOfInclusion",
        "normalized": "(a b)-\u003eImage(Incl a b)a a",
        "package": "type-settheory",
        "partial": "Image Of Inclusion",
        "signature": "(dom cod)-\u003eImage(Incl dom cod)dom dom"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:funEq",
      "description": {
        "fct-descr": "\u003cp\u003eVery useful lemma for proving equality of functions.\n\u003c/p\u003e\u003cp\u003eGiven the properties of functions, it is enough to show that \u003ccode\u003ef\u003c/code\u003e is a subset of \u003ccode\u003ef'\u003c/code\u003e to prove \u003ccode\u003ef = f'\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "forall dom cod cod' f f'.  (dom :~\u003e: cod) f -\u003e (dom :~\u003e: cod') f' -\u003e (f :⊆: f') -\u003e f :==: f'",
        "fct-source": "src/Type-Function.html#funEq",
        "fct-type": "function",
        "title": "funEq"
      },
      "index": {
        "description": "Very useful lemma for proving equality of functions Given the properties of functions it is enough to show that is subset of to prove",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "funEq",
        "normalized": "a b c d e f(b c)e-\u003e(b d)g-\u003e(e g)-\u003ee g",
        "package": "type-settheory",
        "partial": "Eq",
        "signature": "forall dom cod cod' f f'.(dom cod)f-\u003e(dom cod')f'-\u003e(f f')-\u003ef f'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:funEq-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efunEq\u003c/a\u003e\u003c/code\u003e with the inclusion argument flipped\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (dom :~\u003e: cod') f' -\u003e (f' :⊆: f) -\u003e f :==: f'",
        "fct-source": "src/Type-Function.html#funEq%27",
        "fct-type": "function",
        "title": "funEq'"
      },
      "index": {
        "description": "funEq with the inclusion argument flipped",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "funEq'",
        "normalized": "(a b)c-\u003e(a d)e-\u003e(e c)-\u003ec e",
        "package": "type-settheory",
        "partial": "Eq'",
        "signature": "(dom cod)f-\u003e(dom cod')f'-\u003e(f' f)-\u003ef f'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:graphCPS",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "r) -\u003e r",
        "fct-source": "src/Type-Function.html#graphCPS",
        "fct-type": "function",
        "title": "graphCPS"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "graphCPS",
        "normalized": "a)-\u003ea",
        "package": "type-settheory",
        "partial": "CPS",
        "signature": "r)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:graphInjective",
      "description": {
        "fct-descr": "\u003cp\u003eType constructors are injective\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Injective (Graph f)",
        "fct-source": "src/Type-Function.html#graphInjective",
        "fct-type": "function",
        "title": "graphInjective"
      },
      "index": {
        "description": "Type constructors are injective",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "graphInjective",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Injective",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:graphIsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(Univ :~\u003e: Univ) (Graph f)",
        "fct-source": "src/Type-Function.html#graphIsFun",
        "fct-type": "function",
        "title": "graphIsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "graphIsFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:haskFunInjective",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Injective HaskFun",
        "fct-source": "src/Type-Function.html#haskFunInjective",
        "fct-type": "function",
        "title": "haskFunInjective"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "haskFunInjective",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Fun Injective",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:haskFunIsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((Univ :×: Univ) :~\u003e: FunctionType) HaskFun",
        "fct-source": "src/Type-Function.html#haskFunIsFun",
        "fct-type": "function",
        "title": "haskFunIsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "haskFunIsFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Fun Is Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:idIsFun",
      "description": {
        "fct-descr": "\u003cp\u003eId is a function\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: dom) (Id dom)",
        "fct-source": "src/Type-Function.html#idIsFun",
        "fct-type": "function",
        "title": "idIsFun"
      },
      "index": {
        "description": "Id is function",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "idIsFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:idLemma",
      "description": {
        "fct-descr": "\u003cp\u003eLemma for proving a function equal to the identity\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: dom) f -\u003e (forall x y.  ((x, y) :∈: f) -\u003e x :=: y) -\u003e Id dom :==: f",
        "fct-source": "src/Type-Function.html#idLemma",
        "fct-type": "function",
        "title": "idLemma"
      },
      "index": {
        "description": "Lemma for proving function equal to the identity",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "idLemma",
        "normalized": "(a a)b-\u003e(c d e((d,f)b)-\u003ed f)-\u003eId a b",
        "package": "type-settheory",
        "partial": "Lemma",
        "signature": "(dom dom)f-\u003e(forall x y.((x,y)f)-\u003ex y)-\u003eId dom f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageCod",
      "description": {
        "fct-descr": "\u003cp\u003eEvery image is a subset of every possible codomain\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e Image f s :⊆: cod",
        "fct-source": "src/Type-Function.html#imageCod",
        "fct-type": "function",
        "title": "imageCod"
      },
      "index": {
        "description": "Every image is subset of every possible codomain",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "imageCod",
        "normalized": "(a b)c-\u003eImage c d b",
        "package": "type-settheory",
        "partial": "Cod",
        "signature": "(dom cod)f-\u003eImage f s cod"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageEmpty",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Image f Empty :==: Empty",
        "fct-source": "src/Type-Function.html#imageEmpty",
        "fct-type": "function",
        "title": "imageEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "imageEmpty",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageGraphList",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "[a] :∈: Image (Graph []) Univ",
        "fct-source": "src/Type-Function.html#imageGraphList",
        "fct-type": "function",
        "title": "imageGraphList"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "imageGraphList",
        "normalized": "[a]Image(Graph[])Univ",
        "package": "type-settheory",
        "partial": "Graph List",
        "signature": "[a]Image(Graph[])Univ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageMonotonic",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :⊆: s2) -\u003e Image f s1 :⊆: Image f s2",
        "fct-source": "src/Type-Function.html#imageMonotonic",
        "fct-type": "function",
        "title": "imageMonotonic"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "imageMonotonic",
        "normalized": "(a a)-\u003eImage b a Image b a",
        "package": "type-settheory",
        "partial": "Monotonic",
        "signature": "(s s)-\u003eImage f s Image f s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageOfInclusion",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Image (Incl dom cod) s :==: (s :∩: dom)",
        "fct-source": "src/Type-Function.html#imageOfInclusion",
        "fct-type": "function",
        "title": "imageOfInclusion"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "imageOfInclusion",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Of Inclusion",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageUnion",
      "description": {
        "fct-descr": "\u003cp\u003eImage distributes over union (in general not over intersection)\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "forall dom cod s1 s2 f.  (dom :~\u003e: cod) f -\u003e Image f (s1 :∪: s2) :==: (Image f s1 :∪: Image f s2)",
        "fct-source": "src/Type-Function.html#imageUnion",
        "fct-type": "function",
        "title": "imageUnion"
      },
      "index": {
        "description": "Image distributes over union in general not over intersection",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "imageUnion",
        "normalized": "a b c d d e(b c)f-\u003eImage f(d d)(Image f d Image f d)",
        "package": "type-settheory",
        "partial": "Union",
        "signature": "forall dom cod s s f.(dom cod)f-\u003eImage f(s s)(Image f s Image f s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:image_Preimage",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e Image f (Preimage f set) :⊆: set",
        "fct-source": "src/Type-Function.html#image_Preimage",
        "fct-type": "function",
        "title": "image_Preimage"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "image_Preimage",
        "normalized": "(a b)c-\u003eImage c(Preimage c d)d",
        "package": "type-settheory",
        "partial": "Preimage",
        "signature": "(dom cod)f-\u003eImage f(Preimage f set)set"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:inCod",
      "description": {
        "fct-descr": "\u003cp\u003eIf \u003ccode\u003ef a = b\u003c/code\u003e, then \u003ccode\u003eb\u003c/code\u003e is in the codomain of \u003ccode\u003ef\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e ((a, b) :∈: f) -\u003e b :∈: cod",
        "fct-source": "src/Type-Function.html#inCod",
        "fct-type": "function",
        "title": "inCod"
      },
      "index": {
        "description": "If then is in the codomain of",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "inCod",
        "normalized": "(a b)c-\u003e((d,e)c)-\u003ee b",
        "package": "type-settheory",
        "partial": "Cod",
        "signature": "(dom cod)f-\u003e((a,b)f)-\u003eb cod"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:inDom",
      "description": {
        "fct-descr": "\u003cp\u003eIf \u003ccode\u003ef a = b\u003c/code\u003e, then \u003ccode\u003ea\u003c/code\u003e is in the domain of \u003ccode\u003ef\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e ((a, b) :∈: f) -\u003e a :∈: dom",
        "fct-source": "src/Type-Function.html#inDom",
        "fct-type": "function",
        "title": "inDom"
      },
      "index": {
        "description": "If then is in the domain of",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "inDom",
        "normalized": "(a b)c-\u003e((d,e)c)-\u003ed a",
        "package": "type-settheory",
        "partial": "Dom",
        "signature": "(dom cod)f-\u003e((a,b)f)-\u003ea dom"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:inclusionIsFun",
      "description": {
        "fct-descr": "\u003cp\u003eInclusion is a function\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :⊆: cod) -\u003e (dom :~\u003e: cod) (Incl dom cod)",
        "fct-source": "src/Type-Function.html#inclusionIsFun",
        "fct-type": "function",
        "title": "inclusionIsFun"
      },
      "index": {
        "description": "Inclusion is function",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "inclusionIsFun",
        "normalized": "(a b)-\u003e(a b)(Incl a b)",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": "(dom cod)-\u003e(dom cod)(Incl dom cod)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:inclusion_Injective",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Injective (Incl dom cod)",
        "fct-source": "src/Type-Function.html#inclusion_Injective",
        "fct-type": "function",
        "title": "inclusion_Injective"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "inclusion_Injective",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Injective",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:injective",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "forall f a1 a2 b.  Injective f -\u003e ((a1, b) :∈: f) -\u003e ((a2, b) :∈: f) -\u003e a1 :=: a2",
        "fct-source": "src/Type-Function.html#injective",
        "fct-type": "function",
        "title": "injective"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "injective",
        "normalized": "a b c c d Injective b-\u003e((c,e)b)-\u003e((c,e)b)-\u003ec c",
        "package": "type-settheory",
        "partial": "",
        "signature": "forall f a a b. Injective f-\u003e((a,b)f)-\u003e((a,b)f)-\u003ea a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:injective_Inv",
      "description": {
        "fct-descr": "\u003cp\u003eAn injective function has an inverse, with domain the image\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e Injective f -\u003e (Image f dom :~\u003e: dom) (Inv f)",
        "fct-source": "src/Type-Function.html#injective_Inv",
        "fct-type": "function",
        "title": "injective_Inv"
      },
      "index": {
        "description": "An injective function has an inverse with domain the image",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "injective_Inv",
        "normalized": "(a b)c-\u003eInjective c-\u003e(Image c a a)(Inv c)",
        "package": "type-settheory",
        "partial": "Inv",
        "signature": "(dom cod)f-\u003eInjective f-\u003e(Image f dom dom)(Inv f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:introToTyCon",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((x, y) :∈: f) -\u003e y -\u003e ToTyCon f x",
        "fct-source": "src/Type-Function.html#introToTyCon",
        "fct-type": "function",
        "title": "introToTyCon"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "introToTyCon",
        "normalized": "((a,b)c)-\u003eb-\u003eToTyCon c a",
        "package": "type-settheory",
        "partial": "To Ty Con",
        "signature": "((x,y)f)-\u003ey-\u003eToTyCon f x"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:invId",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Inv (Id dom) :==: Id dom",
        "fct-source": "src/Type-Function.html#invId",
        "fct-type": "function",
        "title": "invId"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "invId",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:invInv",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e Inv (Inv f) :==: f",
        "fct-source": "src/Type-Function.html#invInv",
        "fct-type": "function",
        "title": "invInv"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "invInv",
        "normalized": "(a b)c-\u003eInv(Inv c)c",
        "package": "type-settheory",
        "partial": "Inv",
        "signature": "(dom cod)f-\u003eInv(Inv f)f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:invInv0",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Inv (Inv f) :⊆: f",
        "fct-source": "src/Type-Function.html#invInv0",
        "fct-type": "function",
        "title": "invInv0"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "invInv0",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Inv",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:isFun_congruence",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(d :~\u003e: c) f -\u003e (f :==: f') -\u003e (d :~\u003e: c) f'",
        "fct-source": "src/Type-Function.html#isFun_congruence",
        "fct-type": "function",
        "title": "isFun_congruence"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "isFun_congruence",
        "normalized": "(a b)c-\u003e(c d)-\u003e(a b)d",
        "package": "type-settheory",
        "partial": "Fun",
        "signature": "(d c)f-\u003e(f f')-\u003e(d c)f'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:kleisliHomInjective",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "Injective (KleisliHom m)",
        "fct-source": "src/Type-Function.html#kleisliHomInjective",
        "fct-type": "function",
        "title": "kleisliHomInjective"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "kleisliHomInjective",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Hom Injective",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:kleisliHomIsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((Univ :×: Univ) :~\u003e: KleisliType m) (KleisliHom m)",
        "fct-source": "src/Type-Function.html#kleisliHomIsFun",
        "fct-type": "function",
        "title": "kleisliHomIsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "kleisliHomIsFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Hom Is Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:lowerFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (dom :~~\u003e: cod) (Lower f)",
        "fct-source": "src/Type-Function.html#lowerFun",
        "fct-type": "function",
        "title": "lowerFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "lowerFun",
        "normalized": "(a b)c-\u003e(a b)(Lower c)",
        "package": "type-settheory",
        "partial": "Fun",
        "signature": "(dom cod)f-\u003e(dom cod)(Lower f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:preimage_Image",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (set :⊆: dom) -\u003e set :⊆: Preimage f (Image f set)",
        "fct-source": "src/Type-Function.html#preimage_Image",
        "fct-type": "function",
        "title": "preimage_Image"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "preimage_Image",
        "normalized": "(a b)c-\u003e(d a)-\u003ed Preimage c(Image c d)",
        "package": "type-settheory",
        "partial": "Image",
        "signature": "(dom cod)f-\u003e(set dom)-\u003eset Preimage f(Image f set)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:raiseFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~~\u003e: cod) (Lower f) -\u003e (dom :~\u003e: cod) f",
        "fct-source": "src/Type-Function.html#raiseFun",
        "fct-type": "function",
        "title": "raiseFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "raiseFun",
        "normalized": "(a b)(Lower c)-\u003e(a b)c",
        "package": "type-settheory",
        "partial": "Fun",
        "signature": "(dom cod)(Lower f)-\u003e(dom cod)f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:raiseFunCPS",
      "description": {
        "fct-descr": "\u003cp\u003eThis is stronger than \u003ccode\u003e\u003ca\u003eraiseFun\u003c/a\u003e\u003c/code\u003e since it introduces the knowledge that \u003ccode\u003elf\u003c/code\u003e is of the form \u003ccode\u003eLower f\u003c/code\u003e, rather than assuming it.\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e r) -\u003e r",
        "fct-source": "src/Type-Function.html#raiseFunCPS",
        "fct-type": "function",
        "title": "raiseFunCPS"
      },
      "index": {
        "description": "This is stronger than raiseFun since it introduces the knowledge that lf is of the form Lower rather than assuming it",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "raiseFunCPS",
        "normalized": "(a b)c-\u003ed)-\u003ed",
        "package": "type-settheory",
        "partial": "Fun CPS",
        "signature": "(dom cod)f-\u003er)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:rel",
      "description": {
        "fct-descr": "\u003cp\u003eShortcut for unpacking \u003ccode\u003e\u003ca\u003erelation\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (pair :∈: f) -\u003e pair :∈: (dom :×: cod)",
        "fct-source": "src/Type-Function.html#rel",
        "fct-type": "function",
        "title": "rel"
      },
      "index": {
        "description": "Shortcut for unpacking relation",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "rel",
        "normalized": "(a b)c-\u003e(d c)-\u003ed(a b)",
        "package": "type-settheory",
        "partial": "",
        "signature": "(dom cod)f-\u003e(pair f)-\u003epair(dom cod)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:relCPS",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "dom relCPS_x -\u003e cod relCPS_y -\u003e relCPS_return) -\u003e relCPS_return",
        "fct-source": "src/Type-Function.html#relCPS",
        "fct-type": "function",
        "title": "relCPS"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "relCPS",
        "normalized": "a b-\u003ec d-\u003ee)-\u003ee",
        "package": "type-settheory",
        "partial": "CPS",
        "signature": "dom relCPS_x-\u003ecod relCPS_y-\u003erelCPS_return)-\u003erelCPS_return"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:relation",
      "description": {
        "fct-descr": "\u003cp\u003eFunctions are relations\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e f :⊆: (dom :×: cod)",
        "fct-source": "src/Type-Function.html#relation",
        "fct-type": "function",
        "title": "relation"
      },
      "index": {
        "description": "Functions are relations",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "relation",
        "normalized": "(a b)c-\u003ec(a b)",
        "package": "type-settheory",
        "partial": "",
        "signature": "(dom cod)f-\u003ef(dom cod)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:section_CompoId",
      "description": {
        "fct-descr": "\u003cp\u003eIs section ==\u003e composition is \u003cem\u003eid\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(total :~\u003e: base) bun -\u003e (base :~\u003e: total) f -\u003e Section bun f -\u003e (bun :○: f) :==: Id base",
        "fct-source": "src/Type-Function.html#section_CompoId",
        "fct-type": "function",
        "title": "section_CompoId"
      },
      "index": {
        "description": "Is section composition is id",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "section_CompoId",
        "normalized": "(a b)c-\u003e(b a)d-\u003eSection c d-\u003e(c d)Id b",
        "package": "type-settheory",
        "partial": "Compo Id",
        "signature": "(total base)bun-\u003e(base total)f-\u003eSection bun f-\u003e(bun f)Id base"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:setCodToImage",
      "description": {
        "fct-descr": "\u003cp\u003eThe full image is a codomain\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (dom :~\u003e: Image f dom) f",
        "fct-source": "src/Type-Function.html#setCodToImage",
        "fct-type": "function",
        "title": "setCodToImage"
      },
      "index": {
        "description": "The full image is codomain",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "setCodToImage",
        "normalized": "(a b)c-\u003e(a Image c a)c",
        "package": "type-settheory",
        "partial": "Cod To Image",
        "signature": "(dom cod)f-\u003e(dom Image f dom)f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:sndIsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "((s1 :×: s2) :~\u003e: s2) (Snd s1 s2)",
        "fct-source": "src/Type-Function.html#sndIsFun",
        "fct-type": "function",
        "title": "sndIsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "sndIsFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Is Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:snd_tupling",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod1) f1 -\u003e (dom :~\u003e: cod2) f2 -\u003e (Snd cod1 cod2 :○: (f1 :***: f2)) :==: f2",
        "fct-source": "src/Type-Function.html#snd_tupling",
        "fct-type": "function",
        "title": "snd_tupling"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "snd_tupling",
        "normalized": "(a b)c-\u003e(a b)c-\u003e(Snd b b(c***c))c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(dom cod)f-\u003e(dom cod)f-\u003e(Snd cod cod(f***f))f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:sval",
      "description": {
        "fct-descr": "\u003cp\u003eFunctions are single-valued (reified equality version)\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "forall dom cod a b1 b2 f.  (dom :~\u003e: cod) f -\u003e ((a, b1) :∈: f) -\u003e ((a, b2) :∈: f) -\u003e b1 :=: b2",
        "fct-source": "src/Type-Function.html#sval",
        "fct-type": "function",
        "title": "sval"
      },
      "index": {
        "description": "Functions are single-valued reified equality version",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "sval",
        "normalized": "a b c d e e f(b c)g-\u003e((d,e)g)-\u003e((d,e)g)-\u003ee e",
        "package": "type-settheory",
        "partial": "",
        "signature": "forall dom cod a b b f.(dom cod)f-\u003e((a,b)f)-\u003e((a,b)f)-\u003eb b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:svalCPS",
      "description": {
        "fct-descr": "\u003cp\u003eFunctions are single-valued (CPS version)\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "r) -\u003e r",
        "fct-source": "src/Type-Function.html#svalCPS",
        "fct-type": "function",
        "title": "svalCPS"
      },
      "index": {
        "description": "Functions are single-valued CPS version",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "svalCPS",
        "normalized": "a)-\u003ea",
        "package": "type-settheory",
        "partial": "CPS",
        "signature": "r)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:svalCPS-39-",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e ((a, b1) :∈: f) -\u003e ((a, b2) :∈: f) -\u003e ((b1 :=: b2) -\u003e r) -\u003e r",
        "fct-source": "src/Type-Function.html#svalCPS%27",
        "fct-type": "function",
        "title": "svalCPS'"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "svalCPS'",
        "normalized": "(a b)c-\u003e((d,e)c)-\u003e((d,e)c)-\u003e((e e)-\u003ef)-\u003ef",
        "package": "type-settheory",
        "partial": "CPS'",
        "signature": "(dom cod)f-\u003e((a,b)f)-\u003e((a,b)f)-\u003e((b b)-\u003er)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:svalCoerce",
      "description": {
        "fct-descr": "\u003cp\u003ePerform coercion using the single-valuedness\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "forall dom cod a b1 b2 f.  (dom :~\u003e: cod) f -\u003e ((a, b1) :∈: f) -\u003e ((a, b2) :∈: f) -\u003e b1 -\u003e b2",
        "fct-source": "src/Type-Function.html#svalCoerce",
        "fct-type": "function",
        "title": "svalCoerce"
      },
      "index": {
        "description": "Perform coercion using the single-valuedness",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "svalCoerce",
        "normalized": "a b c d e e f(b c)g-\u003e((d,e)g)-\u003e((d,e)g)-\u003ee-\u003ee",
        "package": "type-settheory",
        "partial": "Coerce",
        "signature": "forall dom cod a b b f.(dom cod)f-\u003e((a,b)f)-\u003e((a,b)f)-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:targetTuplingIsFun",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod1) f1 -\u003e (dom :~\u003e: cod2) f2 -\u003e (dom :~\u003e: (cod1 :×: cod2)) (f1 :***: f2)",
        "fct-source": "src/Type-Function.html#targetTuplingIsFun",
        "fct-type": "function",
        "title": "targetTuplingIsFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "targetTuplingIsFun",
        "normalized": "(a b)c-\u003e(a b)c-\u003e(a(b b))(c***c)",
        "package": "type-settheory",
        "partial": "Tupling Is Fun",
        "signature": "(dom cod)f-\u003e(dom cod)f-\u003e(dom(cod cod))(f***f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:toTCG",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "f x -\u003e ToTyCon (Graph f) x",
        "fct-source": "src/Type-Function.html#toTCG",
        "fct-type": "function",
        "title": "toTCG"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "toTCG",
        "normalized": "a b-\u003eToTyCon(Graph a)b",
        "package": "type-settheory",
        "partial": "TCG",
        "signature": "f x-\u003eToTyCon(Graph f)x"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:total",
      "description": {
        "fct-descr": "\u003cp\u003eFunctions are total\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (a :∈: dom) -\u003e ExSnd f a",
        "fct-source": "src/Type-Function.html#total",
        "fct-type": "function",
        "title": "total"
      },
      "index": {
        "description": "Functions are total",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "total",
        "normalized": "(a b)c-\u003e(d a)-\u003eExSnd c d",
        "package": "type-settheory",
        "partial": "",
        "signature": "(dom cod)f-\u003e(a dom)-\u003eExSnd f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:totalCPS",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eThe detailed type variable names help debugging proofs\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: cod) f -\u003e (a :∈: dom) -\u003e (forall totalCPS_y.  ((a, totalCPS_y) :∈: f) -\u003e totalCPS_return) -\u003e totalCPS_return",
        "fct-source": "src/Type-Function.html#totalCPS",
        "fct-type": "function",
        "title": "totalCPS"
      },
      "index": {
        "description": "The detailed type variable names help debugging proofs",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "totalCPS",
        "normalized": "(a b)c-\u003e(d a)-\u003e(e f((d,g)c)-\u003eh)-\u003eh",
        "package": "type-settheory",
        "partial": "CPS",
        "signature": "(dom cod)f-\u003e(a dom)-\u003e(forall totalCPS_y.((a,totalCPS_y)f)-\u003etotalCPS_return)-\u003etotalCPS_return"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:tupling_eta",
      "description": {
        "fct-module": "Type.Function",
        "fct-package": "type-settheory",
        "fct-signature": "(dom :~\u003e: (cod1 :×: cod2)) f -\u003e ((Fst cod1 cod2 :○: f) :***: (Snd cod1 cod2 :○: f)) :==: f",
        "fct-source": "src/Type-Function.html#tupling_eta",
        "fct-type": "function",
        "title": "tupling_eta"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Function",
        "module": "Type.Function",
        "name": "tupling_eta",
        "normalized": "(a(b b))c-\u003e((Fst b b c)***(Snd b b c))c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(dom(cod cod))f-\u003e((Fst cod cod f)***(Snd cod cod f))f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePropositions as types (of kind \u003ccode\u003e*\u003c/code\u003e), proofs as values\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "module",
        "fct-source": "src/Type-Logic.html",
        "fct-type": "module",
        "title": "Logic"
      },
      "index": {
        "description": "Propositions as types of kind proofs as values",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Logic",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Logic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:All",
      "description": {
        "fct-descr": "\u003cp\u003eUniversal quantification\n\u003c/p\u003e",
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "newtype",
        "fct-source": "src/Type-Logic.html#All",
        "fct-type": "newtype",
        "title": "All"
      },
      "index": {
        "description": "Universal quantification",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "All",
        "normalized": "",
        "package": "type-settheory",
        "partial": "All",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:COr",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Logic.html#COr",
        "fct-type": "type",
        "title": "COr"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "COr",
        "normalized": "",
        "package": "type-settheory",
        "partial": "COr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Decidable",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "class",
        "fct-source": "src/Type-Logic.html#Decidable",
        "fct-type": "class",
        "title": "Decidable"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Decidable",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Decidable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Decidable1",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "class",
        "fct-source": "src/Type-Logic.html#Decidable1",
        "fct-type": "class",
        "title": "Decidable1"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Decidable1",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Decidable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Ex",
      "description": {
        "fct-descr": "\u003cp\u003eExistential quantification                                                         \n\u003c/p\u003e",
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Logic.html#Ex",
        "fct-type": "data",
        "title": "Ex"
      },
      "index": {
        "description": "Existential quantification",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Ex",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Ex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:ExUniq",
      "description": {
        "fct-descr": "\u003cp\u003eUnique existence\n\u003c/p\u003e",
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Logic.html#ExUniq",
        "fct-type": "data",
        "title": "ExUniq"
      },
      "index": {
        "description": "Unique existence",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "ExUniq",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Ex Uniq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Fact",
      "description": {
        "fct-descr": "\u003cp\u003eThis class collects lemmas. It plays no foundational role.\n\u003c/p\u003e",
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "class",
        "fct-source": "src/Type-Logic.html#Fact",
        "fct-type": "class",
        "title": "Fact"
      },
      "index": {
        "description": "This class collects lemmas It plays no foundational role",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Fact",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Fact",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Falsity",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "newtype",
        "fct-source": "src/Type-Logic.html#Falsity",
        "fct-type": "newtype",
        "title": "Falsity"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Falsity",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Falsity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Finite",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "class",
        "fct-source": "src/Type-Logic.html#Finite",
        "fct-type": "class",
        "title": "Finite"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Finite",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Finite",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Not",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Logic.html#Not",
        "fct-type": "type",
        "title": "Not"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Not",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Not",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Truth",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Logic.html#Truth",
        "fct-type": "data",
        "title": "Truth"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Truth",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Truth",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:All",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "All",
        "fct-source": "src/Type-Logic.html#All",
        "fct-type": "function",
        "title": "All"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "All",
        "normalized": "",
        "package": "type-settheory",
        "partial": "All",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:Ex",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "p b -\u003e Ex p",
        "fct-source": "src/Type-Logic.html#Ex",
        "fct-type": "function",
        "title": "Ex"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Ex",
        "normalized": "a b-\u003eEx a",
        "package": "type-settheory",
        "partial": "Ex",
        "signature": "p b-\u003eEx p"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:ExUniq",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "p b -\u003e (forall b'.  p b' -\u003e b :=: b') -\u003e ExUniq p",
        "fct-source": "src/Type-Logic.html#ExUniq",
        "fct-type": "function",
        "title": "ExUniq"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "ExUniq",
        "normalized": "a b-\u003e(c d a e-\u003eb e)-\u003eExUniq a",
        "package": "type-settheory",
        "partial": "Ex Uniq",
        "signature": "p b-\u003e(forall b'. p b'-\u003eb b')-\u003eExUniq p"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:Falsity",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "Falsity",
        "fct-source": "src/Type-Logic.html#Falsity",
        "fct-type": "function",
        "title": "Falsity"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "Falsity",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Falsity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:TruthProof",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "TruthProof",
        "fct-source": "src/Type-Logic.html#Truth",
        "fct-type": "function",
        "title": "TruthProof"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "TruthProof",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Truth Proof",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:allElim",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "forall b.  p b",
        "fct-source": "src/Type-Logic.html#All",
        "fct-type": "function",
        "title": "allElim"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "allElim",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Elim",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:auto",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "a",
        "fct-source": "src/Type-Logic.html#auto",
        "fct-type": "method",
        "title": "auto"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "auto",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:decide",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "Either (Not a) a",
        "fct-source": "src/Type-Logic.html#decide",
        "fct-type": "method",
        "title": "decide"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "decide",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:decide1",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "Either (Not (s a)) (s a)",
        "fct-source": "src/Type-Logic.html#decide1",
        "fct-type": "method",
        "title": "decide1"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "decide1",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:elimCor",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "COr r a b -\u003e (a -\u003e r) -\u003e (b -\u003e r) -\u003e r",
        "fct-source": "src/Type-Logic.html#elimCor",
        "fct-type": "function",
        "title": "elimCor"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "elimCor",
        "normalized": "COr a b c-\u003e(b-\u003ea)-\u003e(c-\u003ea)-\u003ea",
        "package": "type-settheory",
        "partial": "Cor",
        "signature": "COr r a b-\u003e(a-\u003er)-\u003e(b-\u003er)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:elimFalsity",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "forall a.  a",
        "fct-source": "src/Type-Logic.html#Falsity",
        "fct-type": "function",
        "title": "elimFalsity"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "elimFalsity",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Falsity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:enum",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "[Ex s]",
        "fct-source": "src/Type-Logic.html#enum",
        "fct-type": "method",
        "title": "enum"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "enum",
        "normalized": "[Ex a]",
        "package": "type-settheory",
        "partial": "",
        "signature": "[Ex s]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:exElim",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "forall p r.  (forall b.  p b -\u003e r) -\u003e Ex p -\u003e r",
        "fct-source": "src/Type-Logic.html#exElim",
        "fct-type": "function",
        "title": "exElim"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "exElim",
        "normalized": "a b c(a d b e-\u003ef)-\u003eEx b-\u003ef",
        "package": "type-settheory",
        "partial": "Elim",
        "signature": "forall p r.(forall b. p b-\u003er)-\u003eEx p-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:lem",
      "description": {
        "fct-module": "Type.Logic",
        "fct-package": "type-settheory",
        "fct-signature": "COr r (a -\u003e r) a",
        "fct-source": "src/Type-Logic.html#lem",
        "fct-type": "function",
        "title": "lem"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Logic",
        "module": "Type.Logic",
        "name": "lem",
        "normalized": "COr a(b-\u003ea)b",
        "package": "type-settheory",
        "partial": "",
        "signature": "COr r(a-\u003er)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTODO\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Prove that \u003ccode\u003e\u003ca\u003eInitor\u003c/a\u003e\u003c/code\u003e is an \u003ccode\u003e\u003ca\u003eNMorphism\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e Prove that it is uniquely so\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "module",
        "fct-source": "src/Type-Nat.html",
        "fct-type": "module",
        "title": "Nat"
      },
      "index": {
        "description": "TODO Prove that Initor is an NMorphism Prove that it is uniquely so",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "Nat",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Nat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:Initor",
      "description": {
        "fct-descr": "\u003cp\u003eThe unique morphism from an \u003ccode\u003e\u003ca\u003eTNat\u003c/a\u003e\u003c/code\u003e to any \u003ccode\u003e\u003ca\u003eNStructure\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e\u003cp\u003eNB: \u003ccode\u003es\u003c/code\u003e is a type constructor, but \u003ccode\u003esucc2\u003c/code\u003e is a Function (\u003ccode\u003e\u003ca\u003eIsFun\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Nat.html#Initor",
        "fct-type": "data",
        "title": "Initor"
      },
      "index": {
        "description": "The unique morphism from an TNat to any NStructure NB is type constructor but succ2 is Function IsFun",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "Initor",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Initor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:NInitial",
      "description": {
        "fct-descr": "\u003cp\u003eExpresses that \u003ccode\u003e(set1,z1,succ1)\u003c/code\u003e is initial in the cat of \u003ccode\u003e\u003ca\u003eNStructure\u003c/a\u003e\u003c/code\u003es, in other words, that it is isomorphic to the natural numbers\n\u003c/p\u003e",
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Nat.html#NInitial",
        "fct-type": "data",
        "title": "NInitial"
      },
      "index": {
        "description": "Expresses that set1 z1 succ1 is initial in the cat of NStructure in other words that it is isomorphic to the natural numbers",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "NInitial",
        "normalized": "",
        "package": "type-settheory",
        "partial": "NInitial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:NMorphism",
      "description": {
        "fct-descr": "\u003cp\u003eStructure-preserving maps of \u003ccode\u003e\u003ca\u003eNStructure\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Nat.html#NMorphism",
        "fct-type": "data",
        "title": "NMorphism"
      },
      "index": {
        "description": "Structure-preserving maps of NStructure",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "NMorphism",
        "normalized": "",
        "package": "type-settheory",
        "partial": "NMorphism",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:NStructure",
      "description": {
        "fct-descr": "\u003cp\u003eSets equipped with a constant and a function to itself\n\u003c/p\u003e",
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Nat.html#NStructure",
        "fct-type": "data",
        "title": "NStructure"
      },
      "index": {
        "description": "Sets equipped with constant and function to itself",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "NStructure",
        "normalized": "",
        "package": "type-settheory",
        "partial": "NStructure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:Succ",
      "description": {
        "fct-descr": "\u003cp\u003eSuccessor function made from a unary type constructor\n\u003c/p\u003e",
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Nat.html#Succ",
        "fct-type": "data",
        "title": "Succ"
      },
      "index": {
        "description": "Successor function made from unary type constructor",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "Succ",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Succ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:TNat",
      "description": {
        "fct-descr": "\u003cp\u003eActually any pair of (nullary type, unary type constructor) gives us a copy of the naturals; let's call these \u003cem\u003eTNats\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Nat.html#TNat",
        "fct-type": "data",
        "title": "TNat"
      },
      "index": {
        "description": "Actually any pair of nullary type unary type constructor gives us copy of the naturals let call these TNats",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "TNat",
        "normalized": "",
        "package": "type-settheory",
        "partial": "TNat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:InitorS",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "Initor z s z2 succ2 (n1, n2) -\u003e ((n2, sn2) :∈: succ2) -\u003e Initor z s z2 succ2 (s n1, sn2)",
        "fct-source": "src/Type-Nat.html#Initor",
        "fct-type": "function",
        "title": "InitorS"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "InitorS",
        "normalized": "Initor a b a c(d,d)-\u003e((d,e)c)-\u003eInitor a b a c(b d,e)",
        "package": "type-settheory",
        "partial": "Initor",
        "signature": "Initor z s z succ(n,n)-\u003e((n,sn)succ)-\u003eInitor z s z succ(s n,sn)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:InitorZ",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "Initor z s z2 succ2 (z, z2)",
        "fct-source": "src/Type-Nat.html#Initor",
        "fct-type": "function",
        "title": "InitorZ"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "InitorZ",
        "normalized": "Initor a b a c(a,a)",
        "package": "type-settheory",
        "partial": "Initor",
        "signature": "Initor z s z succ(z,z)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:IsS",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "TNat z s n -\u003e TNat z s (s n)",
        "fct-source": "src/Type-Nat.html#TNat",
        "fct-type": "function",
        "title": "IsS"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "IsS",
        "normalized": "TNat a b c-\u003eTNat a b(b c)",
        "package": "type-settheory",
        "partial": "Is",
        "signature": "TNat z s n-\u003eTNat z s(s n)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:IsZ",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "TNat z s z",
        "fct-source": "src/Type-Nat.html#TNat",
        "fct-type": "function",
        "title": "IsZ"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "IsZ",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Is",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:NInitial",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "(forall z2 set2 succ2.  ExUniq1 (NMorphism set1 z1 succ1 z2 set2 succ2)) -\u003e NInitial set1 z1 succ1",
        "fct-source": "src/Type-Nat.html#NInitial",
        "fct-type": "function",
        "title": "NInitial"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "NInitial",
        "normalized": "(a b c d ExUniq(NMorphism c b d b c d))-\u003eNInitial c b d",
        "package": "type-settheory",
        "partial": "NInitial",
        "signature": "(forall z set succ ExUniq(NMorphism set z succ z set succ))-\u003eNInitial set z succ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:NMorphism",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "NStructure set1 z1 succ1 -\u003e NStructure set2 z2 succ2 -\u003e (set1 :~\u003e: set2) f -\u003e (f z1 :=: z2) -\u003e ((f :○: succ1) :==: (succ2 :○: f)) -\u003e NMorphism set1 z1 succ1 z2 set2 succ2 f",
        "fct-source": "src/Type-Nat.html#NMorphism",
        "fct-type": "function",
        "title": "NMorphism"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "NMorphism",
        "normalized": "NStructure a b c-\u003eNStructure a b c-\u003e(a a)d-\u003e(d b b)-\u003e((d c)(c d))-\u003eNMorphism a b c b a c d",
        "package": "type-settheory",
        "partial": "NMorphism",
        "signature": "NStructure set z succ-\u003eNStructure set z succ-\u003e(set set)f-\u003e(f z z)-\u003e((f succ)(succ f))-\u003eNMorphism set z succ z set succ f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:NStructure",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "(z :∈: set) -\u003e (set :~\u003e: set) succ -\u003e NStructure set z succ",
        "fct-source": "src/Type-Nat.html#NStructure",
        "fct-type": "function",
        "title": "NStructure"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "NStructure",
        "normalized": "(a b)-\u003e(b b)c-\u003eNStructure b a c",
        "package": "type-settheory",
        "partial": "NStructure",
        "signature": "(z set)-\u003e(set set)succ-\u003eNStructure set z succ"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:Succ",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "(n :∈: TNat z s) -\u003e Succ z s (n, s n)",
        "fct-source": "src/Type-Nat.html#Succ",
        "fct-type": "function",
        "title": "Succ"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "Succ",
        "normalized": "(a TNat b c)-\u003eSucc b c(a,c a)",
        "package": "type-settheory",
        "partial": "Succ",
        "signature": "(n TNat z s)-\u003eSucc z s(n,s n)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:initorFun",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "forall z s set2 z2 succ2.  NStructure set2 z2 succ2 -\u003e (TNat z s :~\u003e: set2) (Initor z s z2 succ2)",
        "fct-source": "src/Type-Nat.html#initorFun",
        "fct-type": "function",
        "title": "initorFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "initorFun",
        "normalized": "a b c d b e NStructure d b e-\u003e(TNat b c d)(Initor b c b e)",
        "package": "type-settheory",
        "partial": "Fun",
        "signature": "forall z s set z succ NStructure set z succ-\u003e(TNat z s set)(Initor z s z succ)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:succFun",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "(TNat z s :~\u003e: TNat z s) (Succ z s)",
        "fct-source": "src/Type-Nat.html#succFun",
        "fct-type": "function",
        "title": "succFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "succFun",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:tyconNStruct",
      "description": {
        "fct-module": "Type.Nat",
        "fct-package": "type-settheory",
        "fct-signature": "NStructure (TNat z s) z (Succ z s)",
        "fct-source": "src/Type-Nat.html#tyconNStruct",
        "fct-type": "function",
        "title": "tyconNStruct"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Nat",
        "module": "Type.Nat",
        "name": "tyconNStruct",
        "normalized": "",
        "package": "type-settheory",
        "partial": "NStruct",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#",
      "description": {
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "module",
        "fct-source": "src/Type-Set-Example.html",
        "fct-type": "module",
        "title": "Example"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "Example",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Example",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#t:ExampleSet",
      "description": {
        "fct-descr": "\u003cp\u003eEither \u003ccode\u003eTypeable\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003es, or \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set-Example.html#ExampleSet",
        "fct-type": "type",
        "title": "ExampleSet"
      },
      "index": {
        "description": "Either Typeable Integral or String",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "ExampleSet",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Example Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#t:SMap",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003eMap\u003c/code\u003e whose keys are taken from any type which is a member of \u003cem\u003eset\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "newtype",
        "fct-source": "src/Type-Set-Example.html#SMap",
        "fct-type": "newtype",
        "title": "SMap"
      },
      "index": {
        "description": "Map whose keys are taken from any type which is member of set",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "SMap",
        "normalized": "",
        "package": "type-settheory",
        "partial": "SMap",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:SMap",
      "description": {
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "SMap (Map (V set) a)",
        "fct-source": "src/Type-Set-Example.html#SMap",
        "fct-type": "function",
        "title": "SMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "SMap",
        "normalized": "",
        "package": "type-settheory",
        "partial": "SMap",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:insert",
      "description": {
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "(k :∈: set) -\u003e k -\u003e a -\u003e SMap set a -\u003e SMap set a",
        "fct-source": "src/Type-Set-Example.html#insert",
        "fct-type": "function",
        "title": "insert"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "insert",
        "normalized": "(a b)-\u003ea-\u003ec-\u003eSMap b c-\u003eSMap b c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(k set)-\u003ek-\u003ea-\u003eSMap set a-\u003eSMap set a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:intInExampleSet",
      "description": {
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "Int :∈: ExampleSet",
        "fct-source": "src/Type-Set-Example.html#intInExampleSet",
        "fct-type": "function",
        "title": "intInExampleSet"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "intInExampleSet",
        "normalized": "",
        "package": "type-settheory",
        "partial": "In Example Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:lookup",
      "description": {
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "(k :∈: set) -\u003e k -\u003e SMap set a -\u003e Maybe a",
        "fct-source": "src/Type-Set-Example.html#lookup",
        "fct-type": "function",
        "title": "lookup"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "lookup",
        "normalized": "(a b)-\u003ea-\u003eSMap b c-\u003eMaybe c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(k set)-\u003ek-\u003eSMap set a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:singleton",
      "description": {
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "(k :∈: set) -\u003e k -\u003e a -\u003e SMap set a",
        "fct-source": "src/Type-Set-Example.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "singleton",
        "normalized": "(a b)-\u003ea-\u003ec-\u003eSMap b c",
        "package": "type-settheory",
        "partial": "",
        "signature": "(k set)-\u003ek-\u003ea-\u003eSMap set a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:stringInExampleSet",
      "description": {
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "String :∈: ExampleSet",
        "fct-source": "src/Type-Set-Example.html#stringInExampleSet",
        "fct-type": "function",
        "title": "stringInExampleSet"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "stringInExampleSet",
        "normalized": "",
        "package": "type-settheory",
        "partial": "In Example Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:test",
      "description": {
        "fct-module": "Type.Set.Example",
        "fct-package": "type-settheory",
        "fct-signature": "SMap ExampleSet Integer",
        "fct-source": "src/Type-Set-Example.html#test",
        "fct-type": "function",
        "title": "test"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set Example",
        "module": "Type.Set.Example",
        "name": "test",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cul\u003e\u003cli\u003e Sets are encoded as certain types of kind \u003ccode\u003e* -\u003e *\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e A value of type \u003ccode\u003eS X\u003c/code\u003e is a proof that the type \u003ccode\u003eX\u003c/code\u003e is a member of \u003ccode\u003eS\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "module",
        "fct-source": "src/Type-Set.html",
        "fct-type": "module",
        "title": "Set"
      },
      "index": {
        "description": "Sets are encoded as certain types of kind value of type is proof that the type is member of",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Set",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:-931-",
      "description": {
        "fct-descr": "\u003cp\u003eDependent sum\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#%3A3",
        "fct-type": "data",
        "title": "Σ"
      },
      "index": {
        "description": "Dependent sum",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Σ",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-215-:",
      "description": {
        "fct-descr": "\u003cp\u003eBinary products\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#%3A%D7%3A",
        "fct-type": "data",
        "title": ":×:"
      },
      "index": {
        "description": "Binary products",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": ":×:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-61--61-:",
      "description": {
        "fct-descr": "\u003cp\u003eExtensional equality of sets\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#%3A%3D%3D%3A",
        "fct-type": "data",
        "title": ":==:"
      },
      "index": {
        "description": "Extensional equality of sets",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": ":==:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-8712-:",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#%3A%2208%3A",
        "fct-type": "type",
        "title": ":∈:"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": ":∈:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-8745-:",
      "description": {
        "fct-descr": "\u003cp\u003eBinary intersection\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#%3A%2229%3A",
        "fct-type": "data",
        "title": ":∩:"
      },
      "index": {
        "description": "Binary intersection",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": ":∩:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-8746-:",
      "description": {
        "fct-descr": "\u003cp\u003eBinary union\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#%3A%222A%3A",
        "fct-type": "data",
        "title": ":∪:"
      },
      "index": {
        "description": "Binary union",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": ":∪:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-8838-:",
      "description": {
        "fct-descr": "\u003cp\u003eRepresents a proof that \u003ccode\u003eset1\u003c/code\u003e is a subset of \u003ccode\u003eset2\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#%3A%2286%3A",
        "fct-type": "data",
        "title": ":⊆:"
      },
      "index": {
        "description": "Represents proof that set1 is subset of set2",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": ":⊆:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:::-8712-:",
      "description": {
        "fct-descr": "\u003cp\u003eMembership of a set in a set representing a set of sets\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#%3A%3A%2208%3A",
        "fct-type": "type",
        "title": "::∈:"
      },
      "index": {
        "description": "Membership of set in set representing set of sets",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "::∈:",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ApplicativeType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#ApplicativeType",
        "fct-type": "data",
        "title": "ApplicativeType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ApplicativeType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Applicative Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:BoundedType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#BoundedType",
        "fct-type": "data",
        "title": "BoundedType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "BoundedType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Bounded Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:CoKleisliType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#CoKleisliType",
        "fct-type": "data",
        "title": "CoKleisliType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "CoKleisliType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Co Kleisli Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Complement",
      "description": {
        "fct-descr": "\u003cp\u003eComplement\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#Complement",
        "fct-type": "data",
        "title": "Complement"
      },
      "index": {
        "description": "Complement",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Complement",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Complement",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:DataType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#DataType",
        "fct-type": "data",
        "title": "DataType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "DataType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Data Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:DependentSum",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#DependentSum",
        "fct-type": "type",
        "title": "DependentSum"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "DependentSum",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Dependent Sum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Diff",
      "description": {
        "fct-descr": "\u003cp\u003eSet difference\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#Diff",
        "fct-type": "data",
        "title": "Diff"
      },
      "index": {
        "description": "Set difference",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Diff",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Diff",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Disjoint",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#Disjoint",
        "fct-type": "type",
        "title": "Disjoint"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Disjoint",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Disjoint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Empty",
      "description": {
        "fct-descr": "\u003cp\u003eEmpty set (barring cheating with \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#Empty",
        "fct-type": "data",
        "title": "Empty"
      },
      "index": {
        "description": "Empty set barring cheating with undefined",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Empty",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:EnumType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#EnumType",
        "fct-type": "data",
        "title": "EnumType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "EnumType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Enum Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:EqType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#EqType",
        "fct-type": "data",
        "title": "EqType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "EqType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Eq Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ExUniq1",
      "description": {
        "fct-descr": "\u003cp\u003eUnique existence, unlowered\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#ExUniq1",
        "fct-type": "data",
        "title": "ExUniq1"
      },
      "index": {
        "description": "Unique existence unlowered",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ExUniq1",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Ex Uniq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:FractionalType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#FractionalType",
        "fct-type": "data",
        "title": "FractionalType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "FractionalType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Fractional Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:FunctionType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#FunctionType",
        "fct-type": "data",
        "title": "FunctionType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "FunctionType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Function Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:FunctorType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#FunctorType",
        "fct-type": "data",
        "title": "FunctorType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "FunctorType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Functor Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:IntegralType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#IntegralType",
        "fct-type": "data",
        "title": "IntegralType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "IntegralType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Integral Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Inter",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#Inter",
        "fct-type": "type",
        "title": "Inter"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Inter",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Inter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Inters",
      "description": {
        "fct-descr": "\u003cp\u003eIntersection of a family\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#Inters",
        "fct-type": "data",
        "title": "Inters"
      },
      "index": {
        "description": "Intersection of family",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Inters",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Inters",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:KleisliType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#KleisliType",
        "fct-type": "data",
        "title": "KleisliType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "KleisliType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Kleisli Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:MonadPlusType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#MonadPlusType",
        "fct-type": "data",
        "title": "MonadPlusType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "MonadPlusType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Monad Plus Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:MonadType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#MonadType",
        "fct-type": "data",
        "title": "MonadType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "MonadType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Monad Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:MonoidType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#MonoidType",
        "fct-type": "data",
        "title": "MonoidType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "MonoidType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Monoid Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:NumType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#NumType",
        "fct-type": "data",
        "title": "NumType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "NumType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Num Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:OrdType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#OrdType",
        "fct-type": "data",
        "title": "OrdType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "OrdType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Ord Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Powerset",
      "description": {
        "fct-descr": "\u003cp\u003ePowerset\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#Powerset",
        "fct-type": "data",
        "title": "Powerset"
      },
      "index": {
        "description": "Powerset",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Powerset",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Powerset",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Prod",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#Prod",
        "fct-type": "type",
        "title": "Prod"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Prod",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Prod",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ProofSet",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#ProofSet",
        "fct-type": "data",
        "title": "ProofSet"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ProofSet",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Proof Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ReadType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#ReadType",
        "fct-type": "data",
        "title": "ReadType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ReadType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Read Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ShowType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#ShowType",
        "fct-type": "data",
        "title": "ShowType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ShowType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Show Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Singleton",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#Singleton",
        "fct-type": "type",
        "title": "Singleton"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Singleton",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Singleton",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Subset",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#Subset",
        "fct-type": "type",
        "title": "Subset"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Subset",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Subset",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:TypeableType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#TypeableType",
        "fct-type": "data",
        "title": "TypeableType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "TypeableType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Typeable Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Union",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "type",
        "fct-source": "src/Type-Set.html#Union",
        "fct-type": "type",
        "title": "Union"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Union",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Union",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Unions",
      "description": {
        "fct-descr": "\u003cp\u003eUnion of a family\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#Unions",
        "fct-type": "data",
        "title": "Unions"
      },
      "index": {
        "description": "Union of family",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Unions",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Unions",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Univ",
      "description": {
        "fct-descr": "\u003cp\u003eSet of \u003cem\u003eall\u003c/em\u003e types of kind *\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#Univ",
        "fct-type": "data",
        "title": "Univ"
      },
      "index": {
        "description": "Set of all types of kind",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Univ",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Univ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:V",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eV s\u003c/code\u003e is the sum of all types \u003ccode\u003ex\u003c/code\u003e such that \u003ccode\u003es x\u003c/code\u003e is provable.\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "data",
        "fct-source": "src/Type-Set.html#V",
        "fct-type": "data",
        "title": "V"
      },
      "index": {
        "description": "is the sum of all types such that is provable",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "V",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:-931-",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(Lower s :∈: fam) -\u003e (a :∈: s) -\u003e Σ fam (Lower s, a)",
        "fct-source": "src/Type-Set.html#%3A3",
        "fct-type": "function",
        "title": "Σ"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Σ",
        "normalized": "(Lower a b)-\u003e(c a)-\u003eΣ b(Lower a,c)",
        "package": "type-settheory",
        "partial": "",
        "signature": "(Lower s fam)-\u003e(a s)-\u003eΣ fam(Lower s,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v::-215-:",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: s1) -\u003e (b :∈: s2) -\u003e (s1 :×: s2) (a, b)",
        "fct-source": "src/Type-Set.html#%3A%D7%3A",
        "fct-type": "function",
        "title": ":×:"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": ":×:",
        "normalized": "(a b)-\u003e(c b)-\u003e(b b)(a,c)",
        "package": "type-settheory",
        "partial": "",
        "signature": "(a s)-\u003e(b s)-\u003e(s s)(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ApplicativeType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "ApplicativeType (Lower a)",
        "fct-source": "src/Type-Set.html#ApplicativeType",
        "fct-type": "function",
        "title": "ApplicativeType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ApplicativeType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Applicative Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:BoundedType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "BoundedType a",
        "fct-source": "src/Type-Set.html#BoundedType",
        "fct-type": "function",
        "title": "BoundedType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "BoundedType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Bounded Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:CoKleisliType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "CoKleisliType w (w a -\u003e b)",
        "fct-source": "src/Type-Set.html#CoKleisliType",
        "fct-type": "function",
        "title": "CoKleisliType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "CoKleisliType",
        "normalized": "CoKleisliType a(a b-\u003ec)",
        "package": "type-settheory",
        "partial": "Co Kleisli Type",
        "signature": "CoKleisliType w(w a-\u003eb)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Complement",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Not (a :∈: s) -\u003e Complement s a",
        "fct-source": "src/Type-Set.html#Complement",
        "fct-type": "function",
        "title": "Complement"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Complement",
        "normalized": "Not(a b)-\u003eComplement b a",
        "package": "type-settheory",
        "partial": "Complement",
        "signature": "Not(a s)-\u003eComplement s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:DataType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "DataType a",
        "fct-source": "src/Type-Set.html#DataType",
        "fct-type": "function",
        "title": "DataType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "DataType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Data Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Diff",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: s) -\u003e Not (a :∈: t) -\u003e Diff s t a",
        "fct-source": "src/Type-Set.html#Diff",
        "fct-type": "function",
        "title": "Diff"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Diff",
        "normalized": "(a b)-\u003eNot(a c)-\u003eDiff b c a",
        "package": "type-settheory",
        "partial": "Diff",
        "signature": "(a s)-\u003eNot(a t)-\u003eDiff s t a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Empty",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(forall b.  b) -\u003e Empty a",
        "fct-source": "src/Type-Set.html#Empty",
        "fct-type": "function",
        "title": "Empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Empty",
        "normalized": "(a b c)-\u003eEmpty d",
        "package": "type-settheory",
        "partial": "Empty",
        "signature": "(forall b. b)-\u003eEmpty a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:EnumType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "EnumType a",
        "fct-source": "src/Type-Set.html#EnumType",
        "fct-type": "function",
        "title": "EnumType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "EnumType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Enum Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:EqType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "EqType a",
        "fct-source": "src/Type-Set.html#EqType",
        "fct-type": "function",
        "title": "EqType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "EqType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Eq Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ExUniq1",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "p b -\u003e (forall b'.  p b' -\u003e b :==: b') -\u003e ExUniq1 p",
        "fct-source": "src/Type-Set.html#ExUniq1",
        "fct-type": "function",
        "title": "ExUniq1"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ExUniq1",
        "normalized": "a b-\u003e(c d a e-\u003eb e)-\u003eExUniq a",
        "package": "type-settheory",
        "partial": "Ex Uniq",
        "signature": "p b-\u003e(forall b'. p b'-\u003eb b')-\u003eExUniq p"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:FractionalType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "FractionalType a",
        "fct-source": "src/Type-Set.html#FractionalType",
        "fct-type": "function",
        "title": "FractionalType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "FractionalType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Fractional Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:FunctionType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "FunctionType (a -\u003e b)",
        "fct-source": "src/Type-Set.html#FunctionType",
        "fct-type": "function",
        "title": "FunctionType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "FunctionType",
        "normalized": "FunctionType(a-\u003eb)",
        "package": "type-settheory",
        "partial": "Function Type",
        "signature": "FunctionType(a-\u003eb)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:FunctorType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "FunctorType (Lower a)",
        "fct-source": "src/Type-Set.html#FunctorType",
        "fct-type": "function",
        "title": "FunctorType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "FunctorType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Functor Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:IntegralType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "IntegralType a",
        "fct-source": "src/Type-Set.html#IntegralType",
        "fct-type": "function",
        "title": "IntegralType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "IntegralType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Integral Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Inter",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: s1) -\u003e (a :∈: s2) -\u003e (s1 :∩: s2) a",
        "fct-source": "src/Type-Set.html#%3A%2229%3A",
        "fct-type": "function",
        "title": "Inter"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Inter",
        "normalized": "(a b)-\u003e(a b)-\u003e(b b)a",
        "package": "type-settheory",
        "partial": "Inter",
        "signature": "(a s)-\u003e(a s)-\u003e(s s)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Inters",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(forall s.  (Lower s :∈: fam) -\u003e a :∈: s) -\u003e Inters fam a",
        "fct-source": "src/Type-Set.html#Inters",
        "fct-type": "function",
        "title": "Inters"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Inters",
        "normalized": "(a b(Lower c d)-\u003ee c)-\u003eInters d e",
        "package": "type-settheory",
        "partial": "Inters",
        "signature": "(forall s.(Lower s fam)-\u003ea s)-\u003eInters fam a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:KleisliType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "KleisliType m (a -\u003e m b)",
        "fct-source": "src/Type-Set.html#KleisliType",
        "fct-type": "function",
        "title": "KleisliType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "KleisliType",
        "normalized": "KleisliType a(b-\u003ea c)",
        "package": "type-settheory",
        "partial": "Kleisli Type",
        "signature": "KleisliType m(a-\u003em b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:MonadPlusType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "MonadPlusType (Lower a)",
        "fct-source": "src/Type-Set.html#MonadPlusType",
        "fct-type": "function",
        "title": "MonadPlusType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "MonadPlusType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Monad Plus Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:MonadType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "MonadType (Lower a)",
        "fct-source": "src/Type-Set.html#MonadType",
        "fct-type": "function",
        "title": "MonadType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "MonadType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Monad Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:MonoidType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "MonoidType a",
        "fct-source": "src/Type-Set.html#MonoidType",
        "fct-type": "function",
        "title": "MonoidType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "MonoidType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Monoid Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:NumType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "NumType a",
        "fct-source": "src/Type-Set.html#NumType",
        "fct-type": "function",
        "title": "NumType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "NumType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Num Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:OrdType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "OrdType a",
        "fct-source": "src/Type-Set.html#OrdType",
        "fct-type": "function",
        "title": "OrdType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "OrdType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Ord Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Powerset",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s :⊆: u) -\u003e Powerset u (Lower s)",
        "fct-source": "src/Type-Set.html#Powerset",
        "fct-type": "function",
        "title": "Powerset"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Powerset",
        "normalized": "(a b)-\u003ePowerset b(Lower a)",
        "package": "type-settheory",
        "partial": "Powerset",
        "signature": "(s u)-\u003ePowerset u(Lower s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ProofSet",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s x -\u003e ProofSet s (s x)",
        "fct-source": "src/Type-Set.html#ProofSet",
        "fct-type": "function",
        "title": "ProofSet"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ProofSet",
        "normalized": "a b-\u003eProofSet a(a b)",
        "package": "type-settheory",
        "partial": "Proof Set",
        "signature": "s x-\u003eProofSet s(s x)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ReadType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "ReadType a",
        "fct-source": "src/Type-Set.html#ReadType",
        "fct-type": "function",
        "title": "ReadType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ReadType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Read Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:SetEq",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "SetEq (set1 :⊆: set2) (set2 :⊆: set1)",
        "fct-source": "src/Type-Set.html#%3A%3D%3D%3A",
        "fct-type": "function",
        "title": "SetEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "SetEq",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Set Eq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ShowType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "ShowType a",
        "fct-source": "src/Type-Set.html#ShowType",
        "fct-type": "function",
        "title": "ShowType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ShowType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Show Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Subset",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(forall a.  (a :∈: set1) -\u003e a :∈: set2) -\u003e set1 :⊆: set2",
        "fct-source": "src/Type-Set.html#%3A%2286%3A",
        "fct-type": "function",
        "title": "Subset"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Subset",
        "normalized": "(a b(c d)-\u003ec d)-\u003ed d",
        "package": "type-settheory",
        "partial": "Subset",
        "signature": "(forall a.(a set)-\u003ea set)-\u003eset set"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:TypeableType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "TypeableType a",
        "fct-source": "src/Type-Set.html#TypeableType",
        "fct-type": "function",
        "title": "TypeableType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "TypeableType",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Typeable Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Union",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Either (a :∈: s1) (a :∈: s2) -\u003e (s1 :∪: s2) a",
        "fct-source": "src/Type-Set.html#%3A%222A%3A",
        "fct-type": "function",
        "title": "Union"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Union",
        "normalized": "Either(a b)(a b)-\u003e(b b)a",
        "package": "type-settheory",
        "partial": "Union",
        "signature": "Either(a s)(a s)-\u003e(s s)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Unions",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(Lower s :∈: fam) -\u003e (a :∈: s) -\u003e Unions fam a",
        "fct-source": "src/Type-Set.html#Unions",
        "fct-type": "function",
        "title": "Unions"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Unions",
        "normalized": "(Lower a b)-\u003e(c a)-\u003eUnions b c",
        "package": "type-settheory",
        "partial": "Unions",
        "signature": "(Lower s fam)-\u003e(a s)-\u003eUnions fam a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Univ",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Univ a",
        "fct-source": "src/Type-Set.html#Univ",
        "fct-type": "function",
        "title": "Univ"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "Univ",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Univ",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:V",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s x -\u003e x -\u003e V s",
        "fct-source": "src/Type-Set.html#V",
        "fct-type": "function",
        "title": "V"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "V",
        "normalized": "a b-\u003eb-\u003eV a",
        "package": "type-settheory",
        "partial": "",
        "signature": "s x-\u003ex-\u003eV s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:autoequality",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s :==: t",
        "fct-source": "src/Type-Set.html#autoequality",
        "fct-type": "function",
        "title": "autoequality"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "autoequality",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:autosubset",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s :⊆: t",
        "fct-source": "src/Type-Set.html#autosubset",
        "fct-type": "function",
        "title": "autosubset"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "autosubset",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:coKleisliType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(w a -\u003e b) :∈: CoKleisliType w",
        "fct-source": "src/Type-Set.html#coKleisliType",
        "fct-type": "function",
        "title": "coKleisliType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "coKleisliType",
        "normalized": "(a b-\u003ec)CoKleisliType a",
        "package": "type-settheory",
        "partial": "Kleisli Type",
        "signature": "(w a-\u003eb)CoKleisliType w"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:complContradiction",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Not (s a, Complement s a)",
        "fct-source": "src/Type-Set.html#complContradiction",
        "fct-type": "function",
        "title": "complContradiction"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "complContradiction",
        "normalized": "Not(a b,Complement a b)",
        "package": "type-settheory",
        "partial": "Contradiction",
        "signature": "Not(s a,Complement s a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:complEmpty",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Disjoint s (Complement s)",
        "fct-source": "src/Type-Set.html#complEmpty",
        "fct-type": "function",
        "title": "complEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "complEmpty",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:complMaximal",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Disjoint s t -\u003e t :⊆: Complement s",
        "fct-source": "src/Type-Set.html#complMaximal",
        "fct-type": "function",
        "title": "complMaximal"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "complMaximal",
        "normalized": "Disjoint a b-\u003eb Complement a",
        "package": "type-settheory",
        "partial": "Maximal",
        "signature": "Disjoint s t-\u003et Complement s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ecoerce",
      "description": {
        "fct-descr": "\u003cp\u003eCoercion using a set equality\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :==: s2) -\u003e (a :∈: s1) -\u003e a :∈: s2",
        "fct-source": "src/Type-Set.html#ecoerce",
        "fct-type": "function",
        "title": "ecoerce"
      },
      "index": {
        "description": "Coercion using set equality",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ecoerce",
        "normalized": "(a a)-\u003e(b a)-\u003eb a",
        "package": "type-settheory",
        "partial": "",
        "signature": "(s s)-\u003e(a s)-\u003ea s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ecoerceFlip",
      "description": {
        "fct-descr": "\u003cp\u003eCoercion using a set equality (flipped)\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :==: s2) -\u003e (a :∈: s2) -\u003e a :∈: s1",
        "fct-source": "src/Type-Set.html#ecoerceFlip",
        "fct-type": "function",
        "title": "ecoerceFlip"
      },
      "index": {
        "description": "Coercion using set equality flipped",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "ecoerceFlip",
        "normalized": "(a a)-\u003e(b a)-\u003eb a",
        "package": "type-settheory",
        "partial": "Flip",
        "signature": "(s s)-\u003e(a s)-\u003ea s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimComplement",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: Complement s) -\u003e Not (a :∈: s)",
        "fct-source": "src/Type-Set.html#elimComplement",
        "fct-type": "function",
        "title": "elimComplement"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "elimComplement",
        "normalized": "(a Complement b)-\u003eNot(a b)",
        "package": "type-settheory",
        "partial": "Complement",
        "signature": "(a Complement s)-\u003eNot(a s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimDiff",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: Diff s t) -\u003e (a :∈: s, Not (a :∈: t))",
        "fct-source": "src/Type-Set.html#elimDiff",
        "fct-type": "function",
        "title": "elimDiff"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "elimDiff",
        "normalized": "(a Diff b c)-\u003e(a b,Not(a c))",
        "package": "type-settheory",
        "partial": "Diff",
        "signature": "(a Diff s t)-\u003e(a s,Not(a t))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimEmpty",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Empty a -\u003e b",
        "fct-source": "src/Type-Set.html#elimEmpty",
        "fct-type": "function",
        "title": "elimEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "elimEmpty",
        "normalized": "Empty a-\u003eb",
        "package": "type-settheory",
        "partial": "Empty",
        "signature": "Empty a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimInter",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: (s1 :∩: s2)) -\u003e (a :∈: s1, a :∈: s2)",
        "fct-source": "src/Type-Set.html#elimInter",
        "fct-type": "function",
        "title": "elimInter"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "elimInter",
        "normalized": "(a(b b))-\u003e(a b,a b)",
        "package": "type-settheory",
        "partial": "Inter",
        "signature": "(a(s s))-\u003e(a s,a s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimInters",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Inters fam a -\u003e (Lower s :∈: fam) -\u003e s a",
        "fct-source": "src/Type-Set.html#elimInters",
        "fct-type": "function",
        "title": "elimInters"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "elimInters",
        "normalized": "Inters a b-\u003e(Lower c a)-\u003ec b",
        "package": "type-settheory",
        "partial": "Inters",
        "signature": "Inters fam a-\u003e(Lower s fam)-\u003es a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimUnion",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: (s1 :∪: s2)) -\u003e Either (a :∈: s1) (a :∈: s2)",
        "fct-source": "src/Type-Set.html#elimUnion",
        "fct-type": "function",
        "title": "elimUnion"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "elimUnion",
        "normalized": "(a(b b))-\u003eEither(a b)(a b)",
        "package": "type-settheory",
        "partial": "Union",
        "signature": "(a(s s))-\u003eEither(a s)(a s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimUnions",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Unions fam a -\u003e (forall s.  (Lower s :∈: fam) -\u003e (a :∈: s) -\u003e r) -\u003e r",
        "fct-source": "src/Type-Set.html#elimUnions",
        "fct-type": "function",
        "title": "elimUnions"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "elimUnions",
        "normalized": "Unions a b-\u003e(c d(Lower e a)-\u003e(b e)-\u003ef)-\u003ef",
        "package": "type-settheory",
        "partial": "Unions",
        "signature": "Unions fam a-\u003e(forall s.(Lower s fam)-\u003e(a s)-\u003er)-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:emptySubset",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "Empty :⊆: s",
        "fct-source": "src/Type-Set.html#emptySubset",
        "fct-type": "function",
        "title": "emptySubset"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "emptySubset",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Subset",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:fstPrf",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "((a, b) :∈: (s1 :×: s2)) -\u003e a :∈: s1",
        "fct-source": "src/Type-Set.html#fstPrf",
        "fct-type": "function",
        "title": "fstPrf"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "fstPrf",
        "normalized": "((a,b)(c c))-\u003ea c",
        "package": "type-settheory",
        "partial": "Prf",
        "signature": "((a,b)(s s))-\u003ea s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:functionType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a -\u003e b) :∈: FunctionType",
        "fct-source": "src/Type-Set.html#functionType",
        "fct-type": "function",
        "title": "functionType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "functionType",
        "normalized": "(a-\u003eb)FunctionType",
        "package": "type-settheory",
        "partial": "Type",
        "signature": "(a-\u003eb)FunctionType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:getCompare",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: OrdType) -\u003e a -\u003e a -\u003e Ordering",
        "fct-source": "src/Type-Set.html#getCompare",
        "fct-type": "function",
        "title": "getCompare"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "getCompare",
        "normalized": "(a OrdType)-\u003ea-\u003ea-\u003eOrdering",
        "package": "type-settheory",
        "partial": "Compare",
        "signature": "(a OrdType)-\u003ea-\u003ea-\u003eOrdering"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:getEq",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: EqType) -\u003e a -\u003e a -\u003e Bool",
        "fct-source": "src/Type-Set.html#getEq",
        "fct-type": "function",
        "title": "getEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "getEq",
        "normalized": "(a EqType)-\u003ea-\u003ea-\u003eBool",
        "package": "type-settheory",
        "partial": "Eq",
        "signature": "(a EqType)-\u003ea-\u003ea-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:getFmap",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(Lower f :∈: FunctorType) -\u003e (a -\u003e b) -\u003e f a -\u003e f b",
        "fct-source": "src/Type-Set.html#getFmap",
        "fct-type": "function",
        "title": "getFmap"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "getFmap",
        "normalized": "(Lower a FunctorType)-\u003e(b-\u003ec)-\u003ea b-\u003ea c",
        "package": "type-settheory",
        "partial": "Fmap",
        "signature": "(Lower f FunctorType)-\u003e(a-\u003eb)-\u003ef a-\u003ef b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:getShow",
      "description": {
        "fct-descr": "\u003cp\u003eExample application\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a :∈: ShowType) -\u003e a -\u003e String",
        "fct-source": "src/Type-Set.html#getShow",
        "fct-type": "function",
        "title": "getShow"
      },
      "index": {
        "description": "Example application",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "getShow",
        "normalized": "(a ShowType)-\u003ea-\u003eString",
        "package": "type-settheory",
        "partial": "Show",
        "signature": "(a ShowType)-\u003ea-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:interFst",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :∩: s2) :⊆: s1",
        "fct-source": "src/Type-Set.html#interFst",
        "fct-type": "function",
        "title": "interFst"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "interFst",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Fst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:interIdempotent",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s :∩: s) :==: s",
        "fct-source": "src/Type-Set.html#interIdempotent",
        "fct-type": "function",
        "title": "interIdempotent"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "interIdempotent",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Idempotent",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:interMaximal",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(t :⊆: s1) -\u003e (t :⊆: s2) -\u003e t :⊆: (s1 :∩: s2)",
        "fct-source": "src/Type-Set.html#interMaximal",
        "fct-type": "function",
        "title": "interMaximal"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "interMaximal",
        "normalized": "(a b)-\u003e(a b)-\u003ea(b b)",
        "package": "type-settheory",
        "partial": "Maximal",
        "signature": "(t s)-\u003e(t s)-\u003et(s s)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:interSnd",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :∩: s2) :⊆: s2",
        "fct-source": "src/Type-Set.html#interSnd",
        "fct-type": "function",
        "title": "interSnd"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "interSnd",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Snd",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:kleisliType",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(a -\u003e m b) :∈: KleisliType m",
        "fct-source": "src/Type-Set.html#kleisliType",
        "fct-type": "function",
        "title": "kleisliType"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "kleisliType",
        "normalized": "(a-\u003eb c)KleisliType b",
        "package": "type-settheory",
        "partial": "Type",
        "signature": "(a-\u003em b)KleisliType m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:liftCompare",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s :⊆: OrdType) -\u003e (s :⊆: TypeableType) -\u003e V s -\u003e V s -\u003e Ordering",
        "fct-source": "src/Type-Set.html#liftCompare",
        "fct-type": "function",
        "title": "liftCompare"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "liftCompare",
        "normalized": "(a OrdType)-\u003e(a TypeableType)-\u003eV a-\u003eV a-\u003eOrdering",
        "package": "type-settheory",
        "partial": "Compare",
        "signature": "(s OrdType)-\u003e(s TypeableType)-\u003eV s-\u003eV s-\u003eOrdering"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:liftEq",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s :⊆: EqType) -\u003e (s :⊆: TypeableType) -\u003e V s -\u003e V s -\u003e Bool",
        "fct-source": "src/Type-Set.html#liftEq",
        "fct-type": "function",
        "title": "liftEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "liftEq",
        "normalized": "(a EqType)-\u003e(a TypeableType)-\u003eV a-\u003eV a-\u003eBool",
        "package": "type-settheory",
        "partial": "Eq",
        "signature": "(s EqType)-\u003e(s TypeableType)-\u003eV s-\u003eV s-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:liftShowsPrec",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s :⊆: ShowType) -\u003e (s :⊆: TypeableType) -\u003e Int -\u003e V s -\u003e ShowS",
        "fct-source": "src/Type-Set.html#liftShowsPrec",
        "fct-type": "function",
        "title": "liftShowsPrec"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "liftShowsPrec",
        "normalized": "(a ShowType)-\u003e(a TypeableType)-\u003eInt-\u003eV a-\u003eShowS",
        "package": "type-settheory",
        "partial": "Shows Prec",
        "signature": "(s ShowType)-\u003e(s TypeableType)-\u003eInt-\u003eV s-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetClosedDownwards",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "∈: Powerset u",
        "fct-source": "src/Type-Set.html#powersetClosedDownwards",
        "fct-type": "function",
        "title": "powersetClosedDownwards"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "powersetClosedDownwards",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Closed Downwards",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetEmpty",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "∈: Powerset u",
        "fct-source": "src/Type-Set.html#powersetEmpty",
        "fct-type": "function",
        "title": "powersetEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "powersetEmpty",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetInter",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "∈: Powerset u",
        "fct-source": "src/Type-Set.html#powersetInter",
        "fct-type": "function",
        "title": "powersetInter"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "powersetInter",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Inter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetMonotonic",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "∈: Powerset u2",
        "fct-source": "src/Type-Set.html#powersetMonotonic",
        "fct-type": "function",
        "title": "powersetMonotonic"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "powersetMonotonic",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Monotonic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetUnion",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "∈: Powerset u",
        "fct-source": "src/Type-Set.html#powersetUnion",
        "fct-type": "function",
        "title": "powersetUnion"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "powersetUnion",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Union",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetWholeset",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "∈: Powerset u",
        "fct-source": "src/Type-Set.html#powersetWholeset",
        "fct-type": "function",
        "title": "powersetWholeset"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "powersetWholeset",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Wholeset",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:prodMonotonic",
      "description": {
        "fct-descr": "\u003cp\u003eProduct is monotonic wrt. subset inclusion\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :⊆: t1) -\u003e (s2 :⊆: t2) -\u003e (s1 :×: s2) :⊆: (t1 :×: t2)",
        "fct-source": "src/Type-Set.html#prodMonotonic",
        "fct-type": "function",
        "title": "prodMonotonic"
      },
      "index": {
        "description": "Product is monotonic wrt subset inclusion",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "prodMonotonic",
        "normalized": "(a b)-\u003e(a b)-\u003e(a a)(b b)",
        "package": "type-settheory",
        "partial": "Monotonic",
        "signature": "(s t)-\u003e(s t)-\u003e(s s)(t t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:scoerce",
      "description": {
        "fct-descr": "\u003cp\u003eCoercion from subset to superset\n\u003c/p\u003e",
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(set1 :⊆: set2) -\u003e (a :∈: set1) -\u003e a :∈: set2",
        "fct-source": "src/Type-Set.html#scoerce",
        "fct-type": "function",
        "title": "scoerce"
      },
      "index": {
        "description": "Coercion from subset to superset",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "scoerce",
        "normalized": "(a a)-\u003e(b a)-\u003eb a",
        "package": "type-settheory",
        "partial": "",
        "signature": "(set set)-\u003e(a set)-\u003ea set"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:setEqRefl",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s :==: s",
        "fct-source": "src/Type-Set.html#setEqRefl",
        "fct-type": "function",
        "title": "setEqRefl"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "setEqRefl",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Eq Refl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:setEqSym",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :==: s2) -\u003e s2 :==: s1",
        "fct-source": "src/Type-Set.html#setEqSym",
        "fct-type": "function",
        "title": "setEqSym"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "setEqSym",
        "normalized": "(a a)-\u003ea a",
        "package": "type-settheory",
        "partial": "Eq Sym",
        "signature": "(s s)-\u003es s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:setEqTrans",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :==: s2) -\u003e (s2 :==: s3) -\u003e s1 :==: s3",
        "fct-source": "src/Type-Set.html#setEqTrans",
        "fct-type": "function",
        "title": "setEqTrans"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "setEqTrans",
        "normalized": "(a a)-\u003e(a a)-\u003ea a",
        "package": "type-settheory",
        "partial": "Eq Trans",
        "signature": "(s s)-\u003e(s s)-\u003es s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:sndPrf",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "((a, b) :∈: (s1 :×: s2)) -\u003e b :∈: s2",
        "fct-source": "src/Type-Set.html#sndPrf",
        "fct-type": "function",
        "title": "sndPrf"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "sndPrf",
        "normalized": "((a,b)(c c))-\u003eb c",
        "package": "type-settheory",
        "partial": "Prf",
        "signature": "((a,b)(s s))-\u003eb s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:subsetRefl",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s :⊆: s",
        "fct-source": "src/Type-Set.html#subsetRefl",
        "fct-type": "function",
        "title": "subsetRefl"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "subsetRefl",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Refl",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:subsetTrans",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :⊆: s2) -\u003e (s2 :⊆: s3) -\u003e s1 :⊆: s3",
        "fct-source": "src/Type-Set.html#subsetTrans",
        "fct-type": "function",
        "title": "subsetTrans"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "subsetTrans",
        "normalized": "(a a)-\u003e(a a)-\u003ea a",
        "package": "type-settheory",
        "partial": "Trans",
        "signature": "(s s)-\u003e(s s)-\u003es s"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:unionIdempotent",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s :∪: s) :==: s",
        "fct-source": "src/Type-Set.html#unionIdempotent",
        "fct-type": "function",
        "title": "unionIdempotent"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "unionIdempotent",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Idempotent",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:unionL",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s1 :⊆: (s1 :∪: s2)",
        "fct-source": "src/Type-Set.html#unionL",
        "fct-type": "function",
        "title": "unionL"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "unionL",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:unionMinimal",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "(s1 :⊆: t) -\u003e (s2 :⊆: t) -\u003e (s1 :∪: s2) :⊆: t",
        "fct-source": "src/Type-Set.html#unionMinimal",
        "fct-type": "function",
        "title": "unionMinimal"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "unionMinimal",
        "normalized": "(a b)-\u003e(a b)-\u003e(a a)b",
        "package": "type-settheory",
        "partial": "Minimal",
        "signature": "(s t)-\u003e(s t)-\u003e(s s)t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:unionR",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s2 :⊆: (s1 :∪: s2)",
        "fct-source": "src/Type-Set.html#unionR",
        "fct-type": "function",
        "title": "unionR"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "unionR",
        "normalized": "",
        "package": "type-settheory",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:univSubset",
      "description": {
        "fct-module": "Type.Set",
        "fct-package": "type-settheory",
        "fct-signature": "s :⊆: Univ",
        "fct-source": "src/Type-Set.html#univSubset",
        "fct-type": "function",
        "title": "univSubset"
      },
      "index": {
        "description": "",
        "hierarchy": "Type Set",
        "module": "Type.Set",
        "name": "univSubset",
        "normalized": "",
        "package": "type-settheory",
        "partial": "Subset",
        "signature": ""
      }
    }
  }
]
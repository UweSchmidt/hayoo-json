[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType classes for lattices and boolean algebras.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algebra-Lattice-Boolean.html",
        "fct-type": "module",
        "title": "Boolean"
      },
      "index": {
        "description": "Type classes for lattices and boolean algebras",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "Boolean",
        "normalized": "",
        "package": "toysolver",
        "partial": "Boolean",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#t:Boolean",
      "description": {
        "fct-descr": "\u003cp\u003etypes that can be combined with boolean operations.\n\u003c/p\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Algebra-Lattice-Boolean.html#Boolean",
        "fct-type": "class",
        "title": "Boolean"
      },
      "index": {
        "description": "types that can be combined with boolean operations",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "Boolean",
        "normalized": "",
        "package": "toysolver",
        "partial": "Boolean",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#t:Complement",
      "description": {
        "fct-descr": "\u003cp\u003etypes that can be negated.\n\u003c/p\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Algebra-Lattice-Boolean.html#Complement",
        "fct-type": "class",
        "title": "Complement"
      },
      "index": {
        "description": "types that can be negated",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "Complement",
        "normalized": "",
        "package": "toysolver",
        "partial": "Complement",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:.-124--124-.",
      "description": {
        "fct-descr": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e a -\u003e a",
        "fct-source": "src/Algebra-Lattice-Boolean.html#.%7C%7C.",
        "fct-type": "function",
        "title": "(.||.)"
      },
      "index": {
        "description": "alias of join",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "(.||.) .||.",
        "normalized": "a-\u003ea-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:.-38--38-.",
      "description": {
        "fct-descr": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e a -\u003e a",
        "fct-source": "src/Algebra-Lattice-Boolean.html#.%26%26.",
        "fct-type": "function",
        "title": "(.&&.)"
      },
      "index": {
        "description": "alias of meet",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "(.&&.) .&&.",
        "normalized": "a-\u003ea-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:.-61--62-.",
      "description": {
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e a -\u003e a",
        "fct-source": "src/Algebra-Lattice-Boolean.html#.%3D%3E.",
        "fct-type": "method",
        "title": "(.=\u003e.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "(.=\u003e.) .=\u003e.",
        "normalized": "a-\u003ea-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:andB",
      "description": {
        "fct-descr": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003emeets\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "[a] -\u003e a",
        "fct-source": "src/Algebra-Lattice-Boolean.html#andB",
        "fct-type": "function",
        "title": "andB"
      },
      "index": {
        "description": "alias of meets",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "andB",
        "normalized": "[a]-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:false",
      "description": {
        "fct-descr": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003ebottom\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "a",
        "fct-source": "src/Algebra-Lattice-Boolean.html#false",
        "fct-type": "function",
        "title": "false"
      },
      "index": {
        "description": "alias of bottom",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "false",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:notB",
      "description": {
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e a",
        "fct-source": "src/Algebra-Lattice-Boolean.html#notB",
        "fct-type": "method",
        "title": "notB"
      },
      "index": {
        "description": "",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "notB",
        "normalized": "a-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:orB",
      "description": {
        "fct-descr": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003ejoins\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "[a] -\u003e a",
        "fct-source": "src/Algebra-Lattice-Boolean.html#orB",
        "fct-type": "function",
        "title": "orB"
      },
      "index": {
        "description": "alias of joins",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "orB",
        "normalized": "[a]-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "[a]-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algebra-Lattice-Boolean.html#v:true",
      "description": {
        "fct-descr": "\u003cp\u003ealias of \u003ccode\u003e\u003ca\u003etop\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Algebra.Lattice.Boolean",
        "fct-package": "toysolver",
        "fct-signature": "a",
        "fct-source": "src/Algebra-Lattice-Boolean.html#true",
        "fct-type": "function",
        "title": "true"
      },
      "index": {
        "description": "alias of top",
        "hierarchy": "Algebra Lattice Boolean",
        "module": "Algebra.Lattice.Boolean",
        "name": "true",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTightening variable bounds by constraint propagation.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.BoundsInference",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-BoundsInference.html",
        "fct-type": "module",
        "title": "BoundsInference"
      },
      "index": {
        "description": "Tightening variable bounds by constraint propagation",
        "hierarchy": "Algorithm BoundsInference",
        "module": "Algorithm.BoundsInference",
        "name": "BoundsInference",
        "normalized": "",
        "package": "toysolver",
        "partial": "Bounds Inference",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#t:BoundsEnv",
      "description": {
        "fct-module": "Algorithm.BoundsInference",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-LA.html#BoundsEnv",
        "fct-type": "type",
        "title": "BoundsEnv"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm BoundsInference",
        "module": "Algorithm.BoundsInference",
        "name": "BoundsEnv",
        "normalized": "",
        "package": "toysolver",
        "partial": "Bounds Env",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#v:computeInterval",
      "description": {
        "fct-descr": "\u003cp\u003ecompute bounds for a \u003ccode\u003eExpr\u003c/code\u003e with respect to \u003ccode\u003eBoundsEnv\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Algorithm.BoundsInference",
        "fct-package": "toysolver",
        "fct-signature": "BoundsEnv r -\u003e Expr r -\u003e Interval r",
        "fct-source": "src/Data-LA.html#computeInterval",
        "fct-type": "function",
        "title": "computeInterval"
      },
      "index": {
        "description": "compute bounds for Expr with respect to BoundsEnv",
        "hierarchy": "Algorithm BoundsInference",
        "module": "Algorithm.BoundsInference",
        "name": "computeInterval",
        "normalized": "BoundsEnv a-\u003eExpr a-\u003eInterval a",
        "package": "toysolver",
        "partial": "Interval",
        "signature": "BoundsEnv r-\u003eExpr r-\u003eInterval r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-BoundsInference.html#v:inferBounds",
      "description": {
        "fct-descr": "\u003cp\u003etightening variable bounds by constraint propagation.\n\u003c/p\u003e",
        "fct-module": "Algorithm.BoundsInference",
        "fct-package": "toysolver",
        "fct-signature": "BoundsEnv r-\u003e [Atom r]-\u003e VarSet-\u003e Int-\u003e BoundsEnv r",
        "fct-type": "function",
        "title": "inferBounds"
      },
      "index": {
        "description": "tightening variable bounds by constraint propagation",
        "hierarchy": "Algorithm BoundsInference",
        "module": "Algorithm.BoundsInference",
        "name": "inferBounds",
        "normalized": "BoundsEnv a-\u003e[Atom a]-\u003eVarSet-\u003eInt-\u003eBoundsEnv a",
        "package": "toysolver",
        "partial": "Bounds",
        "signature": "BoundsEnv r-\u003e[Atom r]-\u003eVarSet-\u003eInt-\u003eBoundsEnv r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  Christian Michaux and Adem Ozturk.\n    Quantifier Elimination following Muchnik\n    \u003ca\u003ehttps://math.umons.ac.be/preprints/src/Ozturk020411.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e  Arnab Bhattacharyya.\n    Something you should know about: Quantifier Elimination (Part I)\n    \u003ca\u003ehttp://cstheory.blogoverflow.com/2011/11/something-you-should-know-about-quantifier-elimination-part-i/\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e  Arnab Bhattacharyya.\n    Something you should know about: Quantifier Elimination (Part II)\n    \u003ca\u003ehttp://cstheory.blogoverflow.com/2012/02/something-you-should-know-about-quantifier-elimination-part-ii/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-CAD.html",
        "fct-type": "module",
        "title": "CAD"
      },
      "index": {
        "description": "References Christian Michaux and Adem Ozturk Quantifier Elimination following Muchnik https math.umons.ac.be preprints src Ozturk020411.pdf Arnab Bhattacharyya Something you should know about Quantifier Elimination Part http cstheory.blogoverflow.com something-you-should-know-about-quantifier-elimination-part-i Arnab Bhattacharyya Something you should know about Quantifier Elimination Part II http cstheory.blogoverflow.com something-you-should-know-about-quantifier-elimination-part-ii",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "CAD",
        "normalized": "",
        "package": "toysolver",
        "partial": "CAD",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#t:Cell",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-CAD.html#Cell",
        "fct-type": "data",
        "title": "Cell"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "Cell",
        "normalized": "",
        "package": "toysolver",
        "partial": "Cell",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#t:Model",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-CAD.html#Model",
        "fct-type": "type",
        "title": "Model"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#t:Point",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-CAD.html#Point",
        "fct-type": "data",
        "title": "Point"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "Point",
        "normalized": "",
        "package": "toysolver",
        "partial": "Point",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:Interval",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "Interval (Point c) (Point c)",
        "fct-source": "src/Algorithm-CAD.html#Cell",
        "fct-type": "function",
        "title": "Interval"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "Interval",
        "normalized": "",
        "package": "toysolver",
        "partial": "Interval",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:NegInf",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "NegInf",
        "fct-source": "src/Algorithm-CAD.html#Point",
        "fct-type": "function",
        "title": "NegInf"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "NegInf",
        "normalized": "",
        "package": "toysolver",
        "partial": "Neg Inf",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:Point",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "Point (Point c)",
        "fct-source": "src/Algorithm-CAD.html#Cell",
        "fct-type": "function",
        "title": "Point"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "Point",
        "normalized": "",
        "package": "toysolver",
        "partial": "Point",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:PosInf",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "PosInf",
        "fct-source": "src/Algorithm-CAD.html#Point",
        "fct-type": "function",
        "title": "PosInf"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "PosInf",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pos Inf",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:RootOf",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "RootOf (UPolynomial c) Int",
        "fct-source": "src/Algorithm-CAD.html#Point",
        "fct-type": "function",
        "title": "RootOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "RootOf",
        "normalized": "",
        "package": "toysolver",
        "partial": "Root Of",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:evalCell",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "Model v -\u003e Cell (Polynomial Rational v) -\u003e Cell Rational",
        "fct-source": "src/Algorithm-CAD.html#evalCell",
        "fct-type": "function",
        "title": "evalCell"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "evalCell",
        "normalized": "Model a-\u003eCell(Polynomial Rational a)-\u003eCell Rational",
        "package": "toysolver",
        "partial": "Cell",
        "signature": "Model v-\u003eCell(Polynomial Rational v)-\u003eCell Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:evalPoint",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "Model v -\u003e Point (Polynomial Rational v) -\u003e Point Rational",
        "fct-source": "src/Algorithm-CAD.html#evalPoint",
        "fct-type": "function",
        "title": "evalPoint"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "evalPoint",
        "normalized": "Model a-\u003ePoint(Polynomial Rational a)-\u003ePoint Rational",
        "package": "toysolver",
        "partial": "Point",
        "signature": "Model v-\u003ePoint(Polynomial Rational v)-\u003ePoint Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:findSample",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "Model v -\u003e Cell (Polynomial Rational v) -\u003e Maybe AReal",
        "fct-source": "src/Algorithm-CAD.html#findSample",
        "fct-type": "function",
        "title": "findSample"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "findSample",
        "normalized": "Model a-\u003eCell(Polynomial Rational a)-\u003eMaybe AReal",
        "package": "toysolver",
        "partial": "Sample",
        "signature": "Model v-\u003eCell(Polynomial Rational v)-\u003eMaybe AReal"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:project",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "[(UPolynomial (Polynomial Rational v), [Sign])] -\u003e [([(Polynomial Rational v, [Sign])], [Cell (Polynomial Rational v)])]",
        "fct-source": "src/Algorithm-CAD.html#project",
        "fct-type": "function",
        "title": "project"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "project",
        "normalized": "[(UPolynomial(Polynomial Rational a),[Sign])]-\u003e[([(Polynomial Rational a,[Sign])],[Cell(Polynomial Rational a)])]",
        "package": "toysolver",
        "partial": "",
        "signature": "[(UPolynomial(Polynomial Rational v),[Sign])]-\u003e[([(Polynomial Rational v,[Sign])],[Cell(Polynomial Rational v)])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:solve",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "Set v -\u003e [Rel (Polynomial Rational v)] -\u003e Maybe (Model v)",
        "fct-source": "src/Algorithm-CAD.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "solve",
        "normalized": "Set a-\u003e[Rel(Polynomial Rational a)]-\u003eMaybe(Model a)",
        "package": "toysolver",
        "partial": "",
        "signature": "Set v-\u003e[Rel(Polynomial Rational v)]-\u003eMaybe(Model v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CAD.html#v:solve-39-",
      "description": {
        "fct-module": "Algorithm.CAD",
        "fct-package": "toysolver",
        "fct-signature": "Set v -\u003e [(Polynomial Rational v, [Sign])] -\u003e Maybe (Model v)",
        "fct-source": "src/Algorithm-CAD.html#solve%27",
        "fct-type": "function",
        "title": "solve'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CAD",
        "module": "Algorithm.CAD",
        "name": "solve'",
        "normalized": "Set a-\u003e[(Polynomial Rational a,[Sign])]-\u003eMaybe(Model a)",
        "package": "toysolver",
        "partial": "",
        "signature": "Set v-\u003e[(Polynomial Rational v,[Sign])]-\u003eMaybe(Model v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e R. Nieuwenhuis and A. Oliveras, \u003ca\u003eFast congruence closure and extensions,\u003c/a\u003e\n   Information and Computation, vol. 205, no. 4, pp. 557-580, Apr. 2007.\n   \u003ca\u003ehttp://www.lsi.upc.edu/~oliveras/espai/papers/IC.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-CongruenceClosure.html",
        "fct-type": "module",
        "title": "CongruenceClosure"
      },
      "index": {
        "description": "References Nieuwenhuis and Oliveras Fast congruence closure and extensions Information and Computation vol no pp Apr http www.lsi.upc.edu oliveras espai papers IC.pdf",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "CongruenceClosure",
        "normalized": "",
        "package": "toysolver",
        "partial": "Congruence Closure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#t:FlatTerm",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-CongruenceClosure.html#FlatTerm",
        "fct-type": "data",
        "title": "FlatTerm"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "FlatTerm",
        "normalized": "",
        "package": "toysolver",
        "partial": "Flat Term",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#t:Solver",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-CongruenceClosure.html#Solver",
        "fct-type": "data",
        "title": "Solver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "Solver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#t:Var",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-CongruenceClosure.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:FTApp",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "FTApp Var Var",
        "fct-source": "src/Algorithm-CongruenceClosure.html#FlatTerm",
        "fct-type": "function",
        "title": "FTApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "FTApp",
        "normalized": "",
        "package": "toysolver",
        "partial": "FTApp",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:FTConst",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "FTConst Var",
        "fct-source": "src/Algorithm-CongruenceClosure.html#FlatTerm",
        "fct-type": "function",
        "title": "FTConst"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "FTConst",
        "normalized": "",
        "package": "toysolver",
        "partial": "FTConst",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:areCongruent",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e FlatTerm -\u003e FlatTerm -\u003e IO Bool",
        "fct-source": "src/Algorithm-CongruenceClosure.html#areCongruent",
        "fct-type": "function",
        "title": "areCongruent"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "areCongruent",
        "normalized": "Solver-\u003eFlatTerm-\u003eFlatTerm-\u003eIO Bool",
        "package": "toysolver",
        "partial": "Congruent",
        "signature": "Solver-\u003eFlatTerm-\u003eFlatTerm-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:merge",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e (FlatTerm, Var) -\u003e IO ()",
        "fct-source": "src/Algorithm-CongruenceClosure.html#merge",
        "fct-type": "function",
        "title": "merge"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "merge",
        "normalized": "Solver-\u003e(FlatTerm,Var)-\u003eIO()",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003e(FlatTerm,Var)-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:newSolver",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "IO Solver",
        "fct-source": "src/Algorithm-CongruenceClosure.html#newSolver",
        "fct-type": "function",
        "title": "newSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "newSolver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-CongruenceClosure.html#v:newVar",
      "description": {
        "fct-module": "Algorithm.CongruenceClosure",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Var",
        "fct-source": "src/Algorithm-CongruenceClosure.html#newVar",
        "fct-type": "function",
        "title": "newVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm CongruenceClosure",
        "module": "Algorithm.CongruenceClosure",
        "name": "newVar",
        "normalized": "Solver-\u003eIO Var",
        "package": "toysolver",
        "partial": "Var",
        "signature": "Solver-\u003eIO Var"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-ContiTraverso.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e P. Conti and C. Traverso, \u003ca\u003eBuchberger algorithm and integer programming,\u003c/a\u003e\n   Applied Algebra, Algebraic Algorithms and Error-Correcting Codes,\n   Lecture Notes in Computer Science Volume 539, 1991, pp 130-139\n   \u003ca\u003ehttp://dx.doi.org/10.1007/3-540-54522-0_102\u003c/a\u003e\n   \u003ca\u003ehttp://posso.dm.unipi.it/users/traverso/conti-traverso-ip.ps\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e IKEGAMI Daisuke, \u003ca\u003e&#25968;&#21015;&#12392;&#22810;&#38917;&#24335;&#12398;&#24859;&#12375;&#12356;&#38306;&#20418;,\u003c/a\u003e 2011,\n   \u003ca\u003ehttp://madscientist.jp/~ikegami/articles/IntroSequencePolynomial.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e &#20234;&#34276;&#38597;&#21490;, , &#24179;&#26519; &#38534;&#19968;, \u003ca\u003e&#25972;&#25968;&#35336;&#30011;&#21839;&#38988;&#12398;&#12383;&#12417;&#12398; b-Gr&#246;bner &#22522;&#24213;&#22793;&#25563;&#12450;&#12523;&#12468;&#12522;&#12474;&#12512;,\u003c/a\u003e\n   \u003ca\u003ehttp://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1295-27.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.ContiTraverso",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-ContiTraverso.html",
        "fct-type": "module",
        "title": "ContiTraverso"
      },
      "index": {
        "description": "References Conti and Traverso Buchberger algorithm and integer programming Applied Algebra Algebraic Algorithms and Error-Correcting Codes Lecture Notes in Computer Science Volume pp http dx.doi.org http posso.dm.unipi.it users traverso conti-traverso-ip.ps IKEGAMI Daisuke http madscientist.jp ikegami articles IntroSequencePolynomial.html b-Gr bner http www.kurims.kyoto-u.ac.jp kyodo kokyuroku contents pdf pdf",
        "hierarchy": "Algorithm ContiTraverso",
        "module": "Algorithm.ContiTraverso",
        "name": "ContiTraverso",
        "normalized": "",
        "package": "toysolver",
        "partial": "Conti Traverso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-ContiTraverso.html#v:solve",
      "description": {
        "fct-module": "Algorithm.ContiTraverso",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder Var -\u003e VarSet -\u003e OptDir -\u003e Expr Rational -\u003e [Atom Rational] -\u003e Maybe (Model Integer)",
        "fct-source": "src/Algorithm-ContiTraverso.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm ContiTraverso",
        "module": "Algorithm.ContiTraverso",
        "name": "solve",
        "normalized": "MonomialOrder Var-\u003eVarSet-\u003eOptDir-\u003eExpr Rational-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "MonomialOrder Var-\u003eVarSet-\u003eOptDir-\u003eExpr Rational-\u003e[Atom Rational]-\u003eMaybe(Model Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-ContiTraverso.html#v:solve-39-",
      "description": {
        "fct-module": "Algorithm.ContiTraverso",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder Var -\u003e VarSet -\u003e Expr Integer -\u003e [(Expr Integer, Integer)] -\u003e Maybe (Model Integer)",
        "fct-source": "src/Algorithm-ContiTraverso.html#solve%27",
        "fct-type": "function",
        "title": "solve'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm ContiTraverso",
        "module": "Algorithm.ContiTraverso",
        "name": "solve'",
        "normalized": "MonomialOrder Var-\u003eVarSet-\u003eExpr Integer-\u003e[(Expr Integer,Integer)]-\u003eMaybe(Model Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "MonomialOrder Var-\u003eVarSet-\u003eExpr Integer-\u003e[(Expr Integer,Integer)]-\u003eMaybe(Model Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNaive implementation of Cooper's algorithm\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hagi.is.s.u-tokyo.ac.jp/pub/staff/hagiya/kougiroku/ronri/5.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.cs.cmu.edu/~emc/spring06/home1_files/Presburger%20Arithmetic.ppt\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/presburger\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-Cooper-Core.html",
        "fct-type": "module",
        "title": "Core"
      },
      "index": {
        "description": "Naive implementation of Cooper algorithm Reference http hagi.is.s.u-tokyo.ac.jp pub staff hagiya kougiroku ronri txt http www.cs.cmu.edu emc spring06 home1 files Presburger Arithmetic.ppt See also http hackage.haskell.org package presburger",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "Core",
        "normalized": "",
        "package": "toysolver",
        "partial": "Core",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#t:ExprZ",
      "description": {
        "fct-descr": "\u003cp\u003eLinear arithmetic expression over integers.\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Cooper-Core.html#ExprZ",
        "fct-type": "type",
        "title": "ExprZ"
      },
      "index": {
        "description": "Linear arithmetic expression over integers",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "ExprZ",
        "normalized": "",
        "package": "toysolver",
        "partial": "Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#t:Lit",
      "description": {
        "fct-descr": "\u003cp\u003eLiteral\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ePos e\u003c/code\u003e means \u003ccode\u003ee \u003e 0\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eDivisible True d e\u003c/code\u003e means \u003ccode\u003ee\u003c/code\u003e can be divided by \u003ccode\u003ed\u003c/code\u003e (i.e. \u003ccode\u003ed|e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eDivisible False d e\u003c/code\u003e means \u003ccode\u003ee\u003c/code\u003e can not be divided by \u003ccode\u003ed\u003c/code\u003e (i.e. \u003ccode\u003e&#172;(d|e)\u003c/code\u003e)\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Cooper-Core.html#Lit",
        "fct-type": "data",
        "title": "Lit"
      },
      "index": {
        "description": "Literal Pos means Divisible True means can be divided by i.e Divisible False means can not be divided by i.e",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#t:QFFormula",
      "description": {
        "fct-descr": "\u003cp\u003equantifier-free negation normal form\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "data",
        "title": "QFFormula"
      },
      "index": {
        "description": "quantifier-free negation normal form",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "QFFormula",
        "normalized": "",
        "package": "toysolver",
        "partial": "QFFormula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:.-124-.",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Integer -\u003e ExprZ -\u003e QFFormula",
        "fct-source": "src/Algorithm-Cooper-Core.html#.%7C.",
        "fct-type": "function",
        "title": "(.|.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "(.|.) .|.",
        "normalized": "Integer-\u003eExprZ-\u003eQFFormula",
        "package": "toysolver",
        "partial": "",
        "signature": "Integer-\u003eExprZ-\u003eQFFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:And-39-",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "And' QFFormula QFFormula",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "And'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "And'",
        "normalized": "",
        "package": "toysolver",
        "partial": "And'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Divisible",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Divisible Bool Integer ExprZ",
        "fct-source": "src/Algorithm-Cooper-Core.html#Lit",
        "fct-type": "function",
        "title": "Divisible"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "Divisible",
        "normalized": "",
        "package": "toysolver",
        "partial": "Divisible",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:F-39-",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "F'",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "F'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "F'",
        "normalized": "",
        "package": "toysolver",
        "partial": "F'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Lit",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Lit Lit",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "Lit"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Or-39-",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Or' QFFormula QFFormula",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "Or'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "Or'",
        "normalized": "",
        "package": "toysolver",
        "partial": "Or'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:Pos",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Pos ExprZ",
        "fct-source": "src/Algorithm-Cooper-Core.html#Lit",
        "fct-type": "function",
        "title": "Pos"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "Pos",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pos",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:T-39-",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "T'",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "T'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "T'",
        "normalized": "",
        "package": "toysolver",
        "partial": "T'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:evalLit",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Model Integer -\u003e Lit -\u003e Bool",
        "fct-source": "src/Algorithm-Cooper-Core.html#evalLit",
        "fct-type": "function",
        "title": "evalLit"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "evalLit",
        "normalized": "Model Integer-\u003eLit-\u003eBool",
        "package": "toysolver",
        "partial": "Lit",
        "signature": "Model Integer-\u003eLit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:evalQFFormula",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Model Integer -\u003e QFFormula -\u003e Bool",
        "fct-source": "src/Algorithm-Cooper-Core.html#evalQFFormula",
        "fct-type": "function",
        "title": "evalQFFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "evalQFFormula",
        "normalized": "Model Integer-\u003eQFFormula-\u003eBool",
        "package": "toysolver",
        "partial": "QFFormula",
        "signature": "Model Integer-\u003eQFFormula-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:fromLAAtom",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Atom Rational -\u003e QFFormula",
        "fct-source": "src/Algorithm-Cooper-Core.html#fromLAAtom",
        "fct-type": "function",
        "title": "fromLAAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "fromLAAtom",
        "normalized": "Atom Rational-\u003eQFFormula",
        "package": "toysolver",
        "partial": "LAAtom",
        "signature": "Atom Rational-\u003eQFFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:project",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e QFFormula -\u003e (QFFormula, Model Integer -\u003e Model Integer)",
        "fct-source": "src/Algorithm-Cooper-Core.html#project",
        "fct-type": "function",
        "title": "project"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "project",
        "normalized": "Var-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:projectCases",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e QFFormula -\u003e [(QFFormula, Model Integer -\u003e Model Integer)]",
        "fct-source": "src/Algorithm-Cooper-Core.html#projectCases",
        "fct-type": "function",
        "title": "projectCases"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "projectCases",
        "normalized": "Var-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]",
        "package": "toysolver",
        "partial": "Cases",
        "signature": "Var-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:projectCasesN",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e QFFormula -\u003e [(QFFormula, Model Integer -\u003e Model Integer)]",
        "fct-source": "src/Algorithm-Cooper-Core.html#projectCasesN",
        "fct-type": "function",
        "title": "projectCasesN"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "projectCasesN",
        "normalized": "VarSet-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]",
        "package": "toysolver",
        "partial": "Cases",
        "signature": "VarSet-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:projectN",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e QFFormula -\u003e (QFFormula, Model Integer -\u003e Model Integer)",
        "fct-source": "src/Algorithm-Cooper-Core.html#projectN",
        "fct-type": "function",
        "title": "projectN"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "projectN",
        "normalized": "VarSet-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "VarSet-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solve",
      "description": {
        "fct-descr": "\u003cp\u003esolve a (open) quantifier-free formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Maybe (Model Integer)",
        "fct-source": "src/Algorithm-Cooper-Core.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "solve open quantifier-free formula",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "solve",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solveQFFormula",
      "description": {
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e QFFormula -\u003e Maybe (Model Integer)",
        "fct-source": "src/Algorithm-Cooper-Core.html#solveQFFormula",
        "fct-type": "function",
        "title": "solveQFFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "solveQFFormula",
        "normalized": "VarSet-\u003eQFFormula-\u003eMaybe(Model Integer)",
        "package": "toysolver",
        "partial": "QFFormula",
        "signature": "VarSet-\u003eQFFormula-\u003eMaybe(Model Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-Core.html#v:solveQFLA",
      "description": {
        "fct-descr": "\u003cp\u003esolve a (open) quantifier-free formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e VarSet -\u003e Maybe (Model Rational)",
        "fct-source": "src/Algorithm-Cooper-Core.html#solveQFLA",
        "fct-type": "function",
        "title": "solveQFLA"
      },
      "index": {
        "description": "solve open quantifier-free formula",
        "hierarchy": "Algorithm Cooper Core",
        "module": "Algorithm.Cooper.Core",
        "name": "solveQFLA",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)",
        "package": "toysolver",
        "partial": "QFLA",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-FOL.html#",
      "description": {
        "fct-module": "Algorithm.Cooper.FOL",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-Cooper-FOL.html",
        "fct-type": "module",
        "title": "FOL"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper FOL",
        "module": "Algorithm.Cooper.FOL",
        "name": "FOL",
        "normalized": "",
        "package": "toysolver",
        "partial": "FOL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-FOL.html#v:eliminateQuantifiers",
      "description": {
        "fct-descr": "\u003cp\u003eeliminate quantifiers and returns equivalent quantifier-free formula.\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper.FOL",
        "fct-package": "toysolver",
        "fct-signature": "Formula (Atom Rational) -\u003e Maybe QFFormula",
        "fct-source": "src/Algorithm-Cooper-FOL.html#eliminateQuantifiers",
        "fct-type": "function",
        "title": "eliminateQuantifiers"
      },
      "index": {
        "description": "eliminate quantifiers and returns equivalent quantifier-free formula",
        "hierarchy": "Algorithm Cooper FOL",
        "module": "Algorithm.Cooper.FOL",
        "name": "eliminateQuantifiers",
        "normalized": "Formula(Atom Rational)-\u003eMaybe QFFormula",
        "package": "toysolver",
        "partial": "Quantifiers",
        "signature": "Formula(Atom Rational)-\u003eMaybe QFFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper-FOL.html#v:solveFormula",
      "description": {
        "fct-module": "Algorithm.Cooper.FOL",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e Formula (Atom Rational) -\u003e SatResult Integer",
        "fct-source": "src/Algorithm-Cooper-FOL.html#solveFormula",
        "fct-type": "function",
        "title": "solveFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper FOL",
        "module": "Algorithm.Cooper.FOL",
        "name": "solveFormula",
        "normalized": "VarSet-\u003eFormula(Atom Rational)-\u003eSatResult Integer",
        "package": "toysolver",
        "partial": "Formula",
        "signature": "VarSet-\u003eFormula(Atom Rational)-\u003eSatResult Integer"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNaive implementation of Cooper's algorithm\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hagi.is.s.u-tokyo.ac.jp/pub/staff/hagiya/kougiroku/ronri/5.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.cs.cmu.edu/~emc/spring06/home1_files/Presburger%20Arithmetic.ppt\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/presburger\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-Cooper.html",
        "fct-type": "module",
        "title": "Cooper"
      },
      "index": {
        "description": "Naive implementation of Cooper algorithm Reference http hagi.is.s.u-tokyo.ac.jp pub staff hagiya kougiroku ronri txt http www.cs.cmu.edu emc spring06 home1 files Presburger Arithmetic.ppt See also http hackage.haskell.org package presburger",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "Cooper",
        "normalized": "",
        "package": "toysolver",
        "partial": "Cooper",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#t:ExprZ",
      "description": {
        "fct-descr": "\u003cp\u003eLinear arithmetic expression over integers.\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Cooper-Core.html#ExprZ",
        "fct-type": "type",
        "title": "ExprZ"
      },
      "index": {
        "description": "Linear arithmetic expression over integers",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "ExprZ",
        "normalized": "",
        "package": "toysolver",
        "partial": "Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#t:Lit",
      "description": {
        "fct-descr": "\u003cp\u003eLiteral\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ePos e\u003c/code\u003e means \u003ccode\u003ee \u003e 0\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eDivisible True d e\u003c/code\u003e means \u003ccode\u003ee\u003c/code\u003e can be divided by \u003ccode\u003ed\u003c/code\u003e (i.e. \u003ccode\u003ed|e\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eDivisible False d e\u003c/code\u003e means \u003ccode\u003ee\u003c/code\u003e can not be divided by \u003ccode\u003ed\u003c/code\u003e (i.e. \u003ccode\u003e&#172;(d|e)\u003c/code\u003e)\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Cooper-Core.html#Lit",
        "fct-type": "data",
        "title": "Lit"
      },
      "index": {
        "description": "Literal Pos means Divisible True means can be divided by i.e Divisible False means can not be divided by i.e",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#t:QFFormula",
      "description": {
        "fct-descr": "\u003cp\u003equantifier-free negation normal form\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "data",
        "title": "QFFormula"
      },
      "index": {
        "description": "quantifier-free negation normal form",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "QFFormula",
        "normalized": "",
        "package": "toysolver",
        "partial": "QFFormula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:.-124-.",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Integer -\u003e ExprZ -\u003e QFFormula",
        "fct-source": "src/Algorithm-Cooper-Core.html#.%7C.",
        "fct-type": "function",
        "title": "(.|.)"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "(.|.) .|.",
        "normalized": "Integer-\u003eExprZ-\u003eQFFormula",
        "package": "toysolver",
        "partial": "",
        "signature": "Integer-\u003eExprZ-\u003eQFFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:And-39-",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "And' QFFormula QFFormula",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "And'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "And'",
        "normalized": "",
        "package": "toysolver",
        "partial": "And'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:Divisible",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Divisible Bool Integer ExprZ",
        "fct-source": "src/Algorithm-Cooper-Core.html#Lit",
        "fct-type": "function",
        "title": "Divisible"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "Divisible",
        "normalized": "",
        "package": "toysolver",
        "partial": "Divisible",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:F-39-",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "F'",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "F'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "F'",
        "normalized": "",
        "package": "toysolver",
        "partial": "F'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:Lit",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Lit Lit",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "Lit"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:Or-39-",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Or' QFFormula QFFormula",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "Or'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "Or'",
        "normalized": "",
        "package": "toysolver",
        "partial": "Or'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:Pos",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Pos ExprZ",
        "fct-source": "src/Algorithm-Cooper-Core.html#Lit",
        "fct-type": "function",
        "title": "Pos"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "Pos",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pos",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:T-39-",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "T'",
        "fct-source": "src/Algorithm-Cooper-Core.html#QFFormula",
        "fct-type": "function",
        "title": "T'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "T'",
        "normalized": "",
        "package": "toysolver",
        "partial": "T'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:eliminateQuantifiers",
      "description": {
        "fct-descr": "\u003cp\u003eeliminate quantifiers and returns equivalent quantifier-free formula.\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Formula (Atom Rational) -\u003e Maybe QFFormula",
        "fct-source": "src/Algorithm-Cooper-FOL.html#eliminateQuantifiers",
        "fct-type": "function",
        "title": "eliminateQuantifiers"
      },
      "index": {
        "description": "eliminate quantifiers and returns equivalent quantifier-free formula",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "eliminateQuantifiers",
        "normalized": "Formula(Atom Rational)-\u003eMaybe QFFormula",
        "package": "toysolver",
        "partial": "Quantifiers",
        "signature": "Formula(Atom Rational)-\u003eMaybe QFFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:fromLAAtom",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Atom Rational -\u003e QFFormula",
        "fct-source": "src/Algorithm-Cooper-Core.html#fromLAAtom",
        "fct-type": "function",
        "title": "fromLAAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "fromLAAtom",
        "normalized": "Atom Rational-\u003eQFFormula",
        "package": "toysolver",
        "partial": "LAAtom",
        "signature": "Atom Rational-\u003eQFFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:project",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e QFFormula -\u003e (QFFormula, Model Integer -\u003e Model Integer)",
        "fct-source": "src/Algorithm-Cooper-Core.html#project",
        "fct-type": "function",
        "title": "project"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "project",
        "normalized": "Var-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eQFFormula-\u003e(QFFormula,Model Integer-\u003eModel Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:projectCases",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e QFFormula -\u003e [(QFFormula, Model Integer -\u003e Model Integer)]",
        "fct-source": "src/Algorithm-Cooper-Core.html#projectCases",
        "fct-type": "function",
        "title": "projectCases"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "projectCases",
        "normalized": "Var-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]",
        "package": "toysolver",
        "partial": "Cases",
        "signature": "Var-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:projectCasesN",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e QFFormula -\u003e [(QFFormula, Model Integer -\u003e Model Integer)]",
        "fct-source": "src/Algorithm-Cooper-Core.html#projectCasesN",
        "fct-type": "function",
        "title": "projectCasesN"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "projectCasesN",
        "normalized": "VarSet-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]",
        "package": "toysolver",
        "partial": "Cases",
        "signature": "VarSet-\u003eQFFormula-\u003e[(QFFormula,Model Integer-\u003eModel Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:solve",
      "description": {
        "fct-descr": "\u003cp\u003esolve a (open) quantifier-free formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Maybe (Model Integer)",
        "fct-source": "src/Algorithm-Cooper-Core.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "solve open quantifier-free formula",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "solve",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:solveFormula",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e Formula (Atom Rational) -\u003e SatResult Integer",
        "fct-source": "src/Algorithm-Cooper-FOL.html#solveFormula",
        "fct-type": "function",
        "title": "solveFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "solveFormula",
        "normalized": "VarSet-\u003eFormula(Atom Rational)-\u003eSatResult Integer",
        "package": "toysolver",
        "partial": "Formula",
        "signature": "VarSet-\u003eFormula(Atom Rational)-\u003eSatResult Integer"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:solveQFFormula",
      "description": {
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e QFFormula -\u003e Maybe (Model Integer)",
        "fct-source": "src/Algorithm-Cooper-Core.html#solveQFFormula",
        "fct-type": "function",
        "title": "solveQFFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "solveQFFormula",
        "normalized": "VarSet-\u003eQFFormula-\u003eMaybe(Model Integer)",
        "package": "toysolver",
        "partial": "QFFormula",
        "signature": "VarSet-\u003eQFFormula-\u003eMaybe(Model Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Cooper.html#v:solveQFLA",
      "description": {
        "fct-descr": "\u003cp\u003esolve a (open) quantifier-free formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Cooper",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e VarSet -\u003e Maybe (Model Rational)",
        "fct-source": "src/Algorithm-Cooper-Core.html#solveQFLA",
        "fct-type": "function",
        "title": "solveQFLA"
      },
      "index": {
        "description": "solve open quantifier-free formula",
        "hierarchy": "Algorithm Cooper",
        "module": "Algorithm.Cooper",
        "name": "solveQFLA",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)",
        "package": "toysolver",
        "partial": "QFLA",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple model finder.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Koen Claessen and Niklas S&#246;rensson.\n   New Techniques that Improve MACE-style Finite Model Finding.\n   CADE-19. 2003.\n   \u003ca\u003ehttp://www.cs.miami.edu/~geoff/Conferences/CADE/Archive/CADE-19/WS4/04.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-FOLModelFinder.html",
        "fct-type": "module",
        "title": "FOLModelFinder"
      },
      "index": {
        "description": "simple model finder References Koen Claessen and Niklas rensson New Techniques that Improve MACE-style Finite Model Finding CADE-19 http www.cs.miami.edu geoff Conferences CADE Archive CADE-19 WS4 pdf",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "FOLModelFinder",
        "normalized": "",
        "package": "toysolver",
        "partial": "FOLModel Finder",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Atom",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Atom",
        "fct-type": "data",
        "title": "Atom"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Atom",
        "normalized": "",
        "package": "toysolver",
        "partial": "Atom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Clause",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Clause",
        "fct-type": "type",
        "title": "Clause"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Clause",
        "normalized": "",
        "package": "toysolver",
        "partial": "Clause",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Entity",
      "description": {
        "fct-descr": "\u003cp\u003eElement of model.\n\u003c/p\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Entity",
        "fct-type": "type",
        "title": "Entity"
      },
      "index": {
        "description": "Element of model",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Entity",
        "normalized": "",
        "package": "toysolver",
        "partial": "Entity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:FSym",
      "description": {
        "fct-descr": "\u003cp\u003eFunction Symbol\n\u003c/p\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FOLModelFinder.html#FSym",
        "fct-type": "type",
        "title": "FSym"
      },
      "index": {
        "description": "Function Symbol",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "FSym",
        "normalized": "",
        "package": "toysolver",
        "partial": "FSym",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Formula",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Formula",
        "fct-type": "type",
        "title": "Formula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Formula",
        "normalized": "",
        "package": "toysolver",
        "partial": "Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:GenFormula",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "data",
        "title": "GenFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "GenFormula",
        "normalized": "",
        "package": "toysolver",
        "partial": "Gen Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:GenLit",
      "description": {
        "fct-descr": "\u003cp\u003eGeneralized literal type parameterized by atom type\n\u003c/p\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenLit",
        "fct-type": "data",
        "title": "GenLit"
      },
      "index": {
        "description": "Generalized literal type parameterized by atom type",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "GenLit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Gen Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Lit",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Lit",
        "fct-type": "type",
        "title": "Lit"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Model",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Model",
        "fct-type": "data",
        "title": "Model"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:PSym",
      "description": {
        "fct-descr": "\u003cp\u003ePredicate Symbol\n\u003c/p\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FOLModelFinder.html#PSym",
        "fct-type": "type",
        "title": "PSym"
      },
      "index": {
        "description": "Predicate Symbol",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "PSym",
        "normalized": "",
        "package": "toysolver",
        "partial": "PSym",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Term",
      "description": {
        "fct-descr": "\u003cp\u003eTerm\n\u003c/p\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Term",
        "fct-type": "data",
        "title": "Term"
      },
      "index": {
        "description": "Term",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Term",
        "normalized": "",
        "package": "toysolver",
        "partial": "Term",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#t:Var",
      "description": {
        "fct-descr": "\u003cp\u003eVariable\n\u003c/p\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "Variable",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:And",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "And (GenFormula a) (GenFormula a)",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "And"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "And",
        "normalized": "",
        "package": "toysolver",
        "partial": "And",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Atom",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Atom a",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "Atom"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Atom",
        "normalized": "",
        "package": "toysolver",
        "partial": "Atom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Equiv",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Equiv (GenFormula a) (GenFormula a)",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "Equiv"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Equiv",
        "normalized": "",
        "package": "toysolver",
        "partial": "Equiv",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Exists",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Exists Var (GenFormula a)",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "Exists"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Exists",
        "normalized": "",
        "package": "toysolver",
        "partial": "Exists",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:F",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "F",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "F"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "F",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Forall",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Forall Var (GenFormula a)",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "Forall"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Forall",
        "normalized": "",
        "package": "toysolver",
        "partial": "Forall",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Imply",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Imply (GenFormula a) (GenFormula a)",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "Imply"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Imply",
        "normalized": "",
        "package": "toysolver",
        "partial": "Imply",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Model",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Model",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Model",
        "fct-type": "function",
        "title": "Model"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Neg",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Neg a",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenLit",
        "fct-type": "function",
        "title": "Neg"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Neg",
        "normalized": "",
        "package": "toysolver",
        "partial": "Neg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Not",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Not (GenFormula a)",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "Not"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Not",
        "normalized": "",
        "package": "toysolver",
        "partial": "Not",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Or",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Or (GenFormula a) (GenFormula a)",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "Or"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Or",
        "normalized": "",
        "package": "toysolver",
        "partial": "Or",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:PApp",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "PApp PSym [Term]",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Atom",
        "fct-type": "function",
        "title": "PApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "PApp",
        "normalized": "PApp PSym[Term]",
        "package": "toysolver",
        "partial": "PApp",
        "signature": "PApp PSym[Term]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:Pos",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Pos a",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenLit",
        "fct-type": "function",
        "title": "Pos"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "Pos",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pos",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:T",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "T",
        "fct-source": "src/Algorithm-FOLModelFinder.html#GenFormula",
        "fct-type": "function",
        "title": "T"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "T",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:TmApp",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "TmApp FSym [Term]",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Term",
        "fct-type": "function",
        "title": "TmApp"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "TmApp",
        "normalized": "TmApp FSym[Term]",
        "package": "toysolver",
        "partial": "Tm App",
        "signature": "TmApp FSym[Term]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:TmVar",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "TmVar Var",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Term",
        "fct-type": "function",
        "title": "TmVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "TmVar",
        "normalized": "",
        "package": "toysolver",
        "partial": "Tm Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:findModel",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Int -\u003e [Clause] -\u003e IO (Maybe Model)",
        "fct-source": "src/Algorithm-FOLModelFinder.html#findModel",
        "fct-type": "function",
        "title": "findModel"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "findModel",
        "normalized": "Int-\u003e[Clause]-\u003eIO(Maybe Model)",
        "package": "toysolver",
        "partial": "Model",
        "signature": "Int-\u003e[Clause]-\u003eIO(Maybe Model)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:mFunctions",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Map FSym [([Entity], Entity)]",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Model",
        "fct-type": "function",
        "title": "mFunctions"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "mFunctions",
        "normalized": "Map FSym[([Entity],Entity)]",
        "package": "toysolver",
        "partial": "Functions",
        "signature": "Map FSym[([Entity],Entity)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:mRelations",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Map PSym [[Entity]]",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Model",
        "fct-type": "function",
        "title": "mRelations"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "mRelations",
        "normalized": "Map PSym[[Entity]]",
        "package": "toysolver",
        "partial": "Relations",
        "signature": "Map PSym[[Entity]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:mUniverse",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "[Entity]",
        "fct-source": "src/Algorithm-FOLModelFinder.html#Model",
        "fct-type": "function",
        "title": "mUniverse"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "mUniverse",
        "normalized": "[Entity]",
        "package": "toysolver",
        "partial": "Universe",
        "signature": "[Entity]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:showEntity",
      "description": {
        "fct-descr": "\u003cp\u003eprint entity\n\u003c/p\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Entity -\u003e String",
        "fct-source": "src/Algorithm-FOLModelFinder.html#showEntity",
        "fct-type": "function",
        "title": "showEntity"
      },
      "index": {
        "description": "print entity",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "showEntity",
        "normalized": "Entity-\u003eString",
        "package": "toysolver",
        "partial": "Entity",
        "signature": "Entity-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:showModel",
      "description": {
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "Model -\u003e [String]",
        "fct-source": "src/Algorithm-FOLModelFinder.html#showModel",
        "fct-type": "function",
        "title": "showModel"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "showModel",
        "normalized": "Model-\u003e[String]",
        "package": "toysolver",
        "partial": "Model",
        "signature": "Model-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FOLModelFinder.html#v:toSkolemNF",
      "description": {
        "fct-descr": "\u003cp\u003enormalize a formula into a skolem normal form.\n\u003c/p\u003e\u003cp\u003eTODO:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Tseitin encoding\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "Algorithm.FOLModelFinder",
        "fct-package": "toysolver",
        "fct-signature": "(String -\u003e Int -\u003e m FSym) -\u003e Formula -\u003e m [Clause]",
        "fct-source": "src/Algorithm-FOLModelFinder.html#toSkolemNF",
        "fct-type": "function",
        "title": "toSkolemNF"
      },
      "index": {
        "description": "normalize formula into skolem normal form TODO Tseitin encoding",
        "hierarchy": "Algorithm FOLModelFinder",
        "module": "Algorithm.FOLModelFinder",
        "name": "toSkolemNF",
        "normalized": "(String-\u003eInt-\u003ea FSym)-\u003eFormula-\u003ea[Clause]",
        "package": "toysolver",
        "partial": "Skolem NF",
        "signature": "(String-\u003eInt-\u003em FSym)-\u003eFormula-\u003em[Clause]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Fourier-Motzkin Variable Elimination\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html",
        "fct-type": "module",
        "title": "Core"
      },
      "index": {
        "description": "Na ve implementation of Fourier-Motzkin Variable Elimination Reference http users.cecs.anu.edu.au michaeln pubs arithmetic-dps.pdf",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "Core",
        "normalized": "",
        "package": "toysolver",
        "partial": "Core",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#t:ExprZ",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#ExprZ",
        "fct-type": "type",
        "title": "ExprZ"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "ExprZ",
        "normalized": "",
        "package": "toysolver",
        "partial": "Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#t:Lit",
      "description": {
        "fct-descr": "\u003cp\u003eLiteral\n\u003c/p\u003e",
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
        "fct-type": "data",
        "title": "Lit"
      },
      "index": {
        "description": "Literal",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#t:Rat",
      "description": {
        "fct-descr": "\u003cp\u003e(t,c) represents t/c, and c must be \u003e0.\n\u003c/p\u003e",
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#Rat",
        "fct-type": "type",
        "title": "Rat"
      },
      "index": {
        "description": "represents and must be",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "Rat",
        "normalized": "",
        "package": "toysolver",
        "partial": "Rat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:Nonneg",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "Nonneg ExprZ",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
        "fct-type": "function",
        "title": "Nonneg"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "Nonneg",
        "normalized": "",
        "package": "toysolver",
        "partial": "Nonneg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:Pos",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "Pos ExprZ",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
        "fct-type": "function",
        "title": "Pos"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "Pos",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pos",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:fromLAAtom",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "Atom Rational -\u003e DNF Lit",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#fromLAAtom",
        "fct-type": "function",
        "title": "fromLAAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "fromLAAtom",
        "normalized": "Atom Rational-\u003eDNF Lit",
        "package": "toysolver",
        "partial": "LAAtom",
        "signature": "Atom Rational-\u003eDNF Lit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:fromRat",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "Rat -\u003e Expr Rational",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#fromRat",
        "fct-type": "function",
        "title": "fromRat"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "fromRat",
        "normalized": "Rat-\u003eExpr Rational",
        "package": "toysolver",
        "partial": "Rat",
        "signature": "Rat-\u003eExpr Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:project",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e [Atom Rational] -\u003e [([Atom Rational], Model Rational -\u003e Model Rational)]",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#project",
        "fct-type": "function",
        "title": "project"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "project",
        "normalized": "Var-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:project-39-",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e [Lit] -\u003e [([Lit], Model Rational -\u003e Model Rational)]",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#project%27",
        "fct-type": "function",
        "title": "project'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "project'",
        "normalized": "Var-\u003e[Lit]-\u003e[([Lit],Model Rational-\u003eModel Rational)]",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003e[Lit]-\u003e[([Lit],Model Rational-\u003eModel Rational)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:projectN",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e [([Atom Rational], Model Rational -\u003e Model Rational)]",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#projectN",
        "fct-type": "function",
        "title": "projectN"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "projectN",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]",
        "package": "toysolver",
        "partial": "",
        "signature": "VarSet-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:projectN-39-",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Lit] -\u003e [([Lit], Model Rational -\u003e Model Rational)]",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#projectN%27",
        "fct-type": "function",
        "title": "projectN'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "projectN'",
        "normalized": "VarSet-\u003e[Lit]-\u003e[([Lit],Model Rational-\u003eModel Rational)]",
        "package": "toysolver",
        "partial": "N'",
        "signature": "VarSet-\u003e[Lit]-\u003e[([Lit],Model Rational-\u003eModel Rational)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:solve",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Maybe (Model Rational)",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "solve",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Rational)",
        "package": "toysolver",
        "partial": "",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:solve-39-",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Lit] -\u003e Maybe (Model Rational)",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#solve%27",
        "fct-type": "function",
        "title": "solve'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "solve'",
        "normalized": "VarSet-\u003e[Lit]-\u003eMaybe(Model Rational)",
        "package": "toysolver",
        "partial": "",
        "signature": "VarSet-\u003e[Lit]-\u003eMaybe(Model Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:toLAAtom",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e Atom Rational",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#toLAAtom",
        "fct-type": "function",
        "title": "toLAAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "toLAAtom",
        "normalized": "Lit-\u003eAtom Rational",
        "package": "toysolver",
        "partial": "LAAtom",
        "signature": "Lit-\u003eAtom Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-Core.html#v:toRat",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.Core",
        "fct-package": "toysolver",
        "fct-signature": "Expr Rational -\u003e Rat",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#toRat",
        "fct-type": "function",
        "title": "toRat"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin Core",
        "module": "Algorithm.FourierMotzkin.Core",
        "name": "toRat",
        "normalized": "Expr Rational-\u003eRat",
        "package": "toysolver",
        "partial": "Rat",
        "signature": "Expr Rational-\u003eRat"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.FOL",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-FourierMotzkin-FOL.html",
        "fct-type": "module",
        "title": "FOL"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin FOL",
        "module": "Algorithm.FourierMotzkin.FOL",
        "name": "FOL",
        "normalized": "",
        "package": "toysolver",
        "partial": "FOL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#v:eliminateQuantifiers",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.FOL",
        "fct-package": "toysolver",
        "fct-signature": "Formula (Atom Rational) -\u003e Maybe (Formula (Atom Rational))",
        "fct-source": "src/Algorithm-FourierMotzkin-FOL.html#eliminateQuantifiers",
        "fct-type": "function",
        "title": "eliminateQuantifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin FOL",
        "module": "Algorithm.FourierMotzkin.FOL",
        "name": "eliminateQuantifiers",
        "normalized": "Formula(Atom Rational)-\u003eMaybe(Formula(Atom Rational))",
        "package": "toysolver",
        "partial": "Quantifiers",
        "signature": "Formula(Atom Rational)-\u003eMaybe(Formula(Atom Rational))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#v:eliminateQuantifiers-39-",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.FOL",
        "fct-package": "toysolver",
        "fct-signature": "Formula (Atom Rational) -\u003e Maybe (DNF Lit)",
        "fct-source": "src/Algorithm-FourierMotzkin-FOL.html#eliminateQuantifiers%27",
        "fct-type": "function",
        "title": "eliminateQuantifiers'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin FOL",
        "module": "Algorithm.FourierMotzkin.FOL",
        "name": "eliminateQuantifiers'",
        "normalized": "Formula(Atom Rational)-\u003eMaybe(DNF Lit)",
        "package": "toysolver",
        "partial": "Quantifiers'",
        "signature": "Formula(Atom Rational)-\u003eMaybe(DNF Lit)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin-FOL.html#v:solveFormula",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin.FOL",
        "fct-package": "toysolver",
        "fct-signature": "[Var] -\u003e Formula (Atom Rational) -\u003e SatResult Rational",
        "fct-source": "src/Algorithm-FourierMotzkin-FOL.html#solveFormula",
        "fct-type": "function",
        "title": "solveFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin FOL",
        "module": "Algorithm.FourierMotzkin.FOL",
        "name": "solveFormula",
        "normalized": "[Var]-\u003eFormula(Atom Rational)-\u003eSatResult Rational",
        "package": "toysolver",
        "partial": "Formula",
        "signature": "[Var]-\u003eFormula(Atom Rational)-\u003eSatResult Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Fourier-Motzkin Variable Elimination\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-FourierMotzkin.html",
        "fct-type": "module",
        "title": "FourierMotzkin"
      },
      "index": {
        "description": "Na ve implementation of Fourier-Motzkin Variable Elimination Reference http users.cecs.anu.edu.au michaeln pubs arithmetic-dps.pdf",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "FourierMotzkin",
        "normalized": "",
        "package": "toysolver",
        "partial": "Fourier Motzkin",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#t:Lit",
      "description": {
        "fct-descr": "\u003cp\u003eLiteral\n\u003c/p\u003e",
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
        "fct-type": "data",
        "title": "Lit"
      },
      "index": {
        "description": "Literal",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:Nonneg",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "Nonneg ExprZ",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
        "fct-type": "function",
        "title": "Nonneg"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "Nonneg",
        "normalized": "",
        "package": "toysolver",
        "partial": "Nonneg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:Pos",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "Pos ExprZ",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#Lit",
        "fct-type": "function",
        "title": "Pos"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "Pos",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pos",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:eliminateQuantifiers",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "Formula (Atom Rational) -\u003e Maybe (Formula (Atom Rational))",
        "fct-source": "src/Algorithm-FourierMotzkin-FOL.html#eliminateQuantifiers",
        "fct-type": "function",
        "title": "eliminateQuantifiers"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "eliminateQuantifiers",
        "normalized": "Formula(Atom Rational)-\u003eMaybe(Formula(Atom Rational))",
        "package": "toysolver",
        "partial": "Quantifiers",
        "signature": "Formula(Atom Rational)-\u003eMaybe(Formula(Atom Rational))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:project",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e [Atom Rational] -\u003e [([Atom Rational], Model Rational -\u003e Model Rational)]",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#project",
        "fct-type": "function",
        "title": "project"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "project",
        "normalized": "Var-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:projectN",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e [([Atom Rational], Model Rational -\u003e Model Rational)]",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#projectN",
        "fct-type": "function",
        "title": "projectN"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "projectN",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]",
        "package": "toysolver",
        "partial": "",
        "signature": "VarSet-\u003e[Atom Rational]-\u003e[([Atom Rational],Model Rational-\u003eModel Rational)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:solve",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Maybe (Model Rational)",
        "fct-source": "src/Algorithm-FourierMotzkin-Core.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "solve",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Rational)",
        "package": "toysolver",
        "partial": "",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eMaybe(Model Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-FourierMotzkin.html#v:solveFormula",
      "description": {
        "fct-module": "Algorithm.FourierMotzkin",
        "fct-package": "toysolver",
        "fct-signature": "[Var] -\u003e Formula (Atom Rational) -\u003e SatResult Rational",
        "fct-source": "src/Algorithm-FourierMotzkin-FOL.html#solveFormula",
        "fct-type": "function",
        "title": "solveFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm FourierMotzkin",
        "module": "Algorithm.FourierMotzkin",
        "name": "solveFormula",
        "normalized": "[Var]-\u003eFormula(Atom Rational)-\u003eSatResult Rational",
        "package": "toysolver",
        "partial": "Formula",
        "signature": "[Var]-\u003eFormula(Atom Rational)-\u003eSatResult Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Simplex method\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.cuhk.edu.hk/~wei/lpch3.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-LPSolver.html",
        "fct-type": "module",
        "title": "LPSolver"
      },
      "index": {
        "description": "Na ve implementation of Simplex method Reference http www.math.cuhk.edu.hk wei lpch3.pdf",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "LPSolver",
        "normalized": "",
        "package": "toysolver",
        "partial": "LPSolver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#t:LP",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-LPSolver.html#LP",
        "fct-type": "type",
        "title": "LP"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "LP",
        "normalized": "",
        "package": "toysolver",
        "partial": "LP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#t:Solver",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-LPSolver.html#Solver",
        "fct-type": "type",
        "title": "Solver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "Solver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:addArtificialVariable",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e LP r ()",
        "fct-source": "src/Algorithm-LPSolver.html#addArtificialVariable",
        "fct-type": "function",
        "title": "addArtificialVariable"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "addArtificialVariable",
        "normalized": "Var-\u003eLP a()",
        "package": "toysolver",
        "partial": "Artificial Variable",
        "signature": "Var-\u003eLP r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:addConstraint",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "Atom r -\u003e LP r ()",
        "fct-source": "src/Algorithm-LPSolver.html#addConstraint",
        "fct-type": "function",
        "title": "addConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "addConstraint",
        "normalized": "Atom a-\u003eLP a()",
        "package": "toysolver",
        "partial": "Constraint",
        "signature": "Atom r-\u003eLP r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:addConstraint2",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "Atom r -\u003e LP r ()",
        "fct-source": "src/Algorithm-LPSolver.html#addConstraint2",
        "fct-type": "function",
        "title": "addConstraint2"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "addConstraint2",
        "normalized": "Atom a-\u003eLP a()",
        "package": "toysolver",
        "partial": "Constraint",
        "signature": "Atom r-\u003eLP r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:clearArtificialVariables",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "LP r ()",
        "fct-source": "src/Algorithm-LPSolver.html#clearArtificialVariables",
        "fct-type": "function",
        "title": "clearArtificialVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "clearArtificialVariables",
        "normalized": "LP a()",
        "package": "toysolver",
        "partial": "Artificial Variables",
        "signature": "LP r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:collectNonnegVars",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "[Atom r] -\u003e VarSet -\u003e (VarSet, [Atom r])",
        "fct-source": "src/Algorithm-LPSolver.html#collectNonnegVars",
        "fct-type": "function",
        "title": "collectNonnegVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "collectNonnegVars",
        "normalized": "[Atom a]-\u003eVarSet-\u003e(VarSet,[Atom a])",
        "package": "toysolver",
        "partial": "Nonneg Vars",
        "signature": "[Atom r]-\u003eVarSet-\u003e(VarSet,[Atom r])"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:define",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Expr r -\u003e LP r ()",
        "fct-source": "src/Algorithm-LPSolver.html#define",
        "fct-type": "function",
        "title": "define"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "define",
        "normalized": "Var-\u003eExpr a-\u003eLP a()",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eExpr r-\u003eLP r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:dualSimplex",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "OptDir -\u003e Expr r -\u003e LP r Bool",
        "fct-source": "src/Algorithm-LPSolver.html#dualSimplex",
        "fct-type": "function",
        "title": "dualSimplex"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "dualSimplex",
        "normalized": "OptDir-\u003eExpr a-\u003eLP a Bool",
        "package": "toysolver",
        "partial": "Simplex",
        "signature": "OptDir-\u003eExpr r-\u003eLP r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:emptySolver",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e Solver r",
        "fct-source": "src/Algorithm-LPSolver.html#emptySolver",
        "fct-type": "function",
        "title": "emptySolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "emptySolver",
        "normalized": "VarSet-\u003eSolver a",
        "package": "toysolver",
        "partial": "Solver",
        "signature": "VarSet-\u003eSolver r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:expandDefs",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e LP r (Expr r)",
        "fct-source": "src/Algorithm-LPSolver.html#expandDefs",
        "fct-type": "function",
        "title": "expandDefs"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "expandDefs",
        "normalized": "Expr a-\u003eLP a(Expr a)",
        "package": "toysolver",
        "partial": "Defs",
        "signature": "Expr r-\u003eLP r(Expr r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:expandDefs-39-",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "Atom r -\u003e LP r (Atom r)",
        "fct-source": "src/Algorithm-LPSolver.html#expandDefs%27",
        "fct-type": "function",
        "title": "expandDefs'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "expandDefs'",
        "normalized": "Atom a-\u003eLP a(Atom a)",
        "package": "toysolver",
        "partial": "Defs'",
        "signature": "Atom r-\u003eLP r(Atom r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:gensym",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "LP r Var",
        "fct-source": "src/Algorithm-LPSolver.html#gensym",
        "fct-type": "function",
        "title": "gensym"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "gensym",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:getArtificialVariables",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "LP r VarSet",
        "fct-source": "src/Algorithm-LPSolver.html#getArtificialVariables",
        "fct-type": "function",
        "title": "getArtificialVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "getArtificialVariables",
        "normalized": "",
        "package": "toysolver",
        "partial": "Artificial Variables",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:getDefs",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "LP r (VarMap (Expr r))",
        "fct-source": "src/Algorithm-LPSolver.html#getDefs",
        "fct-type": "function",
        "title": "getDefs"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "getDefs",
        "normalized": "",
        "package": "toysolver",
        "partial": "Defs",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:getModel",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e LP r (Model r)",
        "fct-source": "src/Algorithm-LPSolver.html#getModel",
        "fct-type": "function",
        "title": "getModel"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "getModel",
        "normalized": "VarSet-\u003eLP a(Model a)",
        "package": "toysolver",
        "partial": "Model",
        "signature": "VarSet-\u003eLP r(Model r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:getTableau",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "LP r (Tableau r)",
        "fct-source": "src/Algorithm-LPSolver.html#getTableau",
        "fct-type": "function",
        "title": "getTableau"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "getTableau",
        "normalized": "",
        "package": "toysolver",
        "partial": "Tableau",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:normalizeConstraint",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "Atom r -\u003e (Expr r, RelOp, r)",
        "fct-source": "src/Algorithm-LPSolver.html#normalizeConstraint",
        "fct-type": "function",
        "title": "normalizeConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "normalizeConstraint",
        "normalized": "Atom a-\u003e(Expr a,RelOp,a)",
        "package": "toysolver",
        "partial": "Constraint",
        "signature": "Atom r-\u003e(Expr r,RelOp,r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:phaseI",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "LP r Bool",
        "fct-source": "src/Algorithm-LPSolver.html#phaseI",
        "fct-type": "function",
        "title": "phaseI"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "phaseI",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:putTableau",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "Tableau r -\u003e LP r ()",
        "fct-source": "src/Algorithm-LPSolver.html#putTableau",
        "fct-type": "function",
        "title": "putTableau"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "putTableau",
        "normalized": "Tableau a-\u003eLP a()",
        "package": "toysolver",
        "partial": "Tableau",
        "signature": "Tableau r-\u003eLP r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:simplex",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "OptDir -\u003e Expr r -\u003e LP r Bool",
        "fct-source": "src/Algorithm-LPSolver.html#simplex",
        "fct-type": "function",
        "title": "simplex"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "simplex",
        "normalized": "OptDir-\u003eExpr a-\u003eLP a Bool",
        "package": "toysolver",
        "partial": "",
        "signature": "OptDir-\u003eExpr r-\u003eLP r Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolver.html#v:tableau",
      "description": {
        "fct-module": "Algorithm.LPSolver",
        "fct-package": "toysolver",
        "fct-signature": "[Atom r] -\u003e LP r ()",
        "fct-source": "src/Algorithm-LPSolver.html#tableau",
        "fct-type": "function",
        "title": "tableau"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolver",
        "module": "Algorithm.LPSolver",
        "name": "tableau",
        "normalized": "[Atom a]-\u003eLP a()",
        "package": "toysolver",
        "partial": "",
        "signature": "[Atom r]-\u003eLP r()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHigh-Level API for LPSolver.hs\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-LPSolverHL.html",
        "fct-type": "module",
        "title": "LPSolverHL"
      },
      "index": {
        "description": "High-Level API for LPSolver.hs",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "LPSolverHL",
        "normalized": "",
        "package": "toysolver",
        "partial": "LPSolver HL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#t:OptResult",
      "description": {
        "fct-descr": "\u003cp\u003eresults of optimization\n\u003c/p\u003e",
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-LPSolverHL.html#OptResult",
        "fct-type": "data",
        "title": "OptResult"
      },
      "index": {
        "description": "results of optimization",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "OptResult",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:OptUnsat",
      "description": {
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "OptUnsat",
        "fct-source": "src/Algorithm-LPSolverHL.html#OptResult",
        "fct-type": "function",
        "title": "OptUnsat"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "OptUnsat",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Unsat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:Optimum",
      "description": {
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "Optimum r (Model r)",
        "fct-source": "src/Algorithm-LPSolverHL.html#OptResult",
        "fct-type": "function",
        "title": "Optimum"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "Optimum",
        "normalized": "",
        "package": "toysolver",
        "partial": "Optimum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:Unbounded",
      "description": {
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "Unbounded",
        "fct-source": "src/Algorithm-LPSolverHL.html#OptResult",
        "fct-type": "function",
        "title": "Unbounded"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "Unbounded",
        "normalized": "",
        "package": "toysolver",
        "partial": "Unbounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:maximize",
      "description": {
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e [Atom r] -\u003e OptResult r",
        "fct-source": "src/Algorithm-LPSolverHL.html#maximize",
        "fct-type": "function",
        "title": "maximize"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "maximize",
        "normalized": "Expr a-\u003e[Atom a]-\u003eOptResult a",
        "package": "toysolver",
        "partial": "",
        "signature": "Expr r-\u003e[Atom r]-\u003eOptResult r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:minimize",
      "description": {
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e [Atom r] -\u003e OptResult r",
        "fct-source": "src/Algorithm-LPSolverHL.html#minimize",
        "fct-type": "function",
        "title": "minimize"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "minimize",
        "normalized": "Expr a-\u003e[Atom a]-\u003eOptResult a",
        "package": "toysolver",
        "partial": "",
        "signature": "Expr r-\u003e[Atom r]-\u003eOptResult r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:optimize",
      "description": {
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "OptDir -\u003e Expr r -\u003e [Atom r] -\u003e OptResult r",
        "fct-source": "src/Algorithm-LPSolverHL.html#optimize",
        "fct-type": "function",
        "title": "optimize"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "optimize",
        "normalized": "OptDir-\u003eExpr a-\u003e[Atom a]-\u003eOptResult a",
        "package": "toysolver",
        "partial": "",
        "signature": "OptDir-\u003eExpr r-\u003e[Atom r]-\u003eOptResult r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPSolverHL.html#v:solve",
      "description": {
        "fct-module": "Algorithm.LPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "[Atom r] -\u003e Maybe (Model r)",
        "fct-source": "src/Algorithm-LPSolverHL.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPSolverHL",
        "module": "Algorithm.LPSolverHL",
        "name": "solve",
        "normalized": "[Atom a]-\u003eMaybe(Model a)",
        "package": "toysolver",
        "partial": "",
        "signature": "[Atom r]-\u003eMaybe(Model r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPUtil.html#",
      "description": {
        "fct-module": "Algorithm.LPUtil",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-LPUtil.html",
        "fct-type": "module",
        "title": "LPUtil"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPUtil",
        "module": "Algorithm.LPUtil",
        "name": "LPUtil",
        "normalized": "",
        "package": "toysolver",
        "partial": "LPUtil",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPUtil.html#v:toStandardForm",
      "description": {
        "fct-module": "Algorithm.LPUtil",
        "fct-package": "toysolver",
        "fct-signature": "(Expr Rational, [Rel (Expr Rational)]) -\u003e ((Expr Rational, [(Expr Rational, Rational)]), Model Rational -\u003e Model Rational)",
        "fct-source": "src/Algorithm-LPUtil.html#toStandardForm",
        "fct-type": "function",
        "title": "toStandardForm"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPUtil",
        "module": "Algorithm.LPUtil",
        "name": "toStandardForm",
        "normalized": "(Expr Rational,[Rel(Expr Rational)])-\u003e((Expr Rational,[(Expr Rational,Rational)]),Model Rational-\u003eModel Rational)",
        "package": "toysolver",
        "partial": "Standard Form",
        "signature": "(Expr Rational,[Rel(Expr Rational)])-\u003e((Expr Rational,[(Expr Rational,Rational)]),Model Rational-\u003eModel Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-LPUtil.html#v:toStandardForm-39-",
      "description": {
        "fct-module": "Algorithm.LPUtil",
        "fct-package": "toysolver",
        "fct-signature": "(Expr Rational, [Rel (Expr Rational)]) -\u003e ((Expr Rational, [(Expr Rational, Rational)]), VarMap (Expr Rational))",
        "fct-source": "src/Algorithm-LPUtil.html#toStandardForm%27",
        "fct-type": "function",
        "title": "toStandardForm'"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm LPUtil",
        "module": "Algorithm.LPUtil",
        "name": "toStandardForm'",
        "normalized": "(Expr Rational,[Rel(Expr Rational)])-\u003e((Expr Rational,[(Expr Rational,Rational)]),VarMap(Expr Rational))",
        "package": "toysolver",
        "partial": "Standard Form'",
        "signature": "(Expr Rational,[Rel(Expr Rational)])-\u003e((Expr Rational,[(Expr Rational,Rational)]),VarMap(Expr Rational))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of MIP solver based on Simplex2 module\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.cuhk.edu.hk/~wei/lpch3.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Ralph E. Gomory.\n   \"An Algorithm for the Mixed Integer Problem\", Technical Report\n   RM-2597, 1960, The Rand Corporation, Santa Monica, CA.\n   \u003ca\u003ehttp://www.rand.org/pubs/research_memoranda/RM2597.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Ralph E. Gomory.\n   \"Outline of an algorithm for integer solutions to linear programs\".\n   Bull. Amer. Math. Soc., Vol. 64, No. 5. (1958), pp. 275-278.\n   \u003ca\u003ehttp://projecteuclid.org/euclid.bams/1183522679\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e R. C. Daniel and Martyn Jeffreys.\n   \"Unboundedness in Integer and Discrete Programming L.P. Relaxations\"\n   The Journal of the Operational Research Society, Vol. 30, No. 12. (1979)\n   \u003ca\u003ehttp://www.jstor.org/stable/3009435\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-MIPSolver2.html",
        "fct-type": "module",
        "title": "MIPSolver2"
      },
      "index": {
        "description": "Na ve implementation of MIP solver based on Simplex2 module Reference http www.math.cuhk.edu.hk wei lpch3.pdf Ralph Gomory An Algorithm for the Mixed Integer Problem Technical Report RM-2597 The Rand Corporation Santa Monica CA http www.rand.org pubs research memoranda RM2597.html Ralph Gomory Outline of an algorithm for integer solutions to linear programs Bull Amer Math Soc Vol No pp http projecteuclid.org euclid.bams Daniel and Martyn Jeffreys Unboundedness in Integer and Discrete Programming L.P Relaxations The Journal of the Operational Research Society Vol No http www.jstor.org stable",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "MIPSolver2",
        "normalized": "",
        "package": "toysolver",
        "partial": "MIPSolver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#t:Solver",
      "description": {
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-MIPSolver2.html#Solver",
        "fct-type": "data",
        "title": "Solver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "Solver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:getObjValue",
      "description": {
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Rational",
        "fct-source": "src/Algorithm-MIPSolver2.html#getObjValue",
        "fct-type": "function",
        "title": "getObjValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "getObjValue",
        "normalized": "Solver-\u003eIO Rational",
        "package": "toysolver",
        "partial": "Obj Value",
        "signature": "Solver-\u003eIO Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:model",
      "description": {
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Model",
        "fct-source": "src/Algorithm-MIPSolver2.html#model",
        "fct-type": "function",
        "title": "model"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "model",
        "normalized": "Solver-\u003eIO Model",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003eIO Model"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:newSolver",
      "description": {
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IntSet -\u003e IO Solver",
        "fct-source": "src/Algorithm-MIPSolver2.html#newSolver",
        "fct-type": "function",
        "title": "newSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "newSolver",
        "normalized": "Solver-\u003eIntSet-\u003eIO Solver",
        "package": "toysolver",
        "partial": "Solver",
        "signature": "Solver-\u003eIntSet-\u003eIO Solver"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:optimize",
      "description": {
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e (Model -\u003e Rational -\u003e IO ()) -\u003e IO OptResult",
        "fct-source": "src/Algorithm-MIPSolver2.html#optimize",
        "fct-type": "function",
        "title": "optimize"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "optimize",
        "normalized": "Solver-\u003e(Model-\u003eRational-\u003eIO())-\u003eIO OptResult",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003e(Model-\u003eRational-\u003eIO())-\u003eIO OptResult"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:setLogger",
      "description": {
        "fct-descr": "\u003cp\u003eset callback function for receiving messages.\n\u003c/p\u003e",
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e (String -\u003e IO ()) -\u003e IO ()",
        "fct-source": "src/Algorithm-MIPSolver2.html#setLogger",
        "fct-type": "function",
        "title": "setLogger"
      },
      "index": {
        "description": "set callback function for receiving messages",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "setLogger",
        "normalized": "Solver-\u003e(String-\u003eIO())-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "Solver-\u003e(String-\u003eIO())-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:setNThread",
      "description": {
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Int -\u003e IO ()",
        "fct-source": "src/Algorithm-MIPSolver2.html#setNThread",
        "fct-type": "function",
        "title": "setNThread"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "setNThread",
        "normalized": "Solver-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "NThread",
        "signature": "Solver-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolver2.html#v:setShowRational",
      "description": {
        "fct-module": "Algorithm.MIPSolver2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Bool -\u003e IO ()",
        "fct-source": "src/Algorithm-MIPSolver2.html#setShowRational",
        "fct-type": "function",
        "title": "setShowRational"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolver2",
        "module": "Algorithm.MIPSolver2",
        "name": "setShowRational",
        "normalized": "Solver-\u003eBool-\u003eIO()",
        "package": "toysolver",
        "partial": "Show Rational",
        "signature": "Solver-\u003eBool-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e [Gomory1960]\n   Ralph E. Gomory.\n   An Algorithm for the Mixed Integer Problem, Technical Report\n   RM-2597, 1960, The Rand Corporation, Santa Monica, CA.\n   \u003ca\u003ehttp://www.rand.org/pubs/research_memoranda/RM2597.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e [Gomory1958]\n   Ralph E. Gomory.\n   Outline of an algorithm for integer solutions to linear programs.\n   Bull. Amer. Math. Soc., Vol. 64, No. 5. (1958), pp. 275-278.\n   \u003ca\u003ehttp://projecteuclid.org/euclid.bams/1183522679\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.MIPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-MIPSolverHL.html",
        "fct-type": "module",
        "title": "MIPSolverHL"
      },
      "index": {
        "description": "References Gomory1960 Ralph Gomory An Algorithm for the Mixed Integer Problem Technical Report RM-2597 The Rand Corporation Santa Monica CA http www.rand.org pubs research memoranda RM2597.html Gomory1958 Ralph Gomory Outline of an algorithm for integer solutions to linear programs Bull Amer Math Soc Vol No pp http projecteuclid.org euclid.bams",
        "hierarchy": "Algorithm MIPSolverHL",
        "module": "Algorithm.MIPSolverHL",
        "name": "MIPSolverHL",
        "normalized": "",
        "package": "toysolver",
        "partial": "MIPSolver HL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#t:OptResult",
      "description": {
        "fct-descr": "\u003cp\u003eresults of optimization\n\u003c/p\u003e",
        "fct-module": "Algorithm.MIPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-LPSolverHL.html#OptResult",
        "fct-type": "data",
        "title": "OptResult"
      },
      "index": {
        "description": "results of optimization",
        "hierarchy": "Algorithm MIPSolverHL",
        "module": "Algorithm.MIPSolverHL",
        "name": "OptResult",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:OptUnsat",
      "description": {
        "fct-module": "Algorithm.MIPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "OptUnsat",
        "fct-source": "src/Algorithm-LPSolverHL.html#OptResult",
        "fct-type": "function",
        "title": "OptUnsat"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolverHL",
        "module": "Algorithm.MIPSolverHL",
        "name": "OptUnsat",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Unsat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:Optimum",
      "description": {
        "fct-module": "Algorithm.MIPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "Optimum r (Model r)",
        "fct-source": "src/Algorithm-LPSolverHL.html#OptResult",
        "fct-type": "function",
        "title": "Optimum"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolverHL",
        "module": "Algorithm.MIPSolverHL",
        "name": "Optimum",
        "normalized": "",
        "package": "toysolver",
        "partial": "Optimum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:Unbounded",
      "description": {
        "fct-module": "Algorithm.MIPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "Unbounded",
        "fct-source": "src/Algorithm-LPSolverHL.html#OptResult",
        "fct-type": "function",
        "title": "Unbounded"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolverHL",
        "module": "Algorithm.MIPSolverHL",
        "name": "Unbounded",
        "normalized": "",
        "package": "toysolver",
        "partial": "Unbounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:maximize",
      "description": {
        "fct-module": "Algorithm.MIPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e [Atom r] -\u003e VarSet -\u003e OptResult r",
        "fct-source": "src/Algorithm-MIPSolverHL.html#maximize",
        "fct-type": "function",
        "title": "maximize"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolverHL",
        "module": "Algorithm.MIPSolverHL",
        "name": "maximize",
        "normalized": "Expr a-\u003e[Atom a]-\u003eVarSet-\u003eOptResult a",
        "package": "toysolver",
        "partial": "",
        "signature": "Expr r-\u003e[Atom r]-\u003eVarSet-\u003eOptResult r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:minimize",
      "description": {
        "fct-module": "Algorithm.MIPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e [Atom r] -\u003e VarSet -\u003e OptResult r",
        "fct-source": "src/Algorithm-MIPSolverHL.html#minimize",
        "fct-type": "function",
        "title": "minimize"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolverHL",
        "module": "Algorithm.MIPSolverHL",
        "name": "minimize",
        "normalized": "Expr a-\u003e[Atom a]-\u003eVarSet-\u003eOptResult a",
        "package": "toysolver",
        "partial": "",
        "signature": "Expr r-\u003e[Atom r]-\u003eVarSet-\u003eOptResult r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-MIPSolverHL.html#v:optimize",
      "description": {
        "fct-module": "Algorithm.MIPSolverHL",
        "fct-package": "toysolver",
        "fct-signature": "OptDir -\u003e Expr r -\u003e [Atom r] -\u003e VarSet -\u003e OptResult r",
        "fct-source": "src/Algorithm-MIPSolverHL.html#optimize",
        "fct-type": "function",
        "title": "optimize"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm MIPSolverHL",
        "module": "Algorithm.MIPSolverHL",
        "name": "optimize",
        "normalized": "OptDir-\u003eExpr a-\u003e[Atom a]-\u003eVarSet-\u003eOptResult a",
        "package": "toysolver",
        "partial": "",
        "signature": "OptDir-\u003eExpr r-\u003e[Atom r]-\u003eVarSet-\u003eOptResult r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest-Misc.html#",
      "description": {
        "fct-module": "Algorithm.OmegaTest.Misc",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-OmegaTest-Misc.html",
        "fct-type": "module",
        "title": "Misc"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest Misc",
        "module": "Algorithm.OmegaTest.Misc",
        "name": "Misc",
        "normalized": "",
        "package": "toysolver",
        "partial": "Misc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest-Misc.html#v:checkRealByCAD",
      "description": {
        "fct-module": "Algorithm.OmegaTest.Misc",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
        "fct-source": "src/Algorithm-OmegaTest-Misc.html#checkRealByCAD",
        "fct-type": "function",
        "title": "checkRealByCAD"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest Misc",
        "module": "Algorithm.OmegaTest.Misc",
        "name": "checkRealByCAD",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
        "package": "toysolver",
        "partial": "Real By CAD",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest-Misc.html#v:checkRealBySimplex",
      "description": {
        "fct-module": "Algorithm.OmegaTest.Misc",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
        "fct-source": "src/Algorithm-OmegaTest-Misc.html#checkRealBySimplex",
        "fct-type": "function",
        "title": "checkRealBySimplex"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest Misc",
        "module": "Algorithm.OmegaTest.Misc",
        "name": "checkRealBySimplex",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
        "package": "toysolver",
        "partial": "Real By Simplex",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e(incomplete) implementation of Omega Test\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e William Pugh. The Omega test: a fast and practical integer\n   programming algorithm for dependence analysis. In Proceedings of\n   the 1991 ACM/IEEE conference on Supercomputing (1991), pp. 4-13.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://users.cecs.anu.edu.au/~michaeln/pubs/arithmetic-dps.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSee also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/Omega\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-OmegaTest.html",
        "fct-type": "module",
        "title": "OmegaTest"
      },
      "index": {
        "description": "incomplete implementation of Omega Test References William Pugh The Omega test fast and practical integer programming algorithm for dependence analysis In Proceedings of the ACM IEEE conference on Supercomputing pp http users.cecs.anu.edu.au michaeln pubs arithmetic-dps.pdf See also http hackage.haskell.org package Omega",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "OmegaTest",
        "normalized": "",
        "package": "toysolver",
        "partial": "Omega Test",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#t:Model",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003eModel\u003c/code\u003e is a map from variables to values.\n\u003c/p\u003e",
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Var.html#Model",
        "fct-type": "type",
        "title": "Model"
      },
      "index": {
        "description": "Model is map from variables to values",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#t:Options",
      "description": {
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-OmegaTest.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:Options",
      "description": {
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/Algorithm-OmegaTest.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:checkRealByFM",
      "description": {
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
        "fct-source": "src/Algorithm-OmegaTest.html#checkRealByFM",
        "fct-type": "function",
        "title": "checkRealByFM"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "checkRealByFM",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
        "package": "toysolver",
        "partial": "Real By FM",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:checkRealNoCheck",
      "description": {
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
        "fct-source": "src/Algorithm-OmegaTest.html#checkRealNoCheck",
        "fct-type": "function",
        "title": "checkRealNoCheck"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "checkRealNoCheck",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
        "package": "toysolver",
        "partial": "Real No Check",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:defaultOptions",
      "description": {
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/Algorithm-OmegaTest.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:optCheckReal",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "VarSet -\u003e [Atom Rational] -\u003e Bool",
        "fct-source": "src/Algorithm-OmegaTest.html#Options",
        "fct-type": "function",
        "title": "optCheckReal"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "optCheckReal",
        "normalized": "VarSet-\u003e[Atom Rational]-\u003eBool",
        "package": "toysolver",
        "partial": "Check Real",
        "signature": "VarSet-\u003e[Atom Rational]-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:solve",
      "description": {
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "Options -\u003e VarSet -\u003e [Atom Rational] -\u003e Maybe (Model Integer)",
        "fct-source": "src/Algorithm-OmegaTest.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "solve",
        "normalized": "Options-\u003eVarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "Options-\u003eVarSet-\u003e[Atom Rational]-\u003eMaybe(Model Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-OmegaTest.html#v:solveQFLA",
      "description": {
        "fct-module": "Algorithm.OmegaTest",
        "fct-package": "toysolver",
        "fct-signature": "Options -\u003e VarSet -\u003e [Atom Rational] -\u003e VarSet -\u003e Maybe (Model Rational)",
        "fct-source": "src/Algorithm-OmegaTest.html#solveQFLA",
        "fct-type": "function",
        "title": "solveQFLA"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm OmegaTest",
        "module": "Algorithm.OmegaTest",
        "name": "solveQFLA",
        "normalized": "Options-\u003eVarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)",
        "package": "toysolver",
        "partial": "QFLA",
        "signature": "Options-\u003eVarSet-\u003e[Atom Rational]-\u003eVarSet-\u003eMaybe(Model Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Simplex method\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.cuhk.edu.hk/~wei/lpch3.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-Simplex.html",
        "fct-type": "module",
        "title": "Simplex"
      },
      "index": {
        "description": "Na ve implementation of Simplex method Reference http www.math.cuhk.edu.hk wei lpch3.pdf",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "Simplex",
        "normalized": "",
        "package": "toysolver",
        "partial": "Simplex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:ColIndex",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Simplex.html#ColIndex",
        "fct-type": "type",
        "title": "ColIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "ColIndex",
        "normalized": "",
        "package": "toysolver",
        "partial": "Col Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:PivotResult",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Simplex.html#PivotResult",
        "fct-type": "data",
        "title": "PivotResult"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "PivotResult",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pivot Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:Row",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Simplex.html#Row",
        "fct-type": "type",
        "title": "Row"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "Row",
        "normalized": "",
        "package": "toysolver",
        "partial": "Row",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:RowIndex",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Simplex.html#RowIndex",
        "fct-type": "type",
        "title": "RowIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "RowIndex",
        "normalized": "",
        "package": "toysolver",
        "partial": "Row Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#t:Tableau",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Simplex.html#Tableau",
        "fct-type": "type",
        "title": "Tableau"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "Tableau",
        "normalized": "",
        "package": "toysolver",
        "partial": "Tableau",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:currentObjValue",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "Tableau r -\u003e r",
        "fct-source": "src/Algorithm-Simplex.html#currentObjValue",
        "fct-type": "function",
        "title": "currentObjValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "currentObjValue",
        "normalized": "Tableau a-\u003ea",
        "package": "toysolver",
        "partial": "Obj Value",
        "signature": "Tableau r-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:dualSimplex",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "OptDir -\u003e Tableau r -\u003e (Bool, Tableau r)",
        "fct-source": "src/Algorithm-Simplex.html#dualSimplex",
        "fct-type": "function",
        "title": "dualSimplex"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "dualSimplex",
        "normalized": "OptDir-\u003eTableau a-\u003e(Bool,Tableau a)",
        "package": "toysolver",
        "partial": "Simplex",
        "signature": "OptDir-\u003eTableau r-\u003e(Bool,Tableau r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:lookupRow",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "RowIndex -\u003e Tableau r -\u003e Row r",
        "fct-source": "src/Algorithm-Simplex.html#lookupRow",
        "fct-type": "function",
        "title": "lookupRow"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "lookupRow",
        "normalized": "RowIndex-\u003eTableau a-\u003eRow a",
        "package": "toysolver",
        "partial": "Row",
        "signature": "RowIndex-\u003eTableau r-\u003eRow r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:objRow",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "RowIndex",
        "fct-source": "src/Algorithm-Simplex.html#objRow",
        "fct-type": "function",
        "title": "objRow"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "objRow",
        "normalized": "",
        "package": "toysolver",
        "partial": "Row",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:phaseI",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "Tableau r -\u003e VarSet -\u003e (Bool, Tableau r)",
        "fct-source": "src/Algorithm-Simplex.html#phaseI",
        "fct-type": "function",
        "title": "phaseI"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "phaseI",
        "normalized": "Tableau a-\u003eVarSet-\u003e(Bool,Tableau a)",
        "package": "toysolver",
        "partial": "",
        "signature": "Tableau r-\u003eVarSet-\u003e(Bool,Tableau r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:pivot",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "RowIndex -\u003e ColIndex -\u003e Tableau r -\u003e Tableau r",
        "fct-source": "src/Algorithm-Simplex.html#pivot",
        "fct-type": "function",
        "title": "pivot"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "pivot",
        "normalized": "RowIndex-\u003eColIndex-\u003eTableau a-\u003eTableau a",
        "package": "toysolver",
        "partial": "",
        "signature": "RowIndex-\u003eColIndex-\u003eTableau r-\u003eTableau r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:setObjFun",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "Tableau r -\u003e Expr r -\u003e Tableau r",
        "fct-source": "src/Algorithm-Simplex.html#setObjFun",
        "fct-type": "function",
        "title": "setObjFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "setObjFun",
        "normalized": "Tableau a-\u003eExpr a-\u003eTableau a",
        "package": "toysolver",
        "partial": "Obj Fun",
        "signature": "Tableau r-\u003eExpr r-\u003eTableau r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:setRow",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "RowIndex -\u003e Tableau r -\u003e Row r -\u003e Tableau r",
        "fct-source": "src/Algorithm-Simplex.html#setRow",
        "fct-type": "function",
        "title": "setRow"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "setRow",
        "normalized": "RowIndex-\u003eTableau a-\u003eRow a-\u003eTableau a",
        "package": "toysolver",
        "partial": "Row",
        "signature": "RowIndex-\u003eTableau r-\u003eRow r-\u003eTableau r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:simplex",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "OptDir -\u003e Tableau r -\u003e (Bool, Tableau r)",
        "fct-source": "src/Algorithm-Simplex.html#simplex",
        "fct-type": "function",
        "title": "simplex"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "simplex",
        "normalized": "OptDir-\u003eTableau a-\u003e(Bool,Tableau a)",
        "package": "toysolver",
        "partial": "",
        "signature": "OptDir-\u003eTableau r-\u003e(Bool,Tableau r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex.html#v:toCSV",
      "description": {
        "fct-module": "Algorithm.Simplex",
        "fct-package": "toysolver",
        "fct-signature": "(r -\u003e String) -\u003e Tableau r -\u003e String",
        "fct-source": "src/Algorithm-Simplex.html#toCSV",
        "fct-type": "function",
        "title": "toCSV"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex",
        "module": "Algorithm.Simplex",
        "name": "toCSV",
        "normalized": "(a-\u003eString)-\u003eTableau a-\u003eString",
        "package": "toysolver",
        "partial": "CSV",
        "signature": "(r-\u003eString)-\u003eTableau r-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNa&#239;ve implementation of Simplex method\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.cuhk.edu.hk/~wei/lpch3.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Bruno Dutertre and Leonardo de Moura.\n   A Fast Linear-Arithmetic Solver for DPLL(T).\n   Computer Aided Verification In Computer Aided Verification, Vol. 4144 (2006), pp. 81-94.\n   \u003ca\u003ehttp://yices.csl.sri.com/cav06.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Bruno Dutertre and Leonardo de Moura.\n   Integrating Simplex with DPLL(T).\n   CSL Technical Report SRI-CSL-06-01. 2006.\n   \u003ca\u003ehttp://yices.csl.sri.com/sri-csl-06-01.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Algorithm-Simplex2.html",
        "fct-type": "module",
        "title": "Simplex2"
      },
      "index": {
        "description": "Na ve implementation of Simplex method Reference http www.math.cuhk.edu.hk wei lpch3.pdf Bruno Dutertre and Leonardo de Moura Fast Linear-Arithmetic Solver for DPLL Computer Aided Verification In Computer Aided Verification Vol pp http yices.csl.sri.com cav06.pdf Bruno Dutertre and Leonardo de Moura Integrating Simplex with DPLL CSL Technical Report SRI-CSL-06-01 http yices.csl.sri.com sri-csl-06-01.pdf",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Simplex2",
        "normalized": "",
        "package": "toysolver",
        "partial": "Simplex",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Atom",
      "description": {
        "fct-descr": "\u003cp\u003eAtomic Formula of Linear Arithmetics\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-LA.html#Atom",
        "fct-type": "type",
        "title": "Atom"
      },
      "index": {
        "description": "Atomic Formula of Linear Arithmetics",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Atom",
        "normalized": "",
        "package": "toysolver",
        "partial": "Atom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:GenericSolver",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Simplex2.html#GenericSolver",
        "fct-type": "data",
        "title": "GenericSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "GenericSolver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Generic Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Model",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Simplex2.html#Model",
        "fct-type": "type",
        "title": "Model"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:OptDir",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eOptDir\u003c/a\u003e\u003c/code\u003e type represents optimization directions.\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "OptDir"
      },
      "index": {
        "description": "The OptDir type represents optimization directions",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "OptDir",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Dir",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:OptResult",
      "description": {
        "fct-descr": "\u003cp\u003eresults of optimization\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Simplex2.html#OptResult",
        "fct-type": "data",
        "title": "OptResult"
      },
      "index": {
        "description": "results of optimization",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "OptResult",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Options",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Simplex2.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:PivotStrategy",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Algorithm-Simplex2.html#PivotStrategy",
        "fct-type": "data",
        "title": "PivotStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "PivotStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pivot Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:RawModel",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Simplex2.html#RawModel",
        "fct-type": "type",
        "title": "RawModel"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "RawModel",
        "normalized": "",
        "package": "toysolver",
        "partial": "Raw Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:RelOp",
      "description": {
        "fct-descr": "\u003cp\u003erelational operators\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "data",
        "title": "RelOp"
      },
      "index": {
        "description": "relational operators",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "RelOp",
        "normalized": "",
        "package": "toysolver",
        "partial": "Rel Op",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Solver",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Simplex2.html#Solver",
        "fct-type": "type",
        "title": "Solver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Solver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:SolverValue",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Algorithm-Simplex2.html#SolverValue",
        "fct-type": "class",
        "title": "SolverValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "SolverValue",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver Value",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#t:Var",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Algorithm-Simplex2.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-60--61-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3C%3D.",
        "fct-type": "function",
        "title": "(.\u003c=.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "(.\u003c=.) .\u003c=.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-60-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3C.",
        "fct-type": "function",
        "title": "(.\u003c.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "(.\u003c.) .\u003c.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-61--61-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3D%3D.",
        "fct-type": "function",
        "title": "(.==.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "(.==.) .==.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-62--61-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3E%3D.",
        "fct-type": "function",
        "title": "(.\u003e=.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "(.\u003e=.) .\u003e=.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:.-62-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3E.",
        "fct-type": "function",
        "title": "(.\u003e.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "(.\u003e.) .\u003e.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Eql",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Eql",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Eql"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Eql",
        "normalized": "",
        "package": "toysolver",
        "partial": "Eql",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Ge",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Ge",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Ge"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Ge",
        "normalized": "",
        "package": "toysolver",
        "partial": "Ge",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Gt",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Gt",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Gt"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Gt",
        "normalized": "",
        "package": "toysolver",
        "partial": "Gt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Le",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Le",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Le"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Le",
        "normalized": "",
        "package": "toysolver",
        "partial": "Le",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Lt",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Lt",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Lt"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Lt",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:NEq",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "NEq",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "NEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "NEq",
        "normalized": "",
        "package": "toysolver",
        "partial": "NEq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:ObjLimit",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "ObjLimit",
        "fct-source": "src/Algorithm-Simplex2.html#OptResult",
        "fct-type": "function",
        "title": "ObjLimit"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "ObjLimit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Limit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:OptMax",
      "description": {
        "fct-descr": "\u003cp\u003emaximization\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "OptMax",
        "fct-type": "function",
        "title": "OptMax"
      },
      "index": {
        "description": "maximization",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "OptMax",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Max",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:OptMin",
      "description": {
        "fct-descr": "\u003cp\u003eminimization \n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "OptMin",
        "fct-type": "function",
        "title": "OptMin"
      },
      "index": {
        "description": "minimization",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "OptMin",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Min",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Optimum",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Optimum",
        "fct-source": "src/Algorithm-Simplex2.html#OptResult",
        "fct-type": "function",
        "title": "Optimum"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Optimum",
        "normalized": "",
        "package": "toysolver",
        "partial": "Optimum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Options",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/Algorithm-Simplex2.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:PivotStrategyBlandRule",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "PivotStrategyBlandRule",
        "fct-source": "src/Algorithm-Simplex2.html#PivotStrategy",
        "fct-type": "function",
        "title": "PivotStrategyBlandRule"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "PivotStrategyBlandRule",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pivot Strategy Bland Rule",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:PivotStrategyLargestCoefficient",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "PivotStrategyLargestCoefficient",
        "fct-source": "src/Algorithm-Simplex2.html#PivotStrategy",
        "fct-type": "function",
        "title": "PivotStrategyLargestCoefficient"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "PivotStrategyLargestCoefficient",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pivot Strategy Largest Coefficient",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Unbounded",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Unbounded",
        "fct-source": "src/Algorithm-Simplex2.html#OptResult",
        "fct-type": "function",
        "title": "Unbounded"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Unbounded",
        "normalized": "",
        "package": "toysolver",
        "partial": "Unbounded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:Unsat",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Unsat",
        "fct-source": "src/Algorithm-Simplex2.html#OptResult",
        "fct-type": "function",
        "title": "Unsat"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "Unsat",
        "normalized": "",
        "package": "toysolver",
        "partial": "Unsat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:assertAtom",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Atom Rational -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#assertAtom",
        "fct-type": "function",
        "title": "assertAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "assertAtom",
        "normalized": "Solver-\u003eAtom Rational-\u003eIO()",
        "package": "toysolver",
        "partial": "Atom",
        "signature": "Solver-\u003eAtom Rational-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:assertAtomEx",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver (Delta Rational) -\u003e Atom Rational -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#assertAtomEx",
        "fct-type": "function",
        "title": "assertAtomEx"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "assertAtomEx",
        "normalized": "GenericSolver(Delta Rational)-\u003eAtom Rational-\u003eIO()",
        "package": "toysolver",
        "partial": "Atom Ex",
        "signature": "GenericSolver(Delta Rational)-\u003eAtom Rational-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:assertLower",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e v -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#assertLower",
        "fct-type": "function",
        "title": "assertLower"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "assertLower",
        "normalized": "GenericSolver a-\u003eVar-\u003ea-\u003eIO()",
        "package": "toysolver",
        "partial": "Lower",
        "signature": "GenericSolver v-\u003eVar-\u003ev-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:assertUpper",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e v -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#assertUpper",
        "fct-type": "function",
        "title": "assertUpper"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "assertUpper",
        "normalized": "GenericSolver a-\u003eVar-\u003ea-\u003eIO()",
        "package": "toysolver",
        "partial": "Upper",
        "signature": "GenericSolver v-\u003eVar-\u003ev-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:check",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO Bool",
        "fct-source": "src/Algorithm-Simplex2.html#check",
        "fct-type": "function",
        "title": "check"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "check",
        "normalized": "GenericSolver a-\u003eIO Bool",
        "package": "toysolver",
        "partial": "",
        "signature": "GenericSolver v-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:clearLogger",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#clearLogger",
        "fct-type": "function",
        "title": "clearLogger"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "clearLogger",
        "normalized": "GenericSolver a-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "GenericSolver v-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:cloneSolver",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO (GenericSolver v)",
        "fct-source": "src/Algorithm-Simplex2.html#cloneSolver",
        "fct-type": "function",
        "title": "cloneSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "cloneSolver",
        "normalized": "GenericSolver a-\u003eIO(GenericSolver a)",
        "package": "toysolver",
        "partial": "Solver",
        "signature": "GenericSolver v-\u003eIO(GenericSolver v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:defaultOptions",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/Algorithm-Simplex2.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:dualSimplex",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Options -\u003e IO OptResult",
        "fct-source": "src/Algorithm-Simplex2.html#dualSimplex",
        "fct-type": "function",
        "title": "dualSimplex"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "dualSimplex",
        "normalized": "Solver-\u003eOptions-\u003eIO OptResult",
        "package": "toysolver",
        "partial": "Simplex",
        "signature": "Solver-\u003eOptions-\u003eIO OptResult"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:dump",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#dump",
        "fct-type": "function",
        "title": "dump"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "dump",
        "normalized": "GenericSolver a-\u003eIO()",
        "package": "toysolver",
        "partial": "",
        "signature": "GenericSolver v-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getCoeff",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e Var -\u003e IO Rational",
        "fct-source": "src/Algorithm-Simplex2.html#getCoeff",
        "fct-type": "function",
        "title": "getCoeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getCoeff",
        "normalized": "GenericSolver a-\u003eVar-\u003eVar-\u003eIO Rational",
        "package": "toysolver",
        "partial": "Coeff",
        "signature": "GenericSolver v-\u003eVar-\u003eVar-\u003eIO Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getCol",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e IO (IntMap Rational)",
        "fct-source": "src/Algorithm-Simplex2.html#getCol",
        "fct-type": "function",
        "title": "getCol"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getCol",
        "normalized": "GenericSolver a-\u003eVar-\u003eIO(IntMap Rational)",
        "package": "toysolver",
        "partial": "Col",
        "signature": "GenericSolver v-\u003eVar-\u003eIO(IntMap Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getLB",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e IO (Maybe v)",
        "fct-source": "src/Algorithm-Simplex2.html#getLB",
        "fct-type": "function",
        "title": "getLB"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getLB",
        "normalized": "GenericSolver a-\u003eVar-\u003eIO(Maybe a)",
        "package": "toysolver",
        "partial": "LB",
        "signature": "GenericSolver v-\u003eVar-\u003eIO(Maybe v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getObj",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO (Expr Rational)",
        "fct-source": "src/Algorithm-Simplex2.html#getObj",
        "fct-type": "function",
        "title": "getObj"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getObj",
        "normalized": "GenericSolver a-\u003eIO(Expr Rational)",
        "package": "toysolver",
        "partial": "Obj",
        "signature": "GenericSolver v-\u003eIO(Expr Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getObjValue",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO v",
        "fct-source": "src/Algorithm-Simplex2.html#getObjValue",
        "fct-type": "function",
        "title": "getObjValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getObjValue",
        "normalized": "GenericSolver a-\u003eIO a",
        "package": "toysolver",
        "partial": "Obj Value",
        "signature": "GenericSolver v-\u003eIO v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getOptDir",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO OptDir",
        "fct-source": "src/Algorithm-Simplex2.html#getOptDir",
        "fct-type": "function",
        "title": "getOptDir"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getOptDir",
        "normalized": "GenericSolver a-\u003eIO OptDir",
        "package": "toysolver",
        "partial": "Opt Dir",
        "signature": "GenericSolver v-\u003eIO OptDir"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getRow",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e IO (Expr Rational)",
        "fct-source": "src/Algorithm-Simplex2.html#getRow",
        "fct-type": "function",
        "title": "getRow"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getRow",
        "normalized": "GenericSolver a-\u003eVar-\u003eIO(Expr Rational)",
        "package": "toysolver",
        "partial": "Row",
        "signature": "GenericSolver v-\u003eVar-\u003eIO(Expr Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getTableau",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO (IntMap (Expr Rational))",
        "fct-source": "src/Algorithm-Simplex2.html#getTableau",
        "fct-type": "function",
        "title": "getTableau"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getTableau",
        "normalized": "GenericSolver a-\u003eIO(IntMap(Expr Rational))",
        "package": "toysolver",
        "partial": "Tableau",
        "signature": "GenericSolver v-\u003eIO(IntMap(Expr Rational))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getUB",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e IO (Maybe v)",
        "fct-source": "src/Algorithm-Simplex2.html#getUB",
        "fct-type": "function",
        "title": "getUB"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getUB",
        "normalized": "GenericSolver a-\u003eVar-\u003eIO(Maybe a)",
        "package": "toysolver",
        "partial": "UB",
        "signature": "GenericSolver v-\u003eVar-\u003eIO(Maybe v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:getValue",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e IO v",
        "fct-source": "src/Algorithm-Simplex2.html#getValue",
        "fct-type": "function",
        "title": "getValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "getValue",
        "normalized": "GenericSolver a-\u003eVar-\u003eIO a",
        "package": "toysolver",
        "partial": "Value",
        "signature": "GenericSolver v-\u003eVar-\u003eIO v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:isBasicVariable",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e IO Bool",
        "fct-source": "src/Algorithm-Simplex2.html#isBasicVariable",
        "fct-type": "function",
        "title": "isBasicVariable"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "isBasicVariable",
        "normalized": "GenericSolver a-\u003eVar-\u003eIO Bool",
        "package": "toysolver",
        "partial": "Basic Variable",
        "signature": "GenericSolver v-\u003eVar-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:isFeasible",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO Bool",
        "fct-source": "src/Algorithm-Simplex2.html#isFeasible",
        "fct-type": "function",
        "title": "isFeasible"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "isFeasible",
        "normalized": "GenericSolver a-\u003eIO Bool",
        "package": "toysolver",
        "partial": "Feasible",
        "signature": "GenericSolver v-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:isNonBasicVariable",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Var -\u003e IO Bool",
        "fct-source": "src/Algorithm-Simplex2.html#isNonBasicVariable",
        "fct-type": "function",
        "title": "isNonBasicVariable"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "isNonBasicVariable",
        "normalized": "GenericSolver a-\u003eVar-\u003eIO Bool",
        "package": "toysolver",
        "partial": "Non Basic Variable",
        "signature": "GenericSolver v-\u003eVar-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:isOptimal",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO Bool",
        "fct-source": "src/Algorithm-Simplex2.html#isOptimal",
        "fct-type": "function",
        "title": "isOptimal"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "isOptimal",
        "normalized": "GenericSolver a-\u003eIO Bool",
        "package": "toysolver",
        "partial": "Optimal",
        "signature": "GenericSolver v-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:model",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO Model",
        "fct-source": "src/Algorithm-Simplex2.html#model",
        "fct-type": "method",
        "title": "model"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "model",
        "normalized": "GenericSolver a-\u003eIO Model",
        "package": "toysolver",
        "partial": "",
        "signature": "GenericSolver v-\u003eIO Model"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:nVars",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO Int",
        "fct-source": "src/Algorithm-Simplex2.html#nVars",
        "fct-type": "function",
        "title": "nVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "nVars",
        "normalized": "GenericSolver a-\u003eIO Int",
        "package": "toysolver",
        "partial": "Vars",
        "signature": "GenericSolver v-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:newSolver",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "IO (GenericSolver v)",
        "fct-source": "src/Algorithm-Simplex2.html#newSolver",
        "fct-type": "function",
        "title": "newSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "newSolver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:newVar",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO Var",
        "fct-source": "src/Algorithm-Simplex2.html#newVar",
        "fct-type": "function",
        "title": "newVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "newVar",
        "normalized": "GenericSolver a-\u003eIO Var",
        "package": "toysolver",
        "partial": "Var",
        "signature": "GenericSolver v-\u003eIO Var"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:objLimit",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Maybe Rational",
        "fct-source": "src/Algorithm-Simplex2.html#Options",
        "fct-type": "function",
        "title": "objLimit"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "objLimit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Limit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:optimize",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Options -\u003e IO OptResult",
        "fct-source": "src/Algorithm-Simplex2.html#optimize",
        "fct-type": "function",
        "title": "optimize"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "optimize",
        "normalized": "Solver-\u003eOptions-\u003eIO OptResult",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003eOptions-\u003eIO OptResult"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:rawModel",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e IO (RawModel v)",
        "fct-source": "src/Algorithm-Simplex2.html#rawModel",
        "fct-type": "function",
        "title": "rawModel"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "rawModel",
        "normalized": "GenericSolver a-\u003eIO(RawModel a)",
        "package": "toysolver",
        "partial": "Model",
        "signature": "GenericSolver v-\u003eIO(RawModel v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:setLogger",
      "description": {
        "fct-descr": "\u003cp\u003eset callback function for receiving messages.\n\u003c/p\u003e",
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e (String -\u003e IO ()) -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#setLogger",
        "fct-type": "function",
        "title": "setLogger"
      },
      "index": {
        "description": "set callback function for receiving messages",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "setLogger",
        "normalized": "GenericSolver a-\u003e(String-\u003eIO())-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "GenericSolver v-\u003e(String-\u003eIO())-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:setObj",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e Expr Rational -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#setObj",
        "fct-type": "function",
        "title": "setObj"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "setObj",
        "normalized": "GenericSolver a-\u003eExpr Rational-\u003eIO()",
        "package": "toysolver",
        "partial": "Obj",
        "signature": "GenericSolver v-\u003eExpr Rational-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:setOptDir",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e OptDir -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#setOptDir",
        "fct-type": "function",
        "title": "setOptDir"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "setOptDir",
        "normalized": "GenericSolver a-\u003eOptDir-\u003eIO()",
        "package": "toysolver",
        "partial": "Opt Dir",
        "signature": "GenericSolver v-\u003eOptDir-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:setPivotStrategy",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "GenericSolver v -\u003e PivotStrategy -\u003e IO ()",
        "fct-source": "src/Algorithm-Simplex2.html#setPivotStrategy",
        "fct-type": "function",
        "title": "setPivotStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "setPivotStrategy",
        "normalized": "GenericSolver a-\u003ePivotStrategy-\u003eIO()",
        "package": "toysolver",
        "partial": "Pivot Strategy",
        "signature": "GenericSolver v-\u003ePivotStrategy-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:showValue",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Bool -\u003e v -\u003e String",
        "fct-source": "src/Algorithm-Simplex2.html#showValue",
        "fct-type": "method",
        "title": "showValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "showValue",
        "normalized": "Bool-\u003ea-\u003eString",
        "package": "toysolver",
        "partial": "Value",
        "signature": "Bool-\u003ev-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Algorithm-Simplex2.html#v:toValue",
      "description": {
        "fct-module": "Algorithm.Simplex2",
        "fct-package": "toysolver",
        "fct-signature": "Rational -\u003e v",
        "fct-source": "src/Algorithm-Simplex2.html#toValue",
        "fct-type": "method",
        "title": "toValue"
      },
      "index": {
        "description": "",
        "hierarchy": "Algorithm Simplex2",
        "module": "Algorithm.Simplex2",
        "name": "toValue",
        "normalized": "Rational-\u003ea",
        "package": "toysolver",
        "partial": "Value",
        "signature": "Rational-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#",
      "description": {
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-LP2SMT.html",
        "fct-type": "module",
        "title": "LP2SMT"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "LP2SMT",
        "normalized": "",
        "package": "toysolver",
        "partial": "LP SMT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#t:Language",
      "description": {
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Converter-LP2SMT.html#Language",
        "fct-type": "data",
        "title": "Language"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "Language",
        "normalized": "",
        "package": "toysolver",
        "partial": "Language",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#t:Options",
      "description": {
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Converter-LP2SMT.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:Options",
      "description": {
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/Converter-LP2SMT.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:SMTLIB2",
      "description": {
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "SMTLIB2",
        "fct-source": "src/Converter-LP2SMT.html#Language",
        "fct-type": "function",
        "title": "SMTLIB2"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "SMTLIB2",
        "normalized": "",
        "package": "toysolver",
        "partial": "SMTLIB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:YICES",
      "description": {
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "YICES",
        "fct-source": "src/Converter-LP2SMT.html#Language",
        "fct-type": "function",
        "title": "YICES"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "YICES",
        "normalized": "",
        "package": "toysolver",
        "partial": "YICES",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:convert",
      "description": {
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "Options -\u003e LP -\u003e ShowS",
        "fct-source": "src/Converter-LP2SMT.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "convert",
        "normalized": "Options-\u003eLP-\u003eShowS",
        "package": "toysolver",
        "partial": "",
        "signature": "Options-\u003eLP-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:defaultOptions",
      "description": {
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/Converter-LP2SMT.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:optCheckSAT",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "Bool",
        "fct-source": "src/Converter-LP2SMT.html#Options",
        "fct-type": "function",
        "title": "optCheckSAT"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "optCheckSAT",
        "normalized": "",
        "package": "toysolver",
        "partial": "Check SAT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:optLanguage",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "Language",
        "fct-source": "src/Converter-LP2SMT.html#Options",
        "fct-type": "function",
        "title": "optLanguage"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "optLanguage",
        "normalized": "",
        "package": "toysolver",
        "partial": "Language",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:optOptimize",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "Bool",
        "fct-source": "src/Converter-LP2SMT.html#Options",
        "fct-type": "function",
        "title": "optOptimize"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "optOptimize",
        "normalized": "",
        "package": "toysolver",
        "partial": "Optimize",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-LP2SMT.html#v:optProduceModel",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Converter.LP2SMT",
        "fct-package": "toysolver",
        "fct-signature": "Bool",
        "fct-source": "src/Converter-LP2SMT.html#Options",
        "fct-type": "function",
        "title": "optProduceModel"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter LP2SMT",
        "module": "Converter.LP2SMT",
        "name": "optProduceModel",
        "normalized": "",
        "package": "toysolver",
        "partial": "Produce Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2LP.html#",
      "description": {
        "fct-module": "Converter.MaxSAT2LP",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-MaxSAT2LP.html",
        "fct-type": "module",
        "title": "MaxSAT2LP"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter MaxSAT2LP",
        "module": "Converter.MaxSAT2LP",
        "name": "MaxSAT2LP",
        "normalized": "",
        "package": "toysolver",
        "partial": "Max SAT LP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2LP.html#v:convert",
      "description": {
        "fct-module": "Converter.MaxSAT2LP",
        "fct-package": "toysolver",
        "fct-signature": "Bool -\u003e WCNF -\u003e (LP, Map Var Rational -\u003e Model)",
        "fct-source": "src/Converter-MaxSAT2LP.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter MaxSAT2LP",
        "module": "Converter.MaxSAT2LP",
        "name": "convert",
        "normalized": "Bool-\u003eWCNF-\u003e(LP,Map Var Rational-\u003eModel)",
        "package": "toysolver",
        "partial": "",
        "signature": "Bool-\u003eWCNF-\u003e(LP,Map Var Rational-\u003eModel)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2NLPB.html#",
      "description": {
        "fct-module": "Converter.MaxSAT2NLPB",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-MaxSAT2NLPB.html",
        "fct-type": "module",
        "title": "MaxSAT2NLPB"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter MaxSAT2NLPB",
        "module": "Converter.MaxSAT2NLPB",
        "name": "MaxSAT2NLPB",
        "normalized": "",
        "package": "toysolver",
        "partial": "Max SAT NLPB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2NLPB.html#v:convert",
      "description": {
        "fct-module": "Converter.MaxSAT2NLPB",
        "fct-package": "toysolver",
        "fct-signature": "WCNF -\u003e Formula",
        "fct-source": "src/Converter-MaxSAT2NLPB.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter MaxSAT2NLPB",
        "module": "Converter.MaxSAT2NLPB",
        "name": "convert",
        "normalized": "WCNF-\u003eFormula",
        "package": "toysolver",
        "partial": "",
        "signature": "WCNF-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2WBO.html#",
      "description": {
        "fct-module": "Converter.MaxSAT2WBO",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-MaxSAT2WBO.html",
        "fct-type": "module",
        "title": "MaxSAT2WBO"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter MaxSAT2WBO",
        "module": "Converter.MaxSAT2WBO",
        "name": "MaxSAT2WBO",
        "normalized": "",
        "package": "toysolver",
        "partial": "Max SAT WBO",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-MaxSAT2WBO.html#v:convert",
      "description": {
        "fct-module": "Converter.MaxSAT2WBO",
        "fct-package": "toysolver",
        "fct-signature": "WCNF -\u003e SoftFormula",
        "fct-source": "src/Converter-MaxSAT2WBO.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter MaxSAT2WBO",
        "module": "Converter.MaxSAT2WBO",
        "name": "convert",
        "normalized": "WCNF-\u003eSoftFormula",
        "package": "toysolver",
        "partial": "",
        "signature": "WCNF-\u003eSoftFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#",
      "description": {
        "fct-module": "Converter.ObjType",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-ObjType.html",
        "fct-type": "module",
        "title": "ObjType"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter ObjType",
        "module": "Converter.ObjType",
        "name": "ObjType",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#t:ObjType",
      "description": {
        "fct-module": "Converter.ObjType",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Converter-ObjType.html#ObjType",
        "fct-type": "data",
        "title": "ObjType"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter ObjType",
        "module": "Converter.ObjType",
        "name": "ObjType",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjMaxOne",
      "description": {
        "fct-module": "Converter.ObjType",
        "fct-package": "toysolver",
        "fct-signature": "ObjMaxOne",
        "fct-source": "src/Converter-ObjType.html#ObjType",
        "fct-type": "function",
        "title": "ObjMaxOne"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter ObjType",
        "module": "Converter.ObjType",
        "name": "ObjMaxOne",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Max One",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjMaxZero",
      "description": {
        "fct-module": "Converter.ObjType",
        "fct-package": "toysolver",
        "fct-signature": "ObjMaxZero",
        "fct-source": "src/Converter-ObjType.html#ObjType",
        "fct-type": "function",
        "title": "ObjMaxZero"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter ObjType",
        "module": "Converter.ObjType",
        "name": "ObjMaxZero",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Max Zero",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-ObjType.html#v:ObjNone",
      "description": {
        "fct-module": "Converter.ObjType",
        "fct-package": "toysolver",
        "fct-signature": "ObjNone",
        "fct-source": "src/Converter-ObjType.html#ObjType",
        "fct-type": "function",
        "title": "ObjNone"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter ObjType",
        "module": "Converter.ObjType",
        "name": "ObjNone",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj None",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LP.html#",
      "description": {
        "fct-module": "Converter.PB2LP",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-PB2LP.html",
        "fct-type": "module",
        "title": "PB2LP"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PB2LP",
        "module": "Converter.PB2LP",
        "name": "PB2LP",
        "normalized": "",
        "package": "toysolver",
        "partial": "PB LP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LP.html#v:convert",
      "description": {
        "fct-module": "Converter.PB2LP",
        "fct-package": "toysolver",
        "fct-signature": "Formula -\u003e (LP, Map Var Rational -\u003e Model)",
        "fct-source": "src/Converter-PB2LP.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PB2LP",
        "module": "Converter.PB2LP",
        "name": "convert",
        "normalized": "Formula-\u003e(LP,Map Var Rational-\u003eModel)",
        "package": "toysolver",
        "partial": "",
        "signature": "Formula-\u003e(LP,Map Var Rational-\u003eModel)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LP.html#v:convertWBO",
      "description": {
        "fct-module": "Converter.PB2LP",
        "fct-package": "toysolver",
        "fct-signature": "Bool -\u003e SoftFormula -\u003e (LP, Map Var Rational -\u003e Model)",
        "fct-source": "src/Converter-PB2LP.html#convertWBO",
        "fct-type": "function",
        "title": "convertWBO"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PB2LP",
        "module": "Converter.PB2LP",
        "name": "convertWBO",
        "normalized": "Bool-\u003eSoftFormula-\u003e(LP,Map Var Rational-\u003eModel)",
        "package": "toysolver",
        "partial": "WBO",
        "signature": "Bool-\u003eSoftFormula-\u003e(LP,Map Var Rational-\u003eModel)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LSP.html#",
      "description": {
        "fct-module": "Converter.PB2LSP",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-PB2LSP.html",
        "fct-type": "module",
        "title": "PB2LSP"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PB2LSP",
        "module": "Converter.PB2LSP",
        "name": "PB2LSP",
        "normalized": "",
        "package": "toysolver",
        "partial": "PB LSP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2LSP.html#v:convert",
      "description": {
        "fct-module": "Converter.PB2LSP",
        "fct-package": "toysolver",
        "fct-signature": "Formula -\u003e ShowS",
        "fct-source": "src/Converter-PB2LSP.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PB2LSP",
        "module": "Converter.PB2LSP",
        "name": "convert",
        "normalized": "Formula-\u003eShowS",
        "package": "toysolver",
        "partial": "",
        "signature": "Formula-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2SMP.html#",
      "description": {
        "fct-module": "Converter.PB2SMP",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-PB2SMP.html",
        "fct-type": "module",
        "title": "PB2SMP"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PB2SMP",
        "module": "Converter.PB2SMP",
        "name": "PB2SMP",
        "normalized": "",
        "package": "toysolver",
        "partial": "PB SMP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2SMP.html#v:convert",
      "description": {
        "fct-module": "Converter.PB2SMP",
        "fct-package": "toysolver",
        "fct-signature": "Bool -\u003e Formula -\u003e ShowS",
        "fct-source": "src/Converter-PB2SMP.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PB2SMP",
        "module": "Converter.PB2SMP",
        "name": "convert",
        "normalized": "Bool-\u003eFormula-\u003eShowS",
        "package": "toysolver",
        "partial": "",
        "signature": "Bool-\u003eFormula-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2WBO.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Improving Unsatisfiability-based Algorithms for Boolean Optimization\n   \u003ca\u003ehttp://sat.inesc-id.pt/~ruben/talks/sat10-talk.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Converter.PB2WBO",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-PB2WBO.html",
        "fct-type": "module",
        "title": "PB2WBO"
      },
      "index": {
        "description": "References Improving Unsatisfiability-based Algorithms for Boolean Optimization http sat.inesc-id.pt ruben talks sat10-talk.pdf",
        "hierarchy": "Converter PB2WBO",
        "module": "Converter.PB2WBO",
        "name": "PB2WBO",
        "normalized": "",
        "package": "toysolver",
        "partial": "PB WBO",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PB2WBO.html#v:convert",
      "description": {
        "fct-module": "Converter.PB2WBO",
        "fct-package": "toysolver",
        "fct-signature": "Formula -\u003e SoftFormula",
        "fct-source": "src/Converter-PB2WBO.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PB2WBO",
        "module": "Converter.PB2WBO",
        "name": "convert",
        "normalized": "Formula-\u003eSoftFormula",
        "package": "toysolver",
        "partial": "",
        "signature": "Formula-\u003eSoftFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#",
      "description": {
        "fct-module": "Converter.PBSetObj",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-PBSetObj.html",
        "fct-type": "module",
        "title": "PBSetObj"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PBSetObj",
        "module": "Converter.PBSetObj",
        "name": "PBSetObj",
        "normalized": "",
        "package": "toysolver",
        "partial": "PBSet Obj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#t:ObjType",
      "description": {
        "fct-module": "Converter.PBSetObj",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Converter-ObjType.html#ObjType",
        "fct-type": "data",
        "title": "ObjType"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PBSetObj",
        "module": "Converter.PBSetObj",
        "name": "ObjType",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#v:ObjMaxOne",
      "description": {
        "fct-module": "Converter.PBSetObj",
        "fct-package": "toysolver",
        "fct-signature": "ObjMaxOne",
        "fct-source": "src/Converter-ObjType.html#ObjType",
        "fct-type": "function",
        "title": "ObjMaxOne"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PBSetObj",
        "module": "Converter.PBSetObj",
        "name": "ObjMaxOne",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Max One",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#v:ObjMaxZero",
      "description": {
        "fct-module": "Converter.PBSetObj",
        "fct-package": "toysolver",
        "fct-signature": "ObjMaxZero",
        "fct-source": "src/Converter-ObjType.html#ObjType",
        "fct-type": "function",
        "title": "ObjMaxZero"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PBSetObj",
        "module": "Converter.PBSetObj",
        "name": "ObjMaxZero",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Max Zero",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#v:ObjNone",
      "description": {
        "fct-module": "Converter.PBSetObj",
        "fct-package": "toysolver",
        "fct-signature": "ObjNone",
        "fct-source": "src/Converter-ObjType.html#ObjType",
        "fct-type": "function",
        "title": "ObjNone"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PBSetObj",
        "module": "Converter.PBSetObj",
        "name": "ObjNone",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj None",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-PBSetObj.html#v:setObj",
      "description": {
        "fct-module": "Converter.PBSetObj",
        "fct-package": "toysolver",
        "fct-signature": "ObjType -\u003e Formula -\u003e Formula",
        "fct-source": "src/Converter-PBSetObj.html#setObj",
        "fct-type": "function",
        "title": "setObj"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter PBSetObj",
        "module": "Converter.PBSetObj",
        "name": "setObj",
        "normalized": "ObjType-\u003eFormula-\u003eFormula",
        "package": "toysolver",
        "partial": "Obj",
        "signature": "ObjType-\u003eFormula-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-SAT2LP.html#",
      "description": {
        "fct-module": "Converter.SAT2LP",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-SAT2LP.html",
        "fct-type": "module",
        "title": "SAT2LP"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter SAT2LP",
        "module": "Converter.SAT2LP",
        "name": "SAT2LP",
        "normalized": "",
        "package": "toysolver",
        "partial": "SAT LP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-SAT2LP.html#v:convert",
      "description": {
        "fct-module": "Converter.SAT2LP",
        "fct-package": "toysolver",
        "fct-signature": "CNF -\u003e (LP, Map Var Rational -\u003e Model)",
        "fct-source": "src/Converter-SAT2LP.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter SAT2LP",
        "module": "Converter.SAT2LP",
        "name": "convert",
        "normalized": "CNF-\u003e(LP,Map Var Rational-\u003eModel)",
        "package": "toysolver",
        "partial": "",
        "signature": "CNF-\u003e(LP,Map Var Rational-\u003eModel)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-SAT2PB.html#",
      "description": {
        "fct-module": "Converter.SAT2PB",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-SAT2PB.html",
        "fct-type": "module",
        "title": "SAT2PB"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter SAT2PB",
        "module": "Converter.SAT2PB",
        "name": "SAT2PB",
        "normalized": "",
        "package": "toysolver",
        "partial": "SAT PB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-SAT2PB.html#v:convert",
      "description": {
        "fct-module": "Converter.SAT2PB",
        "fct-package": "toysolver",
        "fct-signature": "CNF -\u003e Formula",
        "fct-source": "src/Converter-SAT2PB.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter SAT2PB",
        "module": "Converter.SAT2PB",
        "name": "convert",
        "normalized": "CNF-\u003eFormula",
        "package": "toysolver",
        "partial": "",
        "signature": "CNF-\u003eFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-WBO2PB.html#",
      "description": {
        "fct-module": "Converter.WBO2PB",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Converter-WBO2PB.html",
        "fct-type": "module",
        "title": "WBO2PB"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter WBO2PB",
        "module": "Converter.WBO2PB",
        "name": "WBO2PB",
        "normalized": "",
        "package": "toysolver",
        "partial": "WBO PB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Converter-WBO2PB.html#v:convert",
      "description": {
        "fct-module": "Converter.WBO2PB",
        "fct-package": "toysolver",
        "fct-signature": "SoftFormula -\u003e (Formula, Model -\u003e Model)",
        "fct-source": "src/Converter-WBO2PB.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Converter WBO2PB",
        "module": "Converter.WBO2PB",
        "name": "convert",
        "normalized": "SoftFormula-\u003e(Formula,Model-\u003eModel)",
        "package": "toysolver",
        "partial": "",
        "signature": "SoftFormula-\u003e(Formula,Model-\u003eModel)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlgebraic reals\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Why the concept of a field extension is a natural one\n   \u003ca\u003ehttp://www.dpmms.cam.ac.uk/~wtg10/galois.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-AlgebraicNumber-Real.html",
        "fct-type": "module",
        "title": "Real"
      },
      "index": {
        "description": "Algebraic reals Reference Why the concept of field extension is natural one http www.dpmms.cam.ac.uk wtg10 galois.html",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "Real",
        "normalized": "",
        "package": "toysolver",
        "partial": "Real",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#t:AReal",
      "description": {
        "fct-descr": "\u003cp\u003eAlgebraic real numbers.\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#AReal",
        "fct-type": "data",
        "title": "AReal"
      },
      "index": {
        "description": "Algebraic real numbers",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "AReal",
        "normalized": "",
        "package": "toysolver",
        "partial": "AReal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:approx",
      "description": {
        "fct-descr": "\u003cp\u003eReturns approximate rational value such that \u003ccode\u003eabs (a - approx a epsilon) \u003c= epsilon\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "AReal-\u003e Rational-\u003e Rational",
        "fct-type": "function",
        "title": "approx"
      },
      "index": {
        "description": "Returns approximate rational value such that abs approx epsilon epsilon",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "approx",
        "normalized": "AReal-\u003eRational-\u003eRational",
        "package": "toysolver",
        "partial": "",
        "signature": "AReal-\u003eRational-\u003eRational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:approxInterval",
      "description": {
        "fct-descr": "\u003cp\u003eReturns approximate interval such that \u003ccode\u003ewidth (approxInterval a epsilon) \u003c= epsilon\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "AReal-\u003e Rational-\u003e Interval Rational",
        "fct-type": "function",
        "title": "approxInterval"
      },
      "index": {
        "description": "Returns approximate interval such that width approxInterval epsilon epsilon",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "approxInterval",
        "normalized": "AReal-\u003eRational-\u003eInterval Rational",
        "package": "toysolver",
        "partial": "Interval",
        "signature": "AReal-\u003eRational-\u003eInterval Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:goldenRatio",
      "description": {
        "fct-descr": "\u003cp\u003eGolden ratio \n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "AReal",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#goldenRatio",
        "fct-type": "function",
        "title": "goldenRatio"
      },
      "index": {
        "description": "Golden ratio",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "goldenRatio",
        "normalized": "",
        "package": "toysolver",
        "partial": "Ratio",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:height",
      "description": {
        "fct-descr": "\u003cp\u003eHeight of the algebraic number.\n\u003c/p\u003e\u003cp\u003eThe height of an algebraic number is the greatest absolute value of the\n coefficients of the irreducible and primitive polynomial with integral\n rational coefficients.\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "AReal -\u003e Integer",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#height",
        "fct-type": "function",
        "title": "height"
      },
      "index": {
        "description": "Height of the algebraic number The height of an algebraic number is the greatest absolute value of the coefficients of the irreducible and primitive polynomial with integral rational coefficients",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "height",
        "normalized": "AReal-\u003eInteger",
        "package": "toysolver",
        "partial": "",
        "signature": "AReal-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:isAlgebraicInteger",
      "description": {
        "fct-descr": "\u003cp\u003eWhether the algebraic number is a root of a polynomial with integer\n coefficients with leading coefficient \u003ccode\u003e1\u003c/code\u003e (a monic polynomial).\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "AReal -\u003e Bool",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#isAlgebraicInteger",
        "fct-type": "function",
        "title": "isAlgebraicInteger"
      },
      "index": {
        "description": "Whether the algebraic number is root of polynomial with integer coefficients with leading coefficient monic polynomial",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "isAlgebraicInteger",
        "normalized": "AReal-\u003eBool",
        "package": "toysolver",
        "partial": "Algebraic Integer",
        "signature": "AReal-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:isRational",
      "description": {
        "fct-descr": "\u003cp\u003eWhether the algebraic number is a rational.\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "AReal -\u003e Bool",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#isRational",
        "fct-type": "function",
        "title": "isRational"
      },
      "index": {
        "description": "Whether the algebraic number is rational",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "isRational",
        "normalized": "AReal-\u003eBool",
        "package": "toysolver",
        "partial": "Rational",
        "signature": "AReal-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:minimalPolynomial",
      "description": {
        "fct-descr": "\u003cp\u003eThe polynomial of which the algebraic number is root.\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "AReal -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#minimalPolynomial",
        "fct-type": "function",
        "title": "minimalPolynomial"
      },
      "index": {
        "description": "The polynomial of which the algebraic number is root",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "minimalPolynomial",
        "normalized": "AReal-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Polynomial",
        "signature": "AReal-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:nthRoot",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003en\u003c/code\u003eth root of \u003ccode\u003ea\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "Integer -\u003e AReal -\u003e AReal",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#nthRoot",
        "fct-type": "function",
        "title": "nthRoot"
      },
      "index": {
        "description": "The th root of",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "nthRoot",
        "normalized": "Integer-\u003eAReal-\u003eAReal",
        "package": "toysolver",
        "partial": "Root",
        "signature": "Integer-\u003eAReal-\u003eAReal"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:realRoots",
      "description": {
        "fct-descr": "\u003cp\u003eReal roots of the polynomial in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e [AReal]",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#realRoots",
        "fct-type": "function",
        "title": "realRoots"
      },
      "index": {
        "description": "Real roots of the polynomial in ascending order",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "realRoots",
        "normalized": "UPolynomial Rational-\u003e[AReal]",
        "package": "toysolver",
        "partial": "Roots",
        "signature": "UPolynomial Rational-\u003e[AReal]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:realRootsEx",
      "description": {
        "fct-descr": "\u003cp\u003eReal roots of the polynomial in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial AReal -\u003e [AReal]",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#realRootsEx",
        "fct-type": "function",
        "title": "realRootsEx"
      },
      "index": {
        "description": "Real roots of the polynomial in ascending order",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "realRootsEx",
        "normalized": "UPolynomial AReal-\u003e[AReal]",
        "package": "toysolver",
        "partial": "Roots Ex",
        "signature": "UPolynomial AReal-\u003e[AReal]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:rootIndex",
      "description": {
        "fct-descr": "\u003cp\u003eroot index, satisfying\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003erealRoots\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eminimalPolynomial\u003c/a\u003e\u003c/code\u003e a) !! rootIndex a == a\n\u003c/pre\u003e",
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "AReal -\u003e Int",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#rootIndex",
        "fct-type": "function",
        "title": "rootIndex"
      },
      "index": {
        "description": "root index satisfying realRoots minimalPolynomial rootIndex",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "rootIndex",
        "normalized": "AReal-\u003eInt",
        "package": "toysolver",
        "partial": "Index",
        "signature": "AReal-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Real.html#v:simpARealPoly",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Real",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial AReal -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Real.html#simpARealPoly",
        "fct-type": "function",
        "title": "simpARealPoly"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Real",
        "module": "Data.AlgebraicNumber.Real",
        "name": "simpARealPoly",
        "normalized": "UPolynomial AReal-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "AReal Poly",
        "signature": "UPolynomial AReal-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eManipulating polynomials for corresponding operations for algebraic numbers.\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.dpmms.cam.ac.uk/~wtg10/galois.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-AlgebraicNumber-Root.html",
        "fct-type": "module",
        "title": "Root"
      },
      "index": {
        "description": "Manipulating polynomials for corresponding operations for algebraic numbers Reference http www.dpmms.cam.ac.uk wtg10 galois.html",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "Root",
        "normalized": "",
        "package": "toysolver",
        "partial": "Root",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#t:Var",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:findPoly",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial Rational Var -\u003e [Polynomial Rational Var] -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#findPoly",
        "fct-type": "function",
        "title": "findPoly"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "findPoly",
        "normalized": "Polynomial Rational Var-\u003e[Polynomial Rational Var]-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Poly",
        "signature": "Polynomial Rational Var-\u003e[Polynomial Rational Var]-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:lift2",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e a -\u003e a) -\u003e UPolynomial Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#lift2",
        "fct-type": "function",
        "title": "lift2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "lift2",
        "normalized": "a-\u003ea-\u003ea)-\u003eUPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003ea-\u003ea)-\u003eUPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:normalizePoly",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#normalizePoly",
        "fct-type": "function",
        "title": "normalizePoly"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "normalizePoly",
        "normalized": "UPolynomial Rational-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Poly",
        "signature": "UPolynomial Rational-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootAdd",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#rootAdd",
        "fct-type": "function",
        "title": "rootAdd"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "rootAdd",
        "normalized": "UPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Add",
        "signature": "UPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootMul",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#rootMul",
        "fct-type": "function",
        "title": "rootMul"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "rootMul",
        "normalized": "UPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Mul",
        "signature": "UPolynomial Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootNthRoot",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "Integer -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#rootNthRoot",
        "fct-type": "function",
        "title": "rootNthRoot"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "rootNthRoot",
        "normalized": "Integer-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Nth Root",
        "signature": "Integer-\u003eUPolynomial Rational-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootRecip",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#rootRecip",
        "fct-type": "function",
        "title": "rootRecip"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "rootRecip",
        "normalized": "UPolynomial Rational-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Recip",
        "signature": "UPolynomial Rational-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootScale",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#rootScale",
        "fct-type": "function",
        "title": "rootScale"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "rootScale",
        "normalized": "Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Scale",
        "signature": "Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootShift",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "Rational -\u003e UPolynomial Rational -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#rootShift",
        "fct-type": "function",
        "title": "rootShift"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "rootShift",
        "normalized": "Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Shift",
        "signature": "Rational-\u003eUPolynomial Rational-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-AlgebraicNumber-Root.html#v:rootSimpPoly",
      "description": {
        "fct-module": "Data.AlgebraicNumber.Root",
        "fct-package": "toysolver",
        "fct-signature": "(a -\u003e UPolynomial Rational) -\u003e UPolynomial a -\u003e UPolynomial Rational",
        "fct-source": "src/Data-AlgebraicNumber-Root.html#rootSimpPoly",
        "fct-type": "function",
        "title": "rootSimpPoly"
      },
      "index": {
        "description": "",
        "hierarchy": "Data AlgebraicNumber Root",
        "module": "Data.AlgebraicNumber.Root",
        "name": "rootSimpPoly",
        "normalized": "(a-\u003eUPolynomial Rational)-\u003eUPolynomial a-\u003eUPolynomial Rational",
        "package": "toysolver",
        "partial": "Simp Poly",
        "signature": "(a-\u003eUPolynomial Rational)-\u003eUPolynomial a-\u003eUPolynomial Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eArithmetic relations\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-ArithRel.html",
        "fct-type": "module",
        "title": "ArithRel"
      },
      "index": {
        "description": "Arithmetic relations",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "ArithRel",
        "normalized": "",
        "package": "toysolver",
        "partial": "Arith Rel",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#t:IsRel",
      "description": {
        "fct-descr": "\u003cp\u003etype class for constructing relational formula\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-ArithRel.html#IsRel",
        "fct-type": "class",
        "title": "IsRel"
      },
      "index": {
        "description": "type class for constructing relational formula",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "IsRel",
        "normalized": "",
        "package": "toysolver",
        "partial": "Is Rel",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#t:Rel",
      "description": {
        "fct-descr": "\u003cp\u003eAtomic formula\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-ArithRel.html#Rel",
        "fct-type": "data",
        "title": "Rel"
      },
      "index": {
        "description": "Atomic formula",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "Rel",
        "normalized": "",
        "package": "toysolver",
        "partial": "Rel",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#t:RelOp",
      "description": {
        "fct-descr": "\u003cp\u003erelational operators\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "data",
        "title": "RelOp"
      },
      "index": {
        "description": "relational operators",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "RelOp",
        "normalized": "",
        "package": "toysolver",
        "partial": "Rel Op",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-47--61-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%2F%3D.",
        "fct-type": "function",
        "title": "(./=.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "(./=.) ./=.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-60--61-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3C%3D.",
        "fct-type": "function",
        "title": "(.\u003c=.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "(.\u003c=.) .\u003c=.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-60-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3C.",
        "fct-type": "function",
        "title": "(.\u003c.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "(.\u003c.) .\u003c.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-61--61-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3D%3D.",
        "fct-type": "function",
        "title": "(.==.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "(.==.) .==.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-62--61-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3E%3D.",
        "fct-type": "function",
        "title": "(.\u003e=.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "(.\u003e=.) .\u003e=.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:.-62-.",
      "description": {
        "fct-descr": "\u003cp\u003econstructing relational formula\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#.%3E.",
        "fct-type": "function",
        "title": "(.\u003e.)"
      },
      "index": {
        "description": "constructing relational formula",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "(.\u003e.) .\u003e.",
        "normalized": "a-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "e-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Eql",
      "description": {
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "Eql",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Eql"
      },
      "index": {
        "description": "",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "Eql",
        "normalized": "",
        "package": "toysolver",
        "partial": "Eql",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Ge",
      "description": {
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "Ge",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Ge"
      },
      "index": {
        "description": "",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "Ge",
        "normalized": "",
        "package": "toysolver",
        "partial": "Ge",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Gt",
      "description": {
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "Gt",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Gt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "Gt",
        "normalized": "",
        "package": "toysolver",
        "partial": "Gt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Le",
      "description": {
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "Le",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Le"
      },
      "index": {
        "description": "",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "Le",
        "normalized": "",
        "package": "toysolver",
        "partial": "Le",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Lt",
      "description": {
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "Lt",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "Lt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "Lt",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lt",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:NEq",
      "description": {
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "NEq",
        "fct-source": "src/Data-ArithRel.html#RelOp",
        "fct-type": "function",
        "title": "NEq"
      },
      "index": {
        "description": "",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "NEq",
        "normalized": "",
        "package": "toysolver",
        "partial": "NEq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:Rel",
      "description": {
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "Rel e RelOp e",
        "fct-source": "src/Data-ArithRel.html#Rel",
        "fct-type": "function",
        "title": "Rel"
      },
      "index": {
        "description": "",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "Rel",
        "normalized": "",
        "package": "toysolver",
        "partial": "Rel",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:evalOp",
      "description": {
        "fct-descr": "\u003cp\u003eevaluate an operator into a comparision function\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "RelOp -\u003e a -\u003e a -\u003e Bool",
        "fct-source": "src/Data-ArithRel.html#evalOp",
        "fct-type": "function",
        "title": "evalOp"
      },
      "index": {
        "description": "evaluate an operator into comparision function",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "evalOp",
        "normalized": "RelOp-\u003ea-\u003ea-\u003eBool",
        "package": "toysolver",
        "partial": "Op",
        "signature": "RelOp-\u003ea-\u003ea-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:flipOp",
      "description": {
        "fct-descr": "\u003cp\u003eflipping relational operator\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003erel (flipOp op) a b\u003c/code\u003e is equivalent to \u003ccode\u003erel op b a\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "RelOp -\u003e RelOp",
        "fct-source": "src/Data-ArithRel.html#flipOp",
        "fct-type": "function",
        "title": "flipOp"
      },
      "index": {
        "description": "flipping relational operator rel flipOp op is equivalent to rel op",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "flipOp",
        "normalized": "RelOp-\u003eRelOp",
        "package": "toysolver",
        "partial": "Op",
        "signature": "RelOp-\u003eRelOp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:negOp",
      "description": {
        "fct-descr": "\u003cp\u003enegating relational operator\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003erel (negOp op) a b\u003c/code\u003e is equivalent to \u003ccode\u003enotB (rel op a b)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "RelOp -\u003e RelOp",
        "fct-source": "src/Data-ArithRel.html#negOp",
        "fct-type": "function",
        "title": "negOp"
      },
      "index": {
        "description": "negating relational operator rel negOp op is equivalent to notB rel op",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "negOp",
        "normalized": "RelOp-\u003eRelOp",
        "package": "toysolver",
        "partial": "Op",
        "signature": "RelOp-\u003eRelOp"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:rel",
      "description": {
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "RelOp -\u003e e -\u003e e -\u003e r",
        "fct-source": "src/Data-ArithRel.html#rel",
        "fct-type": "method",
        "title": "rel"
      },
      "index": {
        "description": "",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "rel",
        "normalized": "RelOp-\u003ea-\u003ea-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "RelOp-\u003ee-\u003ee-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-ArithRel.html#v:showOp",
      "description": {
        "fct-descr": "\u003cp\u003eoperator symbol\n\u003c/p\u003e",
        "fct-module": "Data.ArithRel",
        "fct-package": "toysolver",
        "fct-signature": "RelOp -\u003e String",
        "fct-source": "src/Data-ArithRel.html#showOp",
        "fct-type": "function",
        "title": "showOp"
      },
      "index": {
        "description": "operator symbol",
        "hierarchy": "Data ArithRel",
        "module": "Data.ArithRel",
        "name": "showOp",
        "normalized": "RelOp-\u003eString",
        "package": "toysolver",
        "partial": "Op",
        "signature": "RelOp-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-DNF.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDisjunctive Normal Form\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.DNF",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-DNF.html",
        "fct-type": "module",
        "title": "DNF"
      },
      "index": {
        "description": "Disjunctive Normal Form",
        "hierarchy": "Data DNF",
        "module": "Data.DNF",
        "name": "DNF",
        "normalized": "",
        "package": "toysolver",
        "partial": "DNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-DNF.html#t:DNF",
      "description": {
        "fct-descr": "\u003cp\u003eDisjunctive normal form\n\u003c/p\u003e",
        "fct-module": "Data.DNF",
        "fct-package": "toysolver",
        "fct-signature": "newtype",
        "fct-source": "src/Data-DNF.html#DNF",
        "fct-type": "newtype",
        "title": "DNF"
      },
      "index": {
        "description": "Disjunctive normal form",
        "hierarchy": "Data DNF",
        "module": "Data.DNF",
        "name": "DNF",
        "normalized": "",
        "package": "toysolver",
        "partial": "DNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-DNF.html#v:DNF",
      "description": {
        "fct-module": "Data.DNF",
        "fct-package": "toysolver",
        "fct-signature": "DNF",
        "fct-source": "src/Data-DNF.html#DNF",
        "fct-type": "function",
        "title": "DNF"
      },
      "index": {
        "description": "",
        "hierarchy": "Data DNF",
        "module": "Data.DNF",
        "name": "DNF",
        "normalized": "",
        "package": "toysolver",
        "partial": "DNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-DNF.html#v:unDNF",
      "description": {
        "fct-descr": "\u003cp\u003elist of conjunction of literals\n\u003c/p\u003e",
        "fct-module": "Data.DNF",
        "fct-package": "toysolver",
        "fct-signature": "[[lit]]",
        "fct-source": "src/Data-DNF.html#DNF",
        "fct-type": "function",
        "title": "unDNF"
      },
      "index": {
        "description": "list of conjunction of literals",
        "hierarchy": "Data DNF",
        "module": "Data.DNF",
        "name": "unDNF",
        "normalized": "[[a]]",
        "package": "toysolver",
        "partial": "DNF",
        "signature": "[[lit]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAugmenting number types with infinitesimal parameter &#948;.\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Bruno Dutertre and Leonardo de Moura,\n   \"\u003cem\u003eA Fast Linear-Arithmetic Solver for DPLL(T)\u003c/em\u003e\",\n   Computer Aided Verification In Computer Aided Verification, Vol. 4144\n   (2006), pp. 81-94.\n   \u003ca\u003ehttp://dx.doi.org/10.1007/11817963_11\u003c/a\u003e\n   \u003ca\u003ehttp://yices.csl.sri.com/cav06.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Delta.html",
        "fct-type": "module",
        "title": "Delta"
      },
      "index": {
        "description": "Augmenting number types with infinitesimal parameter Reference Bruno Dutertre and Leonardo de Moura Fast Linear-Arithmetic Solver for DPLL Computer Aided Verification In Computer Aided Verification Vol pp http dx.doi.org http yices.csl.sri.com cav06.pdf",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "Delta",
        "normalized": "",
        "package": "toysolver",
        "partial": "Delta",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#t:Delta",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eDelta r k\u003c/code\u003e represents r + k&#948; for symbolic infinitesimal parameter &#948;.\n\u003c/p\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Delta.html#Delta",
        "fct-type": "data",
        "title": "Delta"
      },
      "index": {
        "description": "Delta represents for symbolic infinitesimal parameter",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "Delta",
        "normalized": "",
        "package": "toysolver",
        "partial": "Delta",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:Delta",
      "description": {
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "Delta !r !r",
        "fct-source": "src/Data-Delta.html#Delta",
        "fct-type": "function",
        "title": "Delta"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "Delta",
        "normalized": "",
        "package": "toysolver",
        "partial": "Delta",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:ceiling-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDelta\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003eceiling\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eceiling'\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the least integer not less than \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "Delta r -\u003e a",
        "fct-source": "src/Data-Delta.html#ceiling%27",
        "fct-type": "function",
        "title": "ceiling'"
      },
      "index": {
        "description": "Delta version of ceiling ceiling returns the least integer not less than",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "ceiling'",
        "normalized": "Delta a-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "Delta r-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:delta",
      "description": {
        "fct-descr": "\u003cp\u003esymbolic infinitesimal parameter &#948;.\n\u003c/p\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "Delta r",
        "fct-source": "src/Data-Delta.html#delta",
        "fct-type": "function",
        "title": "delta"
      },
      "index": {
        "description": "symbolic infinitesimal parameter",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "delta",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:deltaPart",
      "description": {
        "fct-descr": "\u003cp\u003eExtracts the &#948; part..\n\u003c/p\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "Delta r -\u003e r",
        "fct-source": "src/Data-Delta.html#deltaPart",
        "fct-type": "function",
        "title": "deltaPart"
      },
      "index": {
        "description": "Extracts the part",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "deltaPart",
        "normalized": "Delta a-\u003ea",
        "package": "toysolver",
        "partial": "Part",
        "signature": "Delta r-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:floor-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDelta\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efloor'\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the greatest integer not greater than \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "Delta r -\u003e a",
        "fct-source": "src/Data-Delta.html#floor%27",
        "fct-type": "function",
        "title": "floor'"
      },
      "index": {
        "description": "Delta version of floor floor returns the greatest integer not greater than",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "floor'",
        "normalized": "Delta a-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "Delta r-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:fromReal",
      "description": {
        "fct-descr": "\u003cp\u003eConversion from a base \u003ccode\u003er\u003c/code\u003e value to \u003ccode\u003eDelta r\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "r -\u003e Delta r",
        "fct-source": "src/Data-Delta.html#fromReal",
        "fct-type": "function",
        "title": "fromReal"
      },
      "index": {
        "description": "Conversion from base value to Delta",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "fromReal",
        "normalized": "a-\u003eDelta a",
        "package": "toysolver",
        "partial": "Real",
        "signature": "r-\u003eDelta r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:isInteger-39-",
      "description": {
        "fct-descr": "\u003cp\u003eIs this a integer?\n\u003c/p\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "Delta r -\u003e Bool",
        "fct-source": "src/Data-Delta.html#isInteger%27",
        "fct-type": "function",
        "title": "isInteger'"
      },
      "index": {
        "description": "Is this integer",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "isInteger'",
        "normalized": "Delta a-\u003eBool",
        "package": "toysolver",
        "partial": "Integer'",
        "signature": "Delta r-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Delta.html#v:realPart",
      "description": {
        "fct-descr": "\u003cp\u003eExtracts the real part..\n\u003c/p\u003e",
        "fct-module": "Data.Delta",
        "fct-package": "toysolver",
        "fct-signature": "Delta r -\u003e r",
        "fct-source": "src/Data-Delta.html#realPart",
        "fct-type": "function",
        "title": "realPart"
      },
      "index": {
        "description": "Extracts the real part",
        "hierarchy": "Data Delta",
        "module": "Data.Delta",
        "name": "realPart",
        "normalized": "Delta a-\u003ea",
        "package": "toysolver",
        "partial": "Part",
        "signature": "Delta r-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eArithmetic language (not limited to linear ones).\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-FOL-Arith.html",
        "fct-type": "module",
        "title": "Arith"
      },
      "index": {
        "description": "Arithmetic language not limited to linear ones",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "Arith",
        "normalized": "",
        "package": "toysolver",
        "partial": "Arith",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#t:Atom",
      "description": {
        "fct-descr": "\u003cp\u003eAtomic formula\n\u003c/p\u003e",
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-FOL-Arith.html#Atom",
        "fct-type": "type",
        "title": "Atom"
      },
      "index": {
        "description": "Atomic formula",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "Atom",
        "normalized": "",
        "package": "toysolver",
        "partial": "Atom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#t:Expr",
      "description": {
        "fct-descr": "\u003cp\u003eArithmetic expressions\n\u003c/p\u003e",
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-FOL-Arith.html#Expr",
        "fct-type": "data",
        "title": "Expr"
      },
      "index": {
        "description": "Arithmetic expressions",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "Expr",
        "normalized": "",
        "package": "toysolver",
        "partial": "Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#t:SatResult",
      "description": {
        "fct-descr": "\u003cp\u003eresults of satisfiability checking\n\u003c/p\u003e",
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-FOL-Arith.html#SatResult",
        "fct-type": "data",
        "title": "SatResult"
      },
      "index": {
        "description": "results of satisfiability checking",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "SatResult",
        "normalized": "",
        "package": "toysolver",
        "partial": "Sat Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v::-42-:",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "(Expr r) :*: (Expr r)",
        "fct-source": "src/Data-FOL-Arith.html#Expr",
        "fct-type": "function",
        "title": ":*:"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": ":*:",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v::-43-:",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "(Expr r) :+: (Expr r)",
        "fct-source": "src/Data-FOL-Arith.html#Expr",
        "fct-type": "function",
        "title": ":+:"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": ":+:",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v::-47-:",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "(Expr r) :/: (Expr r)",
        "fct-source": "src/Data-FOL-Arith.html#Expr",
        "fct-type": "function",
        "title": ":/:"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": ":/:",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Const",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "Const r",
        "fct-source": "src/Data-FOL-Arith.html#Expr",
        "fct-type": "function",
        "title": "Const"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "Const",
        "normalized": "",
        "package": "toysolver",
        "partial": "Const",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Sat",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "Sat (Model r)",
        "fct-source": "src/Data-FOL-Arith.html#SatResult",
        "fct-type": "function",
        "title": "Sat"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "Sat",
        "normalized": "",
        "package": "toysolver",
        "partial": "Sat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Unknown",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "Unknown",
        "fct-source": "src/Data-FOL-Arith.html#SatResult",
        "fct-type": "function",
        "title": "Unknown"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "Unknown",
        "normalized": "",
        "package": "toysolver",
        "partial": "Unknown",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Unsat",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "Unsat",
        "fct-source": "src/Data-FOL-Arith.html#SatResult",
        "fct-type": "function",
        "title": "Unsat"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "Unsat",
        "normalized": "",
        "package": "toysolver",
        "partial": "Unsat",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:Var",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "Var Var",
        "fct-source": "src/Data-FOL-Arith.html#Expr",
        "fct-type": "function",
        "title": "Var"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:evalAtom",
      "description": {
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "Model r -\u003e Atom r -\u003e Bool",
        "fct-source": "src/Data-FOL-Arith.html#evalAtom",
        "fct-type": "function",
        "title": "evalAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "evalAtom",
        "normalized": "Model a-\u003eAtom a-\u003eBool",
        "package": "toysolver",
        "partial": "Atom",
        "signature": "Model r-\u003eAtom r-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:evalExpr",
      "description": {
        "fct-descr": "\u003cp\u003eevaluate an \u003ccode\u003e\u003ca\u003eExpr\u003c/a\u003e\u003c/code\u003e with respect to a \u003ccode\u003e\u003ca\u003eModel\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "Model r -\u003e Expr r -\u003e r",
        "fct-source": "src/Data-FOL-Arith.html#evalExpr",
        "fct-type": "function",
        "title": "evalExpr"
      },
      "index": {
        "description": "evaluate an Expr with respect to Model",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "evalExpr",
        "normalized": "Model a-\u003eExpr a-\u003ea",
        "package": "toysolver",
        "partial": "Expr",
        "signature": "Model r-\u003eExpr r-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Arith.html#v:var",
      "description": {
        "fct-descr": "\u003cp\u003esingle variable expression\n\u003c/p\u003e",
        "fct-module": "Data.FOL.Arith",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Expr r",
        "fct-source": "src/Data-FOL-Arith.html#var",
        "fct-type": "function",
        "title": "var"
      },
      "index": {
        "description": "single variable expression",
        "hierarchy": "Data FOL Arith",
        "module": "Data.FOL.Arith",
        "name": "var",
        "normalized": "Var-\u003eExpr a",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eExpr r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFormula of first order logic.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-FOL-Formula.html",
        "fct-type": "module",
        "title": "Formula"
      },
      "index": {
        "description": "Formula of first order logic",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Formula",
        "normalized": "",
        "package": "toysolver",
        "partial": "Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#t:Formula",
      "description": {
        "fct-descr": "\u003cp\u003eformulas of first order logic\n\u003c/p\u003e",
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "data",
        "title": "Formula"
      },
      "index": {
        "description": "formulas of first order logic",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Formula",
        "normalized": "",
        "package": "toysolver",
        "partial": "Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:And",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "And (Formula a) (Formula a)",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "And"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "And",
        "normalized": "",
        "package": "toysolver",
        "partial": "And",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Atom",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "Atom a",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "Atom"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Atom",
        "normalized": "",
        "package": "toysolver",
        "partial": "Atom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Equiv",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "Equiv (Formula a) (Formula a)",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "Equiv"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Equiv",
        "normalized": "",
        "package": "toysolver",
        "partial": "Equiv",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Exists",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "Exists Var (Formula a)",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "Exists"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Exists",
        "normalized": "",
        "package": "toysolver",
        "partial": "Exists",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:F",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "F",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "F"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "F",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Forall",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "Forall Var (Formula a)",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "Forall"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Forall",
        "normalized": "",
        "package": "toysolver",
        "partial": "Forall",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Imply",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "Imply (Formula a) (Formula a)",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "Imply"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Imply",
        "normalized": "",
        "package": "toysolver",
        "partial": "Imply",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Not",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "Not (Formula a)",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "Not"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Not",
        "normalized": "",
        "package": "toysolver",
        "partial": "Not",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:Or",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "Or (Formula a) (Formula a)",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "Or"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "Or",
        "normalized": "",
        "package": "toysolver",
        "partial": "Or",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:T",
      "description": {
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "T",
        "fct-source": "src/Data-FOL-Formula.html#Formula",
        "fct-type": "function",
        "title": "T"
      },
      "index": {
        "description": "",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "T",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-FOL-Formula.html#v:pushNot",
      "description": {
        "fct-descr": "\u003cp\u003econvert a formula into negation normal form\n\u003c/p\u003e",
        "fct-module": "Data.FOL.Formula",
        "fct-package": "toysolver",
        "fct-signature": "Formula a -\u003e Formula a",
        "fct-source": "src/Data-FOL-Formula.html#pushNot",
        "fct-type": "function",
        "title": "pushNot"
      },
      "index": {
        "description": "convert formula into negation normal form",
        "hierarchy": "Data FOL Formula",
        "module": "Data.FOL.Formula",
        "name": "pushNot",
        "normalized": "Formula a-\u003eFormula a",
        "package": "toysolver",
        "partial": "Not",
        "signature": "Formula a-\u003eFormula a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#",
      "description": {
        "fct-module": "Data.LA.FOL",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-LA-FOL.html",
        "fct-type": "module",
        "title": "FOL"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA FOL",
        "module": "Data.LA.FOL",
        "name": "FOL",
        "normalized": "",
        "package": "toysolver",
        "partial": "FOL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#v:fromFOLAtom",
      "description": {
        "fct-module": "Data.LA.FOL",
        "fct-package": "toysolver",
        "fct-signature": "Atom r -\u003e Maybe (Atom r)",
        "fct-source": "src/Data-LA-FOL.html#fromFOLAtom",
        "fct-type": "function",
        "title": "fromFOLAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA FOL",
        "module": "Data.LA.FOL",
        "name": "fromFOLAtom",
        "normalized": "Atom a-\u003eMaybe(Atom a)",
        "package": "toysolver",
        "partial": "FOLAtom",
        "signature": "Atom r-\u003eMaybe(Atom r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#v:fromFOLExpr",
      "description": {
        "fct-module": "Data.LA.FOL",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e Maybe (Expr r)",
        "fct-source": "src/Data-LA-FOL.html#fromFOLExpr",
        "fct-type": "function",
        "title": "fromFOLExpr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA FOL",
        "module": "Data.LA.FOL",
        "name": "fromFOLExpr",
        "normalized": "Expr a-\u003eMaybe(Expr a)",
        "package": "toysolver",
        "partial": "FOLExpr",
        "signature": "Expr r-\u003eMaybe(Expr r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#v:toFOLExpr",
      "description": {
        "fct-module": "Data.LA.FOL",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e Expr r",
        "fct-source": "src/Data-LA-FOL.html#toFOLExpr",
        "fct-type": "function",
        "title": "toFOLExpr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA FOL",
        "module": "Data.LA.FOL",
        "name": "toFOLExpr",
        "normalized": "Expr a-\u003eExpr a",
        "package": "toysolver",
        "partial": "FOLExpr",
        "signature": "Expr r-\u003eExpr r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA-FOL.html#v:toFOLFormula",
      "description": {
        "fct-module": "Data.LA.FOL",
        "fct-package": "toysolver",
        "fct-signature": "Atom r -\u003e Formula (Atom r)",
        "fct-source": "src/Data-LA-FOL.html#toFOLFormula",
        "fct-type": "function",
        "title": "toFOLFormula"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA FOL",
        "module": "Data.LA.FOL",
        "name": "toFOLFormula",
        "normalized": "Atom a-\u003eFormula(Atom a)",
        "package": "toysolver",
        "partial": "FOLFormula",
        "signature": "Atom r-\u003eFormula(Atom r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome definition for Theory of Linear Arithmetics.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-LA.html",
        "fct-type": "module",
        "title": "LA"
      },
      "index": {
        "description": "Some definition for Theory of Linear Arithmetics",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "LA",
        "normalized": "",
        "package": "toysolver",
        "partial": "LA",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#t:Atom",
      "description": {
        "fct-descr": "\u003cp\u003eAtomic Formula of Linear Arithmetics\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-LA.html#Atom",
        "fct-type": "type",
        "title": "Atom"
      },
      "index": {
        "description": "Atomic Formula of Linear Arithmetics",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "Atom",
        "normalized": "",
        "package": "toysolver",
        "partial": "Atom",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#t:BoundsEnv",
      "description": {
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-LA.html#BoundsEnv",
        "fct-type": "type",
        "title": "BoundsEnv"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "BoundsEnv",
        "normalized": "",
        "package": "toysolver",
        "partial": "Bounds Env",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#t:Expr",
      "description": {
        "fct-descr": "\u003cp\u003eLinear combination of variables and constants.\n Non-negative keys are used for variables's coefficients.\n key \u003ccode\u003e\u003ca\u003eunitVar\u003c/a\u003e\u003c/code\u003e is used for constants.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-LA.html#Expr",
        "fct-type": "data",
        "title": "Expr"
      },
      "index": {
        "description": "Linear combination of variables and constants Non-negative keys are used for variables coefficients key unitVar is used for constants",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "Expr",
        "normalized": "",
        "package": "toysolver",
        "partial": "Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:applySubst",
      "description": {
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "VarMap (Expr r) -\u003e Expr r -\u003e Expr r",
        "fct-source": "src/Data-LA.html#applySubst",
        "fct-type": "function",
        "title": "applySubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "applySubst",
        "normalized": "VarMap(Expr a)-\u003eExpr a-\u003eExpr a",
        "package": "toysolver",
        "partial": "Subst",
        "signature": "VarMap(Expr r)-\u003eExpr r-\u003eExpr r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:applySubst1",
      "description": {
        "fct-descr": "\u003cp\u003eapplySubst1 x e e1 == e1[e/x]\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Expr r -\u003e Expr r -\u003e Expr r",
        "fct-source": "src/Data-LA.html#applySubst1",
        "fct-type": "function",
        "title": "applySubst1"
      },
      "index": {
        "description": "applySubst1 e1 e1",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "applySubst1",
        "normalized": "Var-\u003eExpr a-\u003eExpr a-\u003eExpr a",
        "package": "toysolver",
        "partial": "Subst",
        "signature": "Var-\u003eExpr r-\u003eExpr r-\u003eExpr r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:asConst",
      "description": {
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e Maybe r",
        "fct-source": "src/Data-LA.html#asConst",
        "fct-type": "function",
        "title": "asConst"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "asConst",
        "normalized": "Expr a-\u003eMaybe a",
        "package": "toysolver",
        "partial": "Const",
        "signature": "Expr r-\u003eMaybe r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:coeff",
      "description": {
        "fct-descr": "\u003cp\u003elookup a coefficient of the variable.\n \u003ccode\u003e\n   coeff v e == fst (extract v e)\n \u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Expr r -\u003e r",
        "fct-source": "src/Data-LA.html#coeff",
        "fct-type": "function",
        "title": "coeff"
      },
      "index": {
        "description": "lookup coefficient of the variable coeff fst extract",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "coeff",
        "normalized": "Var-\u003eExpr a-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eExpr r-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:coeffMap",
      "description": {
        "fct-descr": "\u003cp\u003ea mapping from variables to coefficients\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e IntMap r",
        "fct-source": "src/Data-LA.html#coeffMap",
        "fct-type": "function",
        "title": "coeffMap"
      },
      "index": {
        "description": "mapping from variables to coefficients",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "coeffMap",
        "normalized": "Expr a-\u003eIntMap a",
        "package": "toysolver",
        "partial": "Map",
        "signature": "Expr r-\u003eIntMap r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:computeInterval",
      "description": {
        "fct-descr": "\u003cp\u003ecompute bounds for a \u003ccode\u003eExpr\u003c/code\u003e with respect to \u003ccode\u003eBoundsEnv\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "BoundsEnv r -\u003e Expr r -\u003e Interval r",
        "fct-source": "src/Data-LA.html#computeInterval",
        "fct-type": "function",
        "title": "computeInterval"
      },
      "index": {
        "description": "compute bounds for Expr with respect to BoundsEnv",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "computeInterval",
        "normalized": "BoundsEnv a-\u003eExpr a-\u003eInterval a",
        "package": "toysolver",
        "partial": "Interval",
        "signature": "BoundsEnv r-\u003eExpr r-\u003eInterval r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:constant",
      "description": {
        "fct-descr": "\u003cp\u003econstant\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "r -\u003e Expr r",
        "fct-source": "src/Data-LA.html#constant",
        "fct-type": "function",
        "title": "constant"
      },
      "index": {
        "description": "constant",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "constant",
        "normalized": "a-\u003eExpr a",
        "package": "toysolver",
        "partial": "",
        "signature": "r-\u003eExpr r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:evalAtom",
      "description": {
        "fct-descr": "\u003cp\u003eevaluate the formula under the model.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Model r -\u003e Atom r -\u003e Bool",
        "fct-source": "src/Data-LA.html#evalAtom",
        "fct-type": "function",
        "title": "evalAtom"
      },
      "index": {
        "description": "evaluate the formula under the model",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "evalAtom",
        "normalized": "Model a-\u003eAtom a-\u003eBool",
        "package": "toysolver",
        "partial": "Atom",
        "signature": "Model r-\u003eAtom r-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:evalExpr",
      "description": {
        "fct-descr": "\u003cp\u003eevaluate the expression under the model.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Model r -\u003e Expr r -\u003e r",
        "fct-source": "src/Data-LA.html#evalExpr",
        "fct-type": "function",
        "title": "evalExpr"
      },
      "index": {
        "description": "evaluate the expression under the model",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "evalExpr",
        "normalized": "Model a-\u003eExpr a-\u003ea",
        "package": "toysolver",
        "partial": "Expr",
        "signature": "Model r-\u003eExpr r-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:evalLinear",
      "description": {
        "fct-descr": "\u003cp\u003eevaluate the expression under the model.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Model a -\u003e a -\u003e Expr (Scalar a) -\u003e a",
        "fct-source": "src/Data-LA.html#evalLinear",
        "fct-type": "function",
        "title": "evalLinear"
      },
      "index": {
        "description": "evaluate the expression under the model",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "evalLinear",
        "normalized": "Model a-\u003ea-\u003eExpr(Scalar a)-\u003ea",
        "package": "toysolver",
        "partial": "Linear",
        "signature": "Model a-\u003ea-\u003eExpr(Scalar a)-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:extract",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eextract v e\u003c/code\u003e returns \u003ccode\u003e(c, e')\u003c/code\u003e such that \u003ccode\u003ee == c *^ v ^+^ e'\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Expr r -\u003e (r, Expr r)",
        "fct-source": "src/Data-LA.html#extract",
        "fct-type": "function",
        "title": "extract"
      },
      "index": {
        "description": "extract returns such that",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "extract",
        "normalized": "Var-\u003eExpr a-\u003e(a,Expr a)",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eExpr r-\u003e(r,Expr r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:extractMaybe",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eextractMaybe v e\u003c/code\u003e returns \u003ccode\u003eJust (c, e')\u003c/code\u003e such that \u003ccode\u003ee == c *^ v ^+^ e'\u003c/code\u003e\n if \u003ccode\u003ee\u003c/code\u003e contains v, and returns \u003ccode\u003eNothing\u003c/code\u003e otherwise.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Expr r -\u003e Maybe (r, Expr r)",
        "fct-source": "src/Data-LA.html#extractMaybe",
        "fct-type": "function",
        "title": "extractMaybe"
      },
      "index": {
        "description": "extractMaybe returns Just such that if contains and returns Nothing otherwise",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "extractMaybe",
        "normalized": "Var-\u003eExpr a-\u003eMaybe(a,Expr a)",
        "package": "toysolver",
        "partial": "Maybe",
        "signature": "Var-\u003eExpr r-\u003eMaybe(r,Expr r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:fromCoeffMap",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003eExpr\u003c/code\u003e from a mapping from variables to coefficients.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "IntMap r -\u003e Expr r",
        "fct-source": "src/Data-LA.html#fromCoeffMap",
        "fct-type": "function",
        "title": "fromCoeffMap"
      },
      "index": {
        "description": "Create Expr from mapping from variables to coefficients",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "fromCoeffMap",
        "normalized": "IntMap a-\u003eExpr a",
        "package": "toysolver",
        "partial": "Coeff Map",
        "signature": "IntMap r-\u003eExpr r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:fromTerms",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003eExpr\u003c/code\u003e from a list of terms.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "[(r, Var)] -\u003e Expr r",
        "fct-source": "src/Data-LA.html#fromTerms",
        "fct-type": "function",
        "title": "fromTerms"
      },
      "index": {
        "description": "Create Expr from list of terms",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "fromTerms",
        "normalized": "[(a,Var)]-\u003eExpr a",
        "package": "toysolver",
        "partial": "Terms",
        "signature": "[(r,Var)]-\u003eExpr r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:lift1",
      "description": {
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "x -\u003e (Var -\u003e x) -\u003e Expr (Scalar x) -\u003e x",
        "fct-source": "src/Data-LA.html#lift1",
        "fct-type": "function",
        "title": "lift1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "lift1",
        "normalized": "a-\u003e(Var-\u003ea)-\u003eExpr(Scalar a)-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "x-\u003e(Var-\u003ex)-\u003eExpr(Scalar x)-\u003ex"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:lookupCoeff",
      "description": {
        "fct-descr": "\u003cp\u003elookup a coefficient of the variable.\n It returns \u003ccode\u003eNothing\u003c/code\u003e if the expression does not contain \u003ccode\u003ev\u003c/code\u003e.\n \u003ccode\u003e\n   lookupCoeff v e == fmap fst (extractMaybe v e)\n \u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Expr r -\u003e Maybe r",
        "fct-source": "src/Data-LA.html#lookupCoeff",
        "fct-type": "function",
        "title": "lookupCoeff"
      },
      "index": {
        "description": "lookup coefficient of the variable It returns Nothing if the expression does not contain lookupCoeff fmap fst extractMaybe",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "lookupCoeff",
        "normalized": "Var-\u003eExpr a-\u003eMaybe a",
        "package": "toysolver",
        "partial": "Coeff",
        "signature": "Var-\u003eExpr r-\u003eMaybe r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:mapCoeff",
      "description": {
        "fct-descr": "\u003cp\u003emap coefficients.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "(a -\u003e b) -\u003e Expr a -\u003e Expr b",
        "fct-source": "src/Data-LA.html#mapCoeff",
        "fct-type": "function",
        "title": "mapCoeff"
      },
      "index": {
        "description": "map coefficients",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "mapCoeff",
        "normalized": "(a-\u003eb)-\u003eExpr a-\u003eExpr b",
        "package": "toysolver",
        "partial": "Coeff",
        "signature": "(a-\u003eb)-\u003eExpr a-\u003eExpr b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:mapCoeffWithVar",
      "description": {
        "fct-descr": "\u003cp\u003emap coefficients.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "(a -\u003e Var -\u003e b) -\u003e Expr a -\u003e Expr b",
        "fct-source": "src/Data-LA.html#mapCoeffWithVar",
        "fct-type": "function",
        "title": "mapCoeffWithVar"
      },
      "index": {
        "description": "map coefficients",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "mapCoeffWithVar",
        "normalized": "(a-\u003eVar-\u003eb)-\u003eExpr a-\u003eExpr b",
        "package": "toysolver",
        "partial": "Coeff With Var",
        "signature": "(a-\u003eVar-\u003eb)-\u003eExpr a-\u003eExpr b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:showAtom",
      "description": {
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Atom r -\u003e String",
        "fct-source": "src/Data-LA.html#showAtom",
        "fct-type": "function",
        "title": "showAtom"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "showAtom",
        "normalized": "Atom a-\u003eString",
        "package": "toysolver",
        "partial": "Atom",
        "signature": "Atom r-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:showExpr",
      "description": {
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e String",
        "fct-source": "src/Data-LA.html#showExpr",
        "fct-type": "function",
        "title": "showExpr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "showExpr",
        "normalized": "Expr a-\u003eString",
        "package": "toysolver",
        "partial": "Expr",
        "signature": "Expr r-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:solveFor",
      "description": {
        "fct-descr": "\u003cp\u003eSolve linear (in)equation for the given variable.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003esolveFor a v\u003c/code\u003e returns \u003ccode\u003eJust (op, e)\u003c/code\u003e such that \u003ccode\u003eAtom v op e\u003c/code\u003e\n is equivalent to \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Atom r -\u003e Var -\u003e Maybe (RelOp, Expr r)",
        "fct-source": "src/Data-LA.html#solveFor",
        "fct-type": "function",
        "title": "solveFor"
      },
      "index": {
        "description": "Solve linear in equation for the given variable solveFor returns Just op such that Atom op is equivalent to",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "solveFor",
        "normalized": "Atom a-\u003eVar-\u003eMaybe(RelOp,Expr a)",
        "package": "toysolver",
        "partial": "For",
        "signature": "Atom r-\u003eVar-\u003eMaybe(RelOp,Expr r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:terms",
      "description": {
        "fct-descr": "\u003cp\u003eterms contained in the expression.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Expr r -\u003e [(r, Var)]",
        "fct-source": "src/Data-LA.html#terms",
        "fct-type": "function",
        "title": "terms"
      },
      "index": {
        "description": "terms contained in the expression",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "terms",
        "normalized": "Expr a-\u003e[(a,Var)]",
        "package": "toysolver",
        "partial": "",
        "signature": "Expr r-\u003e[(r,Var)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:unitVar",
      "description": {
        "fct-descr": "\u003cp\u003eSpecial variable that should always be evaluated to 1.\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Var",
        "fct-source": "src/Data-LA.html#unitVar",
        "fct-type": "function",
        "title": "unitVar"
      },
      "index": {
        "description": "Special variable that should always be evaluated to",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "unitVar",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LA.html#v:var",
      "description": {
        "fct-descr": "\u003cp\u003evariable\n\u003c/p\u003e",
        "fct-module": "Data.LA",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Expr r",
        "fct-source": "src/Data-LA.html#var",
        "fct-type": "function",
        "title": "var"
      },
      "index": {
        "description": "variable",
        "hierarchy": "Data LA",
        "module": "Data.LA",
        "name": "var",
        "normalized": "Var-\u003eExpr a",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eExpr r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLifted boolean type.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.LBool",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-LBool.html",
        "fct-type": "module",
        "title": "LBool"
      },
      "index": {
        "description": "Lifted boolean type",
        "hierarchy": "Data LBool",
        "module": "Data.LBool",
        "name": "LBool",
        "normalized": "",
        "package": "toysolver",
        "partial": "LBool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#t:LBool",
      "description": {
        "fct-descr": "\u003cp\u003eLifted Bool type. It has three values \u003ccode\u003e\u003ca\u003elTrue\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003elFalse\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003elUndef\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.LBool",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-LBool.html#LBool",
        "fct-type": "data",
        "title": "LBool"
      },
      "index": {
        "description": "Lifted Bool type It has three values lTrue lFalse lUndef",
        "hierarchy": "Data LBool",
        "module": "Data.LBool",
        "name": "LBool",
        "normalized": "",
        "package": "toysolver",
        "partial": "LBool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:lFalse",
      "description": {
        "fct-descr": "\u003cp\u003elifted false value\n\u003c/p\u003e",
        "fct-module": "Data.LBool",
        "fct-package": "toysolver",
        "fct-signature": "LBool",
        "fct-source": "src/Data-LBool.html#lFalse",
        "fct-type": "function",
        "title": "lFalse"
      },
      "index": {
        "description": "lifted false value",
        "hierarchy": "Data LBool",
        "module": "Data.LBool",
        "name": "lFalse",
        "normalized": "",
        "package": "toysolver",
        "partial": "False",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:lTrue",
      "description": {
        "fct-descr": "\u003cp\u003elifted true value\n\u003c/p\u003e",
        "fct-module": "Data.LBool",
        "fct-package": "toysolver",
        "fct-signature": "LBool",
        "fct-source": "src/Data-LBool.html#lTrue",
        "fct-type": "function",
        "title": "lTrue"
      },
      "index": {
        "description": "lifted true value",
        "hierarchy": "Data LBool",
        "module": "Data.LBool",
        "name": "lTrue",
        "normalized": "",
        "package": "toysolver",
        "partial": "True",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:lUndef",
      "description": {
        "fct-descr": "\u003cp\u003eundefined truth value\n\u003c/p\u003e",
        "fct-module": "Data.LBool",
        "fct-package": "toysolver",
        "fct-signature": "LBool",
        "fct-source": "src/Data-LBool.html#lUndef",
        "fct-type": "function",
        "title": "lUndef"
      },
      "index": {
        "description": "undefined truth value",
        "hierarchy": "Data LBool",
        "module": "Data.LBool",
        "name": "lUndef",
        "normalized": "",
        "package": "toysolver",
        "partial": "Undef",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:liftBool",
      "description": {
        "fct-descr": "\u003cpre\u003e\n   liftBool True == lTrue\n   liftBool False == lFalse\n\u003c/pre\u003e",
        "fct-module": "Data.LBool",
        "fct-package": "toysolver",
        "fct-signature": "Bool -\u003e LBool",
        "fct-source": "src/Data-LBool.html#liftBool",
        "fct-type": "function",
        "title": "liftBool"
      },
      "index": {
        "description": "liftBool True lTrue liftBool False lFalse",
        "hierarchy": "Data LBool",
        "module": "Data.LBool",
        "name": "liftBool",
        "normalized": "Bool-\u003eLBool",
        "package": "toysolver",
        "partial": "Bool",
        "signature": "Bool-\u003eLBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:lnot",
      "description": {
        "fct-descr": "\u003cpre\u003e\n   lnot lTrue == lFalse\n   lnot lFalse == lTrue\n   lnot lUndef == lUndef\n\u003c/pre\u003e",
        "fct-module": "Data.LBool",
        "fct-package": "toysolver",
        "fct-signature": "LBool -\u003e LBool",
        "fct-source": "src/Data-LBool.html#lnot",
        "fct-type": "function",
        "title": "lnot"
      },
      "index": {
        "description": "lnot lTrue lFalse lnot lFalse lTrue lnot lUndef lUndef",
        "hierarchy": "Data LBool",
        "module": "Data.LBool",
        "name": "lnot",
        "normalized": "LBool-\u003eLBool",
        "package": "toysolver",
        "partial": "",
        "signature": "LBool-\u003eLBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-LBool.html#v:unliftBool",
      "description": {
        "fct-descr": "\u003cpre\u003e\n   unliftBool lTrue == Just True\n   unliftBool lFalse == Just False\n   unliftBool lUndef == Nothing\n\u003c/pre\u003e",
        "fct-module": "Data.LBool",
        "fct-package": "toysolver",
        "fct-signature": "LBool -\u003e Maybe Bool",
        "fct-source": "src/Data-LBool.html#unliftBool",
        "fct-type": "function",
        "title": "unliftBool"
      },
      "index": {
        "description": "unliftBool lTrue Just True unliftBool lFalse Just False unliftBool lUndef Nothing",
        "hierarchy": "Data LBool",
        "module": "Data.LBool",
        "name": "unliftBool",
        "normalized": "LBool-\u003eMaybe Bool",
        "package": "toysolver",
        "partial": "Bool",
        "signature": "LBool-\u003eMaybe Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactoriation of polynomial over a finite field.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/Factorization_of_polynomials_over_a_finite_field_and_irreducibility_tests\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/Berlekamp%27s_algorithm\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Martin Kreuzer and Lorenzo Robbiano. Computational Commutative Algebra 1. Springer Verlag, 2000.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial.Factorization.FiniteField",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-Factorization-FiniteField.html",
        "fct-type": "module",
        "title": "FiniteField"
      },
      "index": {
        "description": "Factoriation of polynomial over finite field References http en.wikipedia.org wiki Factorization of polynomials over finite field and irreducibility tests http en.wikipedia.org wiki Berlekamp algorithm Martin Kreuzer and Lorenzo Robbiano Computational Commutative Algebra Springer Verlag",
        "hierarchy": "Data Polynomial Factorization FiniteField",
        "module": "Data.Polynomial.Factorization.FiniteField",
        "name": "FiniteField",
        "normalized": "",
        "package": "toysolver",
        "partial": "Finite Field",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#v:basisOfBerlekampSubalgebra",
      "description": {
        "fct-module": "Data.Polynomial.Factorization.FiniteField",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e [UPolynomial k]",
        "fct-source": "src/Data-Polynomial-Factorization-FiniteField.html#basisOfBerlekampSubalgebra",
        "fct-type": "function",
        "title": "basisOfBerlekampSubalgebra"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Factorization FiniteField",
        "module": "Data.Polynomial.Factorization.FiniteField",
        "name": "basisOfBerlekampSubalgebra",
        "normalized": "UPolynomial a-\u003e[UPolynomial a]",
        "package": "toysolver",
        "partial": "Of Berlekamp Subalgebra",
        "signature": "UPolynomial k-\u003e[UPolynomial k]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#v:berlekamp",
      "description": {
        "fct-descr": "\u003cp\u003eBerlekamp algorithm for polynomial factorization.\n\u003c/p\u003e\u003cp\u003eInput polynomial is assumed to be monic and square-free.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.Factorization.FiniteField",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e [UPolynomial k]",
        "fct-source": "src/Data-Polynomial-Factorization-FiniteField.html#berlekamp",
        "fct-type": "function",
        "title": "berlekamp"
      },
      "index": {
        "description": "Berlekamp algorithm for polynomial factorization Input polynomial is assumed to be monic and square-free",
        "hierarchy": "Data Polynomial Factorization FiniteField",
        "module": "Data.Polynomial.Factorization.FiniteField",
        "name": "berlekamp",
        "normalized": "UPolynomial a-\u003e[UPolynomial a]",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003e[UPolynomial k]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#v:factor",
      "description": {
        "fct-module": "Data.Polynomial.Factorization.FiniteField",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e [(UPolynomial k, Integer)]",
        "fct-source": "src/Data-Polynomial-Factorization-FiniteField.html#factor",
        "fct-type": "function",
        "title": "factor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Factorization FiniteField",
        "module": "Data.Polynomial.Factorization.FiniteField",
        "name": "factor",
        "normalized": "UPolynomial a-\u003e[(UPolynomial a,Integer)]",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003e[(UPolynomial k,Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-FiniteField.html#v:sqfree",
      "description": {
        "fct-descr": "\u003cp\u003eSquare-free decomposition of univariate polynomials over a finite field.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.Factorization.FiniteField",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e [(UPolynomial k, Integer)]",
        "fct-source": "src/Data-Polynomial-Factorization-FiniteField.html#sqfree",
        "fct-type": "function",
        "title": "sqfree"
      },
      "index": {
        "description": "Square-free decomposition of univariate polynomials over finite field",
        "hierarchy": "Data Polynomial Factorization FiniteField",
        "module": "Data.Polynomial.Factorization.FiniteField",
        "name": "sqfree",
        "normalized": "UPolynomial a-\u003e[(UPolynomial a,Integer)]",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003e[(UPolynomial k,Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Hensel.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.kobe-u.ac.jp/Asir/ca.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www14.in.tum.de/konferenzen/Jass07/courses/1/Bulwahn/Buhlwahn_Paper.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial.Factorization.Hensel",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-Factorization-Hensel.html",
        "fct-type": "module",
        "title": "Hensel"
      },
      "index": {
        "description": "References http www.math.kobe-u.ac.jp Asir ca.pdf http www14.in.tum.de konferenzen Jass07 courses Bulwahn Buhlwahn Paper.pdf",
        "hierarchy": "Data Polynomial Factorization Hensel",
        "module": "Data.Polynomial.Factorization.Hensel",
        "name": "Hensel",
        "normalized": "",
        "package": "toysolver",
        "partial": "Hensel",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Hensel.html#v:hensel",
      "description": {
        "fct-module": "Data.Polynomial.Factorization.Hensel",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Integer -\u003e [UPolynomial (PrimeField p)] -\u003e Integer -\u003e [UPolynomial Integer]",
        "fct-source": "src/Data-Polynomial-Factorization-Hensel.html#hensel",
        "fct-type": "function",
        "title": "hensel"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Factorization Hensel",
        "module": "Data.Polynomial.Factorization.Hensel",
        "name": "hensel",
        "normalized": "UPolynomial Integer-\u003e[UPolynomial(PrimeField a)]-\u003eInteger-\u003e[UPolynomial Integer]",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial Integer-\u003e[UPolynomial(PrimeField p)]-\u003eInteger-\u003e[UPolynomial Integer]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Integer.html#",
      "description": {
        "fct-module": "Data.Polynomial.Factorization.Integer",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-Factorization-Integer.html",
        "fct-type": "module",
        "title": "Integer"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Factorization Integer",
        "module": "Data.Polynomial.Factorization.Integer",
        "name": "Integer",
        "normalized": "",
        "package": "toysolver",
        "partial": "Integer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Kronecker.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactoriation of integer-coefficient polynomial using Kronecker's method.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/Polynomial_factorization\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial.Factorization.Kronecker",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-Factorization-Kronecker.html",
        "fct-type": "module",
        "title": "Kronecker"
      },
      "index": {
        "description": "Factoriation of integer-coefficient polynomial using Kronecker method References http en.wikipedia.org wiki Polynomial factorization",
        "hierarchy": "Data Polynomial Factorization Kronecker",
        "module": "Data.Polynomial.Factorization.Kronecker",
        "name": "Kronecker",
        "normalized": "",
        "package": "toysolver",
        "partial": "Kronecker",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Kronecker.html#v:factor",
      "description": {
        "fct-module": "Data.Polynomial.Factorization.Kronecker",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Integer -\u003e [(UPolynomial Integer, Integer)]",
        "fct-source": "src/Data-Polynomial-Factorization-Kronecker.html#factor",
        "fct-type": "function",
        "title": "factor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Factorization Kronecker",
        "module": "Data.Polynomial.Factorization.Kronecker",
        "name": "factor",
        "normalized": "UPolynomial Integer-\u003e[(UPolynomial Integer,Integer)]",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial Integer-\u003e[(UPolynomial Integer,Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Rational.html#",
      "description": {
        "fct-module": "Data.Polynomial.Factorization.Rational",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-Factorization-Rational.html",
        "fct-type": "module",
        "title": "Rational"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Factorization Rational",
        "module": "Data.Polynomial.Factorization.Rational",
        "name": "Rational",
        "normalized": "",
        "package": "toysolver",
        "partial": "Rational",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-SquareFree.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.kobe-u.ac.jp/Asir/ca.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial.Factorization.SquareFree",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-Factorization-SquareFree.html",
        "fct-type": "module",
        "title": "SquareFree"
      },
      "index": {
        "description": "References http www.math.kobe-u.ac.jp Asir ca.pdf",
        "hierarchy": "Data Polynomial Factorization SquareFree",
        "module": "Data.Polynomial.Factorization.SquareFree",
        "name": "SquareFree",
        "normalized": "",
        "package": "toysolver",
        "partial": "Square Free",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-SquareFree.html#v:sqfreeChar0",
      "description": {
        "fct-descr": "\u003cp\u003eSquare-free decomposition of univariate polynomials over a field of characteristic 0.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.Factorization.SquareFree",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e [(UPolynomial k, Integer)]",
        "fct-source": "src/Data-Polynomial-Factorization-SquareFree.html#sqfreeChar0",
        "fct-type": "function",
        "title": "sqfreeChar0"
      },
      "index": {
        "description": "Square-free decomposition of univariate polynomials over field of characteristic",
        "hierarchy": "Data Polynomial Factorization SquareFree",
        "module": "Data.Polynomial.Factorization.SquareFree",
        "name": "sqfreeChar0",
        "normalized": "UPolynomial a-\u003e[(UPolynomial a,Integer)]",
        "package": "toysolver",
        "partial": "Char",
        "signature": "UPolynomial k-\u003e[(UPolynomial k,Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Zassenhaus.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactoriation of integer-coefficient polynomial using Zassenhaus algorithm.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.math.kobe-u.ac.jp/Asir/ca.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial.Factorization.Zassenhaus",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-Factorization-Zassenhaus.html",
        "fct-type": "module",
        "title": "Zassenhaus"
      },
      "index": {
        "description": "Factoriation of integer-coefficient polynomial using Zassenhaus algorithm References http www.math.kobe-u.ac.jp Asir ca.pdf",
        "hierarchy": "Data Polynomial Factorization Zassenhaus",
        "module": "Data.Polynomial.Factorization.Zassenhaus",
        "name": "Zassenhaus",
        "normalized": "",
        "package": "toysolver",
        "partial": "Zassenhaus",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Factorization-Zassenhaus.html#v:factor",
      "description": {
        "fct-module": "Data.Polynomial.Factorization.Zassenhaus",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Integer -\u003e [(UPolynomial Integer, Integer)]",
        "fct-source": "src/Data-Polynomial-Factorization-Zassenhaus.html#factor",
        "fct-type": "function",
        "title": "factor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Factorization Zassenhaus",
        "module": "Data.Polynomial.Factorization.Zassenhaus",
        "name": "factor",
        "normalized": "UPolynomial Integer-\u003e[(UPolynomial Integer,Integer)]",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial Integer-\u003e[(UPolynomial Integer,Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGr&#246;bner basis\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Monomial order \u003ca\u003ehttp://en.wikipedia.org/wiki/Monomial_order\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Gr&#246;bner basis \u003ca\u003ehttp://en.wikipedia.org/wiki/Gr%C3%B6bner_basis\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e &#12464;&#12524;&#12502;&#12490;&#12540;&#22522;&#24213; \u003ca\u003ehttp://d.hatena.ne.jp/keyword/%A5%B0%A5%EC%A5%D6%A5%CA%A1%BC%B4%F0%C4%EC\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Gr&#246;bner Bases and Buchberger&#8217;s Algorithm \u003ca\u003ehttp://math.rice.edu/~cbruun/vigre/vigreHW6.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Docon \u003ca\u003ehttp://www.haskell.org/docon/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html",
        "fct-type": "module",
        "title": "GroebnerBasis"
      },
      "index": {
        "description": "Gr bner basis References Monomial order http en.wikipedia.org wiki Monomial order Gr bner basis http en.wikipedia.org wiki Gr C3 B6bner basis http d.hatena.ne.jp keyword A5 B0 A5 EC A5 D6 A5 CA A1 BC B4 F0 C4 EC Gr bner Bases and Buchberger Algorithm http math.rice.edu cbruun vigre vigreHW6.pdf Docon http www.haskell.org docon",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "GroebnerBasis",
        "normalized": "",
        "package": "toysolver",
        "partial": "Groebner Basis",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#t:Options",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#t:Strategy",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#Strategy",
        "fct-type": "data",
        "title": "Strategy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "Strategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:NormalStrategy",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "NormalStrategy",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#Strategy",
        "fct-type": "function",
        "title": "NormalStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "NormalStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Normal Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:Options",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:SugarStrategy",
      "description": {
        "fct-descr": "\u003cp\u003esugar strategy (not implemented yet)\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "SugarStrategy",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#Strategy",
        "fct-type": "function",
        "title": "SugarStrategy"
      },
      "index": {
        "description": "sugar strategy not implemented yet",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "SugarStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Sugar Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:basis",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e [Polynomial k v] -\u003e [Polynomial k v]",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#basis",
        "fct-type": "function",
        "title": "basis"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "basis",
        "normalized": "MonomialOrder a-\u003e[Polynomial b a]-\u003e[Polynomial b a]",
        "package": "toysolver",
        "partial": "",
        "signature": "MonomialOrder v-\u003e[Polynomial k v]-\u003e[Polynomial k v]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:basis-39-",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "Options -\u003e MonomialOrder v -\u003e [Polynomial k v] -\u003e [Polynomial k v]",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#basis%27",
        "fct-type": "function",
        "title": "basis'"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "basis'",
        "normalized": "Options-\u003eMonomialOrder a-\u003e[Polynomial b a]-\u003e[Polynomial b a]",
        "package": "toysolver",
        "partial": "",
        "signature": "Options-\u003eMonomialOrder v-\u003e[Polynomial k v]-\u003e[Polynomial k v]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:defaultOptions",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:optStrategy",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "Strategy",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#Options",
        "fct-type": "function",
        "title": "optStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "optStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:reduceGBasis",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e [Polynomial k v] -\u003e [Polynomial k v]",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#reduceGBasis",
        "fct-type": "function",
        "title": "reduceGBasis"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "reduceGBasis",
        "normalized": "MonomialOrder a-\u003e[Polynomial b a]-\u003e[Polynomial b a]",
        "package": "toysolver",
        "partial": "GBasis",
        "signature": "MonomialOrder v-\u003e[Polynomial k v]-\u003e[Polynomial k v]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-GroebnerBasis.html#v:spolynomial",
      "description": {
        "fct-module": "Data.Polynomial.GroebnerBasis",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e Polynomial k v -\u003e Polynomial k v -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-GroebnerBasis.html#spolynomial",
        "fct-type": "function",
        "title": "spolynomial"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial GroebnerBasis",
        "module": "Data.Polynomial.GroebnerBasis",
        "name": "spolynomial",
        "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003ePolynomial b a-\u003ePolynomial b a",
        "package": "toysolver",
        "partial": "",
        "signature": "MonomialOrder v-\u003ePolynomial k v-\u003ePolynomial k v-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Interpolation-Lagrange.html#",
      "description": {
        "fct-module": "Data.Polynomial.Interpolation.Lagrange",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-Interpolation-Lagrange.html",
        "fct-type": "module",
        "title": "Lagrange"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Interpolation Lagrange",
        "module": "Data.Polynomial.Interpolation.Lagrange",
        "name": "Lagrange",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lagrange",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-Interpolation-Lagrange.html#v:interpolate",
      "description": {
        "fct-module": "Data.Polynomial.Interpolation.Lagrange",
        "fct-package": "toysolver",
        "fct-signature": "[(k, k)] -\u003e UPolynomial k",
        "fct-source": "src/Data-Polynomial-Interpolation-Lagrange.html#interpolate",
        "fct-type": "function",
        "title": "interpolate"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial Interpolation Lagrange",
        "module": "Data.Polynomial.Interpolation.Lagrange",
        "name": "interpolate",
        "normalized": "[(a,a)]-\u003eUPolynomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "[(k,k)]-\u003eUPolynomial k"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Graeffe.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGraeffe's Method\n\u003c/p\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://mathworld.wolfram.com/GraeffesMethod.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/Graeffe's_method\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial.RootSeparation.Graeffe",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-RootSeparation-Graeffe.html",
        "fct-type": "module",
        "title": "Graeffe"
      },
      "index": {
        "description": "Graeffe Method Reference http mathworld.wolfram.com GraeffesMethod.html http en.wikipedia.org wiki Graeffe method",
        "hierarchy": "Data Polynomial RootSeparation Graeffe",
        "module": "Data.Polynomial.RootSeparation.Graeffe",
        "name": "Graeffe",
        "normalized": "",
        "package": "toysolver",
        "partial": "Graeffe",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Graeffe.html#t:NthRoot",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Graeffe",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Polynomial-RootSeparation-Graeffe.html#NthRoot",
        "fct-type": "data",
        "title": "NthRoot"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Graeffe",
        "module": "Data.Polynomial.RootSeparation.Graeffe",
        "name": "NthRoot",
        "normalized": "",
        "package": "toysolver",
        "partial": "Nth Root",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Graeffe.html#v:NthRoot",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Graeffe",
        "fct-package": "toysolver",
        "fct-signature": "NthRoot !Integer !Rational",
        "fct-source": "src/Data-Polynomial-RootSeparation-Graeffe.html#NthRoot",
        "fct-type": "function",
        "title": "NthRoot"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Graeffe",
        "module": "Data.Polynomial.RootSeparation.Graeffe",
        "name": "NthRoot",
        "normalized": "",
        "package": "toysolver",
        "partial": "Nth Root",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Graeffe.html#v:graeffesMethod",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Graeffe",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e Int -\u003e [NthRoot]",
        "fct-source": "src/Data-Polynomial-RootSeparation-Graeffe.html#graeffesMethod",
        "fct-type": "function",
        "title": "graeffesMethod"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Graeffe",
        "module": "Data.Polynomial.RootSeparation.Graeffe",
        "name": "graeffesMethod",
        "normalized": "UPolynomial Rational-\u003eInt-\u003e[NthRoot]",
        "package": "toysolver",
        "partial": "Method",
        "signature": "UPolynomial Rational-\u003eInt-\u003e[NthRoot]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \"\u003cem\u003eSturm's theorem\u003c/em\u003e.\" Wikipedia, The Free Encyclopedia. Wikimedia Foundation, Inc.\n   2012-06-23. \u003ca\u003ehttp://en.wikipedia.org/wiki/Sturm%27s_theorem\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Weisstein, Eric W. \"\u003cem\u003eSturm Function\u003c/em\u003e.\" From MathWorld--A Wolfram Web Resource.\n   \u003ca\u003ehttp://mathworld.wolfram.com/SturmFunction.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html",
        "fct-type": "module",
        "title": "Sturm"
      },
      "index": {
        "description": "Reference Sturm theorem Wikipedia The Free Encyclopedia Wikimedia Foundation Inc http en.wikipedia.org wiki Sturm theorem Weisstein Eric Sturm Function From MathWorld--A Wolfram Web Resource http mathworld.wolfram.com SturmFunction.html",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "Sturm",
        "normalized": "",
        "package": "toysolver",
        "partial": "Sturm",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#t:SturmChain",
      "description": {
        "fct-descr": "\u003cp\u003eSturm's chain (Sturm's sequence)\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#SturmChain",
        "fct-type": "type",
        "title": "SturmChain"
      },
      "index": {
        "description": "Sturm chain Sturm sequence",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "SturmChain",
        "normalized": "",
        "package": "toysolver",
        "partial": "Sturm Chain",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:approx",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e Interval Rational -\u003e Rational -\u003e Rational",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#approx",
        "fct-type": "function",
        "title": "approx"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "approx",
        "normalized": "UPolynomial Rational-\u003eInterval Rational-\u003eRational-\u003eRational",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial Rational-\u003eInterval Rational-\u003eRational-\u003eRational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:approx-39-",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "SturmChain -\u003e Interval Rational -\u003e Rational -\u003e Rational",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#approx%27",
        "fct-type": "function",
        "title": "approx'"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "approx'",
        "normalized": "SturmChain-\u003eInterval Rational-\u003eRational-\u003eRational",
        "package": "toysolver",
        "partial": "",
        "signature": "SturmChain-\u003eInterval Rational-\u003eRational-\u003eRational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:halve",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e Interval Rational -\u003e Interval Rational",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#halve",
        "fct-type": "function",
        "title": "halve"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "halve",
        "normalized": "UPolynomial Rational-\u003eInterval Rational-\u003eInterval Rational",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial Rational-\u003eInterval Rational-\u003eInterval Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:halve-39-",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "SturmChain -\u003e Interval Rational -\u003e Interval Rational",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#halve%27",
        "fct-type": "function",
        "title": "halve'"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "halve'",
        "normalized": "SturmChain-\u003eInterval Rational-\u003eInterval Rational",
        "package": "toysolver",
        "partial": "",
        "signature": "SturmChain-\u003eInterval Rational-\u003eInterval Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:narrow",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e Interval Rational -\u003e Rational -\u003e Interval Rational",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#narrow",
        "fct-type": "function",
        "title": "narrow"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "narrow",
        "normalized": "UPolynomial Rational-\u003eInterval Rational-\u003eRational-\u003eInterval Rational",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial Rational-\u003eInterval Rational-\u003eRational-\u003eInterval Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:narrow-39-",
      "description": {
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "SturmChain -\u003e Interval Rational -\u003e Rational -\u003e Interval Rational",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#narrow%27",
        "fct-type": "function",
        "title": "narrow'"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "narrow'",
        "normalized": "SturmChain-\u003eInterval Rational-\u003eRational-\u003eInterval Rational",
        "package": "toysolver",
        "partial": "",
        "signature": "SturmChain-\u003eInterval Rational-\u003eRational-\u003eInterval Rational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:numRoots",
      "description": {
        "fct-descr": "\u003cp\u003eThe number of distinct real roots of \u003ccode\u003ep\u003c/code\u003e in a given interval\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e Interval Rational -\u003e Int",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#numRoots",
        "fct-type": "function",
        "title": "numRoots"
      },
      "index": {
        "description": "The number of distinct real roots of in given interval",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "numRoots",
        "normalized": "UPolynomial Rational-\u003eInterval Rational-\u003eInt",
        "package": "toysolver",
        "partial": "Roots",
        "signature": "UPolynomial Rational-\u003eInterval Rational-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:numRoots-39-",
      "description": {
        "fct-descr": "\u003cp\u003eThe number of distinct real roots of \u003ccode\u003ep\u003c/code\u003e in a given interval.\n This function takes \u003ccode\u003ep\u003c/code\u003e's sturm chain instead of \u003ccode\u003ep\u003c/code\u003e itself.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "SturmChain -\u003e Interval Rational -\u003e Int",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#numRoots%27",
        "fct-type": "function",
        "title": "numRoots'"
      },
      "index": {
        "description": "The number of distinct real roots of in given interval This function takes sturm chain instead of itself",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "numRoots'",
        "normalized": "SturmChain-\u003eInterval Rational-\u003eInt",
        "package": "toysolver",
        "partial": "Roots'",
        "signature": "SturmChain-\u003eInterval Rational-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:separate",
      "description": {
        "fct-descr": "\u003cp\u003eDisjoint intervals each of which contains exactly one real roots of the given polynoimal \u003ccode\u003ep\u003c/code\u003e.\n The intervals can be further narrowed by \u003ccode\u003e\u003ca\u003enarrow\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003enarrow'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e [Interval Rational]",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#separate",
        "fct-type": "function",
        "title": "separate"
      },
      "index": {
        "description": "Disjoint intervals each of which contains exactly one real roots of the given polynoimal The intervals can be further narrowed by narrow or narrow",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "separate",
        "normalized": "UPolynomial Rational-\u003e[Interval Rational]",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial Rational-\u003e[Interval Rational]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:separate-39-",
      "description": {
        "fct-descr": "\u003cp\u003eDisjoint intervals each of which contains exactly one real roots of the given polynoimal \u003ccode\u003ep\u003c/code\u003e.\n The intervals can be further narrowed by \u003ccode\u003e\u003ca\u003enarrow\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003enarrow'\u003c/a\u003e\u003c/code\u003e.\n This function takes \u003ccode\u003ep\u003c/code\u003e's sturm chain instead of \u003ccode\u003ep\u003c/code\u003e itself.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "SturmChain -\u003e [Interval Rational]",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#separate%27",
        "fct-type": "function",
        "title": "separate'"
      },
      "index": {
        "description": "Disjoint intervals each of which contains exactly one real roots of the given polynoimal The intervals can be further narrowed by narrow or narrow This function takes sturm chain instead of itself",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "separate'",
        "normalized": "SturmChain-\u003e[Interval Rational]",
        "package": "toysolver",
        "partial": "",
        "signature": "SturmChain-\u003e[Interval Rational]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial-RootSeparation-Sturm.html#v:sturmChain",
      "description": {
        "fct-descr": "\u003cp\u003eSturm's sequence of a polynomial\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial.RootSeparation.Sturm",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial Rational -\u003e SturmChain",
        "fct-source": "src/Data-Polynomial-RootSeparation-Sturm.html#sturmChain",
        "fct-type": "function",
        "title": "sturmChain"
      },
      "index": {
        "description": "Sturm sequence of polynomial",
        "hierarchy": "Data Polynomial RootSeparation Sturm",
        "module": "Data.Polynomial.RootSeparation.Sturm",
        "name": "sturmChain",
        "normalized": "UPolynomial Rational-\u003eSturmChain",
        "package": "toysolver",
        "partial": "Chain",
        "signature": "UPolynomial Rational-\u003eSturmChain"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePolynomials\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Monomial order \u003ca\u003ehttp://en.wikipedia.org/wiki/Monomial_order\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Polynomial class for Ruby \u003ca\u003ehttp://www.math.kobe-u.ac.jp/~kodama/tips-RubyPoly.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e constructive-algebra package \u003ca\u003ehttp://hackage.haskell.org/package/constructive-algebra\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Polynomial.html",
        "fct-type": "module",
        "title": "Polynomial"
      },
      "index": {
        "description": "Polynomials References Monomial order http en.wikipedia.org wiki Monomial order Polynomial class for Ruby http www.math.kobe-u.ac.jp kodama tips-RubyPoly.html constructive-algebra package http hackage.haskell.org package constructive-algebra",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "Polynomial",
        "normalized": "",
        "package": "toysolver",
        "partial": "Polynomial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:ContPP",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Polynomial-Base.html#ContPP",
        "fct-type": "class",
        "title": "ContPP"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "ContPP",
        "normalized": "",
        "package": "toysolver",
        "partial": "Cont PP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Degree",
      "description": {
        "fct-descr": "\u003cp\u003etotal degree of a given polynomial\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Polynomial-Base.html#Degree",
        "fct-type": "class",
        "title": "Degree"
      },
      "index": {
        "description": "total degree of given polynomial",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "Degree",
        "normalized": "",
        "package": "toysolver",
        "partial": "Degree",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Factor",
      "description": {
        "fct-descr": "\u003cp\u003eFactorization of polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Polynomial-Base.html#Factor",
        "fct-type": "class",
        "title": "Factor"
      },
      "index": {
        "description": "Factorization of polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "Factor",
        "normalized": "",
        "package": "toysolver",
        "partial": "Factor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Monomial",
      "description": {
        "fct-descr": "\u003cp\u003eMonic monomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Polynomial-Base.html#Monomial",
        "fct-type": "data",
        "title": "Monomial"
      },
      "index": {
        "description": "Monic monomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "Monomial",
        "normalized": "",
        "package": "toysolver",
        "partial": "Monomial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:MonomialOrder",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Polynomial-Base.html#MonomialOrder",
        "fct-type": "type",
        "title": "MonomialOrder"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "MonomialOrder",
        "normalized": "",
        "package": "toysolver",
        "partial": "Monomial Order",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Polynomial",
      "description": {
        "fct-descr": "\u003cp\u003ePolynomial over commutative ring r\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Polynomial-Base.html#Polynomial",
        "fct-type": "data",
        "title": "Polynomial"
      },
      "index": {
        "description": "Polynomial over commutative ring",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "Polynomial",
        "normalized": "",
        "package": "toysolver",
        "partial": "Polynomial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:PrettyCoeff",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Polynomial-Base.html#PrettyCoeff",
        "fct-type": "class",
        "title": "PrettyCoeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "PrettyCoeff",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pretty Coeff",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:PrettyVar",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Polynomial-Base.html#PrettyVar",
        "fct-type": "class",
        "title": "PrettyVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "PrettyVar",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pretty Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:PrintOptions",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Polynomial-Base.html#PrintOptions",
        "fct-type": "data",
        "title": "PrintOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "PrintOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Print Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:SQFree",
      "description": {
        "fct-descr": "\u003cp\u003eSquare-free factorization of polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Polynomial-Base.html#SQFree",
        "fct-type": "class",
        "title": "SQFree"
      },
      "index": {
        "description": "Square-free factorization of polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "SQFree",
        "normalized": "",
        "package": "toysolver",
        "partial": "SQFree",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Term",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Polynomial-Base.html#Term",
        "fct-type": "type",
        "title": "Term"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "Term",
        "normalized": "",
        "package": "toysolver",
        "partial": "Term",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:UMonomial",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Polynomial-Base.html#UMonomial",
        "fct-type": "type",
        "title": "UMonomial"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "UMonomial",
        "normalized": "",
        "package": "toysolver",
        "partial": "UMonomial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:UPolynomial",
      "description": {
        "fct-descr": "\u003cp\u003eUnivariate polynomials over commutative ring r\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Polynomial-Base.html#UPolynomial",
        "fct-type": "type",
        "title": "UPolynomial"
      },
      "index": {
        "description": "Univariate polynomials over commutative ring",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "UPolynomial",
        "normalized": "",
        "package": "toysolver",
        "partial": "UPolynomial",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:UTerm",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Polynomial-Base.html#UTerm",
        "fct-type": "type",
        "title": "UTerm"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "UTerm",
        "normalized": "",
        "package": "toysolver",
        "partial": "UTerm",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Var",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Polynomial-Base.html#Var",
        "fct-type": "class",
        "title": "Var"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:Vars",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Polynomial-Base.html#Vars",
        "fct-type": "class",
        "title": "Vars"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "Vars",
        "normalized": "",
        "package": "toysolver",
        "partial": "Vars",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#t:X",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Polynomial-Base.html#X",
        "fct-type": "data",
        "title": "X"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "X",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:PrintOptions",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "PrintOptions",
        "fct-source": "src/Data-Polynomial-Base.html#PrintOptions",
        "fct-type": "function",
        "title": "PrintOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "PrintOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Print Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:X",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "X",
        "fct-source": "src/Data-Polynomial-Base.html#X",
        "fct-type": "function",
        "title": "X"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "X",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:coeff",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Polynomial k v -\u003e k",
        "fct-source": "src/Data-Polynomial-Base.html#coeff",
        "fct-type": "function",
        "title": "coeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "coeff",
        "normalized": "Monomial a-\u003ePolynomial b a-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003ePolynomial k v-\u003ek"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:coeffMap",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial r v -\u003e Map (Monomial v) r",
        "fct-source": "src/Data-Polynomial-Base.html#coeffMap",
        "fct-type": "function",
        "title": "coeffMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "coeffMap",
        "normalized": "Polynomial a b-\u003eMap(Monomial b)a",
        "package": "toysolver",
        "partial": "Map",
        "signature": "Polynomial r v-\u003eMap(Monomial v)r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:constant",
      "description": {
        "fct-descr": "\u003cp\u003econstruct a polynomial from a constant\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "k -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-Base.html#constant",
        "fct-type": "function",
        "title": "constant"
      },
      "index": {
        "description": "construct polynomial from constant",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "constant",
        "normalized": "a-\u003ePolynomial a b",
        "package": "toysolver",
        "partial": "",
        "signature": "k-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:cont",
      "description": {
        "fct-descr": "\u003cp\u003eContent of a polynomial  \n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial k v -\u003e k",
        "fct-source": "src/Data-Polynomial-Base.html#cont",
        "fct-type": "method",
        "title": "cont"
      },
      "index": {
        "description": "Content of polynomial",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "cont",
        "normalized": "Polynomial a b-\u003ea",
        "package": "toysolver",
        "partial": "",
        "signature": "Polynomial k v-\u003ek"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:defaultPrintOptions",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "PrintOptions k v",
        "fct-source": "src/Data-Polynomial-Base.html#defaultPrintOptions",
        "fct-type": "function",
        "title": "defaultPrintOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "defaultPrintOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Print Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:deg",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "t -\u003e Integer",
        "fct-source": "src/Data-Polynomial-Base.html#deg",
        "fct-type": "method",
        "title": "deg"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "deg",
        "normalized": "a-\u003eInteger",
        "package": "toysolver",
        "partial": "",
        "signature": "t-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:deriv",
      "description": {
        "fct-descr": "\u003cp\u003eFormal derivative of polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial k v -\u003e v -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-Base.html#deriv",
        "fct-type": "function",
        "title": "deriv"
      },
      "index": {
        "description": "Formal derivative of polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "deriv",
        "normalized": "Polynomial a b-\u003eb-\u003ePolynomial a b",
        "package": "toysolver",
        "partial": "",
        "signature": "Polynomial k v-\u003ev-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:div",
      "description": {
        "fct-descr": "\u003cp\u003edivision of univariate polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e UPolynomial k -\u003e UPolynomial k",
        "fct-source": "src/Data-Polynomial-Base.html#div",
        "fct-type": "function",
        "title": "div"
      },
      "index": {
        "description": "division of univariate polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "div",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003eUPolynomial k-\u003eUPolynomial k"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:divMod",
      "description": {
        "fct-descr": "\u003cp\u003edivision of univariate polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e UPolynomial k -\u003e (UPolynomial k, UPolynomial k)",
        "fct-source": "src/Data-Polynomial-Base.html#divMod",
        "fct-type": "function",
        "title": "divMod"
      },
      "index": {
        "description": "division of univariate polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "divMod",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003e(UPolynomial a,UPolynomial a)",
        "package": "toysolver",
        "partial": "Mod",
        "signature": "UPolynomial k-\u003eUPolynomial k-\u003e(UPolynomial k,UPolynomial k)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:divModMP",
      "description": {
        "fct-descr": "\u003cp\u003eMultivariate division algorithm\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e Polynomial k v -\u003e [Polynomial k v] -\u003e ([Polynomial k v], Polynomial k v)",
        "fct-source": "src/Data-Polynomial-Base.html#divModMP",
        "fct-type": "function",
        "title": "divModMP"
      },
      "index": {
        "description": "Multivariate division algorithm",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "divModMP",
        "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003e[Polynomial b a]-\u003e([Polynomial b a],Polynomial b a)",
        "package": "toysolver",
        "partial": "Mod MP",
        "signature": "MonomialOrder v-\u003ePolynomial k v-\u003e[Polynomial k v]-\u003e([Polynomial k v],Polynomial k v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:divides",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e UPolynomial k -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#divides",
        "fct-type": "function",
        "title": "divides"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "divides",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eBool",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003eUPolynomial k-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:eval",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluation\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "(v -\u003e k) -\u003e Polynomial k v -\u003e k",
        "fct-source": "src/Data-Polynomial-Base.html#eval",
        "fct-type": "function",
        "title": "eval"
      },
      "index": {
        "description": "Evaluation",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "eval",
        "normalized": "(a-\u003eb)-\u003ePolynomial b a-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "(v-\u003ek)-\u003ePolynomial k v-\u003ek"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:exgcd",
      "description": {
        "fct-descr": "\u003cp\u003eExtended GCD algorithm\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e UPolynomial k -\u003e (UPolynomial k, UPolynomial k, UPolynomial k)",
        "fct-source": "src/Data-Polynomial-Base.html#exgcd",
        "fct-type": "function",
        "title": "exgcd"
      },
      "index": {
        "description": "Extended GCD algorithm",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "exgcd",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003e(UPolynomial a,UPolynomial a,UPolynomial a)",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003eUPolynomial k-\u003e(UPolynomial k,UPolynomial k,UPolynomial k)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:factor",
      "description": {
        "fct-descr": "\u003cp\u003efactor a polynomial \u003ccode\u003ep\u003c/code\u003e into \u003ccode\u003ep1 ^ n1 + p2 ^ n2 + ..\u003c/code\u003e and\n return a list \u003ccode\u003e[(p1,n1), (p2,n2), ..]\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e [(a, Integer)]",
        "fct-source": "src/Data-Polynomial-Base.html#factor",
        "fct-type": "method",
        "title": "factor"
      },
      "index": {
        "description": "factor polynomial into p1 n1 p2 n2 and return list p1 n1 p2 n2",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "factor",
        "normalized": "a-\u003e[(a,Integer)]",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003e[(a,Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:fromCoeffMap",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Map (Monomial v) k -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-Base.html#fromCoeffMap",
        "fct-type": "function",
        "title": "fromCoeffMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "fromCoeffMap",
        "normalized": "Map(Monomial a)b-\u003ePolynomial b a",
        "package": "toysolver",
        "partial": "Coeff Map",
        "signature": "Map(Monomial v)k-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:fromTerm",
      "description": {
        "fct-descr": "\u003cp\u003econstruct a polynomial from a monomial\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Term k v -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-Base.html#fromTerm",
        "fct-type": "function",
        "title": "fromTerm"
      },
      "index": {
        "description": "construct polynomial from monomial",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "fromTerm",
        "normalized": "Term a b-\u003ePolynomial a b",
        "package": "toysolver",
        "partial": "Term",
        "signature": "Term k v-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:fromTerms",
      "description": {
        "fct-descr": "\u003cp\u003econstruct a polynomial from a list of monomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "[Term k v] -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-Base.html#fromTerms",
        "fct-type": "function",
        "title": "fromTerms"
      },
      "index": {
        "description": "construct polynomial from list of monomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "fromTerms",
        "normalized": "[Term a b]-\u003ePolynomial a b",
        "package": "toysolver",
        "partial": "Terms",
        "signature": "[Term k v]-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:gcd",
      "description": {
        "fct-descr": "\u003cp\u003eGCD of univariate polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e UPolynomial k -\u003e UPolynomial k",
        "fct-source": "src/Data-Polynomial-Base.html#gcd",
        "fct-type": "function",
        "title": "gcd"
      },
      "index": {
        "description": "GCD of univariate polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "gcd",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003eUPolynomial k-\u003eUPolynomial k"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:gcd-39-",
      "description": {
        "fct-descr": "\u003cp\u003eGCD of univariate polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial r -\u003e UPolynomial r -\u003e UPolynomial r",
        "fct-source": "src/Data-Polynomial-Base.html#gcd%27",
        "fct-type": "function",
        "title": "gcd'"
      },
      "index": {
        "description": "GCD of univariate polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "gcd'",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial r-\u003eUPolynomial r-\u003eUPolynomial r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:grevlex",
      "description": {
        "fct-descr": "\u003cp\u003eGraded reverse lexicographic order\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v",
        "fct-source": "src/Data-Polynomial-Base.html#grevlex",
        "fct-type": "function",
        "title": "grevlex"
      },
      "index": {
        "description": "Graded reverse lexicographic order",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "grevlex",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:grlex",
      "description": {
        "fct-descr": "\u003cp\u003eGraded lexicographic order\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v",
        "fct-source": "src/Data-Polynomial-Base.html#grlex",
        "fct-type": "function",
        "title": "grlex"
      },
      "index": {
        "description": "Graded lexicographic order",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "grlex",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:integral",
      "description": {
        "fct-descr": "\u003cp\u003eFormal integral of polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial k v -\u003e v -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-Base.html#integral",
        "fct-type": "function",
        "title": "integral"
      },
      "index": {
        "description": "Formal integral of polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "integral",
        "normalized": "Polynomial a b-\u003eb-\u003ePolynomial a b",
        "package": "toysolver",
        "partial": "",
        "signature": "Polynomial k v-\u003ev-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:isNegativeCoeff",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#isNegativeCoeff",
        "fct-type": "method",
        "title": "isNegativeCoeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "isNegativeCoeff",
        "normalized": "a-\u003eBool",
        "package": "toysolver",
        "partial": "Negative Coeff",
        "signature": "a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:isPrimitive",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial k v -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#isPrimitive",
        "fct-type": "function",
        "title": "isPrimitive"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "isPrimitive",
        "normalized": "Polynomial a b-\u003eBool",
        "package": "toysolver",
        "partial": "Primitive",
        "signature": "Polynomial k v-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:isRootOf",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "k -\u003e UPolynomial k -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#isRootOf",
        "fct-type": "function",
        "title": "isRootOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "isRootOf",
        "normalized": "a-\u003eUPolynomial a-\u003eBool",
        "package": "toysolver",
        "partial": "Root Of",
        "signature": "k-\u003eUPolynomial k-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:isSquareFree",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#isSquareFree",
        "fct-type": "function",
        "title": "isSquareFree"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "isSquareFree",
        "normalized": "UPolynomial a-\u003eBool",
        "package": "toysolver",
        "partial": "Square Free",
        "signature": "UPolynomial k-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lc",
      "description": {
        "fct-descr": "\u003cp\u003eleading coefficient with respect to a given monomial order\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e Polynomial k v -\u003e k",
        "fct-source": "src/Data-Polynomial-Base.html#lc",
        "fct-type": "function",
        "title": "lc"
      },
      "index": {
        "description": "leading coefficient with respect to given monomial order",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "lc",
        "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "MonomialOrder v-\u003ePolynomial k v-\u003ek"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lcm",
      "description": {
        "fct-descr": "\u003cp\u003eLCM of univariate polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e UPolynomial k -\u003e UPolynomial k",
        "fct-source": "src/Data-Polynomial-Base.html#lcm",
        "fct-type": "function",
        "title": "lcm"
      },
      "index": {
        "description": "LCM of univariate polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "lcm",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003eUPolynomial k-\u003eUPolynomial k"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lex",
      "description": {
        "fct-descr": "\u003cp\u003eLexicographic order\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v",
        "fct-source": "src/Data-Polynomial-Base.html#lex",
        "fct-type": "function",
        "title": "lex"
      },
      "index": {
        "description": "Lexicographic order",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "lex",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lm",
      "description": {
        "fct-descr": "\u003cp\u003eleading monomial with respect to a given monomial order\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e Polynomial k v -\u003e Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#lm",
        "fct-type": "function",
        "title": "lm"
      },
      "index": {
        "description": "leading monomial with respect to given monomial order",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "lm",
        "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003eMonomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "MonomialOrder v-\u003ePolynomial k v-\u003eMonomial v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lookupCoeff",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Polynomial k v -\u003e Maybe k",
        "fct-source": "src/Data-Polynomial-Base.html#lookupCoeff",
        "fct-type": "function",
        "title": "lookupCoeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "lookupCoeff",
        "normalized": "Monomial a-\u003ePolynomial b a-\u003eMaybe b",
        "package": "toysolver",
        "partial": "Coeff",
        "signature": "Monomial v-\u003ePolynomial k v-\u003eMaybe k"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:lt",
      "description": {
        "fct-descr": "\u003cp\u003eleading term with respect to a given monomial order\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e Polynomial k v -\u003e Term k v",
        "fct-source": "src/Data-Polynomial-Base.html#lt",
        "fct-type": "function",
        "title": "lt"
      },
      "index": {
        "description": "leading term with respect to given monomial order",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "lt",
        "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003eTerm b a",
        "package": "toysolver",
        "partial": "",
        "signature": "MonomialOrder v-\u003ePolynomial k v-\u003eTerm k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mapCoeff",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "(k -\u003e k1) -\u003e Polynomial k v -\u003e Polynomial k1 v",
        "fct-source": "src/Data-Polynomial-Base.html#mapCoeff",
        "fct-type": "function",
        "title": "mapCoeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mapCoeff",
        "normalized": "(a-\u003ea)-\u003ePolynomial a b-\u003ePolynomial a b",
        "package": "toysolver",
        "partial": "Coeff",
        "signature": "(k-\u003ek)-\u003ePolynomial k v-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mcoprime",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Monomial v -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#mcoprime",
        "fct-type": "function",
        "title": "mcoprime"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mcoprime",
        "normalized": "Monomial a-\u003eMonomial a-\u003eBool",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003eMonomial v-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mderiv",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e v -\u003e (Integer, Monomial v)",
        "fct-source": "src/Data-Polynomial-Base.html#mderiv",
        "fct-type": "function",
        "title": "mderiv"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mderiv",
        "normalized": "Monomial a-\u003ea-\u003e(Integer,Monomial a)",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003ev-\u003e(Integer,Monomial v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mdiv",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Monomial v -\u003e Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#mdiv",
        "fct-type": "function",
        "title": "mdiv"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mdiv",
        "normalized": "Monomial a-\u003eMonomial a-\u003eMonomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003eMonomial v-\u003eMonomial v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mdivides",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Monomial v -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#mdivides",
        "fct-type": "function",
        "title": "mdivides"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mdivides",
        "normalized": "Monomial a-\u003eMonomial a-\u003eBool",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003eMonomial v-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mfromIndices",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "[(v, Integer)] -\u003e Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#mfromIndices",
        "fct-type": "function",
        "title": "mfromIndices"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mfromIndices",
        "normalized": "[(a,Integer)]-\u003eMonomial a",
        "package": "toysolver",
        "partial": "Indices",
        "signature": "[(v,Integer)]-\u003eMonomial v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mfromIndicesMap",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Map v Integer -\u003e Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#mfromIndicesMap",
        "fct-type": "function",
        "title": "mfromIndicesMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mfromIndicesMap",
        "normalized": "Map a Integer-\u003eMonomial a",
        "package": "toysolver",
        "partial": "Indices Map",
        "signature": "Map v Integer-\u003eMonomial v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mgcd",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Monomial v -\u003e Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#mgcd",
        "fct-type": "function",
        "title": "mgcd"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mgcd",
        "normalized": "Monomial a-\u003eMonomial a-\u003eMonomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003eMonomial v-\u003eMonomial v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mindices",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e [(v, Integer)]",
        "fct-source": "src/Data-Polynomial-Base.html#mindices",
        "fct-type": "function",
        "title": "mindices"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mindices",
        "normalized": "Monomial a-\u003e[(a,Integer)]",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003e[(v,Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mindicesMap",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Map v Integer",
        "fct-source": "src/Data-Polynomial-Base.html#mindicesMap",
        "fct-type": "function",
        "title": "mindicesMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mindicesMap",
        "normalized": "Monomial a-\u003eMap a Integer",
        "package": "toysolver",
        "partial": "Map",
        "signature": "Monomial v-\u003eMap v Integer"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mintegral",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e v -\u003e (Rational, Monomial v)",
        "fct-source": "src/Data-Polynomial-Base.html#mintegral",
        "fct-type": "function",
        "title": "mintegral"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mintegral",
        "normalized": "Monomial a-\u003ea-\u003e(Rational,Monomial a)",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003ev-\u003e(Rational,Monomial v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mlcm",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Monomial v -\u003e Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#mlcm",
        "fct-type": "function",
        "title": "mlcm"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mlcm",
        "normalized": "Monomial a-\u003eMonomial a-\u003eMonomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003eMonomial v-\u003eMonomial v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mmult",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Monomial v -\u003e Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#mmult",
        "fct-type": "function",
        "title": "mmult"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mmult",
        "normalized": "Monomial a-\u003eMonomial a-\u003eMonomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003eMonomial v-\u003eMonomial v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mod",
      "description": {
        "fct-descr": "\u003cp\u003edivision of univariate polynomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial k -\u003e UPolynomial k -\u003e UPolynomial k",
        "fct-source": "src/Data-Polynomial-Base.html#mod",
        "fct-type": "function",
        "title": "mod"
      },
      "index": {
        "description": "division of univariate polynomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mod",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial k-\u003eUPolynomial k-\u003eUPolynomial k"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mone",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#mone",
        "fct-type": "function",
        "title": "mone"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mone",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:mpow",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Integer -\u003e Monomial v",
        "fct-source": "src/Data-Polynomial-Base.html#mpow",
        "fct-type": "function",
        "title": "mpow"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "mpow",
        "normalized": "Monomial a-\u003eInteger-\u003eMonomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003eInteger-\u003eMonomial v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pOptIsNegativeCoeff",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "k -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#PrintOptions",
        "fct-type": "function",
        "title": "pOptIsNegativeCoeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pOptIsNegativeCoeff",
        "normalized": "a-\u003eBool",
        "package": "toysolver",
        "partial": "Opt Is Negative Coeff",
        "signature": "k-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pOptMonomialOrder",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v",
        "fct-source": "src/Data-Polynomial-Base.html#PrintOptions",
        "fct-type": "function",
        "title": "pOptMonomialOrder"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pOptMonomialOrder",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Monomial Order",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pOptPrintCoeff",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "PrettyLevel -\u003e Rational -\u003e k -\u003e Doc",
        "fct-source": "src/Data-Polynomial-Base.html#PrintOptions",
        "fct-type": "function",
        "title": "pOptPrintCoeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pOptPrintCoeff",
        "normalized": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
        "package": "toysolver",
        "partial": "Opt Print Coeff",
        "signature": "PrettyLevel-\u003eRational-\u003ek-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pOptPrintVar",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "PrettyLevel -\u003e Rational -\u003e v -\u003e Doc",
        "fct-source": "src/Data-Polynomial-Base.html#PrintOptions",
        "fct-type": "function",
        "title": "pOptPrintVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pOptPrintVar",
        "normalized": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
        "package": "toysolver",
        "partial": "Opt Print Var",
        "signature": "PrettyLevel-\u003eRational-\u003ev-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pPrintCoeff",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "PrettyLevel -\u003e Rational -\u003e a -\u003e Doc",
        "fct-source": "src/Data-Polynomial-Base.html#pPrintCoeff",
        "fct-type": "method",
        "title": "pPrintCoeff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pPrintCoeff",
        "normalized": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
        "package": "toysolver",
        "partial": "Print Coeff",
        "signature": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pPrintVar",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "PrettyLevel -\u003e Rational -\u003e a -\u003e Doc",
        "fct-source": "src/Data-Polynomial-Base.html#pPrintVar",
        "fct-type": "method",
        "title": "pPrintVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pPrintVar",
        "normalized": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc",
        "package": "toysolver",
        "partial": "Print Var",
        "signature": "PrettyLevel-\u003eRational-\u003ea-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pdiv",
      "description": {
        "fct-descr": "\u003cp\u003epseudo quotient\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial r -\u003e UPolynomial r -\u003e UPolynomial r",
        "fct-source": "src/Data-Polynomial-Base.html#pdiv",
        "fct-type": "function",
        "title": "pdiv"
      },
      "index": {
        "description": "pseudo quotient",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pdiv",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial r-\u003eUPolynomial r-\u003eUPolynomial r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pdivMod",
      "description": {
        "fct-descr": "\u003cp\u003epseudo division\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial r -\u003e UPolynomial r -\u003e (r, UPolynomial r, UPolynomial r)",
        "fct-source": "src/Data-Polynomial-Base.html#pdivMod",
        "fct-type": "function",
        "title": "pdivMod"
      },
      "index": {
        "description": "pseudo division",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pdivMod",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003e(a,UPolynomial a,UPolynomial a)",
        "package": "toysolver",
        "partial": "Mod",
        "signature": "UPolynomial r-\u003eUPolynomial r-\u003e(r,UPolynomial r,UPolynomial r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pmod",
      "description": {
        "fct-descr": "\u003cp\u003epseudo reminder\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "UPolynomial r -\u003e UPolynomial r -\u003e UPolynomial r",
        "fct-source": "src/Data-Polynomial-Base.html#pmod",
        "fct-type": "function",
        "title": "pmod"
      },
      "index": {
        "description": "pseudo reminder",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pmod",
        "normalized": "UPolynomial a-\u003eUPolynomial a-\u003eUPolynomial a",
        "package": "toysolver",
        "partial": "",
        "signature": "UPolynomial r-\u003eUPolynomial r-\u003eUPolynomial r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:pp",
      "description": {
        "fct-descr": "\u003cp\u003ePrimitive part of a polynomial\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial k v -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-Base.html#pp",
        "fct-type": "method",
        "title": "pp"
      },
      "index": {
        "description": "Primitive part of polynomial",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "pp",
        "normalized": "Polynomial a b-\u003ePolynomial a b",
        "package": "toysolver",
        "partial": "",
        "signature": "Polynomial k v-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:prettyPrint",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "PrintOptions k v -\u003e PrettyLevel -\u003e Rational -\u003e Polynomial k v -\u003e Doc",
        "fct-source": "src/Data-Polynomial-Base.html#prettyPrint",
        "fct-type": "function",
        "title": "prettyPrint"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "prettyPrint",
        "normalized": "PrintOptions a b-\u003ePrettyLevel-\u003eRational-\u003ePolynomial a b-\u003eDoc",
        "package": "toysolver",
        "partial": "Print",
        "signature": "PrintOptions k v-\u003ePrettyLevel-\u003eRational-\u003ePolynomial k v-\u003eDoc"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:reduce",
      "description": {
        "fct-descr": "\u003cp\u003eMultivariate division algorithm\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e Polynomial k v -\u003e [Polynomial k v] -\u003e Polynomial k v",
        "fct-source": "src/Data-Polynomial-Base.html#reduce",
        "fct-type": "function",
        "title": "reduce"
      },
      "index": {
        "description": "Multivariate division algorithm",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "reduce",
        "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003e[Polynomial b a]-\u003ePolynomial b a",
        "package": "toysolver",
        "partial": "",
        "signature": "MonomialOrder v-\u003ePolynomial k v-\u003e[Polynomial k v]-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:revlex",
      "description": {
        "fct-descr": "\u003cp\u003eReverse lexicographic order.\n\u003c/p\u003e\u003cp\u003eNote that revlex is NOT a monomial order.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Monomial v -\u003e Monomial v -\u003e Ordering",
        "fct-source": "src/Data-Polynomial-Base.html#revlex",
        "fct-type": "function",
        "title": "revlex"
      },
      "index": {
        "description": "Reverse lexicographic order Note that revlex is NOT monomial order",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "revlex",
        "normalized": "Monomial a-\u003eMonomial a-\u003eOrdering",
        "package": "toysolver",
        "partial": "",
        "signature": "Monomial v-\u003eMonomial v-\u003eOrdering"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:sqfree",
      "description": {
        "fct-descr": "\u003cp\u003efactor a polynomial \u003ccode\u003ep\u003c/code\u003e into \u003ccode\u003ep1 ^ n1 + p2 ^ n2 + ..\u003c/code\u003e and\n return a list \u003ccode\u003e[(p1,n1), (p2,n2), ..]\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e [(a, Integer)]",
        "fct-source": "src/Data-Polynomial-Base.html#sqfree",
        "fct-type": "method",
        "title": "sqfree"
      },
      "index": {
        "description": "factor polynomial into p1 n1 p2 n2 and return list p1 n1 p2 n2",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "sqfree",
        "normalized": "a-\u003e[(a,Integer)]",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003e[(a,Integer)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:subst",
      "description": {
        "fct-descr": "\u003cp\u003eSubstitution or bind\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial k v1 -\u003e (v1 -\u003e Polynomial k v2) -\u003e Polynomial k v2",
        "fct-source": "src/Data-Polynomial-Base.html#subst",
        "fct-type": "function",
        "title": "subst"
      },
      "index": {
        "description": "Substitution or bind",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "subst",
        "normalized": "Polynomial a b-\u003e(b-\u003ePolynomial a b)-\u003ePolynomial a b",
        "package": "toysolver",
        "partial": "",
        "signature": "Polynomial k v-\u003e(v-\u003ePolynomial k v)-\u003ePolynomial k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tdeg",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Term k v -\u003e Integer",
        "fct-source": "src/Data-Polynomial-Base.html#tdeg",
        "fct-type": "function",
        "title": "tdeg"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "tdeg",
        "normalized": "Term a b-\u003eInteger",
        "package": "toysolver",
        "partial": "",
        "signature": "Term k v-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tderiv",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Term k v -\u003e v -\u003e Term k v",
        "fct-source": "src/Data-Polynomial-Base.html#tderiv",
        "fct-type": "function",
        "title": "tderiv"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "tderiv",
        "normalized": "Term a b-\u003eb-\u003eTerm a b",
        "package": "toysolver",
        "partial": "",
        "signature": "Term k v-\u003ev-\u003eTerm k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tdiv",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Term k v -\u003e Term k v -\u003e Term k v",
        "fct-source": "src/Data-Polynomial-Base.html#tdiv",
        "fct-type": "function",
        "title": "tdiv"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "tdiv",
        "normalized": "Term a b-\u003eTerm a b-\u003eTerm a b",
        "package": "toysolver",
        "partial": "",
        "signature": "Term k v-\u003eTerm k v-\u003eTerm k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tdivides",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Term k v -\u003e Term k v -\u003e Bool",
        "fct-source": "src/Data-Polynomial-Base.html#tdivides",
        "fct-type": "function",
        "title": "tdivides"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "tdivides",
        "normalized": "Term a b-\u003eTerm a b-\u003eBool",
        "package": "toysolver",
        "partial": "",
        "signature": "Term k v-\u003eTerm k v-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:terms",
      "description": {
        "fct-descr": "\u003cp\u003elist of monomials\n\u003c/p\u003e",
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial k v -\u003e [Term k v]",
        "fct-source": "src/Data-Polynomial-Base.html#terms",
        "fct-type": "function",
        "title": "terms"
      },
      "index": {
        "description": "list of monomials",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "terms",
        "normalized": "Polynomial a b-\u003e[Term a b]",
        "package": "toysolver",
        "partial": "",
        "signature": "Polynomial k v-\u003e[Term k v]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tintegral",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Term k v -\u003e v -\u003e Term k v",
        "fct-source": "src/Data-Polynomial-Base.html#tintegral",
        "fct-type": "function",
        "title": "tintegral"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "tintegral",
        "normalized": "Term a b-\u003eb-\u003eTerm a b",
        "package": "toysolver",
        "partial": "",
        "signature": "Term k v-\u003ev-\u003eTerm k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:tmult",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Term k v -\u003e Term k v -\u003e Term k v",
        "fct-source": "src/Data-Polynomial-Base.html#tmult",
        "fct-type": "function",
        "title": "tmult"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "tmult",
        "normalized": "Term a b-\u003eTerm a b-\u003eTerm a b",
        "package": "toysolver",
        "partial": "",
        "signature": "Term k v-\u003eTerm k v-\u003eTerm k v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:toMonic",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "MonomialOrder v -\u003e Polynomial r v -\u003e Polynomial r v",
        "fct-source": "src/Data-Polynomial-Base.html#toMonic",
        "fct-type": "function",
        "title": "toMonic"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "toMonic",
        "normalized": "MonomialOrder a-\u003ePolynomial b a-\u003ePolynomial b a",
        "package": "toysolver",
        "partial": "Monic",
        "signature": "MonomialOrder v-\u003ePolynomial r v-\u003ePolynomial r v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:toUPolynomialOf",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "Polynomial k v -\u003e v -\u003e UPolynomial (Polynomial k v)",
        "fct-source": "src/Data-Polynomial-Base.html#toUPolynomialOf",
        "fct-type": "function",
        "title": "toUPolynomialOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "toUPolynomialOf",
        "normalized": "Polynomial a b-\u003eb-\u003eUPolynomial(Polynomial a b)",
        "package": "toysolver",
        "partial": "UPolynomial Of",
        "signature": "Polynomial k v-\u003ev-\u003eUPolynomial(Polynomial k v)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:var",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "v -\u003e a",
        "fct-source": "src/Data-Polynomial-Base.html#var",
        "fct-type": "method",
        "title": "var"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "var",
        "normalized": "a-\u003eb",
        "package": "toysolver",
        "partial": "",
        "signature": "v-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Polynomial.html#v:vars",
      "description": {
        "fct-module": "Data.Polynomial",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e Set v",
        "fct-source": "src/Data-Polynomial-Base.html#vars",
        "fct-type": "method",
        "title": "vars"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Polynomial",
        "module": "Data.Polynomial",
        "name": "vars",
        "normalized": "a-\u003eSet b",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003eSet v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlgebra of Signs.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Sign.html",
        "fct-type": "module",
        "title": "Sign"
      },
      "index": {
        "description": "Algebra of Signs",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "Sign",
        "normalized": "",
        "package": "toysolver",
        "partial": "Sign",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#t:Sign",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Data-Sign.html#Sign",
        "fct-type": "data",
        "title": "Sign"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "Sign",
        "normalized": "",
        "package": "toysolver",
        "partial": "Sign",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:Neg",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Neg",
        "fct-source": "src/Data-Sign.html#Sign",
        "fct-type": "function",
        "title": "Neg"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "Neg",
        "normalized": "",
        "package": "toysolver",
        "partial": "Neg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:Pos",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Pos",
        "fct-source": "src/Data-Sign.html#Sign",
        "fct-type": "function",
        "title": "Pos"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "Pos",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pos",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:Zero",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Zero",
        "fct-source": "src/Data-Sign.html#Sign",
        "fct-type": "function",
        "title": "Zero"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "Zero",
        "normalized": "",
        "package": "toysolver",
        "partial": "Zero",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:div",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Sign -\u003e Sign -\u003e Sign",
        "fct-source": "src/Data-Sign.html#div",
        "fct-type": "function",
        "title": "div"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "div",
        "normalized": "Sign-\u003eSign-\u003eSign",
        "package": "toysolver",
        "partial": "",
        "signature": "Sign-\u003eSign-\u003eSign"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:mult",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Sign -\u003e Sign -\u003e Sign",
        "fct-source": "src/Data-Sign.html#mult",
        "fct-type": "function",
        "title": "mult"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "mult",
        "normalized": "Sign-\u003eSign-\u003eSign",
        "package": "toysolver",
        "partial": "",
        "signature": "Sign-\u003eSign-\u003eSign"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:negate",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Sign -\u003e Sign",
        "fct-source": "src/Data-Sign.html#negate",
        "fct-type": "function",
        "title": "negate"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "negate",
        "normalized": "Sign-\u003eSign",
        "package": "toysolver",
        "partial": "",
        "signature": "Sign-\u003eSign"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:pow",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Sign -\u003e x -\u003e Sign",
        "fct-source": "src/Data-Sign.html#pow",
        "fct-type": "function",
        "title": "pow"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "pow",
        "normalized": "Sign-\u003ea-\u003eSign",
        "package": "toysolver",
        "partial": "",
        "signature": "Sign-\u003ex-\u003eSign"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:recip",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Sign -\u003e Sign",
        "fct-source": "src/Data-Sign.html#recip",
        "fct-type": "function",
        "title": "recip"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "recip",
        "normalized": "Sign-\u003eSign",
        "package": "toysolver",
        "partial": "",
        "signature": "Sign-\u003eSign"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:signOf",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e Sign",
        "fct-source": "src/Data-Sign.html#signOf",
        "fct-type": "function",
        "title": "signOf"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "signOf",
        "normalized": "a-\u003eSign",
        "package": "toysolver",
        "partial": "Of",
        "signature": "a-\u003eSign"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Sign.html#v:symbol",
      "description": {
        "fct-module": "Data.Sign",
        "fct-package": "toysolver",
        "fct-signature": "Sign -\u003e String",
        "fct-source": "src/Data-Sign.html#symbol",
        "fct-type": "function",
        "title": "symbol"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sign",
        "module": "Data.Sign",
        "name": "symbol",
        "normalized": "Sign-\u003eString",
        "package": "toysolver",
        "partial": "",
        "signature": "Sign-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#",
      "description": {
        "fct-module": "Data.Var",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Data-Var.html",
        "fct-type": "module",
        "title": "Var"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Var",
        "module": "Data.Var",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:Model",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003eModel\u003c/code\u003e is a map from variables to values.\n\u003c/p\u003e",
        "fct-module": "Data.Var",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Var.html#Model",
        "fct-type": "type",
        "title": "Model"
      },
      "index": {
        "description": "Model is map from variables to values",
        "hierarchy": "Data Var",
        "module": "Data.Var",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:Var",
      "description": {
        "fct-descr": "\u003cp\u003eVariables are represented as non-negative integers\n\u003c/p\u003e",
        "fct-module": "Data.Var",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Var.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "Variables are represented as non-negative integers",
        "hierarchy": "Data Var",
        "module": "Data.Var",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:VarMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap from variables\n\u003c/p\u003e",
        "fct-module": "Data.Var",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Var.html#VarMap",
        "fct-type": "type",
        "title": "VarMap"
      },
      "index": {
        "description": "Map from variables",
        "hierarchy": "Data Var",
        "module": "Data.Var",
        "name": "VarMap",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:VarSet",
      "description": {
        "fct-descr": "\u003cp\u003eSet of variables\n\u003c/p\u003e",
        "fct-module": "Data.Var",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Data-Var.html#VarSet",
        "fct-type": "type",
        "title": "VarSet"
      },
      "index": {
        "description": "Set of variables",
        "hierarchy": "Data Var",
        "module": "Data.Var",
        "name": "VarSet",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#t:Variables",
      "description": {
        "fct-descr": "\u003cp\u003ecollecting free variables\n\u003c/p\u003e",
        "fct-module": "Data.Var",
        "fct-package": "toysolver",
        "fct-signature": "class",
        "fct-source": "src/Data-Var.html#Variables",
        "fct-type": "class",
        "title": "Variables"
      },
      "index": {
        "description": "collecting free variables",
        "hierarchy": "Data Var",
        "module": "Data.Var",
        "name": "Variables",
        "normalized": "",
        "package": "toysolver",
        "partial": "Variables",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Data-Var.html#v:vars",
      "description": {
        "fct-module": "Data.Var",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e VarSet",
        "fct-source": "src/Data-Var.html#vars",
        "fct-type": "method",
        "title": "vars"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Var",
        "module": "Data.Var",
        "name": "vars",
        "normalized": "a-\u003eVarSet",
        "package": "toysolver",
        "partial": "",
        "signature": "a-\u003eVarSet"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#",
      "description": {
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-CAMUS.html",
        "fct-type": "module",
        "title": "CAMUS"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "CAMUS",
        "normalized": "",
        "package": "toysolver",
        "partial": "CAMUS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#t:MCS",
      "description": {
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-CAMUS.html#MCS",
        "fct-type": "type",
        "title": "MCS"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "MCS",
        "normalized": "",
        "package": "toysolver",
        "partial": "MCS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#t:MUS",
      "description": {
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-CAMUS.html#MUS",
        "fct-type": "type",
        "title": "MUS"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "MUS",
        "normalized": "",
        "package": "toysolver",
        "partial": "MUS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#t:Options",
      "description": {
        "fct-descr": "\u003cp\u003eOptions for \u003ccode\u003e\u003ca\u003eenumMCSAssumptions\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eallMCSAssumptions\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eallMUSAssumptions\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-CAMUS.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "Options for enumMCSAssumptions allMCSAssumptions allMUSAssumptions",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:Options",
      "description": {
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-CAMUS.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:allMCSAssumptions",
      "description": {
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [Lit] -\u003e Options -\u003e IO [MCS]",
        "fct-source": "src/SAT-CAMUS.html#allMCSAssumptions",
        "fct-type": "function",
        "title": "allMCSAssumptions"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "allMCSAssumptions",
        "normalized": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO[MCS]",
        "package": "toysolver",
        "partial": "MCSAssumptions",
        "signature": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO[MCS]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:allMUSAssumptions",
      "description": {
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [Lit] -\u003e Options -\u003e IO [MCS]",
        "fct-source": "src/SAT-CAMUS.html#allMUSAssumptions",
        "fct-type": "function",
        "title": "allMUSAssumptions"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "allMUSAssumptions",
        "normalized": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO[MCS]",
        "package": "toysolver",
        "partial": "MUSAssumptions",
        "signature": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO[MCS]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:defaultOptions",
      "description": {
        "fct-descr": "\u003cp\u003edefault \u003ccode\u003e\u003ca\u003eOptions\u003c/a\u003e\u003c/code\u003e value\n\u003c/p\u003e",
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-CAMUS.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "default Options value",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:enumMCSAssumptions",
      "description": {
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [Lit] -\u003e Options -\u003e IO ()",
        "fct-source": "src/SAT-CAMUS.html#enumMCSAssumptions",
        "fct-type": "function",
        "title": "enumMCSAssumptions"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "enumMCSAssumptions",
        "normalized": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO()",
        "package": "toysolver",
        "partial": "MCSAssumptions",
        "signature": "Solver-\u003e[Lit]-\u003eOptions-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:hittingSetDual",
      "description": {
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "[MCS] -\u003e [MUS]",
        "fct-source": "src/SAT-CAMUS.html#hittingSetDual",
        "fct-type": "function",
        "title": "hittingSetDual"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "hittingSetDual",
        "normalized": "[MCS]-\u003e[MUS]",
        "package": "toysolver",
        "partial": "Set Dual",
        "signature": "[MCS]-\u003e[MUS]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:optCallback",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "MCS -\u003e IO ()",
        "fct-source": "src/SAT-CAMUS.html#Options",
        "fct-type": "function",
        "title": "optCallback"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "optCallback",
        "normalized": "MCS-\u003eIO()",
        "package": "toysolver",
        "partial": "Callback",
        "signature": "MCS-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-CAMUS.html#v:optLogger",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.CAMUS",
        "fct-package": "toysolver",
        "fct-signature": "String -\u003e IO ()",
        "fct-source": "src/SAT-CAMUS.html#Options",
        "fct-type": "function",
        "title": "optLogger"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT CAMUS",
        "module": "SAT.CAMUS",
        "name": "optLogger",
        "normalized": "String-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "String-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#",
      "description": {
        "fct-module": "SAT.Integer",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-Integer.html",
        "fct-type": "module",
        "title": "Integer"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Integer",
        "module": "SAT.Integer",
        "name": "Integer",
        "normalized": "",
        "package": "toysolver",
        "partial": "Integer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#t:Expr",
      "description": {
        "fct-module": "SAT.Integer",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-Integer.html#Expr",
        "fct-type": "data",
        "title": "Expr"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Integer",
        "module": "SAT.Integer",
        "name": "Expr",
        "normalized": "",
        "package": "toysolver",
        "partial": "Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:Expr",
      "description": {
        "fct-module": "SAT.Integer",
        "fct-package": "toysolver",
        "fct-signature": "Expr [(Integer, [Lit])]",
        "fct-source": "src/SAT-Integer.html#Expr",
        "fct-type": "function",
        "title": "Expr"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Integer",
        "module": "SAT.Integer",
        "name": "Expr",
        "normalized": "Expr[(Integer,[Lit])]",
        "package": "toysolver",
        "partial": "Expr",
        "signature": "Expr[(Integer,[Lit])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:addConstraint",
      "description": {
        "fct-module": "SAT.Integer",
        "fct-package": "toysolver",
        "fct-signature": "Encoder -\u003e Rel Expr -\u003e IO ()",
        "fct-source": "src/SAT-Integer.html#addConstraint",
        "fct-type": "function",
        "title": "addConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Integer",
        "module": "SAT.Integer",
        "name": "addConstraint",
        "normalized": "Encoder-\u003eRel Expr-\u003eIO()",
        "package": "toysolver",
        "partial": "Constraint",
        "signature": "Encoder-\u003eRel Expr-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:addConstraintSoft",
      "description": {
        "fct-module": "SAT.Integer",
        "fct-package": "toysolver",
        "fct-signature": "Encoder -\u003e Lit -\u003e Rel Expr -\u003e IO ()",
        "fct-source": "src/SAT-Integer.html#addConstraintSoft",
        "fct-type": "function",
        "title": "addConstraintSoft"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Integer",
        "module": "SAT.Integer",
        "name": "addConstraintSoft",
        "normalized": "Encoder-\u003eLit-\u003eRel Expr-\u003eIO()",
        "package": "toysolver",
        "partial": "Constraint Soft",
        "signature": "Encoder-\u003eLit-\u003eRel Expr-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:eval",
      "description": {
        "fct-module": "SAT.Integer",
        "fct-package": "toysolver",
        "fct-signature": "Model -\u003e Expr -\u003e Integer",
        "fct-source": "src/SAT-Integer.html#eval",
        "fct-type": "function",
        "title": "eval"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Integer",
        "module": "SAT.Integer",
        "name": "eval",
        "normalized": "Model-\u003eExpr-\u003eInteger",
        "package": "toysolver",
        "partial": "",
        "signature": "Model-\u003eExpr-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:linearize",
      "description": {
        "fct-module": "SAT.Integer",
        "fct-package": "toysolver",
        "fct-signature": "Encoder -\u003e Expr -\u003e IO ([(Integer, Lit)], Integer)",
        "fct-source": "src/SAT-Integer.html#linearize",
        "fct-type": "function",
        "title": "linearize"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Integer",
        "module": "SAT.Integer",
        "name": "linearize",
        "normalized": "Encoder-\u003eExpr-\u003eIO([(Integer,Lit)],Integer)",
        "package": "toysolver",
        "partial": "",
        "signature": "Encoder-\u003eExpr-\u003eIO([(Integer,Lit)],Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Integer.html#v:newVar",
      "description": {
        "fct-module": "SAT.Integer",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Integer -\u003e Integer -\u003e IO Expr",
        "fct-source": "src/SAT-Integer.html#newVar",
        "fct-type": "function",
        "title": "newVar"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Integer",
        "module": "SAT.Integer",
        "name": "newVar",
        "normalized": "Solver-\u003eInteger-\u003eInteger-\u003eIO Expr",
        "package": "toysolver",
        "partial": "Var",
        "signature": "Solver-\u003eInteger-\u003eInteger-\u003eIO Expr"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMinimal Unsatifiable Subset (MUS) Finder\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "SAT.MUS",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-MUS.html",
        "fct-type": "module",
        "title": "MUS"
      },
      "index": {
        "description": "Minimal Unsatifiable Subset MUS Finder",
        "hierarchy": "SAT MUS",
        "module": "SAT.MUS",
        "name": "MUS",
        "normalized": "",
        "package": "toysolver",
        "partial": "MUS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#t:Options",
      "description": {
        "fct-descr": "\u003cp\u003eOptions for \u003ccode\u003e\u003ca\u003efindMUSAssumptions\u003c/a\u003e\u003c/code\u003e function\n\u003c/p\u003e",
        "fct-module": "SAT.MUS",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-MUS.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "Options for findMUSAssumptions function",
        "hierarchy": "SAT MUS",
        "module": "SAT.MUS",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:Options",
      "description": {
        "fct-module": "SAT.MUS",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-MUS.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT MUS",
        "module": "SAT.MUS",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:defaultOptions",
      "description": {
        "fct-descr": "\u003cp\u003edefault \u003ccode\u003e\u003ca\u003eOptions\u003c/a\u003e\u003c/code\u003e value\n\u003c/p\u003e",
        "fct-module": "SAT.MUS",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-MUS.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "default Options value",
        "hierarchy": "SAT MUS",
        "module": "SAT.MUS",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:findMUSAssumptions",
      "description": {
        "fct-descr": "\u003cp\u003eFind a minimal set of assumptions that causes a conflict.\n Initial set of assumptions is taken from \u003ccode\u003e\u003ca\u003efailedAssumptions\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT.MUS",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Options -\u003e IO [Lit]",
        "fct-source": "src/SAT-MUS.html#findMUSAssumptions",
        "fct-type": "function",
        "title": "findMUSAssumptions"
      },
      "index": {
        "description": "Find minimal set of assumptions that causes conflict Initial set of assumptions is taken from failedAssumptions",
        "hierarchy": "SAT MUS",
        "module": "SAT.MUS",
        "name": "findMUSAssumptions",
        "normalized": "Solver-\u003eOptions-\u003eIO[Lit]",
        "package": "toysolver",
        "partial": "MUSAssumptions",
        "signature": "Solver-\u003eOptions-\u003eIO[Lit]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:optLitPrinter",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.MUS",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e String",
        "fct-source": "src/SAT-MUS.html#Options",
        "fct-type": "function",
        "title": "optLitPrinter"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT MUS",
        "module": "SAT.MUS",
        "name": "optLitPrinter",
        "normalized": "Lit-\u003eString",
        "package": "toysolver",
        "partial": "Lit Printer",
        "signature": "Lit-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:optLogger",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.MUS",
        "fct-package": "toysolver",
        "fct-signature": "String -\u003e IO ()",
        "fct-source": "src/SAT-MUS.html#Options",
        "fct-type": "function",
        "title": "optLogger"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT MUS",
        "module": "SAT.MUS",
        "name": "optLogger",
        "normalized": "String-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "String-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-MUS.html#v:optUpdateBest",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.MUS",
        "fct-package": "toysolver",
        "fct-signature": "[Lit] -\u003e IO ()",
        "fct-source": "src/SAT-MUS.html#Options",
        "fct-type": "function",
        "title": "optUpdateBest"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT MUS",
        "module": "SAT.MUS",
        "name": "optUpdateBest",
        "normalized": "[Lit]-\u003eIO()",
        "package": "toysolver",
        "partial": "Update Best",
        "signature": "[Lit]-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReference:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Jo&#227;o P. Marques-Silva and Jordi Planes.\n   Algorithms for Maximum Satisfiability using Unsatisfiable Cores.\n   In Design, Automation and Test in Europe, 2008 (DATE '08). March 2008.\n   pp. 408-413, doi:10.1109/date.2008.4484715.\n   \u003ca\u003ehttp://dx.doi.org/10.1109/date.2008.4484715\u003c/a\u003e\n   \u003ca\u003ehttp://eprints.soton.ac.uk/265000/1/jpms-date08.pdf\u003c/a\u003e\n   \u003ca\u003ehttp://www.csi.ucd.ie/staff/jpms/talks/talksite/jpms-date08.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-PBO-MSU4.html",
        "fct-type": "module",
        "title": "MSU4"
      },
      "index": {
        "description": "Reference Jo Marques-Silva and Jordi Planes Algorithms for Maximum Satisfiability using Unsatisfiable Cores In Design Automation and Test in Europe DATE March pp doi date.2008.4484715 http dx.doi.org date.2008.4484715 http eprints.soton.ac.uk jpms-date08.pdf http www.csi.ucd.ie staff jpms talks talksite jpms-date08.pdf",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "MSU4",
        "normalized": "",
        "package": "toysolver",
        "partial": "MSU",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#t:Options",
      "description": {
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-PBO-MSU4.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:Options",
      "description": {
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-PBO-MSU4.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:defaultOptions",
      "description": {
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-PBO-MSU4.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:optLogger",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "String -\u003e IO ()",
        "fct-source": "src/SAT-PBO-MSU4.html#Options",
        "fct-type": "function",
        "title": "optLogger"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "optLogger",
        "normalized": "String-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "String-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:optUpdateBest",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "Model -\u003e Integer -\u003e IO ()",
        "fct-source": "src/SAT-PBO-MSU4.html#Options",
        "fct-type": "function",
        "title": "optUpdateBest"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "optUpdateBest",
        "normalized": "Model-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "Update Best",
        "signature": "Model-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:optUpdateLB",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "Integer -\u003e IO ()",
        "fct-source": "src/SAT-PBO-MSU4.html#Options",
        "fct-type": "function",
        "title": "optUpdateLB"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "optUpdateLB",
        "normalized": "Integer-\u003eIO()",
        "package": "toysolver",
        "partial": "Update LB",
        "signature": "Integer-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:solve",
      "description": {
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [(Integer, Lit)] -\u003e Options -\u003e IO (Maybe Model)",
        "fct-source": "src/SAT-PBO-MSU4.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "solve",
        "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-MSU4.html#v:solveWBO",
      "description": {
        "fct-module": "SAT.PBO.MSU4",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [(Lit, Integer)] -\u003e Options -\u003e IO (Maybe (Model, Integer))",
        "fct-source": "src/SAT-PBO-MSU4.html#solveWBO",
        "fct-type": "function",
        "title": "solveWBO"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO MSU4",
        "module": "SAT.PBO.MSU4",
        "name": "solveWBO",
        "normalized": "Solver-\u003e[(Lit,Integer)]-\u003eOptions-\u003eIO(Maybe(Model,Integer))",
        "package": "toysolver",
        "partial": "WBO",
        "signature": "Solver-\u003e[(Lit,Integer)]-\u003eOptions-\u003eIO(Maybe(Model,Integer))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#",
      "description": {
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-PBO-UnsatBased.html",
        "fct-type": "module",
        "title": "UnsatBased"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "UnsatBased",
        "normalized": "",
        "package": "toysolver",
        "partial": "Unsat Based",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#t:Options",
      "description": {
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-PBO-UnsatBased.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:Options",
      "description": {
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-PBO-UnsatBased.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:defaultOptions",
      "description": {
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-PBO-UnsatBased.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:optLogger",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "String -\u003e IO ()",
        "fct-source": "src/SAT-PBO-UnsatBased.html#Options",
        "fct-type": "function",
        "title": "optLogger"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "optLogger",
        "normalized": "String-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "String-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:optUpdateBest",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "Model -\u003e Integer -\u003e IO ()",
        "fct-source": "src/SAT-PBO-UnsatBased.html#Options",
        "fct-type": "function",
        "title": "optUpdateBest"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "optUpdateBest",
        "normalized": "Model-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "Update Best",
        "signature": "Model-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:optUpdateLB",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "Integer -\u003e IO ()",
        "fct-source": "src/SAT-PBO-UnsatBased.html#Options",
        "fct-type": "function",
        "title": "optUpdateLB"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "optUpdateLB",
        "normalized": "Integer-\u003eIO()",
        "package": "toysolver",
        "partial": "Update LB",
        "signature": "Integer-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:solve",
      "description": {
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [(Integer, Lit)] -\u003e Options -\u003e IO (Maybe Model)",
        "fct-source": "src/SAT-PBO-UnsatBased.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "solve",
        "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO-UnsatBased.html#v:solveWBO",
      "description": {
        "fct-module": "SAT.PBO.UnsatBased",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [(Lit, Integer)] -\u003e Options -\u003e IO (Maybe (Model, Integer))",
        "fct-source": "src/SAT-PBO-UnsatBased.html#solveWBO",
        "fct-type": "function",
        "title": "solveWBO"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO UnsatBased",
        "module": "SAT.PBO.UnsatBased",
        "name": "solveWBO",
        "normalized": "Solver-\u003e[(Lit,Integer)]-\u003eOptions-\u003eIO(Maybe(Model,Integer))",
        "package": "toysolver",
        "partial": "WBO",
        "signature": "Solver-\u003e[(Lit,Integer)]-\u003eOptions-\u003eIO(Maybe(Model,Integer))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePseudo-Boolean Optimization (PBO) Solver\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-PBO.html",
        "fct-type": "module",
        "title": "PBO"
      },
      "index": {
        "description": "Pseudo-Boolean Optimization PBO Solver",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "PBO",
        "normalized": "",
        "package": "toysolver",
        "partial": "PBO",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#t:Options",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-PBO.html#Options",
        "fct-type": "data",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#t:SearchStrategy",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-PBO.html#SearchStrategy",
        "fct-type": "data",
        "title": "SearchStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "SearchStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Search Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:AdaptiveSearch",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "AdaptiveSearch",
        "fct-source": "src/SAT-PBO.html#SearchStrategy",
        "fct-type": "function",
        "title": "AdaptiveSearch"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "AdaptiveSearch",
        "normalized": "",
        "package": "toysolver",
        "partial": "Adaptive Search",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:BinarySearch",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "BinarySearch",
        "fct-source": "src/SAT-PBO.html#SearchStrategy",
        "fct-type": "function",
        "title": "BinarySearch"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "BinarySearch",
        "normalized": "",
        "package": "toysolver",
        "partial": "Binary Search",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:LinearSearch",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "LinearSearch",
        "fct-source": "src/SAT-PBO.html#SearchStrategy",
        "fct-type": "function",
        "title": "LinearSearch"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "LinearSearch",
        "normalized": "",
        "package": "toysolver",
        "partial": "Linear Search",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:MSU4",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "MSU4",
        "fct-source": "src/SAT-PBO.html#SearchStrategy",
        "fct-type": "function",
        "title": "MSU4"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "MSU4",
        "normalized": "",
        "package": "toysolver",
        "partial": "MSU",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:Options",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-PBO.html#Options",
        "fct-type": "function",
        "title": "Options"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "Options",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:UnsatBased",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "UnsatBased",
        "fct-source": "src/SAT-PBO.html#SearchStrategy",
        "fct-type": "function",
        "title": "UnsatBased"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "UnsatBased",
        "normalized": "",
        "package": "toysolver",
        "partial": "Unsat Based",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:defaultOptions",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "Options",
        "fct-source": "src/SAT-PBO.html#defaultOptions",
        "fct-type": "function",
        "title": "defaultOptions"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "defaultOptions",
        "normalized": "",
        "package": "toysolver",
        "partial": "Options",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:minimize",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [(Integer, Lit)] -\u003e Options -\u003e IO (Maybe Model)",
        "fct-source": "src/SAT-PBO.html#minimize",
        "fct-type": "function",
        "title": "minimize"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "minimize",
        "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003e[(Integer,Lit)]-\u003eOptions-\u003eIO(Maybe Model)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optLogger",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "String -\u003e IO ()",
        "fct-source": "src/SAT-PBO.html#Options",
        "fct-type": "function",
        "title": "optLogger"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "optLogger",
        "normalized": "String-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "String-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optObjFunVarsHeuristics",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "Bool",
        "fct-source": "src/SAT-PBO.html#Options",
        "fct-type": "function",
        "title": "optObjFunVarsHeuristics"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "optObjFunVarsHeuristics",
        "normalized": "",
        "package": "toysolver",
        "partial": "Obj Fun Vars Heuristics",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optSearchStrategy",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "SearchStrategy",
        "fct-source": "src/SAT-PBO.html#Options",
        "fct-type": "function",
        "title": "optSearchStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "optSearchStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Search Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optTrialLimitConf",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "Int",
        "fct-source": "src/SAT-PBO.html#Options",
        "fct-type": "function",
        "title": "optTrialLimitConf"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "optTrialLimitConf",
        "normalized": "",
        "package": "toysolver",
        "partial": "Trial Limit Conf",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optUpdateBest",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "Model -\u003e Integer -\u003e IO ()",
        "fct-source": "src/SAT-PBO.html#Options",
        "fct-type": "function",
        "title": "optUpdateBest"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "optUpdateBest",
        "normalized": "Model-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "Update Best",
        "signature": "Model-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:optUpdateLB",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "Integer -\u003e IO ()",
        "fct-source": "src/SAT-PBO.html#Options",
        "fct-type": "function",
        "title": "optUpdateLB"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "optUpdateLB",
        "normalized": "Integer-\u003eIO()",
        "package": "toysolver",
        "partial": "Update LB",
        "signature": "Integer-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-PBO.html#v:tweakParams",
      "description": {
        "fct-module": "SAT.PBO",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e [(Integer, Lit)] -\u003e IO ()",
        "fct-source": "src/SAT-PBO.html#tweakParams",
        "fct-type": "function",
        "title": "tweakParams"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT PBO",
        "module": "SAT.PBO",
        "name": "tweakParams",
        "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eIO()",
        "package": "toysolver",
        "partial": "Params",
        "signature": "Solver-\u003e[(Integer,Lit)]-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePrinting utilities.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "SAT.Printer",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-Printer.html",
        "fct-type": "module",
        "title": "Printer"
      },
      "index": {
        "description": "Printing utilities",
        "hierarchy": "SAT Printer",
        "module": "SAT.Printer",
        "name": "Printer",
        "normalized": "",
        "package": "toysolver",
        "partial": "Printer",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#v:maxsatPrintModel",
      "description": {
        "fct-descr": "\u003cp\u003ePrint a \u003ccode\u003e\u003ca\u003eModel\u003c/a\u003e\u003c/code\u003e in a way specified for Max-SAT Evaluation.\n See \u003ca\u003ehttp://maxsat.ia.udl.cat/requirements/\u003c/a\u003e for details.\n\u003c/p\u003e",
        "fct-module": "SAT.Printer",
        "fct-package": "toysolver",
        "fct-signature": "Handle -\u003e Model -\u003e Int -\u003e IO ()",
        "fct-source": "src/SAT-Printer.html#maxsatPrintModel",
        "fct-type": "function",
        "title": "maxsatPrintModel"
      },
      "index": {
        "description": "Print Model in way specified for Max-SAT Evaluation See http maxsat.ia.udl.cat requirements for details",
        "hierarchy": "SAT Printer",
        "module": "SAT.Printer",
        "name": "maxsatPrintModel",
        "normalized": "Handle-\u003eModel-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "Print Model",
        "signature": "Handle-\u003eModel-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#v:musPrintSol",
      "description": {
        "fct-module": "SAT.Printer",
        "fct-package": "toysolver",
        "fct-signature": "Handle -\u003e [Int] -\u003e IO ()",
        "fct-source": "src/SAT-Printer.html#musPrintSol",
        "fct-type": "function",
        "title": "musPrintSol"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Printer",
        "module": "SAT.Printer",
        "name": "musPrintSol",
        "normalized": "Handle-\u003e[Int]-\u003eIO()",
        "package": "toysolver",
        "partial": "Print Sol",
        "signature": "Handle-\u003e[Int]-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#v:pbPrintModel",
      "description": {
        "fct-descr": "\u003cp\u003ePrint a \u003ccode\u003e\u003ca\u003eModel\u003c/a\u003e\u003c/code\u003e in a way specified for Pseudo-Boolean Competition.\n See \u003ca\u003ehttp://www.cril.univ-artois.fr/PB12/format.pdf\u003c/a\u003e for details.\n\u003c/p\u003e",
        "fct-module": "SAT.Printer",
        "fct-package": "toysolver",
        "fct-signature": "Handle -\u003e Model -\u003e Int -\u003e IO ()",
        "fct-source": "src/SAT-Printer.html#pbPrintModel",
        "fct-type": "function",
        "title": "pbPrintModel"
      },
      "index": {
        "description": "Print Model in way specified for Pseudo-Boolean Competition See http www.cril.univ-artois.fr PB12 format.pdf for details",
        "hierarchy": "SAT Printer",
        "module": "SAT.Printer",
        "name": "pbPrintModel",
        "normalized": "Handle-\u003eModel-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "Print Model",
        "signature": "Handle-\u003eModel-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Printer.html#v:satPrintModel",
      "description": {
        "fct-descr": "\u003cp\u003ePrint a \u003ccode\u003e\u003ca\u003eModel\u003c/a\u003e\u003c/code\u003e in a way specified for SAT Competition.\n See \u003ca\u003ehttp://www.satcompetition.org/2011/rules.pdf\u003c/a\u003e for details.\n\u003c/p\u003e",
        "fct-module": "SAT.Printer",
        "fct-package": "toysolver",
        "fct-signature": "Handle -\u003e Model -\u003e Int -\u003e IO ()",
        "fct-source": "src/SAT-Printer.html#satPrintModel",
        "fct-type": "function",
        "title": "satPrintModel"
      },
      "index": {
        "description": "Print Model in way specified for SAT Competition See http www.satcompetition.org rules.pdf for details",
        "hierarchy": "SAT Printer",
        "module": "SAT.Printer",
        "name": "satPrintModel",
        "normalized": "Handle-\u003eModel-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "Print Model",
        "signature": "Handle-\u003eModel-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#",
      "description": {
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-TheorySolver.html",
        "fct-type": "module",
        "title": "TheorySolver"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "TheorySolver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Theory Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#t:TheorySolver",
      "description": {
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-TheorySolver.html#TheorySolver",
        "fct-type": "data",
        "title": "TheorySolver"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "TheorySolver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Theory Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:TheorySolver",
      "description": {
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "TheorySolver",
        "fct-source": "src/SAT-TheorySolver.html#TheorySolver",
        "fct-type": "function",
        "title": "TheorySolver"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "TheorySolver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Theory Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:emptyTheory",
      "description": {
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "TheorySolver",
        "fct-source": "src/SAT-TheorySolver.html#emptyTheory",
        "fct-type": "function",
        "title": "emptyTheory"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "emptyTheory",
        "normalized": "",
        "package": "toysolver",
        "partial": "Theory",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thAssertLit",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "(Lit -\u003e IO Bool) -\u003e Lit -\u003e IO Bool",
        "fct-source": "src/SAT-TheorySolver.html#TheorySolver",
        "fct-type": "function",
        "title": "thAssertLit"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "thAssertLit",
        "normalized": "(Lit-\u003eIO Bool)-\u003eLit-\u003eIO Bool",
        "package": "toysolver",
        "partial": "Assert Lit",
        "signature": "(Lit-\u003eIO Bool)-\u003eLit-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thCheck",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "(Lit -\u003e IO Bool) -\u003e IO Bool",
        "fct-source": "src/SAT-TheorySolver.html#TheorySolver",
        "fct-type": "function",
        "title": "thCheck"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "thCheck",
        "normalized": "(Lit-\u003eIO Bool)-\u003eIO Bool",
        "package": "toysolver",
        "partial": "Check",
        "signature": "(Lit-\u003eIO Bool)-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thExplain",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "IO [Lit]",
        "fct-source": "src/SAT-TheorySolver.html#TheorySolver",
        "fct-type": "function",
        "title": "thExplain"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "thExplain",
        "normalized": "IO[Lit]",
        "package": "toysolver",
        "partial": "Explain",
        "signature": "IO[Lit]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thPopBacktrackPoint",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "IO ()",
        "fct-source": "src/SAT-TheorySolver.html#TheorySolver",
        "fct-type": "function",
        "title": "thPopBacktrackPoint"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "thPopBacktrackPoint",
        "normalized": "IO()",
        "package": "toysolver",
        "partial": "Pop Backtrack Point",
        "signature": "IO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TheorySolver.html#v:thPushBacktrackPoint",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "SAT.TheorySolver",
        "fct-package": "toysolver",
        "fct-signature": "IO ()",
        "fct-source": "src/SAT-TheorySolver.html#TheorySolver",
        "fct-type": "function",
        "title": "thPushBacktrackPoint"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TheorySolver",
        "module": "SAT.TheorySolver",
        "name": "thPushBacktrackPoint",
        "normalized": "IO()",
        "package": "toysolver",
        "partial": "Push Backtrack Point",
        "signature": "IO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTseitin encoding\n\u003c/p\u003e\u003cp\u003eTODO:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e reduce variables.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e [Tse83] G. Tseitin. On the complexity of derivation in propositional\n   calculus. Automation of Reasoning: Classical Papers in Computational\n   Logic, 2:466-483, 1983. Springer-Verlag. \n\u003c/li\u003e\u003cli\u003e [For60] R. Fortet. Application de l'alg&#232;bre de Boole en rechercheop\n   op&#233;rationelle. Revue Fran&#231;aise de Recherche Op&#233;rationelle, 4:17-26,\n   1960. \n\u003c/li\u003e\u003cli\u003e [BM84a] E. Balas and J. B. Mazzola. Nonlinear 0-1 programming:\n   I. Linearization techniques. Mathematical Programming, 30(1):1-21,\n   1984.\n\u003c/li\u003e\u003cli\u003e [BM84b] E. Balas and J. B. Mazzola. Nonlinear 0-1 programming:\n   II. Dominance relations and algorithms. Mathematical Programming,\n   30(1):22-45, 1984.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-TseitinEncoder.html",
        "fct-type": "module",
        "title": "TseitinEncoder"
      },
      "index": {
        "description": "Tseitin encoding TODO reduce variables References Tse83 Tseitin On the complexity of derivation in propositional calculus Automation of Reasoning Classical Papers in Computational Logic Springer-Verlag For60 Fortet Application de alg bre de Boole en rechercheop op rationelle Revue Fran aise de Recherche Op rationelle BM84a Balas and Mazzola Nonlinear programming Linearization techniques Mathematical Programming BM84b Balas and Mazzola Nonlinear programming II Dominance relations and algorithms Mathematical Programming",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "TseitinEncoder",
        "normalized": "",
        "package": "toysolver",
        "partial": "Tseitin Encoder",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#t:Encoder",
      "description": {
        "fct-descr": "\u003cp\u003eEncoder instance\n\u003c/p\u003e",
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-TseitinEncoder.html#Encoder",
        "fct-type": "data",
        "title": "Encoder"
      },
      "index": {
        "description": "Encoder instance",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "Encoder",
        "normalized": "",
        "package": "toysolver",
        "partial": "Encoder",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#t:Formula",
      "description": {
        "fct-descr": "\u003cp\u003eArbitrary formula not restricted to CNF\n\u003c/p\u003e",
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT-TseitinEncoder.html#Formula",
        "fct-type": "data",
        "title": "Formula"
      },
      "index": {
        "description": "Arbitrary formula not restricted to CNF",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "Formula",
        "normalized": "",
        "package": "toysolver",
        "partial": "Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:And",
      "description": {
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "And [Formula]",
        "fct-source": "src/SAT-TseitinEncoder.html#Formula",
        "fct-type": "function",
        "title": "And"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "And",
        "normalized": "And[Formula]",
        "package": "toysolver",
        "partial": "And",
        "signature": "And[Formula]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Equiv",
      "description": {
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Equiv Formula Formula",
        "fct-source": "src/SAT-TseitinEncoder.html#Formula",
        "fct-type": "function",
        "title": "Equiv"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "Equiv",
        "normalized": "",
        "package": "toysolver",
        "partial": "Equiv",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Imply",
      "description": {
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Imply Formula Formula",
        "fct-source": "src/SAT-TseitinEncoder.html#Formula",
        "fct-type": "function",
        "title": "Imply"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "Imply",
        "normalized": "",
        "package": "toysolver",
        "partial": "Imply",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Not",
      "description": {
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Not Formula",
        "fct-source": "src/SAT-TseitinEncoder.html#Formula",
        "fct-type": "function",
        "title": "Not"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "Not",
        "normalized": "",
        "package": "toysolver",
        "partial": "Not",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Or",
      "description": {
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Or [Formula]",
        "fct-source": "src/SAT-TseitinEncoder.html#Formula",
        "fct-type": "function",
        "title": "Or"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "Or",
        "normalized": "Or[Formula]",
        "package": "toysolver",
        "partial": "Or",
        "signature": "Or[Formula]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:Var",
      "description": {
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Var Var",
        "fct-source": "src/SAT-TseitinEncoder.html#Formula",
        "fct-type": "function",
        "title": "Var"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:addFormula",
      "description": {
        "fct-descr": "\u003cp\u003eAssert a given formula to underlying SAT solver by using\n Tseitin encoding.\n\u003c/p\u003e",
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Encoder -\u003e Formula -\u003e IO ()",
        "fct-source": "src/SAT-TseitinEncoder.html#addFormula",
        "fct-type": "function",
        "title": "addFormula"
      },
      "index": {
        "description": "Assert given formula to underlying SAT solver by using Tseitin encoding",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "addFormula",
        "normalized": "Encoder-\u003eFormula-\u003eIO()",
        "package": "toysolver",
        "partial": "Formula",
        "signature": "Encoder-\u003eFormula-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:encSolver",
      "description": {
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Encoder -\u003e Solver",
        "fct-source": "src/SAT-TseitinEncoder.html#encSolver",
        "fct-type": "function",
        "title": "encSolver"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "encSolver",
        "normalized": "Encoder-\u003eSolver",
        "package": "toysolver",
        "partial": "Solver",
        "signature": "Encoder-\u003eSolver"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:encodeConj",
      "description": {
        "fct-descr": "\u003cp\u003eReturn an literal which is equivalent to a given conjunction.\n\u003c/p\u003e",
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Encoder -\u003e [Lit] -\u003e IO Lit",
        "fct-source": "src/SAT-TseitinEncoder.html#encodeConj",
        "fct-type": "function",
        "title": "encodeConj"
      },
      "index": {
        "description": "Return an literal which is equivalent to given conjunction",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "encodeConj",
        "normalized": "Encoder-\u003e[Lit]-\u003eIO Lit",
        "package": "toysolver",
        "partial": "Conj",
        "signature": "Encoder-\u003e[Lit]-\u003eIO Lit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:encodeDisj",
      "description": {
        "fct-descr": "\u003cp\u003eReturn an literal which is equivalent to a given disjunction.\n\u003c/p\u003e",
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Encoder -\u003e [Lit] -\u003e IO Lit",
        "fct-source": "src/SAT-TseitinEncoder.html#encodeDisj",
        "fct-type": "function",
        "title": "encodeDisj"
      },
      "index": {
        "description": "Return an literal which is equivalent to given disjunction",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "encodeDisj",
        "normalized": "Encoder-\u003e[Lit]-\u003eIO Lit",
        "package": "toysolver",
        "partial": "Disj",
        "signature": "Encoder-\u003e[Lit]-\u003eIO Lit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:newEncoder",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003eEncoder\u003c/code\u003e instance.\n\u003c/p\u003e",
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Encoder",
        "fct-source": "src/SAT-TseitinEncoder.html#newEncoder",
        "fct-type": "function",
        "title": "newEncoder"
      },
      "index": {
        "description": "Create Encoder instance",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "newEncoder",
        "normalized": "Solver-\u003eIO Encoder",
        "package": "toysolver",
        "partial": "Encoder",
        "signature": "Solver-\u003eIO Encoder"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-TseitinEncoder.html#v:setUsePB",
      "description": {
        "fct-descr": "\u003cp\u003eUse \u003cem\u003epseudo boolean constraints\u003c/em\u003e or use only \u003cem\u003eclauses\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT.TseitinEncoder",
        "fct-package": "toysolver",
        "fct-signature": "Encoder -\u003e Bool -\u003e IO ()",
        "fct-source": "src/SAT-TseitinEncoder.html#setUsePB",
        "fct-type": "function",
        "title": "setUsePB"
      },
      "index": {
        "description": "Use pseudo boolean constraints or use only clauses",
        "hierarchy": "SAT TseitinEncoder",
        "module": "SAT.TseitinEncoder",
        "name": "setUsePB",
        "normalized": "Encoder-\u003eBool-\u003eIO()",
        "package": "toysolver",
        "partial": "Use PB",
        "signature": "Encoder-\u003eBool-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT-Types.html",
        "fct-type": "module",
        "title": "Types"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "Types",
        "normalized": "",
        "package": "toysolver",
        "partial": "Types",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:Clause",
      "description": {
        "fct-descr": "\u003cp\u003eDisjunction of \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#Clause",
        "fct-type": "type",
        "title": "Clause"
      },
      "index": {
        "description": "Disjunction of Lit",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "Clause",
        "normalized": "",
        "package": "toysolver",
        "partial": "Clause",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:Lit",
      "description": {
        "fct-descr": "\u003cp\u003ePositive (resp. negative) literals are represented as positive (resp.\n negative) integers. (DIMACS format).\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#Lit",
        "fct-type": "type",
        "title": "Lit"
      },
      "index": {
        "description": "Positive resp negative literals are represented as positive resp negative integers DIMACS format",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:LitMap",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#LitMap",
        "fct-type": "type",
        "title": "LitMap"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "LitMap",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:LitSet",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#LitSet",
        "fct-type": "type",
        "title": "LitSet"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "LitSet",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:Model",
      "description": {
        "fct-descr": "\u003cp\u003eA model is represented as a mapping from variables to its values.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#Model",
        "fct-type": "type",
        "title": "Model"
      },
      "index": {
        "description": "model is represented as mapping from variables to its values",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:Var",
      "description": {
        "fct-descr": "\u003cp\u003eVariable is represented as positive integers (DIMACS format).\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "Variable is represented as positive integers DIMACS format",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:VarMap",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#VarMap",
        "fct-type": "type",
        "title": "VarMap"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "VarMap",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#t:VarSet",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#VarSet",
        "fct-type": "type",
        "title": "VarSet"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "VarSet",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var Set",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:cardinalityReduction",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "([(Integer, Lit)], Integer) -\u003e ([Lit], Int)",
        "fct-source": "src/SAT-Types.html#cardinalityReduction",
        "fct-type": "function",
        "title": "cardinalityReduction"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "cardinalityReduction",
        "normalized": "([(Integer,Lit)],Integer)-\u003e([Lit],Int)",
        "package": "toysolver",
        "partial": "Reduction",
        "signature": "([(Integer,Lit)],Integer)-\u003e([Lit],Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:cutResolve",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer) -\u003e Var -\u003e ([(Integer, Lit)], Integer)",
        "fct-source": "src/SAT-Types.html#cutResolve",
        "fct-type": "function",
        "title": "cutResolve"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "cutResolve",
        "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)-\u003eVar-\u003e([(Integer,Lit)],Integer)",
        "package": "toysolver",
        "partial": "Resolve",
        "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)-\u003eVar-\u003e([(Integer,Lit)],Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:evalLit",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Model -\u003e Lit -\u003e Bool",
        "fct-source": "src/SAT-Types.html#evalLit",
        "fct-type": "function",
        "title": "evalLit"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "evalLit",
        "normalized": "Model-\u003eLit-\u003eBool",
        "package": "toysolver",
        "partial": "Lit",
        "signature": "Model-\u003eLit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litNot",
      "description": {
        "fct-descr": "\u003cp\u003eNegation of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e Lit",
        "fct-source": "src/SAT-Types.html#litNot",
        "fct-type": "function",
        "title": "litNot"
      },
      "index": {
        "description": "Negation of the Lit",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "litNot",
        "normalized": "Lit-\u003eLit",
        "package": "toysolver",
        "partial": "Not",
        "signature": "Lit-\u003eLit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litPolarity",
      "description": {
        "fct-descr": "\u003cp\u003ePolarity of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e means positive literal and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e means negative literal.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e Bool",
        "fct-source": "src/SAT-Types.html#litPolarity",
        "fct-type": "function",
        "title": "litPolarity"
      },
      "index": {
        "description": "Polarity of the Lit True means positive literal and False means negative literal",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "litPolarity",
        "normalized": "Lit-\u003eBool",
        "package": "toysolver",
        "partial": "Polarity",
        "signature": "Lit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litUndef",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Lit",
        "fct-source": "src/SAT-Types.html#litUndef",
        "fct-type": "function",
        "title": "litUndef"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "litUndef",
        "normalized": "",
        "package": "toysolver",
        "partial": "Undef",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:litVar",
      "description": {
        "fct-descr": "\u003cp\u003eUnderlying variable of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e Var",
        "fct-source": "src/SAT-Types.html#litVar",
        "fct-type": "function",
        "title": "litVar"
      },
      "index": {
        "description": "Underlying variable of the Lit",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "litVar",
        "normalized": "Lit-\u003eVar",
        "package": "toysolver",
        "partial": "Var",
        "signature": "Lit-\u003eVar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:literal",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a literal from a variable and its polarity.\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e (resp \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e) means positive (resp. negative) literal.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Var-\u003e Bool-\u003e Lit",
        "fct-type": "function",
        "title": "literal"
      },
      "index": {
        "description": "Construct literal from variable and its polarity True resp False means positive resp negative literal",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "literal",
        "normalized": "Var-\u003eBool-\u003eLit",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eBool-\u003eLit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:negatePBAtLeast",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer)",
        "fct-source": "src/SAT-Types.html#negatePBAtLeast",
        "fct-type": "function",
        "title": "negatePBAtLeast"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "negatePBAtLeast",
        "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
        "package": "toysolver",
        "partial": "PBAt Least",
        "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizeAtLeast",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "([Lit], Int) -\u003e ([Lit], Int)",
        "fct-source": "src/SAT-Types.html#normalizeAtLeast",
        "fct-type": "function",
        "title": "normalizeAtLeast"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "normalizeAtLeast",
        "normalized": "([Lit],Int)-\u003e([Lit],Int)",
        "package": "toysolver",
        "partial": "At Least",
        "signature": "([Lit],Int)-\u003e([Lit],Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizeClause",
      "description": {
        "fct-descr": "\u003cp\u003eNormalizing clause\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the clause is trivially true.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Clause -\u003e Maybe Clause",
        "fct-source": "src/SAT-Types.html#normalizeClause",
        "fct-type": "function",
        "title": "normalizeClause"
      },
      "index": {
        "description": "Normalizing clause Nothing if the clause is trivially true",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "normalizeClause",
        "normalized": "Clause-\u003eMaybe Clause",
        "package": "toysolver",
        "partial": "Clause",
        "signature": "Clause-\u003eMaybe Clause"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizePBAtLeast",
      "description": {
        "fct-descr": "\u003cp\u003enormalizing PB constraint of the form \u003cem\u003ec1 x1 + c2 cn ... cn xn \u003e= b\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer)",
        "fct-source": "src/SAT-Types.html#normalizePBAtLeast",
        "fct-type": "function",
        "title": "normalizePBAtLeast"
      },
      "index": {
        "description": "normalizing PB constraint of the form c1 x1 c2 cn cn xn",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "normalizePBAtLeast",
        "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
        "package": "toysolver",
        "partial": "PBAt Least",
        "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizePBExactly",
      "description": {
        "fct-descr": "\u003cp\u003enormalizing PB constraint of the form \u003cem\u003ec1 x1 + c2 cn ... cn xn = b\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer)",
        "fct-source": "src/SAT-Types.html#normalizePBExactly",
        "fct-type": "function",
        "title": "normalizePBExactly"
      },
      "index": {
        "description": "normalizing PB constraint of the form c1 x1 c2 cn cn xn",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "normalizePBExactly",
        "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
        "package": "toysolver",
        "partial": "PBExactly",
        "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:normalizePBSum",
      "description": {
        "fct-descr": "\u003cp\u003enormalizing PB term of the form \u003cem\u003ec1 x1 + c2 x2 ... cn xn + c\u003c/em\u003e into\n \u003cem\u003ed1 x1 + d2 x2 ... dm xm + d\u003c/em\u003e where d1,...,dm &#8805; 1.\n\u003c/p\u003e",
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "([(Integer, Lit)], Integer) -\u003e ([(Integer, Lit)], Integer)",
        "fct-source": "src/SAT-Types.html#normalizePBSum",
        "fct-type": "function",
        "title": "normalizePBSum"
      },
      "index": {
        "description": "normalizing PB term of the form c1 x1 c2 x2 cn xn into d1 x1 d2 x2 dm xm where d1 dm",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "normalizePBSum",
        "normalized": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)",
        "package": "toysolver",
        "partial": "PBSum",
        "signature": "([(Integer,Lit)],Integer)-\u003e([(Integer,Lit)],Integer)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:pbEval",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Model -\u003e [(Integer, Lit)] -\u003e Integer",
        "fct-source": "src/SAT-Types.html#pbEval",
        "fct-type": "function",
        "title": "pbEval"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "pbEval",
        "normalized": "Model-\u003e[(Integer,Lit)]-\u003eInteger",
        "package": "toysolver",
        "partial": "Eval",
        "signature": "Model-\u003e[(Integer,Lit)]-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:pbLowerBound",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "[(Integer, Lit)] -\u003e Integer",
        "fct-source": "src/SAT-Types.html#pbLowerBound",
        "fct-type": "function",
        "title": "pbLowerBound"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "pbLowerBound",
        "normalized": "[(Integer,Lit)]-\u003eInteger",
        "package": "toysolver",
        "partial": "Lower Bound",
        "signature": "[(Integer,Lit)]-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:pbUpperBound",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "[(Integer, Lit)] -\u003e Integer",
        "fct-source": "src/SAT-Types.html#pbUpperBound",
        "fct-type": "function",
        "title": "pbUpperBound"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "pbUpperBound",
        "normalized": "[(Integer,Lit)]-\u003eInteger",
        "package": "toysolver",
        "partial": "Upper Bound",
        "signature": "[(Integer,Lit)]-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:validLit",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e Bool",
        "fct-source": "src/SAT-Types.html#validLit",
        "fct-type": "function",
        "title": "validLit"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "validLit",
        "normalized": "Lit-\u003eBool",
        "package": "toysolver",
        "partial": "Lit",
        "signature": "Lit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT-Types.html#v:validVar",
      "description": {
        "fct-module": "SAT.Types",
        "fct-package": "toysolver",
        "fct-signature": "Var -\u003e Bool",
        "fct-source": "src/SAT-Types.html#validVar",
        "fct-type": "function",
        "title": "validVar"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT Types",
        "module": "SAT.Types",
        "name": "validVar",
        "normalized": "Var-\u003eBool",
        "package": "toysolver",
        "partial": "Var",
        "signature": "Var-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA CDCL SAT solver.\n\u003c/p\u003e\u003cp\u003eIt follows the design of MiniSat and SAT4J.\n\u003c/p\u003e\u003cp\u003eSee also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/funsat\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://hackage.haskell.org/package/incremental-sat-solver\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/SAT.html",
        "fct-type": "module",
        "title": "SAT"
      },
      "index": {
        "description": "CDCL SAT solver It follows the design of MiniSat and SAT4J See also http hackage.haskell.org package funsat http hackage.haskell.org package incremental-sat-solver",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "SAT",
        "normalized": "",
        "package": "toysolver",
        "partial": "SAT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:BudgetExceeded",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT.html#BudgetExceeded",
        "fct-type": "data",
        "title": "BudgetExceeded"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "BudgetExceeded",
        "normalized": "",
        "package": "toysolver",
        "partial": "Budget Exceeded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Clause",
      "description": {
        "fct-descr": "\u003cp\u003eDisjunction of \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#Clause",
        "fct-type": "type",
        "title": "Clause"
      },
      "index": {
        "description": "Disjunction of Lit",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "Clause",
        "normalized": "",
        "package": "toysolver",
        "partial": "Clause",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:LearningStrategy",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT.html#LearningStrategy",
        "fct-type": "data",
        "title": "LearningStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "LearningStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Learning Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Lit",
      "description": {
        "fct-descr": "\u003cp\u003ePositive (resp. negative) literals are represented as positive (resp.\n negative) integers. (DIMACS format).\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#Lit",
        "fct-type": "type",
        "title": "Lit"
      },
      "index": {
        "description": "Positive resp negative literals are represented as positive resp negative integers DIMACS format",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Model",
      "description": {
        "fct-descr": "\u003cp\u003eA model is represented as a mapping from variables to its values.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#Model",
        "fct-type": "type",
        "title": "Model"
      },
      "index": {
        "description": "model is represented as mapping from variables to its values",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:RestartStrategy",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT.html#RestartStrategy",
        "fct-type": "data",
        "title": "RestartStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "RestartStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Restart Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Solver",
      "description": {
        "fct-descr": "\u003cp\u003eSolver instance\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/SAT.html#Solver",
        "fct-type": "data",
        "title": "Solver"
      },
      "index": {
        "description": "Solver instance",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "Solver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#t:Var",
      "description": {
        "fct-descr": "\u003cp\u003eVariable is represented as positive integers (DIMACS format).\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/SAT-Types.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "Variable is represented as positive integers DIMACS format",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:ArminRestarts",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "ArminRestarts",
        "fct-source": "src/SAT.html#RestartStrategy",
        "fct-type": "function",
        "title": "ArminRestarts"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "ArminRestarts",
        "normalized": "",
        "package": "toysolver",
        "partial": "Armin Restarts",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:BudgetExceeded",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "BudgetExceeded",
        "fct-source": "src/SAT.html#BudgetExceeded",
        "fct-type": "function",
        "title": "BudgetExceeded"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "BudgetExceeded",
        "normalized": "",
        "package": "toysolver",
        "partial": "Budget Exceeded",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:LearningClause",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "LearningClause",
        "fct-source": "src/SAT.html#LearningStrategy",
        "fct-type": "function",
        "title": "LearningClause"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "LearningClause",
        "normalized": "",
        "package": "toysolver",
        "partial": "Learning Clause",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:LearningHybrid",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "LearningHybrid",
        "fct-source": "src/SAT.html#LearningStrategy",
        "fct-type": "function",
        "title": "LearningHybrid"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "LearningHybrid",
        "normalized": "",
        "package": "toysolver",
        "partial": "Learning Hybrid",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:LubyRestarts",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "LubyRestarts",
        "fct-source": "src/SAT.html#RestartStrategy",
        "fct-type": "function",
        "title": "LubyRestarts"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "LubyRestarts",
        "normalized": "",
        "package": "toysolver",
        "partial": "Luby Restarts",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:MiniSATRestarts",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "MiniSATRestarts",
        "fct-source": "src/SAT.html#RestartStrategy",
        "fct-type": "function",
        "title": "MiniSATRestarts"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "MiniSATRestarts",
        "normalized": "",
        "package": "toysolver",
        "partial": "Mini SATRestarts",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addAtLeast",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a cardinality constraints \u003cem\u003eatleast({l1,l2,..},n)\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e [Lit]-\u003e Int-\u003e IO ()",
        "fct-type": "function",
        "title": "addAtLeast"
      },
      "index": {
        "description": "Add cardinality constraints atleast l1 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addAtLeast",
        "normalized": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "At Least",
        "signature": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addAtMost",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a cardinality constraints \u003cem\u003eatmost({l1,l2,..},n)\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e [Lit]-\u003e Int-\u003e IO ()",
        "fct-type": "function",
        "title": "addAtMost"
      },
      "index": {
        "description": "Add cardinality constraints atmost l1 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addAtMost",
        "normalized": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "At Most",
        "signature": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addClause",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a clause to the solver.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Clause -\u003e IO ()",
        "fct-source": "src/SAT.html#addClause",
        "fct-type": "function",
        "title": "addClause"
      },
      "index": {
        "description": "Add clause to the solver",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addClause",
        "normalized": "Solver-\u003eClause-\u003eIO()",
        "package": "toysolver",
        "partial": "Clause",
        "signature": "Solver-\u003eClause-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addExactly",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a cardinality constraints \u003cem\u003eexactly({l1,l2,..},n)\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e [Lit]-\u003e Int-\u003e IO ()",
        "fct-type": "function",
        "title": "addExactly"
      },
      "index": {
        "description": "Add cardinality constraints exactly l1 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addExactly",
        "normalized": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "Exactly",
        "signature": "Solver-\u003e[Lit]-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBAtLeast",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a pseudo boolean constraints \u003cem\u003ec1*l1 + c2*l2 + &#8230; &#8805; n\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
        "fct-type": "function",
        "title": "addPBAtLeast"
      },
      "index": {
        "description": "Add pseudo boolean constraints c1 l1 c2 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addPBAtLeast",
        "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "PBAt Least",
        "signature": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBAtLeastSoft",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a soft pseudo boolean constraints \u003cem\u003elit &#8658; c1*l1 + c2*l2 + &#8230; &#8805; n\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e Lit-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
        "fct-type": "function",
        "title": "addPBAtLeastSoft"
      },
      "index": {
        "description": "Add soft pseudo boolean constraints lit c1 l1 c2 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addPBAtLeastSoft",
        "normalized": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "PBAt Least Soft",
        "signature": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBAtMost",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a pseudo boolean constraints \u003cem\u003ec1*l1 + c2*l2 + &#8230; &#8804; n\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
        "fct-type": "function",
        "title": "addPBAtMost"
      },
      "index": {
        "description": "Add pseudo boolean constraints c1 l1 c2 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addPBAtMost",
        "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "PBAt Most",
        "signature": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBAtMostSoft",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a soft pseudo boolean constraints \u003cem\u003elit &#8658; c1*l1 + c2*l2 + &#8230; &#8804; n\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e Lit-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
        "fct-type": "function",
        "title": "addPBAtMostSoft"
      },
      "index": {
        "description": "Add soft pseudo boolean constraints lit c1 l1 c2 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addPBAtMostSoft",
        "normalized": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "PBAt Most Soft",
        "signature": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBExactly",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a pseudo boolean constraints \u003cem\u003ec1*l1 + c2*l2 + &#8230; = n\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
        "fct-type": "function",
        "title": "addPBExactly"
      },
      "index": {
        "description": "Add pseudo boolean constraints c1 l1 c2 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addPBExactly",
        "normalized": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "PBExactly",
        "signature": "Solver-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:addPBExactlySoft",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a soft pseudo boolean constraints \u003cem\u003elit &#8658; c1*l1 + c2*l2 + &#8230; = n\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e Lit-\u003e [(Integer, Lit)]-\u003e Integer-\u003e IO ()",
        "fct-type": "function",
        "title": "addPBExactlySoft"
      },
      "index": {
        "description": "Add soft pseudo boolean constraints lit c1 l1 c2 l2",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "addPBExactlySoft",
        "normalized": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()",
        "package": "toysolver",
        "partial": "PBExactly Soft",
        "signature": "Solver-\u003eLit-\u003e[(Integer,Lit)]-\u003eInteger-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultCCMin",
      "description": {
        "fct-descr": "\u003cp\u003edefault value for \u003ccode\u003eCCMin\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Int",
        "fct-source": "src/SAT.html#defaultCCMin",
        "fct-type": "function",
        "title": "defaultCCMin"
      },
      "index": {
        "description": "default value for CCMin",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "defaultCCMin",
        "normalized": "",
        "package": "toysolver",
        "partial": "CCMin",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultLearningStrategy",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "LearningStrategy",
        "fct-source": "src/SAT.html#defaultLearningStrategy",
        "fct-type": "function",
        "title": "defaultLearningStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "defaultLearningStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Learning Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultLearntSizeFirst",
      "description": {
        "fct-descr": "\u003cp\u003edefault value for \u003ccode\u003eLearntSizeFirst\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Int",
        "fct-source": "src/SAT.html#defaultLearntSizeFirst",
        "fct-type": "function",
        "title": "defaultLearntSizeFirst"
      },
      "index": {
        "description": "default value for LearntSizeFirst",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "defaultLearntSizeFirst",
        "normalized": "",
        "package": "toysolver",
        "partial": "Learnt Size First",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultLearntSizeInc",
      "description": {
        "fct-descr": "\u003cp\u003edefault value for \u003ccode\u003eLearntSizeInc\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Double",
        "fct-source": "src/SAT.html#defaultLearntSizeInc",
        "fct-type": "function",
        "title": "defaultLearntSizeInc"
      },
      "index": {
        "description": "default value for LearntSizeInc",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "defaultLearntSizeInc",
        "normalized": "",
        "package": "toysolver",
        "partial": "Learnt Size Inc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultRandomFreq",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Double",
        "fct-source": "src/SAT.html#defaultRandomFreq",
        "fct-type": "function",
        "title": "defaultRandomFreq"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "defaultRandomFreq",
        "normalized": "",
        "package": "toysolver",
        "partial": "Random Freq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultRestartFirst",
      "description": {
        "fct-descr": "\u003cp\u003edefault value for \u003ccode\u003eRestartFirst\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Int",
        "fct-source": "src/SAT.html#defaultRestartFirst",
        "fct-type": "function",
        "title": "defaultRestartFirst"
      },
      "index": {
        "description": "default value for RestartFirst",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "defaultRestartFirst",
        "normalized": "",
        "package": "toysolver",
        "partial": "Restart First",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultRestartInc",
      "description": {
        "fct-descr": "\u003cp\u003edefault value for \u003ccode\u003eRestartInc\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Double",
        "fct-source": "src/SAT.html#defaultRestartInc",
        "fct-type": "function",
        "title": "defaultRestartInc"
      },
      "index": {
        "description": "default value for RestartInc",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "defaultRestartInc",
        "normalized": "",
        "package": "toysolver",
        "partial": "Restart Inc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:defaultRestartStrategy",
      "description": {
        "fct-descr": "\u003cp\u003edefault value for \u003ccode\u003eRestartStrategy\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "RestartStrategy",
        "fct-source": "src/SAT.html#defaultRestartStrategy",
        "fct-type": "function",
        "title": "defaultRestartStrategy"
      },
      "index": {
        "description": "default value for RestartStrategy",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "defaultRestartStrategy",
        "normalized": "",
        "package": "toysolver",
        "partial": "Restart Strategy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:failedAssumptions",
      "description": {
        "fct-descr": "\u003cp\u003eAfter \u003ccode\u003e\u003ca\u003esolveWith\u003c/a\u003e\u003c/code\u003e returns False, it returns a set of assumptions\n that leads to contradiction. In particular, if it returns an empty\n set, the problem is unsatisiable without any assumptions.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO [Lit]",
        "fct-source": "src/SAT.html#failedAssumptions",
        "fct-type": "function",
        "title": "failedAssumptions"
      },
      "index": {
        "description": "After solveWith returns False it returns set of assumptions that leads to contradiction In particular if it returns an empty set the problem is unsatisiable without any assumptions",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "failedAssumptions",
        "normalized": "Solver-\u003eIO[Lit]",
        "package": "toysolver",
        "partial": "Assumptions",
        "signature": "Solver-\u003eIO[Lit]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:litNot",
      "description": {
        "fct-descr": "\u003cp\u003eNegation of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e Lit",
        "fct-source": "src/SAT-Types.html#litNot",
        "fct-type": "function",
        "title": "litNot"
      },
      "index": {
        "description": "Negation of the Lit",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "litNot",
        "normalized": "Lit-\u003eLit",
        "package": "toysolver",
        "partial": "Not",
        "signature": "Lit-\u003eLit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:litPolarity",
      "description": {
        "fct-descr": "\u003cp\u003ePolarity of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e means positive literal and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e means negative literal.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e Bool",
        "fct-source": "src/SAT-Types.html#litPolarity",
        "fct-type": "function",
        "title": "litPolarity"
      },
      "index": {
        "description": "Polarity of the Lit True means positive literal and False means negative literal",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "litPolarity",
        "normalized": "Lit-\u003eBool",
        "package": "toysolver",
        "partial": "Polarity",
        "signature": "Lit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:litVar",
      "description": {
        "fct-descr": "\u003cp\u003eUnderlying variable of the \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Lit -\u003e Var",
        "fct-source": "src/SAT-Types.html#litVar",
        "fct-type": "function",
        "title": "litVar"
      },
      "index": {
        "description": "Underlying variable of the Lit",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "litVar",
        "normalized": "Lit-\u003eVar",
        "package": "toysolver",
        "partial": "Var",
        "signature": "Lit-\u003eVar"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:literal",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a literal from a variable and its polarity.\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e (resp \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e) means positive (resp. negative) literal.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Var-\u003e Bool-\u003e Lit",
        "fct-type": "function",
        "title": "literal"
      },
      "index": {
        "description": "Construct literal from variable and its polarity True resp False means positive resp negative literal",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "literal",
        "normalized": "Var-\u003eBool-\u003eLit",
        "package": "toysolver",
        "partial": "",
        "signature": "Var-\u003eBool-\u003eLit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:model",
      "description": {
        "fct-descr": "\u003cp\u003eAfter \u003ccode\u003e\u003ca\u003esolve\u003c/a\u003e\u003c/code\u003e returns True, it returns the model.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Model",
        "fct-source": "src/SAT.html#model",
        "fct-type": "function",
        "title": "model"
      },
      "index": {
        "description": "After solve returns True it returns the model",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "model",
        "normalized": "Solver-\u003eIO Model",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003eIO Model"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:nAssigns",
      "description": {
        "fct-descr": "\u003cp\u003enumber of assigned variables.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Int",
        "fct-source": "src/SAT.html#nAssigns",
        "fct-type": "function",
        "title": "nAssigns"
      },
      "index": {
        "description": "number of assigned variables",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "nAssigns",
        "normalized": "Solver-\u003eIO Int",
        "package": "toysolver",
        "partial": "Assigns",
        "signature": "Solver-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:nClauses",
      "description": {
        "fct-descr": "\u003cp\u003enumber of clauses.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Int",
        "fct-source": "src/SAT.html#nClauses",
        "fct-type": "function",
        "title": "nClauses"
      },
      "index": {
        "description": "number of clauses",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "nClauses",
        "normalized": "Solver-\u003eIO Int",
        "package": "toysolver",
        "partial": "Clauses",
        "signature": "Solver-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:nLearnt",
      "description": {
        "fct-descr": "\u003cp\u003enumber of learnt constrints.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Int",
        "fct-source": "src/SAT.html#nLearnt",
        "fct-type": "function",
        "title": "nLearnt"
      },
      "index": {
        "description": "number of learnt constrints",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "nLearnt",
        "normalized": "Solver-\u003eIO Int",
        "package": "toysolver",
        "partial": "Learnt",
        "signature": "Solver-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:nVars",
      "description": {
        "fct-descr": "\u003cp\u003enumber of variables of the problem.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Int",
        "fct-source": "src/SAT.html#nVars",
        "fct-type": "function",
        "title": "nVars"
      },
      "index": {
        "description": "number of variables of the problem",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "nVars",
        "normalized": "Solver-\u003eIO Int",
        "package": "toysolver",
        "partial": "Vars",
        "signature": "Solver-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:newSolver",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new Solver instance.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "IO Solver",
        "fct-source": "src/SAT.html#newSolver",
        "fct-type": "function",
        "title": "newSolver"
      },
      "index": {
        "description": "Create new Solver instance",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "newSolver",
        "normalized": "",
        "package": "toysolver",
        "partial": "Solver",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:newVar",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a new variable\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Var",
        "fct-source": "src/SAT.html#newVar",
        "fct-type": "function",
        "title": "newVar"
      },
      "index": {
        "description": "Add new variable",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "newVar",
        "normalized": "Solver-\u003eIO Var",
        "package": "toysolver",
        "partial": "Var",
        "signature": "Solver-\u003eIO Var"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:newVars",
      "description": {
        "fct-descr": "\u003cp\u003eAdd variables. \u003ccode\u003enewVars solver n = replicateM n (newVar solver)\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Int -\u003e IO [Var]",
        "fct-source": "src/SAT.html#newVars",
        "fct-type": "function",
        "title": "newVars"
      },
      "index": {
        "description": "Add variables newVars solver replicateM newVar solver",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "newVars",
        "normalized": "Solver-\u003eInt-\u003eIO[Var]",
        "package": "toysolver",
        "partial": "Vars",
        "signature": "Solver-\u003eInt-\u003eIO[Var]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:newVars_",
      "description": {
        "fct-descr": "\u003cp\u003eAdd variables. \u003ccode\u003enewVars_ solver n \u003e\u003e return () = newVars_ solver n\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Int -\u003e IO ()",
        "fct-source": "src/SAT.html#newVars_",
        "fct-type": "function",
        "title": "newVars_"
      },
      "index": {
        "description": "Add variables newVars solver return newVars solver",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "newVars_",
        "normalized": "Solver-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "Vars",
        "signature": "Solver-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setCCMin",
      "description": {
        "fct-descr": "\u003cp\u003eThe limit for learnt clauses is multiplied with this factor each restart. (default 1.1)\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Int -\u003e IO ()",
        "fct-source": "src/SAT.html#setCCMin",
        "fct-type": "function",
        "title": "setCCMin"
      },
      "index": {
        "description": "The limit for learnt clauses is multiplied with this factor each restart default",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setCCMin",
        "normalized": "Solver-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "CCMin",
        "signature": "Solver-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setCheckModel",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Bool -\u003e IO ()",
        "fct-source": "src/SAT.html#setCheckModel",
        "fct-type": "function",
        "title": "setCheckModel"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setCheckModel",
        "normalized": "Solver-\u003eBool-\u003eIO()",
        "package": "toysolver",
        "partial": "Check Model",
        "signature": "Solver-\u003eBool-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setConfBudget",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Maybe Int -\u003e IO ()",
        "fct-source": "src/SAT.html#setConfBudget",
        "fct-type": "function",
        "title": "setConfBudget"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setConfBudget",
        "normalized": "Solver-\u003eMaybe Int-\u003eIO()",
        "package": "toysolver",
        "partial": "Conf Budget",
        "signature": "Solver-\u003eMaybe Int-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setLearningStrategy",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e LearningStrategy -\u003e IO ()",
        "fct-source": "src/SAT.html#setLearningStrategy",
        "fct-type": "function",
        "title": "setLearningStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setLearningStrategy",
        "normalized": "Solver-\u003eLearningStrategy-\u003eIO()",
        "package": "toysolver",
        "partial": "Learning Strategy",
        "signature": "Solver-\u003eLearningStrategy-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setLearntSizeFirst",
      "description": {
        "fct-descr": "\u003cp\u003eThe initial limit for learnt clauses.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Int -\u003e IO ()",
        "fct-source": "src/SAT.html#setLearntSizeFirst",
        "fct-type": "function",
        "title": "setLearntSizeFirst"
      },
      "index": {
        "description": "The initial limit for learnt clauses",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setLearntSizeFirst",
        "normalized": "Solver-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "Learnt Size First",
        "signature": "Solver-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setLearntSizeInc",
      "description": {
        "fct-descr": "\u003cp\u003eThe limit for learnt clauses is multiplied with this factor each restart. (default 1.1)\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Double -\u003e IO ()",
        "fct-source": "src/SAT.html#setLearntSizeInc",
        "fct-type": "function",
        "title": "setLearntSizeInc"
      },
      "index": {
        "description": "The limit for learnt clauses is multiplied with this factor each restart default",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setLearntSizeInc",
        "normalized": "Solver-\u003eDouble-\u003eIO()",
        "package": "toysolver",
        "partial": "Learnt Size Inc",
        "signature": "Solver-\u003eDouble-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setLogger",
      "description": {
        "fct-descr": "\u003cp\u003eset callback function for receiving messages.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e (String -\u003e IO ()) -\u003e IO ()",
        "fct-source": "src/SAT.html#setLogger",
        "fct-type": "function",
        "title": "setLogger"
      },
      "index": {
        "description": "set callback function for receiving messages",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setLogger",
        "normalized": "Solver-\u003e(String-\u003eIO())-\u003eIO()",
        "package": "toysolver",
        "partial": "Logger",
        "signature": "Solver-\u003e(String-\u003eIO())-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRandomFreq",
      "description": {
        "fct-descr": "\u003cp\u003eThe frequency with which the decision heuristic tries to choose a random variable\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Double -\u003e IO ()",
        "fct-source": "src/SAT.html#setRandomFreq",
        "fct-type": "function",
        "title": "setRandomFreq"
      },
      "index": {
        "description": "The frequency with which the decision heuristic tries to choose random variable",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setRandomFreq",
        "normalized": "Solver-\u003eDouble-\u003eIO()",
        "package": "toysolver",
        "partial": "Random Freq",
        "signature": "Solver-\u003eDouble-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRandomSeed",
      "description": {
        "fct-descr": "\u003cp\u003eUsed by the random variable selection\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Int -\u003e IO ()",
        "fct-source": "src/SAT.html#setRandomSeed",
        "fct-type": "function",
        "title": "setRandomSeed"
      },
      "index": {
        "description": "Used by the random variable selection",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setRandomSeed",
        "normalized": "Solver-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "Random Seed",
        "signature": "Solver-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRestartFirst",
      "description": {
        "fct-descr": "\u003cp\u003eThe initial restart limit. (default 100)\n Negative value is used to disable restart.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Int -\u003e IO ()",
        "fct-source": "src/SAT.html#setRestartFirst",
        "fct-type": "function",
        "title": "setRestartFirst"
      },
      "index": {
        "description": "The initial restart limit default Negative value is used to disable restart",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setRestartFirst",
        "normalized": "Solver-\u003eInt-\u003eIO()",
        "package": "toysolver",
        "partial": "Restart First",
        "signature": "Solver-\u003eInt-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRestartInc",
      "description": {
        "fct-descr": "\u003cp\u003eThe factor with which the restart limit is multiplied in each restart. (default 1.5)\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Double -\u003e IO ()",
        "fct-source": "src/SAT.html#setRestartInc",
        "fct-type": "function",
        "title": "setRestartInc"
      },
      "index": {
        "description": "The factor with which the restart limit is multiplied in each restart default",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setRestartInc",
        "normalized": "Solver-\u003eDouble-\u003eIO()",
        "package": "toysolver",
        "partial": "Restart Inc",
        "signature": "Solver-\u003eDouble-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setRestartStrategy",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e RestartStrategy -\u003e IO ()",
        "fct-source": "src/SAT.html#setRestartStrategy",
        "fct-type": "function",
        "title": "setRestartStrategy"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setRestartStrategy",
        "normalized": "Solver-\u003eRestartStrategy-\u003eIO()",
        "package": "toysolver",
        "partial": "Restart Strategy",
        "signature": "Solver-\u003eRestartStrategy-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:setVarPolarity",
      "description": {
        "fct-descr": "\u003cp\u003eThe default polarity of a variable.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Var -\u003e Bool -\u003e IO ()",
        "fct-source": "src/SAT.html#setVarPolarity",
        "fct-type": "function",
        "title": "setVarPolarity"
      },
      "index": {
        "description": "The default polarity of variable",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "setVarPolarity",
        "normalized": "Solver-\u003eVar-\u003eBool-\u003eIO()",
        "package": "toysolver",
        "partial": "Var Polarity",
        "signature": "Solver-\u003eVar-\u003eBool-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:solve",
      "description": {
        "fct-descr": "\u003cp\u003eSolve constraints.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the problem is SATISFIABLE.\n Returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if the problem is UNSATISFIABLE.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO Bool",
        "fct-source": "src/SAT.html#solve",
        "fct-type": "function",
        "title": "solve"
      },
      "index": {
        "description": "Solve constraints Returns True if the problem is SATISFIABLE Returns False if the problem is UNSATISFIABLE",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "solve",
        "normalized": "Solver-\u003eIO Bool",
        "package": "toysolver",
        "partial": "",
        "signature": "Solver-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:solveWith",
      "description": {
        "fct-descr": "\u003cp\u003eSolve constraints under assuptions.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the problem is SATISFIABLE.\n Returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if the problem is UNSATISFIABLE.\n\u003c/p\u003e",
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver-\u003e [Lit]-\u003e IO Bool",
        "fct-type": "function",
        "title": "solveWith"
      },
      "index": {
        "description": "Solve constraints under assuptions Returns True if the problem is SATISFIABLE Returns False if the problem is UNSATISFIABLE",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "solveWith",
        "normalized": "Solver-\u003e[Lit]-\u003eIO Bool",
        "package": "toysolver",
        "partial": "With",
        "signature": "Solver-\u003e[Lit]-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:varBumpActivity",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e Var -\u003e IO ()",
        "fct-source": "src/SAT.html#varBumpActivity",
        "fct-type": "function",
        "title": "varBumpActivity"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "varBumpActivity",
        "normalized": "Solver-\u003eVar-\u003eIO()",
        "package": "toysolver",
        "partial": "Bump Activity",
        "signature": "Solver-\u003eVar-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/SAT.html#v:varDecayActivity",
      "description": {
        "fct-module": "SAT",
        "fct-package": "toysolver",
        "fct-signature": "Solver -\u003e IO ()",
        "fct-source": "src/SAT.html#varDecayActivity",
        "fct-type": "function",
        "title": "varDecayActivity"
      },
      "index": {
        "description": "",
        "hierarchy": "SAT",
        "module": "SAT",
        "name": "varDecayActivity",
        "normalized": "Solver-\u003eIO()",
        "package": "toysolver",
        "partial": "Decay Activity",
        "signature": "Solver-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://www.satcompetition.org/2011/rules.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Text-GCNF.html",
        "fct-type": "module",
        "title": "GCNF"
      },
      "index": {
        "description": "References http www.satcompetition.org rules.pdf",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "GCNF",
        "normalized": "",
        "package": "toysolver",
        "partial": "GCNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#t:GCNF",
      "description": {
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-GCNF.html#GCNF",
        "fct-type": "data",
        "title": "GCNF"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "GCNF",
        "normalized": "",
        "package": "toysolver",
        "partial": "GCNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#t:GClause",
      "description": {
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-GCNF.html#GClause",
        "fct-type": "type",
        "title": "GClause"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "GClause",
        "normalized": "",
        "package": "toysolver",
        "partial": "GClause",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#t:GroupIndex",
      "description": {
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-GCNF.html#GroupIndex",
        "fct-type": "type",
        "title": "GroupIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "GroupIndex",
        "normalized": "",
        "package": "toysolver",
        "partial": "Group Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:GCNF",
      "description": {
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "GCNF",
        "fct-source": "src/Text-GCNF.html#GCNF",
        "fct-type": "function",
        "title": "GCNF"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "GCNF",
        "normalized": "",
        "package": "toysolver",
        "partial": "GCNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:clauses",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "[GClause]",
        "fct-source": "src/Text-GCNF.html#GCNF",
        "fct-type": "function",
        "title": "clauses"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "clauses",
        "normalized": "[GClause]",
        "package": "toysolver",
        "partial": "",
        "signature": "[GClause]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:lastGroupIndex",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "!GroupIndex",
        "fct-source": "src/Text-GCNF.html#GCNF",
        "fct-type": "function",
        "title": "lastGroupIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "lastGroupIndex",
        "normalized": "",
        "package": "toysolver",
        "partial": "Group Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:numClauses",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "!Int",
        "fct-source": "src/Text-GCNF.html#GCNF",
        "fct-type": "function",
        "title": "numClauses"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "numClauses",
        "normalized": "",
        "package": "toysolver",
        "partial": "Clauses",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:numVars",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "!Int",
        "fct-source": "src/Text-GCNF.html#GCNF",
        "fct-type": "function",
        "title": "numVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "numVars",
        "normalized": "",
        "package": "toysolver",
        "partial": "Vars",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:parseFile",
      "description": {
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "FilePath -\u003e IO (Either String GCNF)",
        "fct-source": "src/Text-GCNF.html#parseFile",
        "fct-type": "function",
        "title": "parseFile"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "parseFile",
        "normalized": "FilePath-\u003eIO(Either String GCNF)",
        "package": "toysolver",
        "partial": "File",
        "signature": "FilePath-\u003eIO(Either String GCNF)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GCNF.html#v:parseString",
      "description": {
        "fct-module": "Text.GCNF",
        "fct-package": "toysolver",
        "fct-signature": "String -\u003e Either String GCNF",
        "fct-source": "src/Text-GCNF.html#parseString",
        "fct-type": "function",
        "title": "parseString"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GCNF",
        "module": "Text.GCNF",
        "name": "parseString",
        "normalized": "String-\u003eEither String GCNF",
        "package": "toysolver",
        "partial": "String",
        "signature": "String-\u003eEither String GCNF"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GurobiSol.html#",
      "description": {
        "fct-module": "Text.GurobiSol",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Text-GurobiSol.html",
        "fct-type": "module",
        "title": "GurobiSol"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GurobiSol",
        "module": "Text.GurobiSol",
        "name": "GurobiSol",
        "normalized": "",
        "package": "toysolver",
        "partial": "Gurobi Sol",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GurobiSol.html#t:Model",
      "description": {
        "fct-module": "Text.GurobiSol",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-GurobiSol.html#Model",
        "fct-type": "type",
        "title": "Model"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GurobiSol",
        "module": "Text.GurobiSol",
        "name": "Model",
        "normalized": "",
        "package": "toysolver",
        "partial": "Model",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-GurobiSol.html#v:render",
      "description": {
        "fct-module": "Text.GurobiSol",
        "fct-package": "toysolver",
        "fct-signature": "Model -\u003e Maybe Double -\u003e String",
        "fct-source": "src/Text-GurobiSol.html#render",
        "fct-type": "function",
        "title": "render"
      },
      "index": {
        "description": "",
        "hierarchy": "Text GurobiSol",
        "module": "Text.GurobiSol",
        "name": "render",
        "normalized": "Model-\u003eMaybe Double-\u003eString",
        "package": "toysolver",
        "partial": "",
        "signature": "Model-\u003eMaybe Double-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA CPLEX .lp format parser library.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://publib.boulder.ibm.com/infocenter/cosinfoc/v12r2/index.jsp?topic=/ilog.odms.cplex.help/Content/Optimization/Documentation/CPLEX/_pubskel/CPLEX880.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.gurobi.com/doc/45/refman/node589.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://lpsolve.sourceforge.net/5.5/CPLEX-format.htm\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Text-LPFile.html",
        "fct-type": "module",
        "title": "LPFile"
      },
      "index": {
        "description": "CPLEX lp format parser library References http publib.boulder.ibm.com infocenter cosinfoc v12r2 index.jsp topic ilog.odms.cplex.help Content Optimization Documentation CPLEX pubskel CPLEX880.html http www.gurobi.com doc refman node589.html http lpsolve.sourceforge.net CPLEX-format.htm",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "LPFile",
        "normalized": "",
        "package": "toysolver",
        "partial": "LPFile",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:BoundExpr",
      "description": {
        "fct-descr": "\u003cp\u003etype for representing lower/upper bound of variables\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#BoundExpr",
        "fct-type": "data",
        "title": "BoundExpr"
      },
      "index": {
        "description": "type for representing lower upper bound of variables",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "BoundExpr",
        "normalized": "",
        "package": "toysolver",
        "partial": "Bound Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Bounds",
      "description": {
        "fct-descr": "\u003cp\u003etype for representing lower/upper bound of variables\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-LPFile.html#Bounds",
        "fct-type": "type",
        "title": "Bounds"
      },
      "index": {
        "description": "type for representing lower upper bound of variables",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Bounds",
        "normalized": "",
        "package": "toysolver",
        "partial": "Bounds",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Constraint",
      "description": {
        "fct-descr": "\u003cp\u003econstraint\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#Constraint",
        "fct-type": "data",
        "title": "Constraint"
      },
      "index": {
        "description": "constraint",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Constraint",
        "normalized": "",
        "package": "toysolver",
        "partial": "Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:ConstraintType",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#ConstraintType",
        "fct-type": "data",
        "title": "ConstraintType"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "ConstraintType",
        "normalized": "",
        "package": "toysolver",
        "partial": "Constraint Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Expr",
      "description": {
        "fct-descr": "\u003cp\u003eexpressions\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-LPFile.html#Expr",
        "fct-type": "type",
        "title": "Expr"
      },
      "index": {
        "description": "expressions",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Expr",
        "normalized": "",
        "package": "toysolver",
        "partial": "Expr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:LP",
      "description": {
        "fct-descr": "\u003cp\u003eProblem\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#LP",
        "fct-type": "data",
        "title": "LP"
      },
      "index": {
        "description": "Problem",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "LP",
        "normalized": "",
        "package": "toysolver",
        "partial": "LP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Label",
      "description": {
        "fct-descr": "\u003cp\u003elabel\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-LPFile.html#Label",
        "fct-type": "type",
        "title": "Label"
      },
      "index": {
        "description": "label",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Label",
        "normalized": "",
        "package": "toysolver",
        "partial": "Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:ObjectiveFunction",
      "description": {
        "fct-descr": "\u003cp\u003eobjective function\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-LPFile.html#ObjectiveFunction",
        "fct-type": "type",
        "title": "ObjectiveFunction"
      },
      "index": {
        "description": "objective function",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "ObjectiveFunction",
        "normalized": "",
        "package": "toysolver",
        "partial": "Objective Function",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:OptDir",
      "description": {
        "fct-descr": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eOptDir\u003c/a\u003e\u003c/code\u003e type represents optimization directions.\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "OptDir"
      },
      "index": {
        "description": "The OptDir type represents optimization directions",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "OptDir",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Dir",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:RelOp",
      "description": {
        "fct-descr": "\u003cp\u003erelational operators\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#RelOp",
        "fct-type": "data",
        "title": "RelOp"
      },
      "index": {
        "description": "relational operators",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "RelOp",
        "normalized": "",
        "package": "toysolver",
        "partial": "Rel Op",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:SOS",
      "description": {
        "fct-descr": "\u003cp\u003eSOS (special ordered sets) constraints\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-LPFile.html#SOS",
        "fct-type": "type",
        "title": "SOS"
      },
      "index": {
        "description": "SOS special ordered sets constraints",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "SOS",
        "normalized": "",
        "package": "toysolver",
        "partial": "SOS",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:SOSType",
      "description": {
        "fct-descr": "\u003cp\u003etypes of SOS (special ordered sets) constraints\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#SOSType",
        "fct-type": "data",
        "title": "SOSType"
      },
      "index": {
        "description": "types of SOS special ordered sets constraints",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "SOSType",
        "normalized": "",
        "package": "toysolver",
        "partial": "SOSType",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Term",
      "description": {
        "fct-descr": "\u003cp\u003eterms\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#Term",
        "fct-type": "data",
        "title": "Term"
      },
      "index": {
        "description": "terms",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Term",
        "normalized": "",
        "package": "toysolver",
        "partial": "Term",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:Var",
      "description": {
        "fct-descr": "\u003cp\u003evariable\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-LPFile.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "variable",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:VarInfo",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#VarInfo",
        "fct-type": "data",
        "title": "VarInfo"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "VarInfo",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var Info",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#t:VarType",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-LPFile.html#VarType",
        "fct-type": "data",
        "title": "VarType"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "VarType",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Constraint",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Constraint",
        "fct-source": "src/Text-LPFile.html#Constraint",
        "fct-type": "function",
        "title": "Constraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Constraint",
        "normalized": "",
        "package": "toysolver",
        "partial": "Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:ContinuousVariable",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "ContinuousVariable",
        "fct-source": "src/Text-LPFile.html#VarType",
        "fct-type": "function",
        "title": "ContinuousVariable"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "ContinuousVariable",
        "normalized": "",
        "package": "toysolver",
        "partial": "Continuous Variable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Eql",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Eql",
        "fct-source": "src/Text-LPFile.html#RelOp",
        "fct-type": "function",
        "title": "Eql"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Eql",
        "normalized": "",
        "package": "toysolver",
        "partial": "Eql",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Finite",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Finite Rational",
        "fct-source": "src/Text-LPFile.html#BoundExpr",
        "fct-type": "function",
        "title": "Finite"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Finite",
        "normalized": "",
        "package": "toysolver",
        "partial": "Finite",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Ge",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Ge",
        "fct-source": "src/Text-LPFile.html#RelOp",
        "fct-type": "function",
        "title": "Ge"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Ge",
        "normalized": "",
        "package": "toysolver",
        "partial": "Ge",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:IntegerVariable",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "IntegerVariable",
        "fct-source": "src/Text-LPFile.html#VarType",
        "fct-type": "function",
        "title": "IntegerVariable"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "IntegerVariable",
        "normalized": "",
        "package": "toysolver",
        "partial": "Integer Variable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:LP",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "LP",
        "fct-source": "src/Text-LPFile.html#LP",
        "fct-type": "function",
        "title": "LP"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "LP",
        "normalized": "",
        "package": "toysolver",
        "partial": "LP",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:LazyConstraint",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "LazyConstraint",
        "fct-source": "src/Text-LPFile.html#ConstraintType",
        "fct-type": "function",
        "title": "LazyConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "LazyConstraint",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lazy Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Le",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Le",
        "fct-source": "src/Text-LPFile.html#RelOp",
        "fct-type": "function",
        "title": "Le"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Le",
        "normalized": "",
        "package": "toysolver",
        "partial": "Le",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:NegInf",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "NegInf",
        "fct-source": "src/Text-LPFile.html#BoundExpr",
        "fct-type": "function",
        "title": "NegInf"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "NegInf",
        "normalized": "",
        "package": "toysolver",
        "partial": "Neg Inf",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:NormalConstraint",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "NormalConstraint",
        "fct-source": "src/Text-LPFile.html#ConstraintType",
        "fct-type": "function",
        "title": "NormalConstraint"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "NormalConstraint",
        "normalized": "",
        "package": "toysolver",
        "partial": "Normal Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:OptMax",
      "description": {
        "fct-descr": "\u003cp\u003emaximization\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "OptMax",
        "fct-type": "function",
        "title": "OptMax"
      },
      "index": {
        "description": "maximization",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "OptMax",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Max",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:OptMin",
      "description": {
        "fct-descr": "\u003cp\u003eminimization \n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "OptMin",
        "fct-type": "function",
        "title": "OptMin"
      },
      "index": {
        "description": "minimization",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "OptMin",
        "normalized": "",
        "package": "toysolver",
        "partial": "Opt Min",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:PosInf",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "PosInf",
        "fct-source": "src/Text-LPFile.html#BoundExpr",
        "fct-type": "function",
        "title": "PosInf"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "PosInf",
        "normalized": "",
        "package": "toysolver",
        "partial": "Pos Inf",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:S1",
      "description": {
        "fct-descr": "\u003cp\u003eType 1 SOS constraint\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "S1",
        "fct-source": "src/Text-LPFile.html#SOSType",
        "fct-type": "function",
        "title": "S1"
      },
      "index": {
        "description": "Type SOS constraint",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "S1",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:S2",
      "description": {
        "fct-descr": "\u003cp\u003eType 2 SOS constraint\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "S2",
        "fct-source": "src/Text-LPFile.html#SOSType",
        "fct-type": "function",
        "title": "S2"
      },
      "index": {
        "description": "Type SOS constraint",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "S2",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:SemiContinuousVariable",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "SemiContinuousVariable",
        "fct-source": "src/Text-LPFile.html#VarType",
        "fct-type": "function",
        "title": "SemiContinuousVariable"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "SemiContinuousVariable",
        "normalized": "",
        "package": "toysolver",
        "partial": "Semi Continuous Variable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:Term",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Term Rational [Var]",
        "fct-source": "src/Text-LPFile.html#Term",
        "fct-type": "function",
        "title": "Term"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "Term",
        "normalized": "Term Rational[Var]",
        "package": "toysolver",
        "partial": "Term",
        "signature": "Term Rational[Var]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:UserDefinedCut",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "UserDefinedCut",
        "fct-source": "src/Text-LPFile.html#ConstraintType",
        "fct-type": "function",
        "title": "UserDefinedCut"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "UserDefinedCut",
        "normalized": "",
        "package": "toysolver",
        "partial": "User Defined Cut",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:VarInfo",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "VarInfo",
        "fct-source": "src/Text-LPFile.html#VarInfo",
        "fct-type": "function",
        "title": "VarInfo"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "VarInfo",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var Info",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constrBody",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "(Expr, RelOp, Rational)",
        "fct-source": "src/Text-LPFile.html#Constraint",
        "fct-type": "function",
        "title": "constrBody"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "constrBody",
        "normalized": "(Expr,RelOp,Rational)",
        "package": "toysolver",
        "partial": "Body",
        "signature": "(Expr,RelOp,Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constrIndicator",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Maybe (Var, Rational)",
        "fct-source": "src/Text-LPFile.html#Constraint",
        "fct-type": "function",
        "title": "constrIndicator"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "constrIndicator",
        "normalized": "Maybe(Var,Rational)",
        "package": "toysolver",
        "partial": "Indicator",
        "signature": "Maybe(Var,Rational)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constrLabel",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Maybe Label",
        "fct-source": "src/Text-LPFile.html#Constraint",
        "fct-type": "function",
        "title": "constrLabel"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "constrLabel",
        "normalized": "",
        "package": "toysolver",
        "partial": "Label",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constrType",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "ConstraintType",
        "fct-source": "src/Text-LPFile.html#Constraint",
        "fct-type": "function",
        "title": "constrType"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "constrType",
        "normalized": "",
        "package": "toysolver",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:constraints",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "[Constraint]",
        "fct-source": "src/Text-LPFile.html#LP",
        "fct-type": "function",
        "title": "constraints"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "constraints",
        "normalized": "[Constraint]",
        "package": "toysolver",
        "partial": "",
        "signature": "[Constraint]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:defaultBounds",
      "description": {
        "fct-descr": "\u003cp\u003edefault bounds\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Bounds",
        "fct-source": "src/Text-LPFile.html#defaultBounds",
        "fct-type": "function",
        "title": "defaultBounds"
      },
      "index": {
        "description": "default bounds",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "defaultBounds",
        "normalized": "",
        "package": "toysolver",
        "partial": "Bounds",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:defaultLB",
      "description": {
        "fct-descr": "\u003cp\u003edefault lower bound (0)\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "BoundExpr",
        "fct-source": "src/Text-LPFile.html#defaultLB",
        "fct-type": "function",
        "title": "defaultLB"
      },
      "index": {
        "description": "default lower bound",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "defaultLB",
        "normalized": "",
        "package": "toysolver",
        "partial": "LB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:defaultUB",
      "description": {
        "fct-descr": "\u003cp\u003edefault upper bound (+&#8734;)\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "BoundExpr",
        "fct-source": "src/Text-LPFile.html#defaultUB",
        "fct-type": "function",
        "title": "defaultUB"
      },
      "index": {
        "description": "default upper bound",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "defaultUB",
        "normalized": "",
        "package": "toysolver",
        "partial": "UB",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:dir",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "OptDir",
        "fct-source": "src/Text-LPFile.html#LP",
        "fct-type": "function",
        "title": "dir"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "dir",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:getBounds",
      "description": {
        "fct-descr": "\u003cp\u003elooking up bounds for a variable\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "LP -\u003e Var -\u003e Bounds",
        "fct-source": "src/Text-LPFile.html#getBounds",
        "fct-type": "function",
        "title": "getBounds"
      },
      "index": {
        "description": "looking up bounds for variable",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "getBounds",
        "normalized": "LP-\u003eVar-\u003eBounds",
        "package": "toysolver",
        "partial": "Bounds",
        "signature": "LP-\u003eVar-\u003eBounds"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:getVarInfo",
      "description": {
        "fct-descr": "\u003cp\u003elooking up attributes for a variable\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "LP -\u003e Var -\u003e VarInfo",
        "fct-source": "src/Text-LPFile.html#getVarInfo",
        "fct-type": "function",
        "title": "getVarInfo"
      },
      "index": {
        "description": "looking up attributes for variable",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "getVarInfo",
        "normalized": "LP-\u003eVar-\u003eVarInfo",
        "package": "toysolver",
        "partial": "Var Info",
        "signature": "LP-\u003eVar-\u003eVarInfo"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:getVarType",
      "description": {
        "fct-descr": "\u003cp\u003elooking up bounds for a variable\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "LP -\u003e Var -\u003e VarType",
        "fct-source": "src/Text-LPFile.html#getVarType",
        "fct-type": "function",
        "title": "getVarType"
      },
      "index": {
        "description": "looking up bounds for variable",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "getVarType",
        "normalized": "LP-\u003eVar-\u003eVarType",
        "package": "toysolver",
        "partial": "Var Type",
        "signature": "LP-\u003eVar-\u003eVarType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:integerVariables",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "LP -\u003e Set Var",
        "fct-source": "src/Text-LPFile.html#integerVariables",
        "fct-type": "function",
        "title": "integerVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "integerVariables",
        "normalized": "LP-\u003eSet Var",
        "package": "toysolver",
        "partial": "Variables",
        "signature": "LP-\u003eSet Var"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:objectiveFunction",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "ObjectiveFunction",
        "fct-source": "src/Text-LPFile.html#LP",
        "fct-type": "function",
        "title": "objectiveFunction"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "objectiveFunction",
        "normalized": "",
        "package": "toysolver",
        "partial": "Function",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:parseFile",
      "description": {
        "fct-descr": "\u003cp\u003eParse a file containing LP file data.\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "FilePath -\u003e IO (Either ParseError LP)",
        "fct-source": "src/Text-LPFile.html#parseFile",
        "fct-type": "function",
        "title": "parseFile"
      },
      "index": {
        "description": "Parse file containing LP file data",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "parseFile",
        "normalized": "FilePath-\u003eIO(Either ParseError LP)",
        "package": "toysolver",
        "partial": "File",
        "signature": "FilePath-\u003eIO(Either ParseError LP)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:parseString",
      "description": {
        "fct-descr": "\u003cp\u003eParse a string containing LP file data.\n The source name is only | used in error messages and may be the empty string.\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "SourceName -\u003e String -\u003e Either ParseError LP",
        "fct-source": "src/Text-LPFile.html#parseString",
        "fct-type": "function",
        "title": "parseString"
      },
      "index": {
        "description": "Parse string containing LP file data The source name is only used in error messages and may be the empty string",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "parseString",
        "normalized": "SourceName-\u003eString-\u003eEither ParseError LP",
        "package": "toysolver",
        "partial": "String",
        "signature": "SourceName-\u003eString-\u003eEither ParseError LP"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:render",
      "description": {
        "fct-descr": "\u003cp\u003eRender a problem into a string.\n\u003c/p\u003e",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "LP -\u003e Maybe String",
        "fct-source": "src/Text-LPFile.html#render",
        "fct-type": "function",
        "title": "render"
      },
      "index": {
        "description": "Render problem into string",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "render",
        "normalized": "LP-\u003eMaybe String",
        "package": "toysolver",
        "partial": "",
        "signature": "LP-\u003eMaybe String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:semiContinuousVariables",
      "description": {
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "LP -\u003e Set Var",
        "fct-source": "src/Text-LPFile.html#semiContinuousVariables",
        "fct-type": "function",
        "title": "semiContinuousVariables"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "semiContinuousVariables",
        "normalized": "LP-\u003eSet Var",
        "package": "toysolver",
        "partial": "Continuous Variables",
        "signature": "LP-\u003eSet Var"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:sos",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "[SOS]",
        "fct-source": "src/Text-LPFile.html#LP",
        "fct-type": "function",
        "title": "sos"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "sos",
        "normalized": "[SOS]",
        "package": "toysolver",
        "partial": "",
        "signature": "[SOS]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:varBounds",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Bounds",
        "fct-source": "src/Text-LPFile.html#VarInfo",
        "fct-type": "function",
        "title": "varBounds"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "varBounds",
        "normalized": "",
        "package": "toysolver",
        "partial": "Bounds",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:varInfo",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Map Var VarInfo",
        "fct-source": "src/Text-LPFile.html#LP",
        "fct-type": "function",
        "title": "varInfo"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "varInfo",
        "normalized": "",
        "package": "toysolver",
        "partial": "Info",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:varName",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Var",
        "fct-source": "src/Text-LPFile.html#VarInfo",
        "fct-type": "function",
        "title": "varName"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "varName",
        "normalized": "",
        "package": "toysolver",
        "partial": "Name",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:varType",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "VarType",
        "fct-source": "src/Text-LPFile.html#VarInfo",
        "fct-type": "function",
        "title": "varType"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "varType",
        "normalized": "",
        "package": "toysolver",
        "partial": "Type",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-LPFile.html#v:variables",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.LPFile",
        "fct-package": "toysolver",
        "fct-signature": "Set Var",
        "fct-source": "src/Text-LPFile.html#LP",
        "fct-type": "function",
        "title": "variables"
      },
      "index": {
        "description": "",
        "hierarchy": "Text LPFile",
        "module": "Text.LPFile",
        "name": "variables",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MPSFile.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA .mps format parser library.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://pic.dhe.ibm.com/infocenter/cosinfoc/v12r4/topic/ilog.odms.cplex.help/CPLEX/File_formats_reference/topics/MPS_synopsis.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://pic.dhe.ibm.com/infocenter/cosinfoc/v12r4/topic/ilog.odms.cplex.help/CPLEX/File_formats_reference/topics/MPS_ext_synopsis.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.gurobi.com/documentation/5.0/reference-manual/node744\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://en.wikipedia.org/wiki/MPS_(format)\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Text.MPSFile",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Text-MPSFile.html",
        "fct-type": "module",
        "title": "MPSFile"
      },
      "index": {
        "description": "mps format parser library References http pic.dhe.ibm.com infocenter cosinfoc v12r4 topic ilog.odms.cplex.help CPLEX File formats reference topics MPS synopsis.html http pic.dhe.ibm.com infocenter cosinfoc v12r4 topic ilog.odms.cplex.help CPLEX File formats reference topics MPS ext synopsis.html http www.gurobi.com documentation reference-manual node744 http en.wikipedia.org wiki MPS format",
        "hierarchy": "Text MPSFile",
        "module": "Text.MPSFile",
        "name": "MPSFile",
        "normalized": "",
        "package": "toysolver",
        "partial": "MPSFile",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MPSFile.html#v:parseFile",
      "description": {
        "fct-descr": "\u003cp\u003eParse a file containing LP file data.\n\u003c/p\u003e",
        "fct-module": "Text.MPSFile",
        "fct-package": "toysolver",
        "fct-signature": "FilePath -\u003e IO (Either ParseError LP)",
        "fct-source": "src/Text-MPSFile.html#parseFile",
        "fct-type": "function",
        "title": "parseFile"
      },
      "index": {
        "description": "Parse file containing LP file data",
        "hierarchy": "Text MPSFile",
        "module": "Text.MPSFile",
        "name": "parseFile",
        "normalized": "FilePath-\u003eIO(Either ParseError LP)",
        "package": "toysolver",
        "partial": "File",
        "signature": "FilePath-\u003eIO(Either ParseError LP)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MPSFile.html#v:parseString",
      "description": {
        "fct-descr": "\u003cp\u003eParse a string containing LP file data.\n The source name is only | used in error messages and may be the empty string.\n\u003c/p\u003e",
        "fct-module": "Text.MPSFile",
        "fct-package": "toysolver",
        "fct-signature": "SourceName -\u003e String -\u003e Either ParseError LP",
        "fct-source": "src/Text-MPSFile.html#parseString",
        "fct-type": "function",
        "title": "parseString"
      },
      "index": {
        "description": "Parse string containing LP file data The source name is only used in error messages and may be the empty string",
        "hierarchy": "Text MPSFile",
        "module": "Text.MPSFile",
        "name": "parseString",
        "normalized": "SourceName-\u003eString-\u003eEither ParseError LP",
        "package": "toysolver",
        "partial": "String",
        "signature": "SourceName-\u003eString-\u003eEither ParseError LP"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://maxsat.ia.udl.cat/requirements/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Text-MaxSAT.html",
        "fct-type": "module",
        "title": "MaxSAT"
      },
      "index": {
        "description": "References http maxsat.ia.udl.cat requirements",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "MaxSAT",
        "normalized": "",
        "package": "toysolver",
        "partial": "Max SAT",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#t:WCNF",
      "description": {
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-MaxSAT.html#WCNF",
        "fct-type": "data",
        "title": "WCNF"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "WCNF",
        "normalized": "",
        "package": "toysolver",
        "partial": "WCNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#t:Weight",
      "description": {
        "fct-descr": "\u003cp\u003eshould be able to represent 2^63\n\u003c/p\u003e",
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-MaxSAT.html#Weight",
        "fct-type": "type",
        "title": "Weight"
      },
      "index": {
        "description": "should be able to represent",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "Weight",
        "normalized": "",
        "package": "toysolver",
        "partial": "Weight",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#t:WeightedClause",
      "description": {
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-MaxSAT.html#WeightedClause",
        "fct-type": "type",
        "title": "WeightedClause"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "WeightedClause",
        "normalized": "",
        "package": "toysolver",
        "partial": "Weighted Clause",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:WCNF",
      "description": {
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "WCNF",
        "fct-source": "src/Text-MaxSAT.html#WCNF",
        "fct-type": "function",
        "title": "WCNF"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "WCNF",
        "normalized": "",
        "package": "toysolver",
        "partial": "WCNF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:clauses",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "[WeightedClause]",
        "fct-source": "src/Text-MaxSAT.html#WCNF",
        "fct-type": "function",
        "title": "clauses"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "clauses",
        "normalized": "[WeightedClause]",
        "package": "toysolver",
        "partial": "",
        "signature": "[WeightedClause]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:numClauses",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "!Int",
        "fct-source": "src/Text-MaxSAT.html#WCNF",
        "fct-type": "function",
        "title": "numClauses"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "numClauses",
        "normalized": "",
        "package": "toysolver",
        "partial": "Clauses",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:numVars",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "!Int",
        "fct-source": "src/Text-MaxSAT.html#WCNF",
        "fct-type": "function",
        "title": "numVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "numVars",
        "normalized": "",
        "package": "toysolver",
        "partial": "Vars",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:parseWCNFFile",
      "description": {
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "FilePath -\u003e IO (Either String WCNF)",
        "fct-source": "src/Text-MaxSAT.html#parseWCNFFile",
        "fct-type": "function",
        "title": "parseWCNFFile"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "parseWCNFFile",
        "normalized": "FilePath-\u003eIO(Either String WCNF)",
        "package": "toysolver",
        "partial": "WCNFFile",
        "signature": "FilePath-\u003eIO(Either String WCNF)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:parseWCNFString",
      "description": {
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "String -\u003e Either String WCNF",
        "fct-source": "src/Text-MaxSAT.html#parseWCNFString",
        "fct-type": "function",
        "title": "parseWCNFString"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "parseWCNFString",
        "normalized": "String-\u003eEither String WCNF",
        "package": "toysolver",
        "partial": "WCNFString",
        "signature": "String-\u003eEither String WCNF"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-MaxSAT.html#v:topCost",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Text.MaxSAT",
        "fct-package": "toysolver",
        "fct-signature": "!Weight",
        "fct-source": "src/Text-MaxSAT.html#WCNF",
        "fct-type": "function",
        "title": "topCost"
      },
      "index": {
        "description": "",
        "hierarchy": "Text MaxSAT",
        "module": "Text.MaxSAT",
        "name": "topCost",
        "normalized": "",
        "package": "toysolver",
        "partial": "Cost",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA parser library for .opb file and .wbo files used by PB Competition.\n\u003c/p\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Input/Output Format and Solver Requirements for the Competitions of\n   Pseudo-Boolean Solvers\n   \u003ca\u003ehttp://www.cril.univ-artois.fr/PB11/format.pdf\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Text-PBFile.html",
        "fct-type": "module",
        "title": "PBFile"
      },
      "index": {
        "description": "parser library for opb file and wbo files used by PB Competition References Input Output Format and Solver Requirements for the Competitions of Pseudo-Boolean Solvers http www.cril.univ-artois.fr PB11 format.pdf",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "PBFile",
        "normalized": "",
        "package": "toysolver",
        "partial": "PBFile",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Constraint",
      "description": {
        "fct-descr": "\u003cp\u003eLhs, relational operator and rhs.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#Constraint",
        "fct-type": "type",
        "title": "Constraint"
      },
      "index": {
        "description": "Lhs relational operator and rhs",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Constraint",
        "normalized": "",
        "package": "toysolver",
        "partial": "Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Formula",
      "description": {
        "fct-descr": "\u003cp\u003ePair of \u003cem\u003eobjective function\u003c/em\u003e and a list of constraints.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#Formula",
        "fct-type": "type",
        "title": "Formula"
      },
      "index": {
        "description": "Pair of objective function and list of constraints",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Formula",
        "normalized": "",
        "package": "toysolver",
        "partial": "Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Lit",
      "description": {
        "fct-descr": "\u003cp\u003ePositive (resp. negative) literal is represented as a positive (resp. negative) integer.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#Lit",
        "fct-type": "type",
        "title": "Lit"
      },
      "index": {
        "description": "Positive resp negative literal is represented as positive resp negative integer",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Lit",
        "normalized": "",
        "package": "toysolver",
        "partial": "Lit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Op",
      "description": {
        "fct-descr": "\u003cp\u003eRelational operators\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-PBFile.html#Op",
        "fct-type": "data",
        "title": "Op"
      },
      "index": {
        "description": "Relational operators",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Op",
        "normalized": "",
        "package": "toysolver",
        "partial": "Op",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:SoftConstraint",
      "description": {
        "fct-descr": "\u003cp\u003eA pair of weight and constraint.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#SoftConstraint",
        "fct-type": "type",
        "title": "SoftConstraint"
      },
      "index": {
        "description": "pair of weight and constraint",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "SoftConstraint",
        "normalized": "",
        "package": "toysolver",
        "partial": "Soft Constraint",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:SoftFormula",
      "description": {
        "fct-descr": "\u003cp\u003eA pair of \u003cem\u003etop cost\u003c/em\u003e and a list of soft constraints.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#SoftFormula",
        "fct-type": "type",
        "title": "SoftFormula"
      },
      "index": {
        "description": "pair of top cost and list of soft constraints",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "SoftFormula",
        "normalized": "",
        "package": "toysolver",
        "partial": "Soft Formula",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Sum",
      "description": {
        "fct-descr": "\u003cp\u003eSum of \u003ccode\u003e\u003ca\u003eWeightedTerm\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#Sum",
        "fct-type": "type",
        "title": "Sum"
      },
      "index": {
        "description": "Sum of WeightedTerm",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Sum",
        "normalized": "",
        "package": "toysolver",
        "partial": "Sum",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Term",
      "description": {
        "fct-descr": "\u003cp\u003eList of variables interpreted as products\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#Term",
        "fct-type": "type",
        "title": "Term"
      },
      "index": {
        "description": "List of variables interpreted as products",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Term",
        "normalized": "",
        "package": "toysolver",
        "partial": "Term",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:Var",
      "description": {
        "fct-descr": "\u003cp\u003eVariable are repserented positive integer.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#Var",
        "fct-type": "type",
        "title": "Var"
      },
      "index": {
        "description": "Variable are repserented positive integer",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Var",
        "normalized": "",
        "package": "toysolver",
        "partial": "Var",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#t:WeightedTerm",
      "description": {
        "fct-descr": "\u003cp\u003eCoefficient and \u003ccode\u003e\u003ca\u003eTerm\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-PBFile.html#WeightedTerm",
        "fct-type": "type",
        "title": "WeightedTerm"
      },
      "index": {
        "description": "Coefficient and Term",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "WeightedTerm",
        "normalized": "",
        "package": "toysolver",
        "partial": "Weighted Term",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:Eq",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eequal\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "Eq",
        "fct-source": "src/Text-PBFile.html#Op",
        "fct-type": "function",
        "title": "Eq"
      },
      "index": {
        "description": "equal",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Eq",
        "normalized": "",
        "package": "toysolver",
        "partial": "Eq",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:Ge",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003egreater than or equal\u003c/em\u003e\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "Ge",
        "fct-source": "src/Text-PBFile.html#Op",
        "fct-type": "function",
        "title": "Ge"
      },
      "index": {
        "description": "greater than or equal",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "Ge",
        "normalized": "",
        "package": "toysolver",
        "partial": "Ge",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:parseOPBFile",
      "description": {
        "fct-descr": "\u003cp\u003eParse a .opb format string containing pseudo boolean problem.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "FilePath -\u003e IO (Either ParseError Formula)",
        "fct-source": "src/Text-PBFile.html#parseOPBFile",
        "fct-type": "function",
        "title": "parseOPBFile"
      },
      "index": {
        "description": "Parse opb format string containing pseudo boolean problem",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "parseOPBFile",
        "normalized": "FilePath-\u003eIO(Either ParseError Formula)",
        "package": "toysolver",
        "partial": "OPBFile",
        "signature": "FilePath-\u003eIO(Either ParseError Formula)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:parseOPBString",
      "description": {
        "fct-descr": "\u003cp\u003eParse a .opb file containing pseudo boolean problem.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "SourceName -\u003e String -\u003e Either ParseError Formula",
        "fct-source": "src/Text-PBFile.html#parseOPBString",
        "fct-type": "function",
        "title": "parseOPBString"
      },
      "index": {
        "description": "Parse opb file containing pseudo boolean problem",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "parseOPBString",
        "normalized": "SourceName-\u003eString-\u003eEither ParseError Formula",
        "package": "toysolver",
        "partial": "OPBString",
        "signature": "SourceName-\u003eString-\u003eEither ParseError Formula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:parseWBOFile",
      "description": {
        "fct-descr": "\u003cp\u003eParse a .wbo format string containing weighted boolean optimization problem.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "FilePath -\u003e IO (Either ParseError SoftFormula)",
        "fct-source": "src/Text-PBFile.html#parseWBOFile",
        "fct-type": "function",
        "title": "parseWBOFile"
      },
      "index": {
        "description": "Parse wbo format string containing weighted boolean optimization problem",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "parseWBOFile",
        "normalized": "FilePath-\u003eIO(Either ParseError SoftFormula)",
        "package": "toysolver",
        "partial": "WBOFile",
        "signature": "FilePath-\u003eIO(Either ParseError SoftFormula)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:parseWBOString",
      "description": {
        "fct-descr": "\u003cp\u003eParse a .wbo file containing weighted boolean optimization problem.\n\u003c/p\u003e",
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "SourceName -\u003e String -\u003e Either ParseError SoftFormula",
        "fct-source": "src/Text-PBFile.html#parseWBOString",
        "fct-type": "function",
        "title": "parseWBOString"
      },
      "index": {
        "description": "Parse wbo file containing weighted boolean optimization problem",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "parseWBOString",
        "normalized": "SourceName-\u003eString-\u003eEither ParseError SoftFormula",
        "package": "toysolver",
        "partial": "WBOString",
        "signature": "SourceName-\u003eString-\u003eEither ParseError SoftFormula"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:pbNumVars",
      "description": {
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "Formula -\u003e Int",
        "fct-source": "src/Text-PBFile.html#pbNumVars",
        "fct-type": "function",
        "title": "pbNumVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "pbNumVars",
        "normalized": "Formula-\u003eInt",
        "package": "toysolver",
        "partial": "Num Vars",
        "signature": "Formula-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:showOPB",
      "description": {
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "Formula -\u003e ShowS",
        "fct-source": "src/Text-PBFile.html#showOPB",
        "fct-type": "function",
        "title": "showOPB"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "showOPB",
        "normalized": "Formula-\u003eShowS",
        "package": "toysolver",
        "partial": "OPB",
        "signature": "Formula-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:showWBO",
      "description": {
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "SoftFormula -\u003e ShowS",
        "fct-source": "src/Text-PBFile.html#showWBO",
        "fct-type": "function",
        "title": "showWBO"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "showWBO",
        "normalized": "SoftFormula-\u003eShowS",
        "package": "toysolver",
        "partial": "WBO",
        "signature": "SoftFormula-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-PBFile.html#v:wboNumVars",
      "description": {
        "fct-module": "Text.PBFile",
        "fct-package": "toysolver",
        "fct-signature": "SoftFormula -\u003e Int",
        "fct-source": "src/Text-PBFile.html#wboNumVars",
        "fct-type": "function",
        "title": "wboNumVars"
      },
      "index": {
        "description": "",
        "hierarchy": "Text PBFile",
        "module": "Text.PBFile",
        "name": "wboNumVars",
        "normalized": "SoftFormula-\u003eInt",
        "package": "toysolver",
        "partial": "Num Vars",
        "signature": "SoftFormula-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e SDPA (Semidefinite Programming Algorithm) User's Manual\n   \u003ca\u003ehttp://sdpa.indsys.chuo-u.ac.jp/~fujisawa/sdpa_doc.pdf\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://euler.nmt.edu/~brian/sdplib/FORMAT\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Text-SDPFile.html",
        "fct-type": "module",
        "title": "SDPFile"
      },
      "index": {
        "description": "References SDPA Semidefinite Programming Algorithm User Manual http sdpa.indsys.chuo-u.ac.jp fujisawa sdpa doc.pdf http euler.nmt.edu brian sdplib FORMAT",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "SDPFile",
        "normalized": "",
        "package": "toysolver",
        "partial": "SDPFile",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:Block",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-SDPFile.html#Block",
        "fct-type": "type",
        "title": "Block"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "Block",
        "normalized": "",
        "package": "toysolver",
        "partial": "Block",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:DenseBlock",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-SDPFile.html#DenseBlock",
        "fct-type": "type",
        "title": "DenseBlock"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "DenseBlock",
        "normalized": "",
        "package": "toysolver",
        "partial": "Dense Block",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:DenseMatrix",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-SDPFile.html#DenseMatrix",
        "fct-type": "type",
        "title": "DenseMatrix"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "DenseMatrix",
        "normalized": "",
        "package": "toysolver",
        "partial": "Dense Matrix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:Matrix",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "type",
        "fct-source": "src/Text-SDPFile.html#Matrix",
        "fct-type": "type",
        "title": "Matrix"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "Matrix",
        "normalized": "",
        "package": "toysolver",
        "partial": "Matrix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#t:Problem",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "data",
        "fct-source": "src/Text-SDPFile.html#Problem",
        "fct-type": "data",
        "title": "Problem"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "Problem",
        "normalized": "",
        "package": "toysolver",
        "partial": "Problem",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:Problem",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "Problem",
        "fct-source": "src/Text-SDPFile.html#Problem",
        "fct-type": "function",
        "title": "Problem"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "Problem",
        "normalized": "",
        "package": "toysolver",
        "partial": "Problem",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:blockElem",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "Int -\u003e Int -\u003e Block -\u003e Rational",
        "fct-source": "src/Text-SDPFile.html#blockElem",
        "fct-type": "function",
        "title": "blockElem"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "blockElem",
        "normalized": "Int-\u003eInt-\u003eBlock-\u003eRational",
        "package": "toysolver",
        "partial": "Elem",
        "signature": "Int-\u003eInt-\u003eBlock-\u003eRational"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:blockStruct",
      "description": {
        "fct-descr": "\u003cp\u003ethe block strcuture vector (bLOCKsTRUCT)\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "[Int]",
        "fct-source": "src/Text-SDPFile.html#Problem",
        "fct-type": "function",
        "title": "blockStruct"
      },
      "index": {
        "description": "the block strcuture vector bLOCKsTRUCT",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "blockStruct",
        "normalized": "[Int]",
        "package": "toysolver",
        "partial": "Struct",
        "signature": "[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:costs",
      "description": {
        "fct-descr": "\u003cp\u003eConstant Vector\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "[Rational]",
        "fct-source": "src/Text-SDPFile.html#Problem",
        "fct-type": "function",
        "title": "costs"
      },
      "index": {
        "description": "Constant Vector",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "costs",
        "normalized": "[Rational]",
        "package": "toysolver",
        "partial": "",
        "signature": "[Rational]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:denseBlock",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "DenseBlock -\u003e Block",
        "fct-source": "src/Text-SDPFile.html#denseBlock",
        "fct-type": "function",
        "title": "denseBlock"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "denseBlock",
        "normalized": "DenseBlock-\u003eBlock",
        "package": "toysolver",
        "partial": "Block",
        "signature": "DenseBlock-\u003eBlock"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:denseMatrix",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "DenseMatrix -\u003e Matrix",
        "fct-source": "src/Text-SDPFile.html#denseMatrix",
        "fct-type": "function",
        "title": "denseMatrix"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "denseMatrix",
        "normalized": "DenseMatrix-\u003eMatrix",
        "package": "toysolver",
        "partial": "Matrix",
        "signature": "DenseMatrix-\u003eMatrix"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:diagBlock",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "[Rational] -\u003e Block",
        "fct-source": "src/Text-SDPFile.html#diagBlock",
        "fct-type": "function",
        "title": "diagBlock"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "diagBlock",
        "normalized": "[Rational]-\u003eBlock",
        "package": "toysolver",
        "partial": "Block",
        "signature": "[Rational]-\u003eBlock"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:mDim",
      "description": {
        "fct-descr": "\u003cp\u003ethe number of primal variables (mDim)\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "Problem -\u003e Int",
        "fct-source": "src/Text-SDPFile.html#mDim",
        "fct-type": "function",
        "title": "mDim"
      },
      "index": {
        "description": "the number of primal variables mDim",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "mDim",
        "normalized": "Problem-\u003eInt",
        "package": "toysolver",
        "partial": "Dim",
        "signature": "Problem-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:matrices",
      "description": {
        "fct-descr": "\u003cp\u003eConstraint Matrices\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "[Matrix]",
        "fct-source": "src/Text-SDPFile.html#Problem",
        "fct-type": "function",
        "title": "matrices"
      },
      "index": {
        "description": "Constraint Matrices",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "matrices",
        "normalized": "[Matrix]",
        "package": "toysolver",
        "partial": "",
        "signature": "[Matrix]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:nBlock",
      "description": {
        "fct-descr": "\u003cp\u003ethe number of blocks (nBLOCK)\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "Problem -\u003e Int",
        "fct-source": "src/Text-SDPFile.html#nBlock",
        "fct-type": "function",
        "title": "nBlock"
      },
      "index": {
        "description": "the number of blocks nBLOCK",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "nBlock",
        "normalized": "Problem-\u003eInt",
        "package": "toysolver",
        "partial": "Block",
        "signature": "Problem-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:parseDataFile",
      "description": {
        "fct-descr": "\u003cp\u003eParse a SDPA format file (.dat).\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "FilePath -\u003e IO (Either ParseError Problem)",
        "fct-source": "src/Text-SDPFile.html#parseDataFile",
        "fct-type": "function",
        "title": "parseDataFile"
      },
      "index": {
        "description": "Parse SDPA format file dat",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "parseDataFile",
        "normalized": "FilePath-\u003eIO(Either ParseError Problem)",
        "package": "toysolver",
        "partial": "Data File",
        "signature": "FilePath-\u003eIO(Either ParseError Problem)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:parseDataString",
      "description": {
        "fct-descr": "\u003cp\u003eParse a SDPA format (.dat) string.\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "SourceName -\u003e String -\u003e Either ParseError Problem",
        "fct-source": "src/Text-SDPFile.html#parseDataString",
        "fct-type": "function",
        "title": "parseDataString"
      },
      "index": {
        "description": "Parse SDPA format dat string",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "parseDataString",
        "normalized": "SourceName-\u003eString-\u003eEither ParseError Problem",
        "package": "toysolver",
        "partial": "Data String",
        "signature": "SourceName-\u003eString-\u003eEither ParseError Problem"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:parseSparseDataFile",
      "description": {
        "fct-descr": "\u003cp\u003eParse a SDPA sparse format file (.dat-s).\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "FilePath -\u003e IO (Either ParseError Problem)",
        "fct-source": "src/Text-SDPFile.html#parseSparseDataFile",
        "fct-type": "function",
        "title": "parseSparseDataFile"
      },
      "index": {
        "description": "Parse SDPA sparse format file dat-s",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "parseSparseDataFile",
        "normalized": "FilePath-\u003eIO(Either ParseError Problem)",
        "package": "toysolver",
        "partial": "Sparse Data File",
        "signature": "FilePath-\u003eIO(Either ParseError Problem)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:parseSparseDataString",
      "description": {
        "fct-descr": "\u003cp\u003eParse a SDPA sparse format (.dat-s) string.\n\u003c/p\u003e",
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "SourceName -\u003e String -\u003e Either ParseError Problem",
        "fct-source": "src/Text-SDPFile.html#parseSparseDataString",
        "fct-type": "function",
        "title": "parseSparseDataString"
      },
      "index": {
        "description": "Parse SDPA sparse format dat-s string",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "parseSparseDataString",
        "normalized": "SourceName-\u003eString-\u003eEither ParseError Problem",
        "package": "toysolver",
        "partial": "Sparse Data String",
        "signature": "SourceName-\u003eString-\u003eEither ParseError Problem"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:render",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "Problem -\u003e ShowS",
        "fct-source": "src/Text-SDPFile.html#render",
        "fct-type": "function",
        "title": "render"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "render",
        "normalized": "Problem-\u003eShowS",
        "package": "toysolver",
        "partial": "",
        "signature": "Problem-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Text-SDPFile.html#v:renderSparse",
      "description": {
        "fct-module": "Text.SDPFile",
        "fct-package": "toysolver",
        "fct-signature": "Problem -\u003e ShowS",
        "fct-source": "src/Text-SDPFile.html#renderSparse",
        "fct-type": "function",
        "title": "renderSparse"
      },
      "index": {
        "description": "",
        "hierarchy": "Text SDPFile",
        "module": "Text.SDPFile",
        "name": "renderSparse",
        "normalized": "Problem-\u003eShowS",
        "package": "toysolver",
        "partial": "Sparse",
        "signature": "Problem-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome utility functions.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Util.html",
        "fct-type": "module",
        "title": "Util"
      },
      "index": {
        "description": "Some utility functions",
        "hierarchy": "Util",
        "module": "Util",
        "name": "Util",
        "normalized": "",
        "package": "toysolver",
        "partial": "Util",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:combineMaybe",
      "description": {
        "fct-descr": "\u003cp\u003eCombining two \u003ccode\u003eMaybe\u003c/code\u003e values using given function.\n\u003c/p\u003e",
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Maybe a -\u003e Maybe a -\u003e Maybe a",
        "fct-source": "src/Util.html#combineMaybe",
        "fct-type": "function",
        "title": "combineMaybe"
      },
      "index": {
        "description": "Combining two Maybe values using given function",
        "hierarchy": "Util",
        "module": "Util",
        "name": "combineMaybe",
        "normalized": "(a-\u003ea-\u003ea)-\u003eMaybe a-\u003eMaybe a-\u003eMaybe a",
        "package": "toysolver",
        "partial": "Maybe",
        "signature": "(a-\u003ea-\u003ea)-\u003eMaybe a-\u003eMaybe a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:fracPart",
      "description": {
        "fct-descr": "\u003cp\u003efractional part\n\u003c/p\u003e\u003cpre\u003e\n   fracPart x = x - fromInteger (floor x)\n\u003c/pre\u003e",
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e a",
        "fct-source": "src/Util.html#fracPart",
        "fct-type": "function",
        "title": "fracPart"
      },
      "index": {
        "description": "fractional part fracPart fromInteger floor",
        "hierarchy": "Util",
        "module": "Util",
        "name": "fracPart",
        "normalized": "a-\u003ea",
        "package": "toysolver",
        "partial": "Part",
        "signature": "a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:isInteger",
      "description": {
        "fct-descr": "\u003cp\u003eis the number integral?\n\u003c/p\u003e\u003cpre\u003e\n    isInteger x = fromInteger (round x) == x\n\u003c/pre\u003e",
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "a -\u003e Bool",
        "fct-source": "src/Util.html#isInteger",
        "fct-type": "function",
        "title": "isInteger"
      },
      "index": {
        "description": "is the number integral isInteger fromInteger round",
        "hierarchy": "Util",
        "module": "Util",
        "name": "isInteger",
        "normalized": "a-\u003eBool",
        "package": "toysolver",
        "partial": "Integer",
        "signature": "a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:revForM",
      "description": {
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "[a] -\u003e (a -\u003e m b) -\u003e m [b]",
        "fct-source": "src/Util.html#revForM",
        "fct-type": "function",
        "title": "revForM"
      },
      "index": {
        "description": "",
        "hierarchy": "Util",
        "module": "Util",
        "name": "revForM",
        "normalized": "[a]-\u003e(a-\u003eb c)-\u003eb[c]",
        "package": "toysolver",
        "partial": "For",
        "signature": "[a]-\u003e(a-\u003em b)-\u003em[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:revMapM",
      "description": {
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "(a -\u003e m b) -\u003e [a] -\u003e m [b]",
        "fct-source": "src/Util.html#revMapM",
        "fct-type": "function",
        "title": "revMapM"
      },
      "index": {
        "description": "",
        "hierarchy": "Util",
        "module": "Util",
        "name": "revMapM",
        "normalized": "(a-\u003eb c)-\u003e[a]-\u003eb[c]",
        "package": "toysolver",
        "partial": "Map",
        "signature": "(a-\u003em b)-\u003e[a]-\u003em[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:revSequence",
      "description": {
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "[m a] -\u003e m [a]",
        "fct-source": "src/Util.html#revSequence",
        "fct-type": "function",
        "title": "revSequence"
      },
      "index": {
        "description": "",
        "hierarchy": "Util",
        "module": "Util",
        "name": "revSequence",
        "normalized": "[a b]-\u003ea[b]",
        "package": "toysolver",
        "partial": "Sequence",
        "signature": "[m a]-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:showRational",
      "description": {
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "Bool -\u003e Rational -\u003e String",
        "fct-source": "src/Util.html#showRational",
        "fct-type": "function",
        "title": "showRational"
      },
      "index": {
        "description": "",
        "hierarchy": "Util",
        "module": "Util",
        "name": "showRational",
        "normalized": "Bool-\u003eRational-\u003eString",
        "package": "toysolver",
        "partial": "Rational",
        "signature": "Bool-\u003eRational-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Util.html#v:showRationalAsFiniteDecimal",
      "description": {
        "fct-module": "Util",
        "fct-package": "toysolver",
        "fct-signature": "Rational -\u003e Maybe String",
        "fct-source": "src/Util.html#showRationalAsFiniteDecimal",
        "fct-type": "function",
        "title": "showRationalAsFiniteDecimal"
      },
      "index": {
        "description": "",
        "hierarchy": "Util",
        "module": "Util",
        "name": "showRationalAsFiniteDecimal",
        "normalized": "Rational-\u003eMaybe String",
        "package": "toysolver",
        "partial": "Rational As Finite Decimal",
        "signature": "Rational-\u003eMaybe String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Version.html#",
      "description": {
        "fct-module": "Version",
        "fct-package": "toysolver",
        "fct-signature": "module",
        "fct-source": "src/Version.html",
        "fct-type": "module",
        "title": "Version"
      },
      "index": {
        "description": "",
        "hierarchy": "Version",
        "module": "Version",
        "name": "Version",
        "normalized": "",
        "package": "toysolver",
        "partial": "Version",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Version.html#v:packageVersions",
      "description": {
        "fct-module": "Version",
        "fct-package": "toysolver",
        "fct-signature": "[(String, String)]",
        "fct-source": "src/Version.html#packageVersions",
        "fct-type": "function",
        "title": "packageVersions"
      },
      "index": {
        "description": "",
        "hierarchy": "Version",
        "module": "Version",
        "name": "packageVersions",
        "normalized": "[(String,String)]",
        "package": "toysolver",
        "partial": "Versions",
        "signature": "[(String,String)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/toysolver/docs/Version.html#v:version",
      "description": {
        "fct-module": "Version",
        "fct-package": "toysolver",
        "fct-signature": "Version",
        "fct-source": "src/Paths_toysolver.html#version",
        "fct-type": "function",
        "title": "version"
      },
      "index": {
        "description": "",
        "hierarchy": "Version",
        "module": "Version",
        "name": "version",
        "normalized": "",
        "package": "toysolver",
        "partial": "",
        "signature": ""
      }
    }
  }
]
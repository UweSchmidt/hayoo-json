[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#",
      "description": {
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "module",
        "fct-source": "src/Foreign-GreenCard.html",
        "fct-type": "module",
        "title": "GreenCard"
      },
      "index": {
        "description": "",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "GreenCard",
        "normalized": "",
        "package": "greencard",
        "partial": "Green Card",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#t:Char",
      "description": {
        "fct-descr": "\u003cp\u003eThe character type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e is an enumeration whose values represent\nUnicode (or equivalently ISO/IEC 10646) characters (see\n\u003ca\u003ehttp://www.unicode.org/\u003c/a\u003e for details).  This set extends the ISO 8859-1\n(Latin-1) character set (the first 256 characters), which is itself an extension\nof the ASCII character set (the first 128 characters).  A character literal in\nHaskell has type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTo convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e to or from the corresponding \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e value defined\nby Unicode, use \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e from the\n\u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e class respectively (or equivalently \u003ccode\u003eord\u003c/code\u003e and \u003ccode\u003echr\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "Char"
      },
      "index": {
        "description": "The character type Char is an enumeration whose values represent Unicode or equivalently ISO IEC characters see http www.unicode.org for details This set extends the ISO Latin-1 character set the first characters which is itself an extension of the ASCII character set the first characters character literal in Haskell has type Char To convert Char to or from the corresponding Int value defined by Unicode use toEnum and fromEnum from the Enum class respectively or equivalently ord and chr",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "Char",
        "normalized": "",
        "package": "greencard",
        "partial": "Char",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#t:Double",
      "description": {
        "fct-descr": "\u003cp\u003eDouble-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE double-precision type.\n\u003c/p\u003e",
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "Double"
      },
      "index": {
        "description": "Double-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE double-precision type",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "Double",
        "normalized": "",
        "package": "greencard",
        "partial": "Double",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#t:Float",
      "description": {
        "fct-descr": "\u003cp\u003eSingle-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE single-precision type.\n\u003c/p\u003e",
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "Float"
      },
      "index": {
        "description": "Single-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE single-precision type",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "Float",
        "normalized": "",
        "package": "greencard",
        "partial": "Float",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#t:MbString",
      "description": {
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "type",
        "fct-source": "src/Foreign-GreenCard.html#MbString",
        "fct-type": "type",
        "title": "MbString"
      },
      "index": {
        "description": "",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "MbString",
        "normalized": "",
        "package": "greencard",
        "partial": "Mb String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#v:marshall_bool_",
      "description": {
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "Bool -\u003e IO Int",
        "fct-source": "src/Foreign-GreenCard.html#marshall_bool_",
        "fct-type": "function",
        "title": "marshall_bool_"
      },
      "index": {
        "description": "",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "marshall_bool_",
        "normalized": "Bool-\u003eIO Int",
        "package": "greencard",
        "partial": "",
        "signature": "Bool-\u003eIO Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#v:marshall_stringLen_",
      "description": {
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "[Char] -\u003e IO CStringLen",
        "fct-source": "src/Foreign-GreenCard.html#marshall_stringLen_",
        "fct-type": "function",
        "title": "marshall_stringLen_"
      },
      "index": {
        "description": "",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "marshall_stringLen_",
        "normalized": "[Char]-\u003eIO CStringLen",
        "package": "greencard",
        "partial": "Len",
        "signature": "[Char]-\u003eIO CStringLen"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#v:marshall_string_",
      "description": {
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "[Char] -\u003e IO CString",
        "fct-source": "src/Foreign-GreenCard.html#marshall_string_",
        "fct-type": "function",
        "title": "marshall_string_"
      },
      "index": {
        "description": "",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "marshall_string_",
        "normalized": "[Char]-\u003eIO CString",
        "package": "greencard",
        "partial": "",
        "signature": "[Char]-\u003eIO CString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#v:unmarshall_bool_",
      "description": {
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "Int -\u003e IO Bool",
        "fct-source": "src/Foreign-GreenCard.html#unmarshall_bool_",
        "fct-type": "function",
        "title": "unmarshall_bool_"
      },
      "index": {
        "description": "",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "unmarshall_bool_",
        "normalized": "Int-\u003eIO Bool",
        "package": "greencard",
        "partial": "",
        "signature": "Int-\u003eIO Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#v:unmarshall_stringLen_",
      "description": {
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "CString -\u003e Int -\u003e IO String",
        "fct-source": "src/Foreign-GreenCard.html#unmarshall_stringLen_",
        "fct-type": "function",
        "title": "unmarshall_stringLen_"
      },
      "index": {
        "description": "",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "unmarshall_stringLen_",
        "normalized": "CString-\u003eInt-\u003eIO String",
        "package": "greencard",
        "partial": "Len",
        "signature": "CString-\u003eInt-\u003eIO String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#v:unmarshall_string_",
      "description": {
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "CString -\u003e IO String",
        "fct-source": "src/Foreign-GreenCard.html#unmarshall_string_",
        "fct-type": "function",
        "title": "unmarshall_string_"
      },
      "index": {
        "description": "",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "unmarshall_string_",
        "normalized": "CString-\u003eIO String",
        "package": "greencard",
        "partial": "",
        "signature": "CString-\u003eIO String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/greencard/docs/Foreign-GreenCard.html#v:unsafePerformIO",
      "description": {
        "fct-descr": "\u003cp\u003eThis is the \"back door\" into the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad, allowing\n\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation to be performed at any time.  For\nthis to be safe, the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computation should be\nfree of side effects and independent of its environment.\n\u003c/p\u003e\u003cp\u003eIf the I/O computation wrapped in \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e performs side\neffects, then the relative order in which those side effects take\nplace (relative to the main I/O trunk, or other calls to\n\u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e) is indeterminate.  Furthermore, when using\n\u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e to cause side-effects, you should take the following\nprecautions to ensure the side effects are performed as many times as\nyou expect them to be.  Note that these precautions are necessary for\nGHC, but may not be sufficient, and other compilers may require\ndifferent precautions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Use \u003ccode\u003e{-# NOINLINE foo #-}\u003c/code\u003e as a pragma on any function \u003ccode\u003efoo\u003c/code\u003e\n        that calls \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e.  If the call is inlined,\n        the I/O may be performed more than once.\n\u003c/li\u003e\u003cli\u003e Use the compiler flag \u003ccode\u003e-fno-cse\u003c/code\u003e to prevent common sub-expression\n        elimination being performed on the module, which might combine\n        two side effects that were meant to be separate.  A good example\n        is using multiple global variables (like \u003ccode\u003etest\u003c/code\u003e in the example below).\n\u003c/li\u003e\u003cli\u003e Make sure that the either you switch off let-floating (\u003ccode\u003e-fno-full-laziness\u003c/code\u003e), or that the \n        call to \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e cannot float outside a lambda.  For example, \n        if you say:\n        \u003ccode\u003e\n           f x = unsafePerformIO (newIORef [])\n        \u003c/code\u003e\n        you may get only one reference cell shared between all calls to \u003ccode\u003ef\u003c/code\u003e.\n        Better would be\n        \u003ccode\u003e\n           f x = unsafePerformIO (newIORef [x])\n        \u003c/code\u003e\n        because now it can't float outside the lambda.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt is less well known that\n\u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e is not type safe.  For example:\n\u003c/p\u003e\u003cpre\u003e     test :: IORef [a]\n     test = unsafePerformIO $ newIORef []\n     \n     main = do\n             writeIORef test [42]\n             bang \u003c- readIORef test\n             print (bang :: [Char])\n\u003c/pre\u003e\u003cp\u003eThis program will core dump.  This problem with polymorphic references\nis well known in the ML community, and does not arise with normal\nmonadic use of references.  There is no easy way to make it impossible\nonce you use \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e.  Indeed, it is\npossible to write \u003ccode\u003ecoerce :: a -\u003e b\u003c/code\u003e with the\nhelp of \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e.  So be careful!\n\u003c/p\u003e",
        "fct-module": "Foreign.GreenCard",
        "fct-package": "greencard",
        "fct-signature": "IO a -\u003e a",
        "fct-type": "function",
        "title": "unsafePerformIO"
      },
      "index": {
        "description": "This is the back door into the IO monad allowing IO computation to be performed at any time For this to be safe the IO computation should be free of side effects and independent of its environment If the computation wrapped in unsafePerformIO performs side effects then the relative order in which those side effects take place relative to the main trunk or other calls to unsafePerformIO is indeterminate Furthermore when using unsafePerformIO to cause side-effects you should take the following precautions to ensure the side effects are performed as many times as you expect them to be Note that these precautions are necessary for GHC but may not be sufficient and other compilers may require different precautions Use NOINLINE foo as pragma on any function foo that calls unsafePerformIO If the call is inlined the may be performed more than once Use the compiler flag fno-cse to prevent common sub-expression elimination being performed on the module which might combine two side effects that were meant to be separate good example is using multiple global variables like test in the example below Make sure that the either you switch off let-floating fno-full-laziness or that the call to unsafePerformIO cannot float outside lambda For example if you say unsafePerformIO newIORef you may get only one reference cell shared between all calls to Better would be unsafePerformIO newIORef because now it can float outside the lambda It is less well known that unsafePerformIO is not type safe For example test IORef test unsafePerformIO newIORef main do writeIORef test bang readIORef test print bang Char This program will core dump This problem with polymorphic references is well known in the ML community and does not arise with normal monadic use of references There is no easy way to make it impossible once you use unsafePerformIO Indeed it is possible to write coerce with the help of unsafePerformIO So be careful",
        "hierarchy": "Foreign GreenCard",
        "module": "Foreign.GreenCard",
        "name": "unsafePerformIO",
        "normalized": "IO a-\u003ea",
        "package": "greencard",
        "partial": "Perform IO",
        "signature": "IO a-\u003ea"
      }
    }
  }
]
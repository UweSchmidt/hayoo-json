[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLightweight parsing library based on partial functions.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "module",
        "fct-source": "src/Data-Sparser.html",
        "fct-type": "module",
        "title": "Sparser"
      },
      "index": {
        "description": "Lightweight parsing library based on partial functions",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "Sparser",
        "normalized": "",
        "package": "sparser",
        "partial": "Sparser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#t:Sparser",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "type",
        "fct-source": "src/Data-Sparser.html#Sparser",
        "fct-type": "type",
        "title": "Sparser"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "Sparser",
        "normalized": "",
        "package": "sparser",
        "partial": "Sparser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#t:SparserT",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "data",
        "fct-source": "src/Data-Sparser.html#SparserT",
        "fct-type": "data",
        "title": "SparserT"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "SparserT",
        "normalized": "",
        "package": "sparser",
        "partial": "Sparser",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:asSparser",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "Sparser a -\u003e Sparser a",
        "fct-source": "src/Data-Sparser.html#asSparser",
        "fct-type": "function",
        "title": "asSparser"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "asSparser",
        "normalized": "Sparser a-\u003eSparser a",
        "package": "sparser",
        "partial": "Sparser",
        "signature": "Sparser a-\u003eSparser a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:atEnd",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s a ()",
        "fct-source": "src/Data-Sparser.html#atEnd",
        "fct-type": "function",
        "title": "atEnd"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "atEnd",
        "normalized": "SparserT a b()",
        "package": "sparser",
        "partial": "End",
        "signature": "SparserT s a()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:between",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "m a -\u003e m a1 -\u003e m b -\u003e m b",
        "fct-source": "src/Data-Sparser.html#between",
        "fct-type": "function",
        "title": "between"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "between",
        "normalized": "a b-\u003ea b-\u003ea c-\u003ea c",
        "package": "sparser",
        "partial": "",
        "signature": "m a-\u003em a-\u003em b-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:braces",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s Char b -\u003e SparserT s Char b",
        "fct-source": "src/Data-Sparser.html#braces",
        "fct-type": "function",
        "title": "braces"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "braces",
        "normalized": "SparserT a Char b-\u003eSparserT a Char b",
        "package": "sparser",
        "partial": "",
        "signature": "SparserT s Char b-\u003eSparserT s Char b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:brackets",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s Char b -\u003e SparserT s Char b",
        "fct-source": "src/Data-Sparser.html#brackets",
        "fct-type": "function",
        "title": "brackets"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "brackets",
        "normalized": "SparserT a Char b-\u003eSparserT a Char b",
        "package": "sparser",
        "partial": "",
        "signature": "SparserT s Char b-\u003eSparserT s Char b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:char",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "a -\u003e SparserT s a a",
        "fct-source": "src/Data-Sparser.html#char",
        "fct-type": "function",
        "title": "char"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "char",
        "normalized": "a-\u003eSparserT b a a",
        "package": "sparser",
        "partial": "",
        "signature": "a-\u003eSparserT s a a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:charIf",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "(a -\u003e Bool) -\u003e SparserT s a a",
        "fct-source": "src/Data-Sparser.html#charIf",
        "fct-type": "function",
        "title": "charIf"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "charIf",
        "normalized": "(a-\u003eBool)-\u003eSparserT b a a",
        "package": "sparser",
        "partial": "If",
        "signature": "(a-\u003eBool)-\u003eSparserT s a a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:complete",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s a b -\u003e SparserT s a b",
        "fct-source": "src/Data-Sparser.html#complete",
        "fct-type": "function",
        "title": "complete"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "complete",
        "normalized": "SparserT a b c-\u003eSparserT a b c",
        "package": "sparser",
        "partial": "",
        "signature": "SparserT s a b-\u003eSparserT s a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:count",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "Int -\u003e m a -\u003e m [a]",
        "fct-source": "src/Data-Sparser.html#count",
        "fct-type": "function",
        "title": "count"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "count",
        "normalized": "Int-\u003ea b-\u003ea[b]",
        "package": "sparser",
        "partial": "",
        "signature": "Int-\u003em a-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:endBy",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "f a -\u003e f a1 -\u003e f [a]",
        "fct-source": "src/Data-Sparser.html#endBy",
        "fct-type": "function",
        "title": "endBy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "endBy",
        "normalized": "a b-\u003ea b-\u003ea[b]",
        "package": "sparser",
        "partial": "By",
        "signature": "f a-\u003ef a-\u003ef[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:endBy1",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "m a -\u003e m a1 -\u003e m [a]",
        "fct-source": "src/Data-Sparser.html#endBy1",
        "fct-type": "function",
        "title": "endBy1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "endBy1",
        "normalized": "a b-\u003ea b-\u003ea[b]",
        "package": "sparser",
        "partial": "By",
        "signature": "m a-\u003em a-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:gateP",
      "description": {
        "fct-descr": "\u003cp\u003eSucceed based on predicate, but do not consume input.\n\u003c/p\u003e\u003cp\u003eThe given function receives the \u003cem\u003eentire\u003c/em\u003e remaining input.\n\u003c/p\u003e",
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "(s -\u003e [a] -\u003e Bool) -\u003e SparserT s a ()",
        "fct-source": "src/Data-Sparser.html#gateP",
        "fct-type": "function",
        "title": "gateP"
      },
      "index": {
        "description": "Succeed based on predicate but do not consume input The given function receives the entire remaining input",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "gateP",
        "normalized": "(a-\u003e[b]-\u003eBool)-\u003eSparserT a b()",
        "package": "sparser",
        "partial": "",
        "signature": "(s-\u003e[a]-\u003eBool)-\u003eSparserT s a()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:headP",
      "description": {
        "fct-descr": "\u003cp\u003eConsumes one input element.\n\u003c/p\u003e\u003cp\u003eFails if the predicate fails, or if there is no more input.\n\u003c/p\u003e",
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "(s -\u003e a -\u003e Bool) -\u003e SparserT s a a",
        "fct-source": "src/Data-Sparser.html#headP",
        "fct-type": "function",
        "title": "headP"
      },
      "index": {
        "description": "Consumes one input element Fails if the predicate fails or if there is no more input",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "headP",
        "normalized": "(a-\u003eb-\u003eBool)-\u003eSparserT a b b",
        "package": "sparser",
        "partial": "",
        "signature": "(s-\u003ea-\u003eBool)-\u003eSparserT s a a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:ifState",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "(s -\u003e Bool) -\u003e SparserT s a b -\u003e SparserT s a b",
        "fct-source": "src/Data-Sparser.html#ifState",
        "fct-type": "function",
        "title": "ifState"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "ifState",
        "normalized": "(a-\u003eBool)-\u003eSparserT a b c-\u003eSparserT a b c",
        "package": "sparser",
        "partial": "State",
        "signature": "(s-\u003eBool)-\u003eSparserT s a b-\u003eSparserT s a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:integer",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s Char Integer",
        "fct-source": "src/Data-Sparser.html#integer",
        "fct-type": "function",
        "title": "integer"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "integer",
        "normalized": "",
        "package": "sparser",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:many1",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "m a -\u003e m [a]",
        "fct-source": "src/Data-Sparser.html#many1",
        "fct-type": "function",
        "title": "many1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "many1",
        "normalized": "a b-\u003ea[b]",
        "package": "sparser",
        "partial": "",
        "signature": "m a-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:notChar",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "a -\u003e SparserT s a a",
        "fct-source": "src/Data-Sparser.html#notChar",
        "fct-type": "function",
        "title": "notChar"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "notChar",
        "normalized": "a-\u003eSparserT b a a",
        "package": "sparser",
        "partial": "Char",
        "signature": "a-\u003eSparserT s a a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:runSparser",
      "description": {
        "fct-descr": "\u003cp\u003e&#160;\n Run a parser, returning the result.\n\u003c/p\u003e",
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "Sparser a -\u003e String -\u003e Maybe a",
        "fct-source": "src/Data-Sparser.html#runSparser",
        "fct-type": "function",
        "title": "runSparser"
      },
      "index": {
        "description": "Run parser returning the result",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "runSparser",
        "normalized": "Sparser a-\u003eString-\u003eMaybe a",
        "package": "sparser",
        "partial": "Sparser",
        "signature": "Sparser a-\u003eString-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:runSparserT",
      "description": {
        "fct-descr": "\u003cp\u003e&#160;\n Run a parser with a custom state, returning the result.\n\u003c/p\u003e",
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s a b -\u003e s -\u003e [a] -\u003e Maybe b",
        "fct-source": "src/Data-Sparser.html#runSparserT",
        "fct-type": "function",
        "title": "runSparserT"
      },
      "index": {
        "description": "Run parser with custom state returning the result",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "runSparserT",
        "normalized": "SparserT a b c-\u003ea-\u003e[b]-\u003eMaybe c",
        "package": "sparser",
        "partial": "Sparser",
        "signature": "SparserT s a b-\u003es-\u003e[a]-\u003eMaybe b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:runSparserT-39-",
      "description": {
        "fct-descr": "\u003cp\u003e&#160;\n Run a parser with a custom state.\n\u003c/p\u003e\u003cp\u003eThis is the most general way to run a parser. It returns the final state,\n remaining input and the result.\n\u003c/p\u003e",
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s a b -\u003e s -\u003e [a] -\u003e Maybe (s, [a], b)",
        "fct-source": "src/Data-Sparser.html#runSparserT%27",
        "fct-type": "function",
        "title": "runSparserT'"
      },
      "index": {
        "description": "Run parser with custom state This is the most general way to run parser It returns the final state remaining input and the result",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "runSparserT'",
        "normalized": "SparserT a b c-\u003ea-\u003e[b]-\u003eMaybe(a,[b],c)",
        "package": "sparser",
        "partial": "Sparser T'",
        "signature": "SparserT s a b-\u003es-\u003e[a]-\u003eMaybe(s,[a],b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:sepBy",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "f a1 -\u003e f a -\u003e f [a1]",
        "fct-source": "src/Data-Sparser.html#sepBy",
        "fct-type": "function",
        "title": "sepBy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "sepBy",
        "normalized": "a b-\u003ea b-\u003ea[b]",
        "package": "sparser",
        "partial": "By",
        "signature": "f a-\u003ef a-\u003ef[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:sepBy1",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "m a1 -\u003e m a -\u003e m [a1]",
        "fct-source": "src/Data-Sparser.html#sepBy1",
        "fct-type": "function",
        "title": "sepBy1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "sepBy1",
        "normalized": "a b-\u003ea b-\u003ea[b]",
        "package": "sparser",
        "partial": "By",
        "signature": "m a-\u003em a-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:sepEndBy",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "m a1 -\u003e m a -\u003e m [a1]",
        "fct-source": "src/Data-Sparser.html#sepEndBy",
        "fct-type": "function",
        "title": "sepEndBy"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "sepEndBy",
        "normalized": "a b-\u003ea b-\u003ea[b]",
        "package": "sparser",
        "partial": "End By",
        "signature": "m a-\u003em a-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:sepEndBy1",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "m a1 -\u003e m a -\u003e m [a1]",
        "fct-source": "src/Data-Sparser.html#sepEndBy1",
        "fct-type": "function",
        "title": "sepEndBy1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "sepEndBy1",
        "normalized": "a b-\u003ea b-\u003ea[b]",
        "package": "sparser",
        "partial": "End By",
        "signature": "m a-\u003em a-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:skipMany",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "f a -\u003e f ()",
        "fct-source": "src/Data-Sparser.html#skipMany",
        "fct-type": "function",
        "title": "skipMany"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "skipMany",
        "normalized": "a b-\u003ea()",
        "package": "sparser",
        "partial": "Many",
        "signature": "f a-\u003ef()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:skipMany1",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "m a -\u003e m ()",
        "fct-source": "src/Data-Sparser.html#skipMany1",
        "fct-type": "function",
        "title": "skipMany1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "skipMany1",
        "normalized": "a b-\u003ea()",
        "package": "sparser",
        "partial": "Many",
        "signature": "m a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:space",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s Char [Char]",
        "fct-source": "src/Data-Sparser.html#space",
        "fct-type": "function",
        "title": "space"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "space",
        "normalized": "SparserT a Char[Char]",
        "package": "sparser",
        "partial": "",
        "signature": "SparserT s Char[Char]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:splitP",
      "description": {
        "fct-descr": "\u003cp\u003eConsume one or more input elements.\n\u003c/p\u003e\u003cp\u003eThe given function receives the \u003cem\u003eentire\u003c/em\u003e remaining input, and must return\n   the number of consumed elements.\n\u003c/p\u003e\u003cp\u003eFails if the predicate return 0 or less, or if there is no more input.\n\u003c/p\u003e",
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "(s -\u003e [a] -\u003e Int) -\u003e SparserT s a [a]",
        "fct-source": "src/Data-Sparser.html#splitP",
        "fct-type": "function",
        "title": "splitP"
      },
      "index": {
        "description": "Consume one or more input elements The given function receives the entire remaining input and must return the number of consumed elements Fails if the predicate return or less or if there is no more input",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "splitP",
        "normalized": "(a-\u003e[b]-\u003eInt)-\u003eSparserT a b[b]",
        "package": "sparser",
        "partial": "",
        "signature": "(s-\u003e[a]-\u003eInt)-\u003eSparserT s a[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:stateP",
      "description": {
        "fct-descr": "\u003cp\u003e&#160;Return the state as result.\n\u003c/p\u003e",
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s a s",
        "fct-source": "src/Data-Sparser.html#stateP",
        "fct-type": "function",
        "title": "stateP"
      },
      "index": {
        "description": "Return the state as result",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "stateP",
        "normalized": "",
        "package": "sparser",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:string",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "[a] -\u003e SparserT s a [a]",
        "fct-source": "src/Data-Sparser.html#string",
        "fct-type": "function",
        "title": "string"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "string",
        "normalized": "[a]-\u003eSparserT b a[a]",
        "package": "sparser",
        "partial": "",
        "signature": "[a]-\u003eSparserT s a[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:stringIf",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "Int -\u003e ([a] -\u003e Bool) -\u003e SparserT s a [a]",
        "fct-source": "src/Data-Sparser.html#stringIf",
        "fct-type": "function",
        "title": "stringIf"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "stringIf",
        "normalized": "Int-\u003e([a]-\u003eBool)-\u003eSparserT b a[a]",
        "package": "sparser",
        "partial": "If",
        "signature": "Int-\u003e([a]-\u003eBool)-\u003eSparserT s a[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:stringLiteral",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "SparserT s Char String",
        "fct-source": "src/Data-Sparser.html#stringLiteral",
        "fct-type": "function",
        "title": "stringLiteral"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "stringLiteral",
        "normalized": "",
        "package": "sparser",
        "partial": "Literal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/sparser/docs/Data-Sparser.html#v:withState",
      "description": {
        "fct-module": "Data.Sparser",
        "fct-package": "sparser",
        "fct-signature": "(s -\u003e t) -\u003e (t -\u003e s) -\u003e SparserT t a b -\u003e SparserT s a b",
        "fct-source": "src/Data-Sparser.html#withState",
        "fct-type": "function",
        "title": "withState"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Sparser",
        "module": "Data.Sparser",
        "name": "withState",
        "normalized": "(a-\u003eb)-\u003e(b-\u003ea)-\u003eSparserT b c d-\u003eSparserT a c d",
        "package": "sparser",
        "partial": "State",
        "signature": "(s-\u003et)-\u003e(t-\u003es)-\u003eSparserT t a b-\u003eSparserT s a b"
      }
    }
  }
]
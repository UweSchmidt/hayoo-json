[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "module",
        "fct-source": "src/Data-Boolean-BF.html",
        "fct-type": "module",
        "title": "BF"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BF",
        "normalized": "",
        "package": "hBDD",
        "partial": "BF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#t:BF",
      "description": {
        "fct-descr": "\u003cp\u003eAn abstract syntax tree-ish instance of the \u003ccode\u003e\u003ca\u003eBoolean\u003c/a\u003e\u003c/code\u003e interface,\n sometimes useful for debugging.\n\u003c/p\u003e\u003cp\u003eNote the \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e instance is \u003cem\u003enot\u003c/em\u003e semantic equality.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "data",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "data",
        "title": "BF"
      },
      "index": {
        "description": "An abstract syntax tree-ish instance of the Boolean interface sometimes useful for debugging Note the Eq instance is not semantic equality",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BF",
        "normalized": "",
        "package": "hBDD",
        "partial": "BF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFand",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BF BFand BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFand"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFand",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFand",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFexists",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BFexists [BF] BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFexists"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFexists",
        "normalized": "BFexists[BF]BF",
        "package": "hBDD",
        "partial": "BFexists",
        "signature": "BFexists[BF]BF"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFfalse",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BFfalse",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFfalse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFfalse",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFfalse",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFforall",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BFforall [BF] BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFforall"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFforall",
        "normalized": "BFforall[BF]BF",
        "package": "hBDD",
        "partial": "BFforall",
        "signature": "BFforall[BF]BF"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFiff",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BF BFiff BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFiff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFiff",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFiff",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFimplies",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BF BFimplies BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFimplies"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFimplies",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFimplies",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFneg",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BFneg BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFneg"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFneg",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFneg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFor",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BF BFor BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFor",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFsubst",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BFsubst [(BF, BF)] BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFsubst"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFsubst",
        "normalized": "BFsubst[(BF,BF)]BF",
        "package": "hBDD",
        "partial": "BFsubst",
        "signature": "BFsubst[(BF,BF)]BF"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFtrue",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BFtrue",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFtrue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFtrue",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFtrue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFvar",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BFvar String",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFvar"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFvar",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFvar",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean-BF.html#v:BFxor",
      "description": {
        "fct-module": "Data.Boolean.BF",
        "fct-package": "hBDD",
        "fct-signature": "BF BFxor BF",
        "fct-source": "src/Data-Boolean-BF.html#BF",
        "fct-type": "function",
        "title": "BFxor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean BF",
        "module": "Data.Boolean.BF",
        "name": "BFxor",
        "normalized": "",
        "package": "hBDD",
        "partial": "BFxor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn interface to libraries supporting efficient manipulation of\n Boolean functions, such as BDDs. It is an evolution of \u003ccode\u003eLogical\n Abstractions in Haskell\u003c/code\u003e by Nancy A. Day, John Launchbury and Jeff\n Lewis, Haskell Workshop, Paris, October 1999.\n\u003c/p\u003e\u003cp\u003eThe purity of this interface may make it difficult to predict when\n BDDs actually get constructed.\n\u003c/p\u003e\u003cp\u003eNote the use of \u003ccode\u003e\u003ca\u003eneg\u003c/a\u003e\u003c/code\u003e rather than \u003ccode\u003enot\u003c/code\u003e to avoid a clash with\n \u003ccode\u003ePrelude.not\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "module",
        "fct-source": "src/Data-Boolean.html",
        "fct-type": "module",
        "title": "Boolean"
      },
      "index": {
        "description": "An interface to libraries supporting efficient manipulation of Boolean functions such as BDDs It is an evolution of Logical Abstractions in Haskell by Nancy Day John Launchbury and Jeff Lewis Haskell Workshop Paris October The purity of this interface may make it difficult to predict when BDDs actually get constructed Note the use of neg rather than not to avoid clash with Prelude.not",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "Boolean",
        "normalized": "",
        "package": "hBDD",
        "partial": "Boolean",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#t:BDDOps",
      "description": {
        "fct-descr": "\u003cp\u003eOperations provided by BDD representations.\n\u003c/p\u003e\u003cp\u003eNote that the \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e instance is expected to provide \u003cem\u003esemantic\u003c/em\u003e\n equality on boolean functions, as is typical of BDD packages.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "class",
        "fct-source": "src/Data-Boolean.html#BDDOps",
        "fct-type": "class",
        "title": "BDDOps"
      },
      "index": {
        "description": "Operations provided by BDD representations Note that the Eq instance is expected to provide semantic equality on boolean functions as is typical of BDD packages",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "BDDOps",
        "normalized": "",
        "package": "hBDD",
        "partial": "BDDOps",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#t:Boolean",
      "description": {
        "fct-descr": "\u003cp\u003eThe operators have similar fixities and associativies to the\n standard boolean operators, but at higher precedence (they bind\n more strongly).\n\u003c/p\u003e\u003cp\u003eThe overloaded Boolean operations proper. Provides defaults for\n operations with obvious expansions, such as \u003ccode\u003e\u003ca\u003enand\u003c/a\u003e\u003c/code\u003e. A minimal\n instance should define '(/)' and \u003ccode\u003e\u003ca\u003eneg\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "class",
        "fct-source": "src/Data-Boolean.html#Boolean",
        "fct-type": "class",
        "title": "Boolean"
      },
      "index": {
        "description": "The operators have similar fixities and associativies to the standard boolean operators but at higher precedence they bind more strongly The overloaded Boolean operations proper Provides defaults for operations with obvious expansions such as nand minimal instance should define and neg",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "Boolean",
        "normalized": "",
        "package": "hBDD",
        "partial": "Boolean",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#t:BooleanVariable",
      "description": {
        "fct-descr": "\u003cp\u003eBoolean variables.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "class",
        "fct-source": "src/Data-Boolean.html#BooleanVariable",
        "fct-type": "class",
        "title": "BooleanVariable"
      },
      "index": {
        "description": "Boolean variables",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "BooleanVariable",
        "normalized": "",
        "package": "hBDD",
        "partial": "Boolean Variable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#t:QBF",
      "description": {
        "fct-descr": "\u003cp\u003eQuantified Boolean Formulae (QBF) operations.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "class",
        "fct-source": "src/Data-Boolean.html#QBF",
        "fct-type": "class",
        "title": "QBF"
      },
      "index": {
        "description": "Quantified Boolean Formulae QBF operations",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "QBF",
        "normalized": "",
        "package": "hBDD",
        "partial": "QBF",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#t:RenderBool",
      "description": {
        "fct-descr": "\u003cp\u003eA class for the text constants and operators used by \u003ccode\u003e\u003ca\u003esop\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "class",
        "fct-source": "src/Data-Boolean.html#RenderBool",
        "fct-type": "class",
        "title": "RenderBool"
      },
      "index": {
        "description": "class for the text constants and operators used by sop",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "RenderBool",
        "normalized": "",
        "package": "hBDD",
        "partial": "Render Bool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#t:ReorderingMethod",
      "description": {
        "fct-descr": "\u003cp\u003eBDD libraries tend to include some kind of variable reordering\n heuristics. These are some common ones.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "data",
        "fct-source": "src/Data-Boolean.html#ReorderingMethod",
        "fct-type": "data",
        "title": "ReorderingMethod"
      },
      "index": {
        "description": "BDD libraries tend to include some kind of variable reordering heuristics These are some common ones",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "ReorderingMethod",
        "normalized": "",
        "package": "hBDD",
        "partial": "Reordering Method",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#t:Substitution",
      "description": {
        "fct-descr": "\u003cp\u003eSubstitutions.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "class",
        "fct-source": "src/Data-Boolean.html#Substitution",
        "fct-type": "class",
        "title": "Substitution"
      },
      "index": {
        "description": "Substitutions",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "Substitution",
        "normalized": "",
        "package": "hBDD",
        "partial": "Substitution",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:-45--45--62-",
      "description": {
        "fct-descr": "\u003cp\u003eImplication\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#--%3E",
        "fct-type": "method",
        "title": "(--\u003e)"
      },
      "index": {
        "description": "Implication",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "(--\u003e) --\u003e",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:-47--92-",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#%2F%5C",
        "fct-type": "method",
        "title": "(/\\)"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "(/\\) /\\",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:-60--45--45-",
      "description": {
        "fct-descr": "\u003cp\u003eReverse implication\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#%3C--",
        "fct-type": "function",
        "title": "(\u003c--)"
      },
      "index": {
        "description": "Reverse implication",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "(\u003c--) \u003c--",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:-60--45--62-",
      "description": {
        "fct-descr": "\u003cp\u003eIf-and-only-if is exclusive nor.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#%3C-%3E",
        "fct-type": "method",
        "title": "(\u003c-\u003e)"
      },
      "index": {
        "description": "If-and-only-if is exclusive nor",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "(\u003c-\u003e) \u003c-\u003e",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:-92--47-",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#%5C%2F",
        "fct-type": "method",
        "title": "(\\/)"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "(\\/) \\/",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:ReorderNone",
      "description": {
        "fct-descr": "\u003cp\u003eSwitch off variable reordering.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "ReorderNone",
        "fct-source": "src/Data-Boolean.html#ReorderingMethod",
        "fct-type": "function",
        "title": "ReorderNone"
      },
      "index": {
        "description": "Switch off variable reordering",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "ReorderNone",
        "normalized": "",
        "package": "hBDD",
        "partial": "Reorder None",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:ReorderSift",
      "description": {
        "fct-descr": "\u003cp\u003eSifting\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "ReorderSift",
        "fct-source": "src/Data-Boolean.html#ReorderingMethod",
        "fct-type": "function",
        "title": "ReorderSift"
      },
      "index": {
        "description": "Sifting",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "ReorderSift",
        "normalized": "",
        "package": "hBDD",
        "partial": "Reorder Sift",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:ReorderSiftSym",
      "description": {
        "fct-descr": "\u003cp\u003eSifting with identification of symmetric variables\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "ReorderSiftSym",
        "fct-source": "src/Data-Boolean.html#ReorderingMethod",
        "fct-type": "function",
        "title": "ReorderSiftSym"
      },
      "index": {
        "description": "Sifting with identification of symmetric variables",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "ReorderSiftSym",
        "normalized": "",
        "package": "hBDD",
        "partial": "Reorder Sift Sym",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:ReorderStableWindow3",
      "description": {
        "fct-descr": "\u003cp\u003eWindow permutation.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "ReorderStableWindow3",
        "fct-source": "src/Data-Boolean.html#ReorderingMethod",
        "fct-type": "function",
        "title": "ReorderStableWindow3"
      },
      "index": {
        "description": "Window permutation",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "ReorderStableWindow3",
        "normalized": "",
        "package": "hBDD",
        "partial": "Reorder Stable Window",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:belse",
      "description": {
        "fct-descr": "\u003cp\u003eExtracts the this-node-false-branch of a \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "belse",
        "fct-source": "src/Data-Boolean.html#belse",
        "fct-type": "method",
        "title": "belse"
      },
      "index": {
        "description": "Extracts the this-node-false-branch of",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "belse",
        "normalized": "",
        "package": "hBDD",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:bif",
      "description": {
        "fct-descr": "\u003cp\u003eExtracts the variable labelling the topmost node in \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "bif",
        "fct-source": "src/Data-Boolean.html#bif",
        "fct-type": "method",
        "title": "bif"
      },
      "index": {
        "description": "Extracts the variable labelling the topmost node in",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "bif",
        "normalized": "",
        "package": "hBDD",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:bthen",
      "description": {
        "fct-descr": "\u003cp\u003eExtracts the this-node-true-branch of a \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "bthen",
        "fct-source": "src/Data-Boolean.html#bthen",
        "fct-type": "method",
        "title": "bthen"
      },
      "index": {
        "description": "Extracts the this-node-true-branch of",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "bthen",
        "normalized": "",
        "package": "hBDD",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:bvar",
      "description": {
        "fct-descr": "\u003cp\u003eA single variable.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "String -\u003e b",
        "fct-source": "src/Data-Boolean.html#bvar",
        "fct-type": "method",
        "title": "bvar"
      },
      "index": {
        "description": "single variable",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "bvar",
        "normalized": "String-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "String-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:bvars",
      "description": {
        "fct-descr": "\u003cp\u003eA set of variables, notionally 'adjacent'. What this means\n is implementation-defined, but the intention is to support\n (current, next)-state variable pairing.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "[String] -\u003e [b]",
        "fct-source": "src/Data-Boolean.html#bvars",
        "fct-type": "method",
        "title": "bvars"
      },
      "index": {
        "description": "set of variables notionally adjacent What this means is implementation-defined but the intention is to support current next state variable pairing",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "bvars",
        "normalized": "[String]-\u003e[a]",
        "package": "hBDD",
        "partial": "",
        "signature": "[String]-\u003e[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:conjoin",
      "description": {
        "fct-descr": "\u003cp\u003eForms the Big Conjunction of a list of \u003ccode\u003e\u003ca\u003eBoolean\u003c/a\u003e\u003c/code\u003e formulas.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "[b] -\u003e b",
        "fct-source": "src/Data-Boolean.html#conjoin",
        "fct-type": "function",
        "title": "conjoin"
      },
      "index": {
        "description": "Forms the Big Conjunction of list of Boolean formulas",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "conjoin",
        "normalized": "[a]-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "[b]-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:countPaths",
      "description": {
        "fct-descr": "\u003cp\u003eCount the number of paths in a BDD leading to \u003ccode\u003e\u003ca\u003etrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e Integer",
        "fct-source": "src/Data-Boolean.html#countPaths",
        "fct-type": "function",
        "title": "countPaths"
      },
      "index": {
        "description": "Count the number of paths in BDD leading to true",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "countPaths",
        "normalized": "a-\u003eInteger",
        "package": "hBDD",
        "partial": "Paths",
        "signature": "b-\u003eInteger"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:disjoin",
      "description": {
        "fct-descr": "\u003cp\u003eForms the Big Disjunction of a list of \u003ccode\u003e\u003ca\u003eBoolean\u003c/a\u003e\u003c/code\u003e formulas.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "[b] -\u003e b",
        "fct-source": "src/Data-Boolean.html#disjoin",
        "fct-type": "function",
        "title": "disjoin"
      },
      "index": {
        "description": "Forms the Big Disjunction of list of Boolean formulas",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "disjoin",
        "normalized": "[a]-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "[b]-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:exists",
      "description": {
        "fct-descr": "\u003cp\u003eExistentially quantify out a given set of variables.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "Group b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#exists",
        "fct-type": "method",
        "title": "exists"
      },
      "index": {
        "description": "Existentially quantify out given set of variables",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "exists",
        "normalized": "Group a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "Group b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:false",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b",
        "fct-source": "src/Data-Boolean.html#false",
        "fct-type": "method",
        "title": "false"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "false",
        "normalized": "",
        "package": "hBDD",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:fix",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the fixpoint of a \u003ca\u003eBoolean\u003c/a\u003e function.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e (b -\u003e b) -\u003e b",
        "fct-source": "src/Data-Boolean.html#fix",
        "fct-type": "function",
        "title": "fix"
      },
      "index": {
        "description": "Compute the fixpoint of Boolean function",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "fix",
        "normalized": "a-\u003e(a-\u003ea)-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003e(b-\u003eb)-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:fix2",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ca\u003efix\u003c/a\u003e with state.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "a -\u003e b -\u003e (a -\u003e b -\u003e (a, b)) -\u003e (a, b)",
        "fct-source": "src/Data-Boolean.html#fix2",
        "fct-type": "function",
        "title": "fix2"
      },
      "index": {
        "description": "fix with state",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "fix2",
        "normalized": "a-\u003eb-\u003e(a-\u003eb-\u003e(a,b))-\u003e(a,b)",
        "package": "hBDD",
        "partial": "",
        "signature": "a-\u003eb-\u003e(a-\u003eb-\u003e(a,b))-\u003e(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:forall",
      "description": {
        "fct-descr": "\u003cp\u003eUniversally quantify out a given set of variables.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "Group b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#forall",
        "fct-type": "method",
        "title": "forall"
      },
      "index": {
        "description": "Universally quantify out given set of variables",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "forall",
        "normalized": "Group a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "Group b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:get_bdd_ptr",
      "description": {
        "fct-descr": "\u003cp\u003eReturn a pointer to the underlying representation.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e IntPtr",
        "fct-source": "src/Data-Boolean.html#get_bdd_ptr",
        "fct-type": "method",
        "title": "get_bdd_ptr"
      },
      "index": {
        "description": "Return pointer to the underlying representation",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "get_bdd_ptr",
        "normalized": "a-\u003eIntPtr",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eIntPtr"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:mkGroup",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct aggregations.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "[b] -\u003e Group b",
        "fct-source": "src/Data-Boolean.html#mkGroup",
        "fct-type": "method",
        "title": "mkGroup"
      },
      "index": {
        "description": "Construct aggregations",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "mkGroup",
        "normalized": "[a]-\u003eGroup a",
        "package": "hBDD",
        "partial": "Group",
        "signature": "[b]-\u003eGroup b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:mkSubst",
      "description": {
        "fct-descr": "\u003cp\u003eBuilds a new substitution. The arguments are\n \u003ccode\u003e(Variable, Formula)\u003c/code\u003e pairs.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "[(b, b)] -\u003e Subst b",
        "fct-source": "src/Data-Boolean.html#mkSubst",
        "fct-type": "method",
        "title": "mkSubst"
      },
      "index": {
        "description": "Builds new substitution The arguments are Variable Formula pairs",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "mkSubst",
        "normalized": "[(a,a)]-\u003eSubst a",
        "package": "hBDD",
        "partial": "Subst",
        "signature": "[(b,b)]-\u003eSubst b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:nand",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#nand",
        "fct-type": "method",
        "title": "nand"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "nand",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:neg",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b",
        "fct-source": "src/Data-Boolean.html#neg",
        "fct-type": "method",
        "title": "neg"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "neg",
        "normalized": "a-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:nor",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#nor",
        "fct-type": "method",
        "title": "nor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "nor",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rbAnd",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "a",
        "fct-source": "src/Data-Boolean.html#rbAnd",
        "fct-type": "method",
        "title": "rbAnd"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rbAnd",
        "normalized": "",
        "package": "hBDD",
        "partial": "And",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rbConcat",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "a -\u003e a -\u003e a",
        "fct-source": "src/Data-Boolean.html#rbConcat",
        "fct-type": "method",
        "title": "rbConcat"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rbConcat",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "Concat",
        "signature": "a-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rbEmpty",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "a",
        "fct-source": "src/Data-Boolean.html#rbEmpty",
        "fct-type": "method",
        "title": "rbEmpty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rbEmpty",
        "normalized": "",
        "package": "hBDD",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rbFalse",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "a",
        "fct-source": "src/Data-Boolean.html#rbFalse",
        "fct-type": "method",
        "title": "rbFalse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rbFalse",
        "normalized": "",
        "package": "hBDD",
        "partial": "False",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rbNeg",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "a",
        "fct-source": "src/Data-Boolean.html#rbNeg",
        "fct-type": "method",
        "title": "rbNeg"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rbNeg",
        "normalized": "",
        "package": "hBDD",
        "partial": "Neg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rbOr",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "a",
        "fct-source": "src/Data-Boolean.html#rbOr",
        "fct-type": "method",
        "title": "rbOr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rbOr",
        "normalized": "",
        "package": "hBDD",
        "partial": "Or",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rbTrue",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "a",
        "fct-source": "src/Data-Boolean.html#rbTrue",
        "fct-type": "method",
        "title": "rbTrue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rbTrue",
        "normalized": "",
        "package": "hBDD",
        "partial": "True",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rbVar",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "String -\u003e a",
        "fct-source": "src/Data-Boolean.html#rbVar",
        "fct-type": "method",
        "title": "rbVar"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rbVar",
        "normalized": "String-\u003ea",
        "package": "hBDD",
        "partial": "Var",
        "signature": "String-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:reduce",
      "description": {
        "fct-descr": "\u003cp\u003eReturns a BDD which agrees with \u003cem\u003ef\u003c/em\u003e for all valuations for which\n \u003cem\u003eg\u003c/em\u003e is true, and which is hopefully smaller than \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "reduce",
        "fct-source": "src/Data-Boolean.html#reduce",
        "fct-type": "method",
        "title": "reduce"
      },
      "index": {
        "description": "Returns BDD which agrees with for all valuations for which is true and which is hopefully smaller than",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "reduce",
        "normalized": "",
        "package": "hBDD",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rel_product",
      "description": {
        "fct-descr": "\u003cp\u003eComputes the relational product of two \u003ccode\u003e\u003ca\u003eBoolean\u003c/a\u003e\u003c/code\u003e formulas:\n\u003c/p\u003e\u003cpre\u003erel_product qvars f g = exists qvars (f /\\ g)\u003c/pre\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "Group b -\u003e b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#rel_product",
        "fct-type": "method",
        "title": "rel_product"
      },
      "index": {
        "description": "Computes the relational product of two Boolean formulas rel product qvars exists qvars",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rel_product",
        "normalized": "Group a-\u003ea-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "Group b-\u003eb-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:rename",
      "description": {
        "fct-descr": "\u003cp\u003eSubstitutes variables for variables in a \u003ccode\u003e\u003ca\u003eBoolean\u003c/a\u003e\u003c/code\u003e formula.\n Note that it is the user's responsibility to ensure the\n \u003ccode\u003eFormula\u003c/code\u003es in the substitution are in fact \u003ccode\u003eBDD\u003c/code\u003e variables, and\n that the domain and range do not overlap.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "Subst b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#rename",
        "fct-type": "method",
        "title": "rename"
      },
      "index": {
        "description": "Substitutes variables for variables in Boolean formula Note that it is the user responsibility to ensure the Formula in the substitution are in fact BDD variables and that the domain and range do not overlap",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "rename",
        "normalized": "Subst a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "Subst b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:satisfy",
      "description": {
        "fct-descr": "\u003cp\u003eFinds a satisfying variable assignment for \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "satisfy",
        "fct-source": "src/Data-Boolean.html#satisfy",
        "fct-type": "method",
        "title": "satisfy"
      },
      "index": {
        "description": "Finds satisfying variable assignment for",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "satisfy",
        "normalized": "",
        "package": "hBDD",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:sop",
      "description": {
        "fct-descr": "\u003cp\u003eRender a \u003ccode\u003e\u003ca\u003eBoolean\u003c/a\u003e\u003c/code\u003e type as a sum-of-products. This was stolen\n lock-stock from David Long's calculator example.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e a",
        "fct-source": "src/Data-Boolean.html#sop",
        "fct-type": "function",
        "title": "sop"
      },
      "index": {
        "description": "Render Boolean type as sum-of-products This was stolen lock-stock from David Long calculator example",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "sop",
        "normalized": "a-\u003eb",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:substitute",
      "description": {
        "fct-descr": "\u003cp\u003eSubstitutes formulas for variables in a \u003ccode\u003e\u003ca\u003eBoolean\u003c/a\u003e\u003c/code\u003e formula.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "Subst b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#substitute",
        "fct-type": "method",
        "title": "substitute"
      },
      "index": {
        "description": "Substitutes formulas for variables in Boolean formula",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "substitute",
        "normalized": "Subst a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "Subst b-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:support",
      "description": {
        "fct-descr": "\u003cp\u003eFinds the set of variables that \u003cem\u003ef\u003c/em\u003e depends on.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "support",
        "fct-source": "src/Data-Boolean.html#support",
        "fct-type": "method",
        "title": "support"
      },
      "index": {
        "description": "Finds the set of variables that depends on",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "support",
        "normalized": "",
        "package": "hBDD",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:true",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b",
        "fct-source": "src/Data-Boolean.html#true",
        "fct-type": "method",
        "title": "true"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "true",
        "normalized": "",
        "package": "hBDD",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:unbvar",
      "description": {
        "fct-descr": "\u003cp\u003eReverse mapping.\n\u003c/p\u003e",
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e String",
        "fct-source": "src/Data-Boolean.html#unbvar",
        "fct-type": "method",
        "title": "unbvar"
      },
      "index": {
        "description": "Reverse mapping",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "unbvar",
        "normalized": "a-\u003eString",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/hBDD/docs/Data-Boolean.html#v:xor",
      "description": {
        "fct-module": "Data.Boolean",
        "fct-package": "hBDD",
        "fct-signature": "b -\u003e b -\u003e b",
        "fct-source": "src/Data-Boolean.html#xor",
        "fct-type": "method",
        "title": "xor"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Boolean",
        "module": "Data.Boolean",
        "name": "xor",
        "normalized": "a-\u003ea-\u003ea",
        "package": "hBDD",
        "partial": "",
        "signature": "b-\u003eb-\u003eb"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch-Formatting.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains some utility functions for formatting descriptions\n It is probably only useful when you're writing your own matchers\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Rematch.Formatting",
        "fct-package": "rematch",
        "fct-signature": "module",
        "fct-source": "src/Control-Rematch-Formatting.html",
        "fct-type": "module",
        "title": "Formatting"
      },
      "index": {
        "description": "This module contains some utility functions for formatting descriptions It is probably only useful when you re writing your own matchers",
        "hierarchy": "Control Rematch Formatting",
        "module": "Control.Rematch.Formatting",
        "name": "Formatting",
        "normalized": "",
        "package": "rematch",
        "partial": "Formatting",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch-Formatting.html#v:describeList",
      "description": {
        "fct-module": "Control.Rematch.Formatting",
        "fct-package": "rematch",
        "fct-signature": "String -\u003e [String] -\u003e String",
        "fct-source": "src/Control-Rematch-Formatting.html#describeList",
        "fct-type": "function",
        "title": "describeList"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Rematch Formatting",
        "module": "Control.Rematch.Formatting",
        "name": "describeList",
        "normalized": "String-\u003e[String]-\u003eString",
        "package": "rematch",
        "partial": "List",
        "signature": "String-\u003e[String]-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch-Formatting.html#v:join",
      "description": {
        "fct-descr": "\u003cp\u003eUtility function for formatting a list of strings with a separator\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Formatting",
        "fct-package": "rematch",
        "fct-signature": "String -\u003e [String] -\u003e String",
        "fct-source": "src/Control-Rematch-Formatting.html#join",
        "fct-type": "function",
        "title": "join"
      },
      "index": {
        "description": "Utility function for formatting list of strings with separator",
        "hierarchy": "Control Rematch Formatting",
        "module": "Control.Rematch.Formatting",
        "name": "join",
        "normalized": "String-\u003e[String]-\u003eString",
        "package": "rematch",
        "partial": "",
        "signature": "String-\u003e[String]-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch-Run.html#",
      "description": {
        "fct-module": "Control.Rematch.Run",
        "fct-package": "rematch",
        "fct-signature": "module",
        "fct-source": "src/Control-Rematch-Run.html",
        "fct-type": "module",
        "title": "Run"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Rematch Run",
        "module": "Control.Rematch.Run",
        "name": "Run",
        "normalized": "",
        "package": "rematch",
        "partial": "Run",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch-Run.html#t:Match",
      "description": {
        "fct-descr": "\u003cp\u003eA type representing a match success or failure.\n\u003c/p\u003e",
        "fct-module": "Control.Rematch.Run",
        "fct-package": "rematch",
        "fct-signature": "data",
        "fct-source": "src/Control-Rematch-Run.html#Match",
        "fct-type": "data",
        "title": "Match"
      },
      "index": {
        "description": "type representing match success or failure",
        "hierarchy": "Control Rematch Run",
        "module": "Control.Rematch.Run",
        "name": "Match",
        "normalized": "",
        "package": "rematch",
        "partial": "Match",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch-Run.html#v:MatchFailure",
      "description": {
        "fct-module": "Control.Rematch.Run",
        "fct-package": "rematch",
        "fct-signature": "MatchFailure String",
        "fct-source": "src/Control-Rematch-Run.html#Match",
        "fct-type": "function",
        "title": "MatchFailure"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Rematch Run",
        "module": "Control.Rematch.Run",
        "name": "MatchFailure",
        "normalized": "",
        "package": "rematch",
        "partial": "Match Failure",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch-Run.html#v:MatchSuccess",
      "description": {
        "fct-module": "Control.Rematch.Run",
        "fct-package": "rematch",
        "fct-signature": "MatchSuccess",
        "fct-source": "src/Control-Rematch-Run.html#Match",
        "fct-type": "function",
        "title": "MatchSuccess"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Rematch Run",
        "module": "Control.Rematch.Run",
        "name": "MatchSuccess",
        "normalized": "",
        "package": "rematch",
        "partial": "Match Success",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines an api for matchers: rules that can pass or fail,\n and describe their failure and success conditions for humans to read.\n\u003c/p\u003e\u003cp\u003eThis module also exports some useful matchers for things in the \u003ca\u003ePrelude\u003c/a\u003e,\n and some combinators that are useful for combining several matchers into one.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "module",
        "fct-source": "src/Control-Rematch.html",
        "fct-type": "module",
        "title": "Rematch"
      },
      "index": {
        "description": "This module defines an api for matchers rules that can pass or fail and describe their failure and success conditions for humans to read This module also exports some useful matchers for things in the Prelude and some combinators that are useful for combining several matchers into one",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "Rematch",
        "normalized": "",
        "package": "rematch",
        "partial": "Rematch",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#t:Matcher",
      "description": {
        "fct-descr": "\u003cp\u003eThe basic api for a matcher\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "data",
        "fct-source": "src/Control-Rematch.html#Matcher",
        "fct-type": "data",
        "title": "Matcher"
      },
      "index": {
        "description": "The basic api for matcher",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "Matcher",
        "normalized": "",
        "package": "rematch",
        "partial": "Matcher",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:Matcher",
      "description": {
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher",
        "fct-source": "src/Control-Rematch.html#Matcher",
        "fct-type": "function",
        "title": "Matcher"
      },
      "index": {
        "description": "",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "Matcher",
        "normalized": "",
        "package": "rematch",
        "partial": "Matcher",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:allOf",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if all of a list of matchers pass\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "[Matcher a] -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#allOf",
        "fct-type": "function",
        "title": "allOf"
      },
      "index": {
        "description": "Matches if all of list of matchers pass",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "allOf",
        "normalized": "[Matcher a]-\u003eMatcher a",
        "package": "rematch",
        "partial": "Of",
        "signature": "[Matcher a]-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:anyOf",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if any of a list of matchers pass\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "[Matcher a] -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#anyOf",
        "fct-type": "function",
        "title": "anyOf"
      },
      "index": {
        "description": "Matches if any of list of matchers pass",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "anyOf",
        "normalized": "[Matcher a]-\u003eMatcher a",
        "package": "rematch",
        "partial": "Of",
        "signature": "[Matcher a]-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:describeMismatch",
      "description": {
        "fct-descr": "\u003cp\u003eA description to be shown if the match fails.\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Control-Rematch.html#Matcher",
        "fct-type": "function",
        "title": "describeMismatch"
      },
      "index": {
        "description": "description to be shown if the match fails",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "describeMismatch",
        "normalized": "a-\u003eString",
        "package": "rematch",
        "partial": "Mismatch",
        "signature": "a-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:description",
      "description": {
        "fct-descr": "\u003cp\u003eA description of the matcher (usually of its success conditions)\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "String",
        "fct-source": "src/Control-Rematch.html#Matcher",
        "fct-type": "function",
        "title": "description"
      },
      "index": {
        "description": "description of the matcher usually of its success conditions",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "description",
        "normalized": "",
        "package": "rematch",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:equalTo",
      "description": {
        "fct-descr": "\u003cp\u003eMatcher on equality\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#equalTo",
        "fct-type": "function",
        "title": "equalTo"
      },
      "index": {
        "description": "Matcher on equality",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "equalTo",
        "normalized": "a-\u003eMatcher a",
        "package": "rematch",
        "partial": "To",
        "signature": "a-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:everyItem",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if every item in the input list passes a matcher\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher a -\u003e Matcher [a]",
        "fct-source": "src/Control-Rematch.html#everyItem",
        "fct-type": "function",
        "title": "everyItem"
      },
      "index": {
        "description": "Matches if every item in the input list passes matcher",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "everyItem",
        "normalized": "Matcher a-\u003eMatcher[a]",
        "package": "rematch",
        "partial": "Item",
        "signature": "Matcher a-\u003eMatcher[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:greaterThan",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if the input is greater than the required number\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#greaterThan",
        "fct-type": "function",
        "title": "greaterThan"
      },
      "index": {
        "description": "Matches if the input is greater than the required number",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "greaterThan",
        "normalized": "a-\u003eMatcher a",
        "package": "rematch",
        "partial": "Than",
        "signature": "a-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:greaterThanOrEqual",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if the input is greater than or equal to the required number\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#greaterThanOrEqual",
        "fct-type": "function",
        "title": "greaterThanOrEqual"
      },
      "index": {
        "description": "Matches if the input is greater than or equal to the required number",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "greaterThanOrEqual",
        "normalized": "a-\u003eMatcher a",
        "package": "rematch",
        "partial": "Than Or Equal",
        "signature": "a-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:hasItem",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if any of the items in the input list passes the provided matcher\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher a -\u003e Matcher [a]",
        "fct-source": "src/Control-Rematch.html#hasItem",
        "fct-type": "function",
        "title": "hasItem"
      },
      "index": {
        "description": "Matches if any of the items in the input list passes the provided matcher",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "hasItem",
        "normalized": "Matcher a-\u003eMatcher[a]",
        "package": "rematch",
        "partial": "Item",
        "signature": "Matcher a-\u003eMatcher[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:hasJust",
      "description": {
        "fct-descr": "\u003cp\u003eMatcher combinator, turns Matcher a to Matcher (Maybe a)\n Fails if the Maybe is Nothing, otherwise tries the original\n matcher on the content of the Maybe\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher a -\u003e Matcher (Maybe a)",
        "fct-source": "src/Control-Rematch.html#hasJust",
        "fct-type": "function",
        "title": "hasJust"
      },
      "index": {
        "description": "Matcher combinator turns Matcher to Matcher Maybe Fails if the Maybe is Nothing otherwise tries the original matcher on the content of the Maybe",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "hasJust",
        "normalized": "Matcher a-\u003eMatcher(Maybe a)",
        "package": "rematch",
        "partial": "Just",
        "signature": "Matcher a-\u003eMatcher(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:hasLeft",
      "description": {
        "fct-descr": "\u003cp\u003eMatcher combinator: turns a Matcher a into a Matcher on the\n Left side of an Either a b\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher a -\u003e Matcher (Either a b)",
        "fct-source": "src/Control-Rematch.html#hasLeft",
        "fct-type": "function",
        "title": "hasLeft"
      },
      "index": {
        "description": "Matcher combinator turns Matcher into Matcher on the Left side of an Either",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "hasLeft",
        "normalized": "Matcher a-\u003eMatcher(Either a b)",
        "package": "rematch",
        "partial": "Left",
        "signature": "Matcher a-\u003eMatcher(Either a b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:hasRight",
      "description": {
        "fct-descr": "\u003cp\u003eMatcher combinator: turns a Matcher b into a Matcher on the\n Right side of an Either a b\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher b -\u003e Matcher (Either a b)",
        "fct-source": "src/Control-Rematch.html#hasRight",
        "fct-type": "function",
        "title": "hasRight"
      },
      "index": {
        "description": "Matcher combinator turns Matcher into Matcher on the Right side of an Either",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "hasRight",
        "normalized": "Matcher a-\u003eMatcher(Either b a)",
        "package": "rematch",
        "partial": "Right",
        "signature": "Matcher b-\u003eMatcher(Either a b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:hasSize",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if the input list has the required size\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Int -\u003e Matcher [a]",
        "fct-source": "src/Control-Rematch.html#hasSize",
        "fct-type": "function",
        "title": "hasSize"
      },
      "index": {
        "description": "Matches if the input list has the required size",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "hasSize",
        "normalized": "Int-\u003eMatcher[a]",
        "package": "rematch",
        "partial": "Size",
        "signature": "Int-\u003eMatcher[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:is",
      "description": {
        "fct-descr": "\u003cp\u003eMatcher on equality\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#is",
        "fct-type": "function",
        "title": "is"
      },
      "index": {
        "description": "Matcher on equality",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "is",
        "normalized": "a-\u003eMatcher a",
        "package": "rematch",
        "partial": "",
        "signature": "a-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:isEmpty",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if the input list is empty\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher [a]",
        "fct-source": "src/Control-Rematch.html#isEmpty",
        "fct-type": "function",
        "title": "isEmpty"
      },
      "index": {
        "description": "Matches if the input list is empty",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "isEmpty",
        "normalized": "Matcher[a]",
        "package": "rematch",
        "partial": "Empty",
        "signature": "Matcher[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:isJust",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if the input is (Just a)\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher (Maybe a)",
        "fct-source": "src/Control-Rematch.html#isJust",
        "fct-type": "function",
        "title": "isJust"
      },
      "index": {
        "description": "Matches if the input is Just",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "isJust",
        "normalized": "",
        "package": "rematch",
        "partial": "Just",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:isLeft",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if an Either is Left\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher (Either a b)",
        "fct-source": "src/Control-Rematch.html#isLeft",
        "fct-type": "function",
        "title": "isLeft"
      },
      "index": {
        "description": "Matches if an Either is Left",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "isLeft",
        "normalized": "",
        "package": "rematch",
        "partial": "Left",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:isNot",
      "description": {
        "fct-descr": "\u003cp\u003eInverts a matcher, so success becomes failure, and failure\n becomes success\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher a -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#isNot",
        "fct-type": "function",
        "title": "isNot"
      },
      "index": {
        "description": "Inverts matcher so success becomes failure and failure becomes success",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "isNot",
        "normalized": "Matcher a-\u003eMatcher a",
        "package": "rematch",
        "partial": "Not",
        "signature": "Matcher a-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:isNothing",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if the input is Nothing\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher (Maybe a)",
        "fct-source": "src/Control-Rematch.html#isNothing",
        "fct-type": "function",
        "title": "isNothing"
      },
      "index": {
        "description": "Matches if the input is Nothing",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "isNothing",
        "normalized": "",
        "package": "rematch",
        "partial": "Nothing",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:isRight",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if an Either is Right\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher (Either a b)",
        "fct-source": "src/Control-Rematch.html#isRight",
        "fct-type": "function",
        "title": "isRight"
      },
      "index": {
        "description": "Matches if an Either is Right",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "isRight",
        "normalized": "",
        "package": "rematch",
        "partial": "Right",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:lessThan",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if the input is less than the required number\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#lessThan",
        "fct-type": "function",
        "title": "lessThan"
      },
      "index": {
        "description": "Matches if the input is less than the required number",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "lessThan",
        "normalized": "a-\u003eMatcher a",
        "package": "rematch",
        "partial": "Than",
        "signature": "a-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:lessThanOrEqual",
      "description": {
        "fct-descr": "\u003cp\u003eMatches if the input is less than or equal to the required number\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#lessThanOrEqual",
        "fct-type": "function",
        "title": "lessThanOrEqual"
      },
      "index": {
        "description": "Matches if the input is less than or equal to the required number",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "lessThanOrEqual",
        "normalized": "a-\u003eMatcher a",
        "package": "rematch",
        "partial": "Than Or Equal",
        "signature": "a-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:match",
      "description": {
        "fct-descr": "\u003cp\u003eA function that returns True if the matcher should pass, False if it should fail\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e Bool",
        "fct-source": "src/Control-Rematch.html#Matcher",
        "fct-type": "function",
        "title": "match"
      },
      "index": {
        "description": "function that returns True if the matcher should pass False if it should fail",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "match",
        "normalized": "a-\u003eBool",
        "package": "rematch",
        "partial": "",
        "signature": "a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:matchList",
      "description": {
        "fct-descr": "\u003cp\u003eUtility function for running a list of matchers\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "[Matcher a] -\u003e a -\u003e [Bool]",
        "fct-source": "src/Control-Rematch.html#matchList",
        "fct-type": "function",
        "title": "matchList"
      },
      "index": {
        "description": "Utility function for running list of matchers",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "matchList",
        "normalized": "[Matcher a]-\u003ea-\u003e[Bool]",
        "package": "rematch",
        "partial": "List",
        "signature": "[Matcher a]-\u003ea-\u003e[Bool]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:matcherOn",
      "description": {
        "fct-descr": "\u003cp\u003eBuilds a Matcher a out of a name and a function from (a -\u003e a -\u003e Bool)\n Succeeds if the function returns true, fails if the function returns false\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "String -\u003e (a -\u003e a -\u003e Bool) -\u003e a -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#matcherOn",
        "fct-type": "function",
        "title": "matcherOn"
      },
      "index": {
        "description": "Builds Matcher out of name and function from Bool Succeeds if the function returns true fails if the function returns false",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "matcherOn",
        "normalized": "String-\u003e(a-\u003ea-\u003eBool)-\u003ea-\u003eMatcher a",
        "package": "rematch",
        "partial": "On",
        "signature": "String-\u003e(a-\u003ea-\u003eBool)-\u003ea-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:on",
      "description": {
        "fct-descr": "\u003cp\u003eA combinator that translates Matcher a to Matcher b using\n a function :: (a -\u003e b)\n Takes a name of the function for better error messages\n\u003c/p\u003e\u003cp\u003eUsing this as an infix operator gets you some nice syntax:\n expect ((is 1) \u003ccode\u003e\u003ca\u003eon\u003c/a\u003e\u003c/code\u003e (length, \u003ca\u003elength\u003c/a\u003e)) []\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher b -\u003e (a -\u003e b, String) -\u003e Matcher a",
        "fct-source": "src/Control-Rematch.html#on",
        "fct-type": "function",
        "title": "on"
      },
      "index": {
        "description": "combinator that translates Matcher to Matcher using function Takes name of the function for better error messages Using this as an infix operator gets you some nice syntax expect is on length length",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "on",
        "normalized": "Matcher a-\u003e(b-\u003ea,String)-\u003eMatcher b",
        "package": "rematch",
        "partial": "",
        "signature": "Matcher b-\u003e(a-\u003eb,String)-\u003eMatcher a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:runMatch",
      "description": {
        "fct-descr": "\u003cp\u003eRun a matcher, producing a Match with a good error string\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "Matcher a -\u003e a -\u003e Match",
        "fct-source": "src/Control-Rematch.html#runMatch",
        "fct-type": "function",
        "title": "runMatch"
      },
      "index": {
        "description": "Run matcher producing Match with good error string",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "runMatch",
        "normalized": "Matcher a-\u003ea-\u003eMatch",
        "package": "rematch",
        "partial": "Match",
        "signature": "Matcher a-\u003ea-\u003eMatch"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rematch/docs/Control-Rematch.html#v:standardMismatch",
      "description": {
        "fct-descr": "\u003cp\u003eA standard mismatch description on (Show a):\n standardMismatch 1 == \u003ca\u003ewas 1\u003c/a\u003e\n\u003c/p\u003e",
        "fct-module": "Control.Rematch",
        "fct-package": "rematch",
        "fct-signature": "a -\u003e String",
        "fct-source": "src/Control-Rematch.html#standardMismatch",
        "fct-type": "function",
        "title": "standardMismatch"
      },
      "index": {
        "description": "standard mismatch description on Show standardMismatch was",
        "hierarchy": "Control Rematch",
        "module": "Control.Rematch",
        "name": "standardMismatch",
        "normalized": "a-\u003eString",
        "package": "rematch",
        "partial": "Mismatch",
        "signature": "a-\u003eString"
      }
    }
  }
]
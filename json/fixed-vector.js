[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Boxed.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVector which could hold any value.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed.Boxed",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed-Boxed.html",
        "fct-type": "module",
        "title": "Boxed"
      },
      "index": {
        "description": "Vector which could hold any value",
        "hierarchy": "Data Vector Fixed Boxed",
        "module": "Data.Vector.Fixed.Boxed",
        "name": "Boxed",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Boxed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Boxed.html#t:MVec",
      "description": {
        "fct-descr": "\u003cp\u003eMutable unboxed vector with fixed length\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Boxed",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Boxed.html#MVec",
        "fct-type": "data",
        "title": "MVec"
      },
      "index": {
        "description": "Mutable unboxed vector with fixed length",
        "hierarchy": "Data Vector Fixed Boxed",
        "module": "Data.Vector.Fixed.Boxed",
        "name": "MVec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "MVec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Boxed.html#t:Vec",
      "description": {
        "fct-descr": "\u003cp\u003eVector with fixed length which can hold any value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Boxed",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Boxed.html#Vec",
        "fct-type": "data",
        "title": "Vec"
      },
      "index": {
        "description": "Vector with fixed length which can hold any value",
        "hierarchy": "Data Vector Fixed Boxed",
        "module": "Data.Vector.Fixed.Boxed",
        "name": "Vec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Boxed.html#t:Vec2",
      "description": {
        "fct-module": "Data.Vector.Fixed.Boxed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Boxed.html#Vec2",
        "fct-type": "type",
        "title": "Vec2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Boxed",
        "module": "Data.Vector.Fixed.Boxed",
        "name": "Vec2",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Boxed.html#t:Vec3",
      "description": {
        "fct-module": "Data.Vector.Fixed.Boxed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Boxed.html#Vec3",
        "fct-type": "type",
        "title": "Vec3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Boxed",
        "module": "Data.Vector.Fixed.Boxed",
        "name": "Vec3",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Boxed.html#t:Vec4",
      "description": {
        "fct-module": "Data.Vector.Fixed.Boxed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Boxed.html#Vec4",
        "fct-type": "type",
        "title": "Vec4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Boxed",
        "module": "Data.Vector.Fixed.Boxed",
        "name": "Vec4",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Boxed.html#t:Vec5",
      "description": {
        "fct-module": "Data.Vector.Fixed.Boxed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Boxed.html#Vec5",
        "fct-type": "type",
        "title": "Vec5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Boxed",
        "module": "Data.Vector.Fixed.Boxed",
        "name": "Vec5",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAPI for Church-encoded vectors. Implementation of function from\n \u003ca\u003eData.Vector.Fixed\u003c/a\u003e module uses these function internally in order\n to provide shortcut fusion.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed-Cont.html",
        "fct-type": "module",
        "title": "Cont"
      },
      "index": {
        "description": "API for Church-encoded vectors Implementation of function from Data.Vector.Fixed module uses these function internally in order to provide shortcut fusion",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Cont",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Cont",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:Arity",
      "description": {
        "fct-descr": "\u003cp\u003eType class for handling \u003cem\u003en\u003c/em\u003e-ary functions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Arity",
        "fct-type": "class",
        "title": "Arity"
      },
      "index": {
        "description": "Type class for handling ary functions",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Arity",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Arity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:ContVec",
      "description": {
        "fct-descr": "\u003cp\u003eVector represented as continuation. Alternative wording: it's\n   Church encoded N-element vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#ContVec",
        "fct-type": "newtype",
        "title": "ContVec"
      },
      "index": {
        "description": "Vector represented as continuation Alternative wording it Church encoded N-element vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "ContVec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Cont Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:Dim",
      "description": {
        "fct-descr": "\u003cp\u003eSize of vector expressed as type-level natural.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Dim",
        "fct-type": "function",
        "title": "Dim"
      },
      "index": {
        "description": "Size of vector expressed as type-level natural",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Dim",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Dim",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:Fn",
      "description": {
        "fct-descr": "\u003cp\u003eType family for n-ary functions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fn",
        "fct-type": "function",
        "title": "Fn"
      },
      "index": {
        "description": "Type family for n-ary functions",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Fn",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fn",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:Fun",
      "description": {
        "fct-descr": "\u003cp\u003eNewtype wrapper which is used to make \u003ccode\u003e\u003ca\u003eFn\u003c/a\u003e\u003c/code\u003e injective. It's also a\n   reader monad.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "newtype",
        "title": "Fun"
      },
      "index": {
        "description": "Newtype wrapper which is used to make Fn injective It also reader monad",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Fun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:Index",
      "description": {
        "fct-descr": "\u003cp\u003eType class for indexing of vector when index value is known at\n   compile time.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Index",
        "fct-type": "class",
        "title": "Index"
      },
      "index": {
        "description": "Type class for indexing of vector when index value is known at compile time",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Index",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:N1",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N1",
        "fct-type": "type",
        "title": "N1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "N1",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:N2",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N2",
        "fct-type": "type",
        "title": "N2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "N2",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:N3",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N3",
        "fct-type": "type",
        "title": "N3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "N3",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:N4",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N4",
        "fct-type": "type",
        "title": "N4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "N4",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:N5",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N5",
        "fct-type": "type",
        "title": "N5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "N5",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:N6",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N6",
        "fct-type": "type",
        "title": "N6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "N6",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:S",
      "description": {
        "fct-descr": "\u003cp\u003eSuccessor of n\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#S",
        "fct-type": "data",
        "title": "S"
      },
      "index": {
        "description": "Successor of",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "S",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:Vector",
      "description": {
        "fct-descr": "\u003cp\u003eType class for vectors with fixed length. Instance should provide\n two functions: one to create vector and another for vector\n deconstruction. They must obey following law:\n\u003c/p\u003e\u003cpre\u003e inspect v construct = v\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Vector",
        "fct-type": "class",
        "title": "Vector"
      },
      "index": {
        "description": "Type class for vectors with fixed length Instance should provide two functions one to create vector and another for vector deconstruction They must obey following law inspect construct",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Vector",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:VectorN",
      "description": {
        "fct-descr": "\u003cp\u003eVector parametrized by length. In ideal world it should be:\n\u003c/p\u003e\u003cpre\u003e forall n. (Arity n, Vector (v n) a, Dim (v n) ~ n) =\u003e VectorN v a\n\u003c/pre\u003e\u003cp\u003eAlas polymorphic constraints aren't allowed in haskell.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#VectorN",
        "fct-type": "class",
        "title": "VectorN"
      },
      "index": {
        "description": "Vector parametrized by length In ideal world it should be forall Arity Vector Dim VectorN Alas polymorphic constraints aren allowed in haskell",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "VectorN",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#t:Z",
      "description": {
        "fct-descr": "\u003cp\u003eType level zero\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Z",
        "fct-type": "data",
        "title": "Z"
      },
      "index": {
        "description": "Type level zero",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Z",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:ContVec",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec (forall r.  Fun n a r -\u003e r)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#ContVec",
        "fct-type": "function",
        "title": "ContVec"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "ContVec",
        "normalized": "ContVec(a b Fun c d e-\u003ee)",
        "package": "fixed-vector",
        "partial": "Cont Vec",
        "signature": "ContVec(forall r. Fun n a r-\u003er)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:Fun",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "function",
        "title": "Fun"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "Fun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:accum",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over \u003cem\u003en\u003c/em\u003e elements exposed as n-ary function. These\n   elements are supplied as arguments to the function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "accum",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#accum",
        "fct-type": "method",
        "title": "accum"
      },
      "index": {
        "description": "Left fold over elements exposed as n-ary function These elements are supplied as arguments to the function",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "accum",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003eDetermines whether all elements of vector satisfy predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e Bool) -\u003e ContVec n a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Determines whether all elements of vector satisfy predicate",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eContVec b a-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eContVec n a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003eConjunction of elements of a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "Conjunction of elements of vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "and",
        "normalized": "ContVec a Bool-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec n Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003eDetermines whether any of element of vector satisfy predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e Bool) -\u003e ContVec n a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Determines whether any of element of vector satisfy predicate",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eContVec b a-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eContVec n a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:apFun",
      "description": {
        "fct-descr": "\u003cp\u003eApply single parameter to function\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun (S n) a b -\u003e a -\u003e Fun n a b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#apFun",
        "fct-type": "function",
        "title": "apFun"
      },
      "index": {
        "description": "Apply single parameter to function",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "apFun",
        "normalized": "Fun(S a)b c-\u003eb-\u003eFun a b c",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": "Fun(S n)a b-\u003ea-\u003eFun n a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:apLast",
      "description": {
        "fct-descr": "\u003cp\u003eApply last parameter to function. Unlike \u003ccode\u003e\u003ca\u003eapFun\u003c/a\u003e\u003c/code\u003e we need to\n   traverse all parameters but last hence \u003ccode\u003e\u003ca\u003eArity\u003c/a\u003e\u003c/code\u003e constraint.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun (S n) a b -\u003e a -\u003e Fun n a b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#apLast",
        "fct-type": "function",
        "title": "apLast"
      },
      "index": {
        "description": "Apply last parameter to function Unlike apFun we need to traverse all parameters but last hence Arity constraint",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "apLast",
        "normalized": "Fun(S a)b c-\u003eb-\u003eFun a b c",
        "package": "fixed-vector",
        "partial": "Last",
        "signature": "Fun(S n)a b-\u003ea-\u003eFun n a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:apply",
      "description": {
        "fct-descr": "\u003cp\u003eApply all parameters to the function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(forall k.  t (S k) -\u003e (a, t k))-\u003e t n-\u003e Fn n a b-\u003e b",
        "fct-type": "function",
        "title": "apply"
      },
      "index": {
        "description": "Apply all parameters to the function",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "apply",
        "normalized": "(a b c(S d)-\u003e(e,c d))-\u003ec f-\u003eFn f e g-\u003eg",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(forall k. t(S k)-\u003e(a,t k))-\u003et n-\u003eFn n a b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:applyFun",
      "description": {
        "fct-descr": "\u003cp\u003eApply all parameters to the function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "applyFun",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#applyFun",
        "fct-type": "method",
        "title": "applyFun"
      },
      "index": {
        "description": "Apply all parameters to the function",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "applyFun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:applyFunM",
      "description": {
        "fct-descr": "\u003cp\u003eApply all parameters to the function using monadic\n   actions. Note that for identity monad it's same as\n   applyFun. Ignoring newtypes:\n\u003c/p\u003e\u003cpre\u003e forall b. Fn n a b -\u003e b  ~ ContVecn n a\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "applyFunM",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#applyFunM",
        "fct-type": "method",
        "title": "applyFunM"
      },
      "index": {
        "description": "Apply all parameters to the function using monadic actions Note that for identity monad it same as applyFun Ignoring newtypes forall Fn ContVecn",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "applyFunM",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:applyM",
      "description": {
        "fct-descr": "\u003cp\u003eApply all parameters to the function using monadic actions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(forall k.  t (S k) -\u003e m (a, t k))-\u003e t n-\u003e m (ContVec n a)",
        "fct-type": "function",
        "title": "applyM"
      },
      "index": {
        "description": "Apply all parameters to the function using monadic actions",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "applyM",
        "normalized": "(a b c(S d)-\u003ee(f,c d))-\u003ec g-\u003ee(ContVec g f)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(forall k. t(S k)-\u003em(a,t k))-\u003et n-\u003em(ContVec n a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:arity",
      "description": {
        "fct-descr": "\u003cp\u003eArity of function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "n -\u003e Int",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#arity",
        "fct-type": "method",
        "title": "arity"
      },
      "index": {
        "description": "Arity of function",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "arity",
        "normalized": "a-\u003eInt",
        "package": "fixed-vector",
        "partial": "",
        "signature": "n-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:basicIndex",
      "description": {
        "fct-descr": "\u003cp\u003eOptional more efficient implementation of indexing. Shouldn't\n   be used directly, use \u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#basicIndex",
        "fct-type": "method",
        "title": "basicIndex"
      },
      "index": {
        "description": "Optional more efficient implementation of indexing Shouldn be used directly use instead",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "basicIndex",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "fixed-vector",
        "partial": "Index",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:basis",
      "description": {
        "fct-descr": "\u003cp\u003eUnit vector along Nth axis.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Int -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#basis",
        "fct-type": "function",
        "title": "basis"
      },
      "index": {
        "description": "Unit vector along Nth axis",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "basis",
        "normalized": "Int-\u003eContVec a b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "Int-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:collect",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e ContVec n b) -\u003e f a -\u003e ContVec n (f b)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#collect",
        "fct-type": "function",
        "title": "collect"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "collect",
        "normalized": "(a-\u003eContVec b c)-\u003ed a-\u003eContVec b(d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eContVec n b)-\u003ef a-\u003eContVec n(f b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:collectM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e ContVec n b) -\u003e m a -\u003e ContVec n (m b)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#collectM",
        "fct-type": "function",
        "title": "collectM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "collectM",
        "normalized": "(a-\u003eContVec b c)-\u003ed a-\u003eContVec b(d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eContVec n b)-\u003em a-\u003eContVec n(m b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Prepend element to vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e ContVec n a -\u003e ContVec (S n) a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend element to vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "cons",
        "normalized": "a-\u003eContVec b a-\u003eContVec(S b)a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003eContVec n a-\u003eContVec(S n)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:consV",
      "description": {
        "fct-descr": "\u003cp\u003ePrepend single element to vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "forall n a.  ContVec (S Z) a -\u003e ContVec n a -\u003e ContVec (S n) a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#consV",
        "fct-type": "function",
        "title": "consV"
      },
      "index": {
        "description": "Prepend single element to vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "consV",
        "normalized": "a b c ContVec(S Z)d-\u003eContVec b d-\u003eContVec(S b)d",
        "package": "fixed-vector",
        "partial": "",
        "signature": "forall n a. ContVec(S Z)a-\u003eContVec n a-\u003eContVec(S n)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:constFun",
      "description": {
        "fct-descr": "\u003cp\u003eAdd one parameter to function which is ignored.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun n a b -\u003e Fun (S n) a b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#constFun",
        "fct-type": "function",
        "title": "constFun"
      },
      "index": {
        "description": "Add one parameter to function which is ignored",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "constFun",
        "normalized": "Fun a b c-\u003eFun(S a)b c",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": "Fun n a b-\u003eFun(S n)a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:construct",
      "description": {
        "fct-descr": "\u003cp\u003eN-ary function for creation of vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun (Dim v) a (v a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#construct",
        "fct-type": "method",
        "title": "construct"
      },
      "index": {
        "description": "N-ary function for creation of vectors",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "construct",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:cvec",
      "description": {
        "fct-descr": "\u003cp\u003eConvert regular vector to continuation based one.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#cvec",
        "fct-type": "function",
        "title": "cvec"
      },
      "index": {
        "description": "Convert regular vector to continuation based one",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "cvec",
        "normalized": "a b-\u003eContVec c b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:distribute",
      "description": {
        "fct-descr": "\u003cp\u003eThe dual of sequenceA\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "f (ContVec n a) -\u003e ContVec n (f a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#distribute",
        "fct-type": "function",
        "title": "distribute"
      },
      "index": {
        "description": "The dual of sequenceA",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "distribute",
        "normalized": "a(ContVec b c)-\u003eContVec b(a c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "f(ContVec n a)-\u003eContVec n(f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:distributeM",
      "description": {
        "fct-descr": "\u003cp\u003eThe dual of sequence\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "m (ContVec n a) -\u003e ContVec n (m a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#distributeM",
        "fct-type": "function",
        "title": "distributeM"
      },
      "index": {
        "description": "The dual of sequence",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "distributeM",
        "normalized": "a(ContVec b c)-\u003eContVec b(a c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "m(ContVec n a)-\u003eContVec n(m a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:element",
      "description": {
        "fct-descr": "\u003cp\u003eTwan van Laarhoven lens for continuation based vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Int -\u003e (a -\u003e f a) -\u003e ContVec n a -\u003e f (ContVec n a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#element",
        "fct-type": "function",
        "title": "element"
      },
      "index": {
        "description": "Twan van Laarhoven lens for continuation based vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "element",
        "normalized": "Int-\u003e(a-\u003eb a)-\u003eContVec c a-\u003eb(ContVec c a)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ef a)-\u003eContVec n a-\u003ef(ContVec n a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:elementTy",
      "description": {
        "fct-descr": "\u003cp\u003eTwan van Laarhoven's lens for element of vector with statically\n   known index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "k -\u003e (a -\u003e f a) -\u003e ContVec n a -\u003e f (ContVec n a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#elementTy",
        "fct-type": "function",
        "title": "elementTy"
      },
      "index": {
        "description": "Twan van Laarhoven lens for element of vector with statically known index",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "elementTy",
        "normalized": "a-\u003e(b-\u003ec b)-\u003eContVec d b-\u003ec(ContVec d b)",
        "package": "fixed-vector",
        "partial": "Ty",
        "signature": "k-\u003e(a-\u003ef a)-\u003eContVec n a-\u003ef(ContVec n a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003eCreate empty vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec Z a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Create empty vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "empty",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic left fold over continuation vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e a -\u003e m b) -\u003e b -\u003e ContVec n a -\u003e m b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic left fold over continuation vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eContVec d b-\u003ec a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003ea-\u003em b)-\u003eb-\u003eContVec n a-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over continuation vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e a -\u003e b) -\u003e b -\u003e ContVec n a -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold over continuation vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eContVec c b-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003ea-\u003eb)-\u003eb-\u003eContVec n a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e ContVec (S n) a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eContVec(S b)a-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eContVec(S n)a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold over continuation vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e ContVec n a -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold over continuation vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eContVec c a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eContVec n a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert list to continuation-based vector. Will throw error if\n   list is shorter than resulting vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "[a] -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to continuation-based vector Will throw error if list is shorter than resulting vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "fromList",
        "normalized": "[a]-\u003eContVec b a",
        "package": "fixed-vector",
        "partial": "List",
        "signature": "[a]-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:fromList-39-",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e bu throws error is list doesn't have same\n   length as vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "[a] -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#fromList%27",
        "fct-type": "function",
        "title": "fromList'"
      },
      "index": {
        "description": "Same as fromList bu throws error is list doesn have same length as vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "fromList'",
        "normalized": "[a]-\u003eContVec b a",
        "package": "fixed-vector",
        "partial": "List'",
        "signature": "[a]-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:fromListM",
      "description": {
        "fct-descr": "\u003cp\u003eConvert list to continuation-based vector. Will fail with\n   \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if list doesn't have right length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "[a] -\u003e Maybe (ContVec n a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#fromListM",
        "fct-type": "function",
        "title": "fromListM"
      },
      "index": {
        "description": "Convert list to continuation-based vector Will fail with Nothing if list doesn have right length",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "fromListM",
        "normalized": "[a]-\u003eMaybe(ContVec b a)",
        "package": "fixed-vector",
        "partial": "List",
        "signature": "[a]-\u003eMaybe(ContVec n a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate vector from function which maps element's index to its value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a) -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Generate vector from function which maps element index to its value",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "generate",
        "normalized": "(Int-\u003ea)-\u003eContVec b a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea)-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate vector from monadic function which maps element's index\n   to its value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e m a) -\u003e m (ContVec n a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Generate vector from monadic function which maps element index to its value",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "generateM",
        "normalized": "(Int-\u003ea b)-\u003ea(ContVec c b)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003em a)-\u003em(ContVec n a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:getF",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "k -\u003e Fun n a a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#getF",
        "fct-type": "method",
        "title": "getF"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "getF",
        "normalized": "a-\u003eFun b c c",
        "package": "fixed-vector",
        "partial": "",
        "signature": "k-\u003eFun n a a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:gfoldl",
      "description": {
        "fct-descr": "\u003cp\u003eGeneric \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e which could work with any vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "c (x -\u003e y) -\u003e x -\u003e c y) -\u003e (forall x.  x -\u003e c x) -\u003e v a -\u003e c (v a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#gfoldl",
        "fct-type": "function",
        "title": "gfoldl"
      },
      "index": {
        "description": "Generic gfoldl which could work with any vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "gfoldl",
        "normalized": "a(b-\u003ec)-\u003eb-\u003ea c)-\u003e(d e b-\u003ea b)-\u003ef g-\u003ea(f g)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "c(x-\u003ey)-\u003ex-\u003ec y)-\u003e(forall x. x-\u003ec x)-\u003ev a-\u003ec(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:gunfold",
      "description": {
        "fct-descr": "\u003cp\u003eGeneric \u003ccode\u003e\u003ca\u003egunfoldl\u003c/a\u003e\u003c/code\u003e which could work with any\n   vector. Since vector can only have one constructor argument for\n   constructor is ignored.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "c (b -\u003e r) -\u003e c r) -\u003e (forall r.  r -\u003e c r) -\u003e con -\u003e c (v a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#gunfold",
        "fct-type": "function",
        "title": "gunfold"
      },
      "index": {
        "description": "Generic gunfoldl which could work with any vector Since vector can only have one constructor argument for constructor is ignored",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "gunfold",
        "normalized": "a(b-\u003ec)-\u003ea c)-\u003e(d e c-\u003ea c)-\u003ef-\u003ea(g h)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "c(b-\u003er)-\u003ec r)-\u003e(forall r. r-\u003ec r)-\u003econ-\u003ec(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:gunfoldF",
      "description": {
        "fct-descr": "\u003cp\u003eWorker function for \u003ccode\u003e\u003ca\u003egunfold\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "c (b -\u003e x) -\u003e c x) -\u003e T_gunfold c r a n -\u003e c r",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#gunfoldF",
        "fct-type": "method",
        "title": "gunfoldF"
      },
      "index": {
        "description": "Worker function for gunfold",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "gunfoldF",
        "normalized": "a(b-\u003ec)-\u003ea c)-\u003eT_gunfold a d e f-\u003ea d",
        "package": "fixed-vector",
        "partial": "",
        "signature": "c(b-\u003ex)-\u003ec x)-\u003eT_gunfold c r a n-\u003ec r"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003eFinalizer function for getting head of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec (S n) a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "Finalizer function for getting head of the vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "head",
        "normalized": "ContVec(S a)b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec(S n)a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:hideLast",
      "description": {
        "fct-descr": "\u003cp\u003eMove last parameter into function result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun (S n) a b -\u003e Fun n a (a -\u003e b)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#hideLast",
        "fct-type": "function",
        "title": "hideLast"
      },
      "index": {
        "description": "Move last parameter into function result",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "hideLast",
        "normalized": "Fun(S a)b c-\u003eFun a b(b-\u003ec)",
        "package": "fixed-vector",
        "partial": "Last",
        "signature": "Fun(S n)a b-\u003eFun n a(a-\u003eb)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:ifoldM",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic left fold over continuation vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e Int -\u003e a -\u003e m b) -\u003e b -\u003e ContVec n a -\u003e m b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#ifoldM",
        "fct-type": "function",
        "title": "ifoldM"
      },
      "index": {
        "description": "Monadic left fold over continuation vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "ifoldM",
        "normalized": "(a-\u003eInt-\u003eb-\u003ec a)-\u003ea-\u003eContVec d b-\u003ec a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003eInt-\u003ea-\u003em b)-\u003eb-\u003eContVec n a-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over continuation vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e Int -\u003e a -\u003e b) -\u003e b -\u003e ContVec n a -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold over continuation vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eContVec c b-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003eInt-\u003ea-\u003eb)-\u003eb-\u003eContVec n a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold over continuation vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e ContVec n a -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Right fold over continuation vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eContVec c a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eContVec n a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003eApply function to every element of the vector and its index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e ContVec n a -\u003e ContVec n b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of the vector and its index",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003eb)-\u003eContVec c a-\u003eContVec c b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003eContVec n a-\u003eContVec n b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:imapM",
      "description": {
        "fct-descr": "\u003cp\u003eApply monadic function to every element of the vector and its index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e m b) -\u003e ContVec n a -\u003e m (ContVec n b)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#imapM",
        "fct-type": "function",
        "title": "imapM"
      },
      "index": {
        "description": "Apply monadic function to every element of the vector and its index",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "imapM",
        "normalized": "(Int-\u003ea-\u003eb c)-\u003eContVec d a-\u003eb(ContVec d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003em b)-\u003eContVec n a-\u003em(ContVec n b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:imapM_",
      "description": {
        "fct-descr": "\u003cp\u003eApply monadic action to each element of vector and its index and\n   ignore result.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e m b) -\u003e ContVec n a -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#imapM_",
        "fct-type": "function",
        "title": "imapM_"
      },
      "index": {
        "description": "Apply monadic action to each element of vector and its index and ignore result",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "imapM_",
        "normalized": "(Int-\u003ea-\u003eb c)-\u003eContVec d a-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003em b)-\u003eContVec n a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:index",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Get value at specified index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Int -\u003e ContVec n a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#index",
        "fct-type": "function",
        "title": "index"
      },
      "index": {
        "description": "Get value at specified index",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "index",
        "normalized": "Int-\u003eContVec a b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "Int-\u003eContVec n a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:inspect",
      "description": {
        "fct-descr": "\u003cp\u003eDeconstruction of vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Fun (Dim v) a b -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#inspect",
        "fct-type": "method",
        "title": "inspect"
      },
      "index": {
        "description": "Deconstruction of vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "inspect",
        "normalized": "a b-\u003eFun(Dim a)b c-\u003ec",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003eFun(Dim v)a b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using function which takes element index\n   as well.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e ContVec n a -\u003e ContVec n b -\u003e ContVec n c",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "Zip two vector together using function which takes element index as well",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003eContVec d a-\u003eContVec d b-\u003eContVec d c",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003eContVec n a-\u003eContVec n b-\u003eContVec n c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:izipWithM",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using monadic function which takes element\n   index as well..\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e m c) -\u003e ContVec n a -\u003e ContVec n b -\u003e m (ContVec n c)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#izipWithM",
        "fct-type": "function",
        "title": "izipWithM"
      },
      "index": {
        "description": "Zip two vector together using monadic function which takes element index as well",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "izipWithM",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec d)-\u003eContVec e a-\u003eContVec e b-\u003ec(ContVec e d)",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003em c)-\u003eContVec n a-\u003eContVec n b-\u003em(ContVec n c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of vector. Function doesn't evaluate its argument.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of vector Function doesn evaluate its argument",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "length",
        "normalized": "a b-\u003eInt",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:lensF",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "k -\u003e (a -\u003e f a) -\u003e Fun n a r -\u003e Fun n a (f r)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#lensF",
        "fct-type": "method",
        "title": "lensF"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "lensF",
        "normalized": "a-\u003e(b-\u003ec b)-\u003eFun d b e-\u003eFun d b(c e)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "k-\u003e(a-\u003ef a)-\u003eFun n a r-\u003eFun n a(f r)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003eMap over vector. Synonym for \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b) -\u003e ContVec n a -\u003e ContVec n b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map over vector Synonym for fmap",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003eContVec c a-\u003eContVec c b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eContVec n a-\u003eContVec n b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic map over vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e m b) -\u003e ContVec n a -\u003e m (ContVec n b)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Monadic map over vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003eContVec d a-\u003eb(ContVec d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eContVec n a-\u003em(ContVec n b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003eApply monadic action to each element of vector and ignore result.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e m b) -\u003e ContVec n a -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply monadic action to each element of vector and ignore result",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003eContVec d a-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eContVec n a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003eMaximal element of vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec (S n) a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Maximal element of vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "maximum",
        "normalized": "ContVec(S a)b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec(S n)a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003eMinimal element of vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec (S n) a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Minimal element of vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "minimum",
        "normalized": "ContVec(S a)b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec(S n)a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:mk1",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e ContVec N1 a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#mk1",
        "fct-type": "function",
        "title": "mk1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "mk1",
        "normalized": "a-\u003eContVec N a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003eContVec N a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:mk2",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e ContVec N2 a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#mk2",
        "fct-type": "function",
        "title": "mk2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "mk2",
        "normalized": "a-\u003ea-\u003eContVec N a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003eContVec N a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:mk3",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e ContVec N3 a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#mk3",
        "fct-type": "function",
        "title": "mk3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "mk3",
        "normalized": "a-\u003ea-\u003ea-\u003eContVec N a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003eContVec N a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:mk4",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e a -\u003e ContVec N4 a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#mk4",
        "fct-type": "function",
        "title": "mk4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "mk4",
        "normalized": "a-\u003ea-\u003ea-\u003ea-\u003eContVec N a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003ea-\u003eContVec N a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:mk5",
      "description": {
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e ContVec N5 a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#mk5",
        "fct-type": "function",
        "title": "mk5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "mk5",
        "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eContVec N a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eContVec N a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003eDisjunction of all elements of a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "Disjunction of all elements of vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "or",
        "normalized": "ContVec a Bool-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec n Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eExecute monadic action for every element of vector. Synonym for \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Execute monadic action for every element of vector Synonym for pure",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "replicate",
        "normalized": "a-\u003eContVec b a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eExecute monadic action for every element of vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "m a -\u003e m (ContVec n a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute monadic action for every element of vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "replicateM",
        "normalized": "a b-\u003ea(ContVec c b)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "m a-\u003em(ContVec n a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003eReverse order of elements in the vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n a -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse order of elements in the vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "reverse",
        "normalized": "ContVec a b-\u003eContVec a b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec n a-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:reverseF",
      "description": {
        "fct-descr": "\u003cp\u003eReverse order of parameters.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun n a b -\u003e Fun n a b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#reverseF",
        "fct-type": "method",
        "title": "reverseF"
      },
      "index": {
        "description": "Reverse order of parameters",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "reverseF",
        "normalized": "Fun a b c-\u003eFun a b c",
        "package": "fixed-vector",
        "partial": "",
        "signature": "Fun n a b-\u003eFun n a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:runContVec",
      "description": {
        "fct-descr": "\u003cp\u003eRun continuation vector. It's same as \u003ccode\u003e\u003ca\u003einspect\u003c/a\u003e\u003c/code\u003e but with\n   arguments flipped.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun n a r -\u003e ContVec n a -\u003e r",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#runContVec",
        "fct-type": "function",
        "title": "runContVec"
      },
      "index": {
        "description": "Run continuation vector It same as inspect but with arguments flipped",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "runContVec",
        "normalized": "Fun a b c-\u003eContVec a b-\u003ec",
        "package": "fixed-vector",
        "partial": "Cont Vec",
        "signature": "Fun n a r-\u003eContVec n a-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:sequence",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate every action in the vector from left to right.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n (m a) -\u003e m (ContVec n a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#sequence",
        "fct-type": "function",
        "title": "sequence"
      },
      "index": {
        "description": "Evaluate every action in the vector from left to right",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "sequence",
        "normalized": "ContVec a(b c)-\u003eb(ContVec a c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec n(m a)-\u003em(ContVec n a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:sequence_",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate every action in the vector from left to right and ignore result.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n (m a) -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#sequence_",
        "fct-type": "function",
        "title": "sequence_"
      },
      "index": {
        "description": "Evaluate every action in the vector from left to right and ignore result",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "sequence_",
        "normalized": "ContVec a(b c)-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec n(m a)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:shuffleFun",
      "description": {
        "fct-descr": "\u003cp\u003eMove function parameter to the result of N-ary function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e Fun n a r) -\u003e Fun n a (b -\u003e r)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#shuffleFun",
        "fct-type": "function",
        "title": "shuffleFun"
      },
      "index": {
        "description": "Move function parameter to the result of N-ary function",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "shuffleFun",
        "normalized": "(a-\u003eFun b c d)-\u003eFun b c(a-\u003ed)",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": "(b-\u003eFun n a r)-\u003eFun n a(b-\u003er)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Append element to vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e ContVec n a -\u003e ContVec (S n) a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append element to vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "snoc",
        "normalized": "a-\u003eContVec b a-\u003eContVec(S b)a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003eContVec n a-\u003eContVec(S n)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003eSum all elements in the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "Sum all elements in the vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "sum",
        "normalized": "ContVec a b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec n a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Tail of vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec (S n) a -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Tail of vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "tail",
        "normalized": "ContVec(S a)b-\u003eContVec a b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec(S n)a-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert vector to the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n a -\u003e [a]",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to the list",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "toList",
        "normalized": "ContVec a b-\u003e[b]",
        "package": "fixed-vector",
        "partial": "List",
        "signature": "ContVec n a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:unFun",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "Fn n a b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "function",
        "title": "unFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "unFun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003eUnfold vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e (a, b)) -\u003e b -\u003e ContVec n a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Unfold vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "unfoldr",
        "normalized": "(a-\u003e(b,a))-\u003ea-\u003eContVec c b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003e(a,b))-\u003eb-\u003eContVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:vector",
      "description": {
        "fct-descr": "\u003cp\u003eConvert continuation to the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#vector",
        "fct-type": "function",
        "title": "vector"
      },
      "index": {
        "description": "Convert continuation to the vector",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "vector",
        "normalized": "ContVec a b-\u003ec b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec n a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e ContVec n a -\u003e ContVec n b -\u003e ContVec n c",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "Zip two vector together using function",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003eContVec d a-\u003eContVec d b-\u003eContVec d c",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eContVec n a-\u003eContVec n b-\u003eContVec n c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Cont.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using monadic function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Cont",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e ContVec n a -\u003e ContVec n b -\u003e m (ContVec n c)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "Zip two vector together using monadic function",
        "hierarchy": "Data Vector Fixed Cont",
        "module": "Data.Vector.Fixed.Cont",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eContVec e a-\u003eContVec e b-\u003ec(ContVec e d)",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eContVec n a-\u003eContVec n b-\u003em(ContVec n c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMore generic version of function from \u003ca\u003eData.Vector.Fixed\u003c/a\u003e\n module. They do not require that all vector have same type, only\n same length. All such functions have suffix \u003cem\u003eG\u003c/em\u003e.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed-Generic.html",
        "fct-type": "module",
        "title": "Generic"
      },
      "index": {
        "description": "More generic version of function from Data.Vector.Fixed module They do not require that all vector have same type only same length All such functions have suffix",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "Generic",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Generic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#v:imapG",
      "description": {
        "fct-descr": "\u003cp\u003eApply function to every element of the vector and its index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e v a -\u003e w b",
        "fct-source": "src/Data-Vector-Fixed-Generic.html#imapG",
        "fct-type": "function",
        "title": "imapG"
      },
      "index": {
        "description": "Apply function to every element of the vector and its index",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "imapG",
        "normalized": "(Int-\u003ea-\u003eb)-\u003ec a-\u003ed b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003ev a-\u003ew b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#v:imapMG",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic map over vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e m b) -\u003e v a -\u003e m (w b)",
        "fct-source": "src/Data-Vector-Fixed-Generic.html#imapMG",
        "fct-type": "function",
        "title": "imapMG"
      },
      "index": {
        "description": "Monadic map over vector",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "imapMG",
        "normalized": "(Int-\u003ea-\u003eb c)-\u003ed a-\u003eb(e c)",
        "package": "fixed-vector",
        "partial": "MG",
        "signature": "(Int-\u003ea-\u003em b)-\u003ev a-\u003em(w b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#v:izipWithG",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using function which takes element index\n   as well.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e v a -\u003e w b -\u003e u c",
        "fct-source": "src/Data-Vector-Fixed-Generic.html#izipWithG",
        "fct-type": "function",
        "title": "izipWithG"
      },
      "index": {
        "description": "Zip two vector together using function which takes element index as well",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "izipWithG",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003ed a-\u003ee b-\u003ef c",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003ev a-\u003ew b-\u003eu c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#v:izipWithMG",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using monadic function which takes element\n   index as well..\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e m c) -\u003e v a -\u003e w b -\u003e m (u c)",
        "fct-source": "src/Data-Vector-Fixed-Generic.html#izipWithMG",
        "fct-type": "function",
        "title": "izipWithMG"
      },
      "index": {
        "description": "Zip two vector together using monadic function which takes element index as well",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "izipWithMG",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec d)-\u003ee a-\u003ef b-\u003ec(g d)",
        "package": "fixed-vector",
        "partial": "With MG",
        "signature": "(Int-\u003ea-\u003eb-\u003em c)-\u003ev a-\u003ew b-\u003em(u c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#v:mapG",
      "description": {
        "fct-descr": "\u003cp\u003eMap over vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b) -\u003e v a -\u003e w b",
        "fct-source": "src/Data-Vector-Fixed-Generic.html#mapG",
        "fct-type": "function",
        "title": "mapG"
      },
      "index": {
        "description": "Map over vector",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "mapG",
        "normalized": "(a-\u003eb)-\u003ec a-\u003ed b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003ev a-\u003ew b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#v:mapMG",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic map over vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e m b) -\u003e v a -\u003e m (w b)",
        "fct-source": "src/Data-Vector-Fixed-Generic.html#mapMG",
        "fct-type": "function",
        "title": "mapMG"
      },
      "index": {
        "description": "Monadic map over vector",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "mapMG",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(e c)",
        "package": "fixed-vector",
        "partial": "MG",
        "signature": "(a-\u003em b)-\u003ev a-\u003em(w b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#v:zipWithG",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e v a -\u003e w b -\u003e u c",
        "fct-source": "src/Data-Vector-Fixed-Generic.html#zipWithG",
        "fct-type": "function",
        "title": "zipWithG"
      },
      "index": {
        "description": "Zip two vector together using function",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "zipWithG",
        "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ee b-\u003ef c",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003ev a-\u003ew b-\u003eu c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Generic.html#v:zipWithMG",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using monadic function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Generic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e v a -\u003e w b -\u003e m (u c)",
        "fct-source": "src/Data-Vector-Fixed-Generic.html#zipWithMG",
        "fct-type": "function",
        "title": "zipWithMG"
      },
      "index": {
        "description": "Zip two vector together using monadic function",
        "hierarchy": "Data Vector Fixed Generic",
        "module": "Data.Vector.Fixed.Generic",
        "name": "zipWithMG",
        "normalized": "(a-\u003eb-\u003ec d)-\u003ee a-\u003ef b-\u003ec(g d)",
        "package": "fixed-vector",
        "partial": "With MG",
        "signature": "(a-\u003eb-\u003em c)-\u003ev a-\u003ew b-\u003em(u c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWrapper function for working with monomorphic vectors. Standard API\n require vector to be parametric in their element type making it\n impossible to work with vectors like\n\u003c/p\u003e\u003cpre\u003e data Vec3 = Vec3 Double Double Double\n\u003c/pre\u003e\u003cp\u003eThis module provides newtype wrapper which allows use of functions\n from \u003ca\u003eData.Vector.Fixed\u003c/a\u003e with such data types and function which\n works with such vectors.\n\u003c/p\u003e\u003cp\u003eFunctions have same meaning as ones from \u003ca\u003eData.Vector.Fixed\u003c/a\u003e and\n documented there.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html",
        "fct-type": "module",
        "title": "Monomorphic"
      },
      "index": {
        "description": "Wrapper function for working with monomorphic vectors Standard API require vector to be parametric in their element type making it impossible to work with vectors like data Vec3 Vec3 Double Double Double This module provides newtype wrapper which allows use of functions from Data.Vector.Fixed with such data types and function which works with such vectors Functions have same meaning as ones from Data.Vector.Fixed and documented there",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "Monomorphic",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Monomorphic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:Arity",
      "description": {
        "fct-descr": "\u003cp\u003eType class for handling \u003cem\u003en\u003c/em\u003e-ary functions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Arity",
        "fct-type": "class",
        "title": "Arity"
      },
      "index": {
        "description": "Type class for handling ary functions",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "Arity",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Arity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:DimMono",
      "description": {
        "fct-descr": "\u003cp\u003eDimensions of monomorphic vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "DimMono",
        "fct-type": "function",
        "title": "DimMono"
      },
      "index": {
        "description": "Dimensions of monomorphic vector",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "DimMono",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Dim Mono",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:Fun",
      "description": {
        "fct-descr": "\u003cp\u003eNewtype wrapper which is used to make \u003ccode\u003e\u003ca\u003eFn\u003c/a\u003e\u003c/code\u003e injective. It's also a\n   reader monad.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "newtype",
        "title": "Fun"
      },
      "index": {
        "description": "Newtype wrapper which is used to make Fn injective It also reader monad",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "Fun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:N1",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N1",
        "fct-type": "type",
        "title": "N1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "N1",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:N2",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N2",
        "fct-type": "type",
        "title": "N2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "N2",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:N3",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N3",
        "fct-type": "type",
        "title": "N3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "N3",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:N4",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N4",
        "fct-type": "type",
        "title": "N4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "N4",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:N5",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N5",
        "fct-type": "type",
        "title": "N5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "N5",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:N6",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N6",
        "fct-type": "type",
        "title": "N6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "N6",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:S",
      "description": {
        "fct-descr": "\u003cp\u003eSuccessor of n\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#S",
        "fct-type": "data",
        "title": "S"
      },
      "index": {
        "description": "Successor of",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "S",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:VectorMono",
      "description": {
        "fct-descr": "\u003cp\u003eCounterpart of \u003ccode\u003eVector\u003c/code\u003e type class for monomorphic vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#VectorMono",
        "fct-type": "class",
        "title": "VectorMono"
      },
      "index": {
        "description": "Counterpart of Vector type class for monomorphic vectors",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "VectorMono",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vector Mono",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#t:Z",
      "description": {
        "fct-descr": "\u003cp\u003eType level zero\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Z",
        "fct-type": "data",
        "title": "Z"
      },
      "index": {
        "description": "Type level zero",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "Z",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:-33-",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "(!) !",
        "normalized": "a-\u003eInt-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:Fun",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "function",
        "title": "Fun"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "Fun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:all",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eb-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:and",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "and",
        "normalized": "a-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:any",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eb-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:basicIndex",
      "description": {
        "fct-descr": "\u003cp\u003eOptional more efficient implementation of indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e Int -\u003e VectorElm v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#basicIndex",
        "fct-type": "method",
        "title": "basicIndex"
      },
      "index": {
        "description": "Optional more efficient implementation of indexing",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "basicIndex",
        "normalized": "a-\u003eInt-\u003eVectorElm a",
        "package": "fixed-vector",
        "partial": "Index",
        "signature": "v-\u003eInt-\u003eVectorElm v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:basis",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "Int -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#basis",
        "fct-type": "function",
        "title": "basis"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "basis",
        "normalized": "Int-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "Int-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:construct",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun (DimMono v) (VectorElm v) v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#construct",
        "fct-type": "method",
        "title": "construct"
      },
      "index": {
        "description": "Construct vector",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "construct",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:convert",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e w",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "convert",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003ew"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:eq",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e v -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#eq",
        "fct-type": "function",
        "title": "eq"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "eq",
        "normalized": "a-\u003ea-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003ev-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:fold",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e VectorElm v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#fold",
        "fct-type": "function",
        "title": "fold"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "fold",
        "normalized": "a-\u003eVectorElm a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003eVectorElm v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:foldM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e a -\u003e m b) -\u003e b -\u003e v -\u003e m b",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed-\u003ec a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003ea-\u003em b)-\u003eb-\u003ev-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:foldMap",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(VectorElm v -\u003e m) -\u003e v -\u003e m",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#foldMap",
        "fct-type": "function",
        "title": "foldMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "foldMap",
        "normalized": "(VectorElm a-\u003eb)-\u003ea-\u003eb",
        "package": "fixed-vector",
        "partial": "Map",
        "signature": "(VectorElm v-\u003em)-\u003ev-\u003em"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:foldl",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e a -\u003e b) -\u003e b -\u003e v -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003ea-\u003eb)-\u003eb-\u003ev-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:foldl1",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:foldr",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:fromList",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "[a] -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "fromList",
        "normalized": "[a]-\u003eb",
        "package": "fixed-vector",
        "partial": "List",
        "signature": "[a]-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:generate",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a) -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "generate",
        "normalized": "(Int-\u003ea)-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea)-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:generateM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e m a) -\u003e m v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "generateM",
        "normalized": "(Int-\u003ea b)-\u003ea c",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003em a)-\u003em v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:head",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "head",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:ifoldM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e Int -\u003e a -\u003e m b) -\u003e b -\u003e v -\u003e m b",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#ifoldM",
        "fct-type": "function",
        "title": "ifoldM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "ifoldM",
        "normalized": "(a-\u003eInt-\u003eb-\u003ec a)-\u003ea-\u003ed-\u003ec a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003eInt-\u003ea-\u003em b)-\u003eb-\u003ev-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:ifoldl",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e Int -\u003e a -\u003e b) -\u003e b -\u003e v -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ec-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003eInt-\u003ea-\u003eb)-\u003eb-\u003ev-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:ifoldr",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e v -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ev-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:imap",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e a) -\u003e v -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003ea)-\u003eb-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003ea)-\u003ev-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:imapM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e m a) -\u003e v -\u003e m v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#imapM",
        "fct-type": "function",
        "title": "imapM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "imapM",
        "normalized": "(Int-\u003ea-\u003eb a)-\u003ec-\u003eb c",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003em a)-\u003ev-\u003em v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:imapM_",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e m b) -\u003e v -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#imapM_",
        "fct-type": "function",
        "title": "imapM_"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "imapM_",
        "normalized": "(Int-\u003ea-\u003eb c)-\u003ed-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003em b)-\u003ev-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:inspect",
      "description": {
        "fct-descr": "\u003cp\u003eInspect vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e Fun (DimMono v) (VectorElm v) r -\u003e r",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#inspect",
        "fct-type": "method",
        "title": "inspect"
      },
      "index": {
        "description": "Inspect vector",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "inspect",
        "normalized": "a-\u003eFun(DimMono a)(VectorElm a)b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003eFun(DimMono v)(VectorElm v)r-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:izipWith",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e a -\u003e a) -\u003e v -\u003e v -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003ea-\u003ea)-\u003eb-\u003eb-\u003eb",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003ea-\u003ea)-\u003ev-\u003ev-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:izipWithM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e a -\u003e m a) -\u003e v -\u003e v -\u003e m v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#izipWithM",
        "fct-type": "function",
        "title": "izipWithM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "izipWithM",
        "normalized": "(Int-\u003ea-\u003ea-\u003eb a)-\u003ec-\u003ec-\u003eb c",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003ea-\u003em a)-\u003ev-\u003ev-\u003em v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e Int",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of vector",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "length",
        "normalized": "a-\u003eInt",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:map",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e a) -\u003e v -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "map",
        "normalized": "(a-\u003ea)-\u003eb-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003ea)-\u003ev-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:mapM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e m a) -\u003e v -\u003e m v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "mapM",
        "normalized": "(a-\u003eb a)-\u003ec-\u003eb c",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003em a)-\u003ev-\u003em v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:mapM_",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e m b) -\u003e v -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003ed-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003ev-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:maximum",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "maximum",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:minimum",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "minimum",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:mk1",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#mk1",
        "fct-type": "function",
        "title": "mk1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "mk1",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:mk2",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#mk2",
        "fct-type": "function",
        "title": "mk2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "mk2",
        "normalized": "a-\u003ea-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:mk3",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#mk3",
        "fct-type": "function",
        "title": "mk3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "mk3",
        "normalized": "a-\u003ea-\u003ea-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:mk4",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e a -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#mk4",
        "fct-type": "function",
        "title": "mk4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "mk4",
        "normalized": "a-\u003ea-\u003ea-\u003ea-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003ea-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:mk5",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#mk5",
        "fct-type": "function",
        "title": "mk5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "mk5",
        "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:or",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "or",
        "normalized": "a-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:replicate",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "replicate",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:replicateM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "m a -\u003e m v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "replicateM",
        "normalized": "a b-\u003ea c",
        "package": "fixed-vector",
        "partial": "",
        "signature": "m a-\u003em v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:reverse",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "reverse",
        "normalized": "a-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:sum",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "sum",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e w",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "tail",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v-\u003ew"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:toList",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "v -\u003e [a]",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "toList",
        "normalized": "a-\u003e[b]",
        "package": "fixed-vector",
        "partial": "List",
        "signature": "v-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:unFun",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "Fn n a b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "function",
        "title": "unFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "unFun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:unfoldr",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e (a, b)) -\u003e b -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "unfoldr",
        "normalized": "(a-\u003e(b,a))-\u003ea-\u003ec",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003e(a,b))-\u003eb-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:zipWith",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v -\u003e v -\u003e v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "zipWith",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb-\u003eb-\u003eb",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(a-\u003ea-\u003ea)-\u003ev-\u003ev-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Monomorphic.html#v:zipWithM",
      "description": {
        "fct-module": "Data.Vector.Fixed.Monomorphic",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e v -\u003e v -\u003e m v",
        "fct-source": "src/Data-Vector-Fixed-Monomorphic.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Monomorphic",
        "module": "Data.Vector.Fixed.Monomorphic",
        "name": "zipWithM",
        "normalized": "(a-\u003ea-\u003eb a)-\u003ec-\u003ec-\u003eb c",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(a-\u003ea-\u003em a)-\u003ev-\u003ev-\u003em v"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType classes for vectors which are implemented on top of the arrays\n and support in-place mutation. API is similar to one used in the\n \u003ccode\u003evector\u003c/code\u003e package.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html",
        "fct-type": "module",
        "title": "Mutable"
      },
      "index": {
        "description": "Type classes for vectors which are implemented on top of the arrays and support in-place mutation API is similar to one used in the vector package",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#t:Arity",
      "description": {
        "fct-descr": "\u003cp\u003eType class for handling \u003cem\u003en\u003c/em\u003e-ary functions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Arity",
        "fct-type": "class",
        "title": "Arity"
      },
      "index": {
        "description": "Type class for handling ary functions",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "Arity",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Arity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#t:DimM",
      "description": {
        "fct-descr": "\u003cp\u003eDimension for mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "DimM",
        "fct-type": "function",
        "title": "DimM"
      },
      "index": {
        "description": "Dimension for mutable vector",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "DimM",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Dim",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#t:IVector",
      "description": {
        "fct-descr": "\u003cp\u003eType class for immutable vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#IVector",
        "fct-type": "class",
        "title": "IVector"
      },
      "index": {
        "description": "Type class for immutable vectors",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "IVector",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "IVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eType class for mutable vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#MVector",
        "fct-type": "class",
        "title": "MVector"
      },
      "index": {
        "description": "Type class for mutable vectors",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#t:Mutable",
      "description": {
        "fct-descr": "\u003cp\u003eMutable counterpart of fixed-length vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "Mutable",
        "fct-type": "function",
        "title": "Mutable"
      },
      "index": {
        "description": "Mutable counterpart of fixed-length vector",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:arity",
      "description": {
        "fct-descr": "\u003cp\u003eArity of function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "n -\u003e Int",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#arity",
        "fct-type": "method",
        "title": "arity"
      },
      "index": {
        "description": "Arity of function",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "arity",
        "normalized": "a-\u003eInt",
        "package": "fixed-vector",
        "partial": "",
        "signature": "n-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eCreate copy of vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v (PrimState m) a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Create copy of vector",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "clone",
        "normalized": "a(PrimState b)c-\u003eb(a(PrimState b)c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:constructVec",
      "description": {
        "fct-descr": "\u003cp\u003eGeneric construct implementation for array-based vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun (Dim v) a (v a)",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#constructVec",
        "fct-type": "function",
        "title": "constructVec"
      },
      "index": {
        "description": "Generic construct implementation for array-based vectors",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "constructVec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy vector. The two vectors may not overlap. Since vectors'\n   length is encoded in the type there is no need in runtime checks.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "copy",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#copy",
        "fct-type": "method",
        "title": "copy"
      },
      "index": {
        "description": "Copy vector The two vectors may not overlap Since vectors length is encoded in the type there is no need in runtime checks",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "copy",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:freeze",
      "description": {
        "fct-descr": "\u003cp\u003eSafely convert mutable vector to immutable.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "Mutable v (PrimState m) a -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#freeze",
        "fct-type": "function",
        "title": "freeze"
      },
      "index": {
        "description": "Safely convert mutable vector to immutable",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "freeze",
        "normalized": "Mutable a(PrimState b)c-\u003eb(a c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "Mutable v(PrimState m)a-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:index",
      "description": {
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#index",
        "fct-type": "function",
        "title": "index"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "index",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:inspectVec",
      "description": {
        "fct-descr": "\u003cp\u003eGeneric inspect implementation for array-based vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Fun (Dim v) a b -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#inspectVec",
        "fct-type": "function",
        "title": "inspectVec"
      },
      "index": {
        "description": "Generic inspect implementation for array-based vectors",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "inspectVec",
        "normalized": "a b-\u003eFun(Dim a)b c-\u003ec",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": "v a-\u003eFun(Dim v)a b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:lengthI",
      "description": {
        "fct-descr": "\u003cp\u003eLength of immutable vector. Function doesn't evaluate its argument.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#lengthI",
        "fct-type": "function",
        "title": "lengthI"
      },
      "index": {
        "description": "Length of immutable vector Function doesn evaluate its argument",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "lengthI",
        "normalized": "a b-\u003eInt",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:lengthM",
      "description": {
        "fct-descr": "\u003cp\u003eLength of mutable vector. Function doesn't evaluate its argument.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v s a -\u003e Int",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#lengthM",
        "fct-type": "function",
        "title": "lengthM"
      },
      "index": {
        "description": "Length of mutable vector Function doesn evaluate its argument",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "lengthM",
        "normalized": "a b c-\u003eInt",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v s a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:move",
      "description": {
        "fct-descr": "\u003cp\u003eCopy vector. The two vectors may overlap. Since vectors' length\n   is encoded in the type there is no need in runtime checks.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "move",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#move",
        "fct-type": "method",
        "title": "move"
      },
      "index": {
        "description": "Copy vector The two vectors may overlap Since vectors length is encoded in the type there is no need in runtime checks",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "move",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eAllocate new vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#new",
        "fct-type": "method",
        "title": "new"
      },
      "index": {
        "description": "Allocate new vector",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "new",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:overlaps",
      "description": {
        "fct-descr": "\u003cp\u003eChecks whether vectors' buffers overlaps\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v s a -\u003e v s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#overlaps",
        "fct-type": "method",
        "title": "overlaps"
      },
      "index": {
        "description": "Checks whether vectors buffers overlaps",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "overlaps",
        "normalized": "a b c-\u003ea b c-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v s a-\u003ev s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eRead value at index with bound checks.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Read value at index with bound checks",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "read",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:thaw",
      "description": {
        "fct-descr": "\u003cp\u003eSafely convert immutable vector to mutable.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e m (Mutable v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#thaw",
        "fct-type": "function",
        "title": "thaw"
      },
      "index": {
        "description": "Safely convert immutable vector to mutable",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "thaw",
        "normalized": "a b-\u003ec(Mutable a(PrimState c)b)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003em(Mutable v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:unsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003eConvert vector to immutable state. Mutable vector must not be\n   modified afterwards.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "Mutable v (PrimState m) a -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#unsafeFreeze",
        "fct-type": "method",
        "title": "unsafeFreeze"
      },
      "index": {
        "description": "Convert vector to immutable state Mutable vector must not be modified afterwards",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "unsafeFreeze",
        "normalized": "Mutable a(PrimState b)c-\u003eb(a c)",
        "package": "fixed-vector",
        "partial": "Freeze",
        "signature": "Mutable v(PrimState m)a-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003eGet element at specified index without bounds check.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#unsafeIndex",
        "fct-type": "method",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Get element at specified index without bounds check",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "unsafeIndex",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "fixed-vector",
        "partial": "Index",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:unsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eRead value at index without bound checks.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#unsafeRead",
        "fct-type": "method",
        "title": "unsafeRead"
      },
      "index": {
        "description": "Read value at index without bound checks",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "unsafeRead",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
        "package": "fixed-vector",
        "partial": "Read",
        "signature": "v(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:unsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003eConvert immutable vector to mutable. Immutable vector must not\n   be used afterwards.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e m (Mutable v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#unsafeThaw",
        "fct-type": "method",
        "title": "unsafeThaw"
      },
      "index": {
        "description": "Convert immutable vector to mutable Immutable vector must not be used afterwards",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "unsafeThaw",
        "normalized": "a b-\u003ec(Mutable a(PrimState c)b)",
        "package": "fixed-vector",
        "partial": "Thaw",
        "signature": "v a-\u003em(Mutable v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:unsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eWrite value at index without bound checks.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#unsafeWrite",
        "fct-type": "method",
        "title": "unsafeWrite"
      },
      "index": {
        "description": "Write value at index without bound checks",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "unsafeWrite",
        "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
        "package": "fixed-vector",
        "partial": "Write",
        "signature": "v(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Mutable.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eWrite value at index with bound checks.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Mutable",
        "fct-package": "fixed-vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Mutable.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Write value at index with bound checks",
        "hierarchy": "Data Vector Fixed Mutable",
        "module": "Data.Vector.Fixed.Mutable",
        "name": "write",
        "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Primitive.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnboxed vectors with fixed length. Vectors from\n \u003ca\u003eData.Vector.Fixed.Unboxed\u003c/a\u003e provide more flexibility at no\n performeance cost.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed.Primitive",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed-Primitive.html",
        "fct-type": "module",
        "title": "Primitive"
      },
      "index": {
        "description": "Unboxed vectors with fixed length Vectors from Data.Vector.Fixed.Unboxed provide more flexibility at no performeance cost",
        "hierarchy": "Data Vector Fixed Primitive",
        "module": "Data.Vector.Fixed.Primitive",
        "name": "Primitive",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Primitive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Primitive.html#t:MVec",
      "description": {
        "fct-descr": "\u003cp\u003eMutable unboxed vector with fixed length\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Primitive",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Primitive.html#MVec",
        "fct-type": "data",
        "title": "MVec"
      },
      "index": {
        "description": "Mutable unboxed vector with fixed length",
        "hierarchy": "Data Vector Fixed Primitive",
        "module": "Data.Vector.Fixed.Primitive",
        "name": "MVec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "MVec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Primitive.html#t:Prim",
      "description": {
        "fct-descr": "\u003cp\u003eClass of types supporting primitive array operations\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Primitive",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-type": "class",
        "title": "Prim"
      },
      "index": {
        "description": "Class of types supporting primitive array operations",
        "hierarchy": "Data Vector Fixed Primitive",
        "module": "Data.Vector.Fixed.Primitive",
        "name": "Prim",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Prim",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Primitive.html#t:Vec",
      "description": {
        "fct-descr": "\u003cp\u003eUnboxed vector with fixed length\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Primitive",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Primitive.html#Vec",
        "fct-type": "data",
        "title": "Vec"
      },
      "index": {
        "description": "Unboxed vector with fixed length",
        "hierarchy": "Data Vector Fixed Primitive",
        "module": "Data.Vector.Fixed.Primitive",
        "name": "Vec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Primitive.html#t:Vec2",
      "description": {
        "fct-module": "Data.Vector.Fixed.Primitive",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Primitive.html#Vec2",
        "fct-type": "type",
        "title": "Vec2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Primitive",
        "module": "Data.Vector.Fixed.Primitive",
        "name": "Vec2",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Primitive.html#t:Vec3",
      "description": {
        "fct-module": "Data.Vector.Fixed.Primitive",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Primitive.html#Vec3",
        "fct-type": "type",
        "title": "Vec3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Primitive",
        "module": "Data.Vector.Fixed.Primitive",
        "name": "Vec3",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Primitive.html#t:Vec4",
      "description": {
        "fct-module": "Data.Vector.Fixed.Primitive",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Primitive.html#Vec4",
        "fct-type": "type",
        "title": "Vec4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Primitive",
        "module": "Data.Vector.Fixed.Primitive",
        "name": "Vec4",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Primitive.html#t:Vec5",
      "description": {
        "fct-module": "Data.Vector.Fixed.Primitive",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Primitive.html#Vec5",
        "fct-type": "type",
        "title": "Vec5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Primitive",
        "module": "Data.Vector.Fixed.Primitive",
        "name": "Vec5",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStorable-based unboxed vectors.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed-Storable.html",
        "fct-type": "module",
        "title": "Storable"
      },
      "index": {
        "description": "Storable-based unboxed vectors",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "Storable",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Storable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#t:MVec",
      "description": {
        "fct-descr": "\u003cp\u003eStorable-based mutable vector with fixed length\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#MVec",
        "fct-type": "newtype",
        "title": "MVec"
      },
      "index": {
        "description": "Storable-based mutable vector with fixed length",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "MVec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "MVec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#t:Storable",
      "description": {
        "fct-descr": "\u003cp\u003eThe member functions of this class facilitate writing values of\nprimitive types to raw memory (which may have been allocated with the\nabove mentioned routines) and reading values from blocks of raw\nmemory.  The class, furthermore, includes support for computing the\nstorage requirements and alignment restrictions of storable types.\n\u003c/p\u003e\u003cp\u003eMemory addresses are represented as values of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e, for some\n\u003ccode\u003ea\u003c/code\u003e which is an instance of class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e.  The type argument to\n\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e helps provide some valuable type safety in FFI code (you can't\nmix pointers of different types without an explicit cast), while\nhelping the Haskell type system figure out which marshalling method is\nneeded for a given pointer.\n\u003c/p\u003e\u003cp\u003eAll marshalling between Haskell and a foreign language ultimately\nboils down to translating Haskell data structures into the binary\nrepresentation of a corresponding data structure of the foreign\nlanguage and vice versa.  To code this marshalling in Haskell, it is\nnecessary to manipulate primitive data types stored in unstructured\nmemory blocks.  The class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e facilitates this manipulation on\nall types for which it is instantiated, which are the standard basic\ntypes of Haskell, the fixed size \u003ccode\u003eInt\u003c/code\u003e types (\u003ccode\u003e\u003ca\u003eInt8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e), the fixed size \u003ccode\u003eWord\u003c/code\u003e types (\u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eWord32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord64\u003c/a\u003e\u003c/code\u003e), \u003ccode\u003e\u003ca\u003eStablePtr\u003c/a\u003e\u003c/code\u003e, all types from \u003ca\u003eForeign.C.Types\u003c/a\u003e,\nas well as \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003esizeOf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ealignment\u003c/a\u003e\u003c/code\u003e, one of \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003epeekElemOff\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epeekByteOff\u003c/a\u003e\u003c/code\u003e, and one of \u003ccode\u003e\u003ca\u003epoke\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epokeElemOff\u003c/a\u003e\u003c/code\u003e and\n\u003ccode\u003e\u003ca\u003epokeByteOff\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-type": "class",
        "title": "Storable"
      },
      "index": {
        "description": "The member functions of this class facilitate writing values of primitive types to raw memory which may have been allocated with the above mentioned routines and reading values from blocks of raw memory The class furthermore includes support for computing the storage requirements and alignment restrictions of storable types Memory addresses are represented as values of type Ptr for some which is an instance of class Storable The type argument to Ptr helps provide some valuable type safety in FFI code you can mix pointers of different types without an explicit cast while helping the Haskell type system figure out which marshalling method is needed for given pointer All marshalling between Haskell and foreign language ultimately boils down to translating Haskell data structures into the binary representation of corresponding data structure of the foreign language and vice versa To code this marshalling in Haskell it is necessary to manipulate primitive data types stored in unstructured memory blocks The class Storable facilitates this manipulation on all types for which it is instantiated which are the standard basic types of Haskell the fixed size Int types Int8 Int16 Int32 Int64 the fixed size Word types Word8 Word16 Word32 Word64 StablePtr all types from Foreign.C.Types as well as Ptr Minimal complete definition sizeOf alignment one of peek peekElemOff and peekByteOff and one of poke pokeElemOff and pokeByteOff",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "Storable",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Storable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#t:Vec",
      "description": {
        "fct-descr": "\u003cp\u003eStorable-based vector with fixed length\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#Vec",
        "fct-type": "data",
        "title": "Vec"
      },
      "index": {
        "description": "Storable-based vector with fixed length",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "Vec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#t:Vec2",
      "description": {
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#Vec2",
        "fct-type": "type",
        "title": "Vec2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "Vec2",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#t:Vec3",
      "description": {
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#Vec3",
        "fct-type": "type",
        "title": "Vec3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "Vec3",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#t:Vec4",
      "description": {
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#Vec4",
        "fct-type": "type",
        "title": "Vec4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "Vec4",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#t:Vec5",
      "description": {
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#Vec5",
        "fct-type": "type",
        "title": "Vec5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "Vec5",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#v:MVec",
      "description": {
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "MVec (ForeignPtr a)",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#MVec",
        "fct-type": "function",
        "title": "MVec"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "MVec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "MVec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#v:unsafeFromForeignPtr",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct vector from foreign pointer.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "ForeignPtr a -\u003e Vec n a",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#unsafeFromForeignPtr",
        "fct-type": "function",
        "title": "unsafeFromForeignPtr"
      },
      "index": {
        "description": "Construct vector from foreign pointer",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "unsafeFromForeignPtr",
        "normalized": "ForeignPtr a-\u003eVec b a",
        "package": "fixed-vector",
        "partial": "From Foreign Ptr",
        "signature": "ForeignPtr a-\u003eVec n a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#v:unsafeToForeignPtr",
      "description": {
        "fct-descr": "\u003cp\u003eGet underlying pointer. Data may not be modified through pointer.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "Vec n a -\u003e ForeignPtr a",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#unsafeToForeignPtr",
        "fct-type": "function",
        "title": "unsafeToForeignPtr"
      },
      "index": {
        "description": "Get underlying pointer Data may not be modified through pointer",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "unsafeToForeignPtr",
        "normalized": "Vec a b-\u003eForeignPtr b",
        "package": "fixed-vector",
        "partial": "To Foreign Ptr",
        "signature": "Vec n a-\u003eForeignPtr a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Storable.html#v:unsafeWith",
      "description": {
        "fct-module": "Data.Vector.Fixed.Storable",
        "fct-package": "fixed-vector",
        "fct-signature": "(Ptr a -\u003e IO b) -\u003e Vec n a -\u003e IO b",
        "fct-source": "src/Data-Vector-Fixed-Storable.html#unsafeWith",
        "fct-type": "function",
        "title": "unsafeWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Storable",
        "module": "Data.Vector.Fixed.Storable",
        "name": "unsafeWith",
        "normalized": "(Ptr a-\u003eIO b)-\u003eVec c a-\u003eIO b",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(Ptr a-\u003eIO b)-\u003eVec n a-\u003eIO b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Unboxed.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnboxed vectors with fixed length.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed.Unboxed",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed-Unboxed.html",
        "fct-type": "module",
        "title": "Unboxed"
      },
      "index": {
        "description": "Unboxed vectors with fixed length",
        "hierarchy": "Data Vector Fixed Unboxed",
        "module": "Data.Vector.Fixed.Unboxed",
        "name": "Unboxed",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Unboxed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Unboxed.html#t:MVec",
      "description": {
        "fct-module": "Data.Vector.Fixed.Unboxed",
        "fct-package": "fixed-vector",
        "fct-signature": "MVec",
        "fct-type": "function",
        "title": "MVec"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Unboxed",
        "module": "Data.Vector.Fixed.Unboxed",
        "name": "MVec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "MVec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Unboxed.html#t:Unbox",
      "description": {
        "fct-module": "Data.Vector.Fixed.Unboxed",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Unboxed.html#Unbox",
        "fct-type": "class",
        "title": "Unbox"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Unboxed",
        "module": "Data.Vector.Fixed.Unboxed",
        "name": "Unbox",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Unbox",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Unboxed.html#t:Vec",
      "description": {
        "fct-module": "Data.Vector.Fixed.Unboxed",
        "fct-package": "fixed-vector",
        "fct-signature": "Vec",
        "fct-type": "function",
        "title": "Vec"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Unboxed",
        "module": "Data.Vector.Fixed.Unboxed",
        "name": "Vec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Unboxed.html#t:Vec2",
      "description": {
        "fct-module": "Data.Vector.Fixed.Unboxed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Unboxed.html#Vec2",
        "fct-type": "type",
        "title": "Vec2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Unboxed",
        "module": "Data.Vector.Fixed.Unboxed",
        "name": "Vec2",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Unboxed.html#t:Vec3",
      "description": {
        "fct-module": "Data.Vector.Fixed.Unboxed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Unboxed.html#Vec3",
        "fct-type": "type",
        "title": "Vec3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Unboxed",
        "module": "Data.Vector.Fixed.Unboxed",
        "name": "Vec3",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Unboxed.html#t:Vec4",
      "description": {
        "fct-module": "Data.Vector.Fixed.Unboxed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Unboxed.html#Vec4",
        "fct-type": "type",
        "title": "Vec4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Unboxed",
        "module": "Data.Vector.Fixed.Unboxed",
        "name": "Vec4",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed-Unboxed.html#t:Vec5",
      "description": {
        "fct-module": "Data.Vector.Fixed.Unboxed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Unboxed.html#Vec5",
        "fct-type": "type",
        "title": "Vec5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed Unboxed",
        "module": "Data.Vector.Fixed.Unboxed",
        "name": "Vec5",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneric API for vectors with fixed length.\n\u003c/p\u003e\u003cp\u003eFor encoding of vector size library uses Peano naturals defined in\n the library. At come point in the future it would make sense to\n switch to new GHC type level numerals.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eCommon pitfalls\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eLibrary provide instances for tuples. But there's a catch. Tuples\n are monomorphic in element type. Let consider 2-tuple \u003ccode\u003e(Int,Int)\u003c/code\u003e.\n Vector type \u003ccode\u003ev\u003c/code\u003e is \u003ccode\u003e(,) Int\u003c/code\u003e and only allowed element type is\n \u003ccode\u003eInt\u003c/code\u003e.  Because of that we cannot change element type and following\n code will fail:\n\u003c/p\u003e\u003cpre\u003e \u003e\u003e\u003e map (== 1) ((1,2) :: (Int,Int))\n\n \u003cinteractive\u003e:3:1:\n     Couldn't match type `Int' with `Bool'\n     In the expression: F.map (== 1) ((1, 2) :: (Int, Int))\n     In an equation for `it': it = map (== 1) ((1, 2) :: (Int, Int))\n\u003c/pre\u003e\u003cp\u003eTo make it work we need to change vector type as well. Functions\n from module \u003ca\u003eData.Vector.Fixed.Generic\u003c/a\u003e provide this functionality.\n\u003c/p\u003e\u003cpre\u003e \u003e\u003e\u003e map (== 1) ((1,2) :: (Int,Int)) :: (Bool,Bool)\n (True,False)\n\u003c/pre\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fixed.html",
        "fct-type": "module",
        "title": "Fixed"
      },
      "index": {
        "description": "Generic API for vectors with fixed length For encoding of vector size library uses Peano naturals defined in the library At come point in the future it would make sense to switch to new GHC type level numerals Common pitfalls Library provide instances for tuples But there catch Tuples are monomorphic in element type Let consider tuple Int Int Vector type is Int and only allowed element type is Int Because of that we cannot change element type and following code will fail map Int Int interactive Couldn match type Int with Bool In the expression F.map Int Int In an equation for it it map Int Int To make it work we need to change vector type as well Functions from module Data.Vector.Fixed.Generic provide this functionality map Int Int Bool Bool True False",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Fixed",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fixed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Arity",
      "description": {
        "fct-descr": "\u003cp\u003eType class for handling \u003cem\u003en\u003c/em\u003e-ary functions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Arity",
        "fct-type": "class",
        "title": "Arity"
      },
      "index": {
        "description": "Type class for handling ary functions",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Arity",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Arity",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:ContVec",
      "description": {
        "fct-descr": "\u003cp\u003eVector represented as continuation. Alternative wording: it's\n   Church encoded N-element vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#ContVec",
        "fct-type": "data",
        "title": "ContVec"
      },
      "index": {
        "description": "Vector represented as continuation Alternative wording it Church encoded N-element vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "ContVec",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Cont Vec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Dim",
      "description": {
        "fct-descr": "\u003cp\u003eSize of vector expressed as type-level natural.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "Dim",
        "fct-type": "function",
        "title": "Dim"
      },
      "index": {
        "description": "Size of vector expressed as type-level natural",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Dim",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Dim",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Empty",
      "description": {
        "fct-descr": "\u003cp\u003eEmpty tuple.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed.html#Empty",
        "fct-type": "data",
        "title": "Empty"
      },
      "index": {
        "description": "Empty tuple",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Empty",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Fun",
      "description": {
        "fct-descr": "\u003cp\u003eNewtype wrapper which is used to make \u003ccode\u003e\u003ca\u003eFn\u003c/a\u003e\u003c/code\u003e injective. It's also a\n   reader monad.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "newtype",
        "title": "Fun"
      },
      "index": {
        "description": "Newtype wrapper which is used to make Fn injective It also reader monad",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Fun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Index",
      "description": {
        "fct-descr": "\u003cp\u003eType class for indexing of vector when index value is known at\n   compile time.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Index",
        "fct-type": "class",
        "title": "Index"
      },
      "index": {
        "description": "Type class for indexing of vector when index value is known at compile time",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Index",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Index",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Make",
      "description": {
        "fct-descr": "\u003cp\u003eType class for variadic vector constructors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#Make",
        "fct-type": "class",
        "title": "Make"
      },
      "index": {
        "description": "Type class for variadic vector constructors",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Make",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Make",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:N1",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N1",
        "fct-type": "type",
        "title": "N1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "N1",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:N2",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N2",
        "fct-type": "type",
        "title": "N2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "N2",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:N3",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N3",
        "fct-type": "type",
        "title": "N3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "N3",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:N4",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N4",
        "fct-type": "type",
        "title": "N4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "N4",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:N5",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N5",
        "fct-type": "type",
        "title": "N5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "N5",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:N6",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#N6",
        "fct-type": "type",
        "title": "N6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "N6",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Only",
      "description": {
        "fct-descr": "\u003cp\u003eSingle-element tuple.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Vector-Fixed.html#Only",
        "fct-type": "newtype",
        "title": "Only"
      },
      "index": {
        "description": "Single-element tuple",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Only",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Only",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:S",
      "description": {
        "fct-descr": "\u003cp\u003eSuccessor of n\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#S",
        "fct-type": "data",
        "title": "S"
      },
      "index": {
        "description": "Successor of",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "S",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Tuple2",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed.html#Tuple2",
        "fct-type": "type",
        "title": "Tuple2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Tuple2",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Tuple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Tuple3",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed.html#Tuple3",
        "fct-type": "type",
        "title": "Tuple3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Tuple3",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Tuple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Tuple4",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed.html#Tuple4",
        "fct-type": "type",
        "title": "Tuple4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Tuple4",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Tuple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Tuple5",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fixed.html#Tuple5",
        "fct-type": "type",
        "title": "Tuple5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Tuple5",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Tuple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:VecList",
      "description": {
        "fct-descr": "\u003cp\u003eVector based on the lists. Not very useful by itself but is\n   necessary for implementation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed.html#VecList",
        "fct-type": "data",
        "title": "VecList"
      },
      "index": {
        "description": "Vector based on the lists Not very useful by itself but is necessary for implementation",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "VecList",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vec List",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Vector",
      "description": {
        "fct-descr": "\u003cp\u003eType class for vectors with fixed length. Instance should provide\n two functions: one to create vector and another for vector\n deconstruction. They must obey following law:\n\u003c/p\u003e\u003cpre\u003e inspect v construct = v\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Vector",
        "fct-type": "class",
        "title": "Vector"
      },
      "index": {
        "description": "Type class for vectors with fixed length Instance should provide two functions one to create vector and another for vector deconstruction They must obey following law inspect construct",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Vector",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:VectorN",
      "description": {
        "fct-descr": "\u003cp\u003eVector parametrized by length. In ideal world it should be:\n\u003c/p\u003e\u003cpre\u003e forall n. (Arity n, Vector (v n) a, Dim (v n) ~ n) =\u003e VectorN v a\n\u003c/pre\u003e\u003cp\u003eAlas polymorphic constraints aren't allowed in haskell.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#VectorN",
        "fct-type": "class",
        "title": "VectorN"
      },
      "index": {
        "description": "Vector parametrized by length In ideal world it should be forall Arity Vector Dim VectorN Alas polymorphic constraints aren allowed in haskell",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "VectorN",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#t:Z",
      "description": {
        "fct-descr": "\u003cp\u003eType level zero\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Z",
        "fct-type": "data",
        "title": "Z"
      },
      "index": {
        "description": "Type level zero",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Z",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eRetrieve vector's element at index. Generic implementation is\n   \u003cem\u003eO(n)\u003c/em\u003e but more efficient one is used when possible.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Retrieve vector element at index Generic implementation is but more efficient one is used when possible",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "(!) !",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:-60--124-",
      "description": {
        "fct-descr": "\u003cp\u003eCons value to continuation based vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e ContVec n a -\u003e ContVec (S n) a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#%3C%7C",
        "fct-type": "function",
        "title": "(\u003c|)"
      },
      "index": {
        "description": "Cons value to continuation based vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "(\u003c|) \u003c|",
        "normalized": "a-\u003eContVec b a-\u003eContVec(S b)a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003eContVec n a-\u003eContVec(S n)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:Cons",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e VecList n a -\u003e VecList (S n) a",
        "fct-source": "src/Data-Vector-Fixed.html#VecList",
        "fct-type": "function",
        "title": "Cons"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Cons",
        "normalized": "a-\u003eVecList b a-\u003eVecList(S b)a",
        "package": "fixed-vector",
        "partial": "Cons",
        "signature": "a-\u003eVecList n a-\u003eVecList(S n)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:Empty",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "Empty",
        "fct-source": "src/Data-Vector-Fixed.html#Empty",
        "fct-type": "function",
        "title": "Empty"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Empty",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Empty",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:Fun",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "function",
        "title": "Fun"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Fun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:Nil",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "VecList Z a",
        "fct-source": "src/Data-Vector-Fixed.html#VecList",
        "fct-type": "function",
        "title": "Nil"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Nil",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Nil",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:Only",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "Only a",
        "fct-source": "src/Data-Vector-Fixed.html#Only",
        "fct-type": "function",
        "title": "Only"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "Only",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Only",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003eDetermines whether all elements of vector satisfy predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Determines whether all elements of vector satisfy predicate",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003eConjunction of all elements of a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "Conjunction of all elements of vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "and",
        "normalized": "a Bool-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003eDetermines whether any of element of vector satisfy predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Determines whether any of element of vector satisfy predicate",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:basicIndex",
      "description": {
        "fct-descr": "\u003cp\u003eOptional more efficient implementation of indexing. Shouldn't\n   be used directly, use \u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#basicIndex",
        "fct-type": "method",
        "title": "basicIndex"
      },
      "index": {
        "description": "Optional more efficient implementation of indexing Shouldn be used directly use instead",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "basicIndex",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "fixed-vector",
        "partial": "Index",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:basis",
      "description": {
        "fct-descr": "\u003cp\u003eUnit vector along Nth axis. If index is larger than vector\n   dimensions returns zero vector.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec3)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ebasis 0 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003efromList [1,0,0]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ebasis 1 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003efromList [0,1,0]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ebasis 3 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003efromList [0,0,0]\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "Int -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#basis",
        "fct-type": "function",
        "title": "basis"
      },
      "index": {
        "description": "Unit vector along Nth axis If index is larger than vector dimensions returns zero vector Examples import Data.Vector.Fixed.Boxed Vec3 basis Vec3 Int fromList basis Vec3 Int fromList basis Vec3 Int fromList",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "basis",
        "normalized": "Int-\u003ea b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "Int-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:collect",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e v b) -\u003e f a -\u003e v (f b)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#collect",
        "fct-type": "function",
        "title": "collect"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "collect",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003ev b)-\u003ef a-\u003ev(f b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:collectM",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e v b) -\u003e m a -\u003e v (m b)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#collectM",
        "fct-type": "function",
        "title": "collectM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "collectM",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003ev b)-\u003em a-\u003ev(m b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003eCons element to the vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e v a -\u003e w a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Cons element to the vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "cons",
        "normalized": "a-\u003eb a-\u003ec a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ev a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:construct",
      "description": {
        "fct-descr": "\u003cp\u003eN-ary function for creation of vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "Fun (Dim v) a (v a)",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#construct",
        "fct-type": "method",
        "title": "construct"
      },
      "index": {
        "description": "N-ary function for creation of vectors",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "construct",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:convert",
      "description": {
        "fct-descr": "\u003cp\u003eConvert between different vector types\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e w a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "Convert between different vector types",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "convert",
        "normalized": "a b-\u003ec b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:distribute",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "f (v a) -\u003e v (f a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#distribute",
        "fct-type": "function",
        "title": "distribute"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "distribute",
        "normalized": "a(b c)-\u003eb(a c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "f(v a)-\u003ev(f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:distributeM",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "m (v a) -\u003e v (m a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#distributeM",
        "fct-type": "function",
        "title": "distributeM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "distributeM",
        "normalized": "a(b c)-\u003eb(a c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "m(v a)-\u003ev(m a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:element",
      "description": {
        "fct-descr": "\u003cp\u003eTwan van Laarhoven's lens for element of vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "Int -\u003e (a -\u003e f a) -\u003e v a -\u003e f (v a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#element",
        "fct-type": "function",
        "title": "element"
      },
      "index": {
        "description": "Twan van Laarhoven lens for element of vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "element",
        "normalized": "Int-\u003e(a-\u003eb a)-\u003ec a-\u003eb(c a)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ef a)-\u003ev a-\u003ef(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:elementTy",
      "description": {
        "fct-descr": "\u003cp\u003eTwan van Laarhoven's lens for element of vector with statically\n   known index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "k -\u003e (a -\u003e f a) -\u003e v a -\u003e f (v a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#elementTy",
        "fct-type": "function",
        "title": "elementTy"
      },
      "index": {
        "description": "Twan van Laarhoven lens for element of vector with statically known index",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "elementTy",
        "normalized": "a-\u003e(b-\u003ec b)-\u003ed b-\u003ec(d b)",
        "package": "fixed-vector",
        "partial": "Ty",
        "signature": "k-\u003e(a-\u003ef a)-\u003ev a-\u003ef(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003eCreate empty vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec Z a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Create empty vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "empty",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:eq",
      "description": {
        "fct-descr": "\u003cp\u003eTest two vectors for equality.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec2)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet v0 = basis 0 :: Vec2 Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet v1 = basis 1 :: Vec2 Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev0 `eq` v0\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev0 `eq` v1\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#eq",
        "fct-type": "function",
        "title": "eq"
      },
      "index": {
        "description": "Test two vectors for equality Examples import Data.Vector.Fixed.Boxed Vec2 let v0 basis Vec2 Int let v1 basis Vec2 Int v0 eq v0 True v0 eq v1 False",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "eq",
        "normalized": "a b-\u003ea b-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:fold",
      "description": {
        "fct-descr": "\u003cp\u003eCombine the elements of a structure using a monoid. Similar to\n   \u003ccode\u003e\u003ca\u003efold\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v m -\u003e m",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#fold",
        "fct-type": "function",
        "title": "fold"
      },
      "index": {
        "description": "Combine the elements of structure using monoid Similar to fold",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "fold",
        "normalized": "a b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v m-\u003em"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic fold over vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e a -\u003e m b) -\u003e b -\u003e v a -\u003e m b",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold over vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003ea-\u003em b)-\u003eb-\u003ev a-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:foldMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap each element of the structure to a monoid,\n   and combine the results. Similar to \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e m) -\u003e v a -\u003e m",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#foldMap",
        "fct-type": "function",
        "title": "foldMap"
      },
      "index": {
        "description": "Map each element of the structure to monoid and combine the results Similar to foldMap",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "foldMap",
        "normalized": "(a-\u003eb)-\u003ec a-\u003eb",
        "package": "fixed-vector",
        "partial": "Map",
        "signature": "(a-\u003em)-\u003ev a-\u003em"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e a -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold over vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003ea-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold over vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold over vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold over vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:fromFoldable",
      "description": {
        "fct-descr": "\u003cp\u003eCreate vector from \u003ccode\u003eFoldable\u003c/code\u003e data type. Will return \u003ccode\u003eNothing\u003c/code\u003e if\n   data type different number of elements that resulting vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "f a -\u003e Maybe (v a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#fromFoldable",
        "fct-type": "function",
        "title": "fromFoldable"
      },
      "index": {
        "description": "Create vector from Foldable data type Will return Nothing if data type different number of elements that resulting vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "fromFoldable",
        "normalized": "a b-\u003eMaybe(c b)",
        "package": "fixed-vector",
        "partial": "Foldable",
        "signature": "f a-\u003eMaybe(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003eCreate vector form list. Will throw error if list is shorter than\n   resulting vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "[a] -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Create vector form list Will throw error if list is shorter than resulting vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "fromList",
        "normalized": "[a]-\u003eb a",
        "package": "fixed-vector",
        "partial": "List",
        "signature": "[a]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:fromList-39-",
      "description": {
        "fct-descr": "\u003cp\u003eCreate vector form list. Will throw error if list has different\n   length from resulting vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "[a] -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#fromList%27",
        "fct-type": "function",
        "title": "fromList'"
      },
      "index": {
        "description": "Create vector form list Will throw error if list has different length from resulting vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "fromList'",
        "normalized": "[a]-\u003eb a",
        "package": "fixed-vector",
        "partial": "List'",
        "signature": "[a]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:fromListM",
      "description": {
        "fct-descr": "\u003cp\u003eCreate vector form list. Will return \u003ccode\u003eNothing\u003c/code\u003e if list has different\n   length from resulting vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "[a] -\u003e Maybe (v a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#fromListM",
        "fct-type": "function",
        "title": "fromListM"
      },
      "index": {
        "description": "Create vector form list Will return Nothing if list has different length from resulting vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "fromListM",
        "normalized": "[a]-\u003eMaybe(b a)",
        "package": "fixed-vector",
        "partial": "List",
        "signature": "[a]-\u003eMaybe(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate vector from function which maps element's index to its\n   value.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Unboxed (Vec4)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003egenerate (^2) :: Vec4 Int\n\u003c/code\u003e\u003c/strong\u003efromList [0,1,4,9]\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a) -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Generate vector from function which maps element index to its value Examples import Data.Vector.Fixed.Unboxed Vec4 generate Vec4 Int fromList",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "generate",
        "normalized": "(Int-\u003ea)-\u003eb a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea)-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate vector from monadic function which maps element's index\n   to its value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e m a) -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Generate vector from monadic function which maps element index to its value",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "generateM",
        "normalized": "(Int-\u003ea b)-\u003ea(c b)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003em a)-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003eFirst element of vector.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec3)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet x = mk3 1 2 3 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehead x\n\u003c/code\u003e\u003c/strong\u003e1\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element of vector Examples import Data.Vector.Fixed.Boxed Vec3 let mk3 Vec3 Int head",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "head",
        "normalized": "a b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:ifoldM",
      "description": {
        "fct-descr": "\u003cp\u003eLeft monadic fold over vector. Function is applied to each element and\n   its index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e Int -\u003e a -\u003e m b) -\u003e b -\u003e v a -\u003e m b",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#ifoldM",
        "fct-type": "function",
        "title": "ifoldM"
      },
      "index": {
        "description": "Left monadic fold over vector Function is applied to each element and its index",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "ifoldM",
        "normalized": "(a-\u003eInt-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003eInt-\u003ea-\u003em b)-\u003eb-\u003ev a-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over vector. Function is applied to each element and\n   its index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e Int -\u003e a -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold over vector Function is applied to each element and its index",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003eInt-\u003ea-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Left fold over vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003eApply function to every element of the vector and its index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of the vector and its index",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003eb)-\u003ec a-\u003ec b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:imapM",
      "description": {
        "fct-descr": "\u003cp\u003eApply monadic function to every element of the vector and its index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e m b) -\u003e v a -\u003e m (v b)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#imapM",
        "fct-type": "function",
        "title": "imapM"
      },
      "index": {
        "description": "Apply monadic function to every element of the vector and its index",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "imapM",
        "normalized": "(Int-\u003ea-\u003eb c)-\u003ed a-\u003eb(d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003em b)-\u003ev a-\u003em(v b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:imapM_",
      "description": {
        "fct-descr": "\u003cp\u003eApply monadic function to every element of the vector and its\n   index and discard result.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e m b) -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#imapM_",
        "fct-type": "function",
        "title": "imapM_"
      },
      "index": {
        "description": "Apply monadic function to every element of the vector and its index and discard result",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "imapM_",
        "normalized": "(Int-\u003ea-\u003eb c)-\u003ed a-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003em b)-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:index",
      "description": {
        "fct-descr": "\u003cp\u003eGet element from vector at statically known index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e k -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#index",
        "fct-type": "function",
        "title": "index"
      },
      "index": {
        "description": "Get element from vector at statically known index",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "index",
        "normalized": "a b-\u003ec-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ek-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:inspect",
      "description": {
        "fct-descr": "\u003cp\u003eDeconstruction of vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Fun (Dim v) a b -\u003e b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#inspect",
        "fct-type": "method",
        "title": "inspect"
      },
      "index": {
        "description": "Deconstruction of vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "inspect",
        "normalized": "a b-\u003eFun(Dim a)b c-\u003ec",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003eFun(Dim v)a b-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using function which takes element index\n   as well.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e v a -\u003e v b -\u003e v c",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "Zip two vector together using function which takes element index as well",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003ev a-\u003ev b-\u003ev c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:izipWithM",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using monadic function which takes element\n   index as well..\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e m c) -\u003e v a -\u003e v b -\u003e m (v c)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#izipWithM",
        "fct-type": "function",
        "title": "izipWithM"
      },
      "index": {
        "description": "Zip two vector together using monadic function which takes element index as well",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "izipWithM",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec d)-\u003ee a-\u003ee b-\u003ec(e d)",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003em c)-\u003ev a-\u003ev b-\u003em(v c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of vector. Function doesn't evaluate its argument.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of vector Function doesn evaluate its argument",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "length",
        "normalized": "a b-\u003eInt",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003eMap over vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b) -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map over vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic map over vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e m b) -\u003e v a -\u003e m (v b)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Monadic map over vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003ev a-\u003em(v b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003eApply monadic action to each element of vector and ignore result.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e m b) -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply monadic action to each element of vector and ignore result",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003eMaximal element of vector.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec3)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet x = mk3 1 2 3 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emaximum x\n\u003c/code\u003e\u003c/strong\u003e3\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Maximal element of vector Examples import Data.Vector.Fixed.Boxed Vec3 let mk3 Vec3 Int maximum",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "maximum",
        "normalized": "a b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003eMinimal element of vector.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec3)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet x = mk3 1 2 3 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eminimum x\n\u003c/code\u003e\u003c/strong\u003e1\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Minimal element of vector Examples import Data.Vector.Fixed.Boxed Vec3 let mk3 Vec3 Int minimum",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "minimum",
        "normalized": "a b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mk0",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mk0",
        "fct-type": "function",
        "title": "mk0"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mk0",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mk1",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mk1",
        "fct-type": "function",
        "title": "mk1"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mk1",
        "normalized": "a-\u003eb a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mk2",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mk2",
        "fct-type": "function",
        "title": "mk2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mk2",
        "normalized": "a-\u003ea-\u003eb a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mk3",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mk3",
        "fct-type": "function",
        "title": "mk3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mk3",
        "normalized": "a-\u003ea-\u003ea-\u003eb a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mk4",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mk4",
        "fct-type": "function",
        "title": "mk4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mk4",
        "normalized": "a-\u003ea-\u003ea-\u003ea-\u003eb a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mk5",
      "description": {
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mk5",
        "fct-type": "function",
        "title": "mk5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mk5",
        "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eb a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:mkN",
      "description": {
        "fct-descr": "\u003cp\u003eVariadic vector constructor. Resulting vector should be converted\n   from \u003ccode\u003e\u003ca\u003eContVec\u003c/a\u003e\u003c/code\u003e using \u003ccode\u003e\u003ca\u003evector\u003c/a\u003e\u003c/code\u003e function.  For example:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003evector $ mkN 'a' 'b' 'c' :: (Char,Char,Char)\n\u003c/code\u003e\u003c/strong\u003e('a','b','c')\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e r",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#mkN",
        "fct-type": "function",
        "title": "mkN"
      },
      "index": {
        "description": "Variadic vector constructor Resulting vector should be converted from ContVec using vector function For example vector mkN Char Char Char",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "mkN",
        "normalized": "a-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003er"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003eDisjunction of all elements of a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "Disjunction of all elements of vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "or",
        "normalized": "a Bool-\u003eBool",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:ord",
      "description": {
        "fct-descr": "\u003cp\u003eLexicographic ordering of two vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e v a -\u003e Ordering",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#ord",
        "fct-type": "function",
        "title": "ord"
      },
      "index": {
        "description": "Lexicographic ordering of two vectors",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "ord",
        "normalized": "a b-\u003ea b-\u003eOrdering",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ev a-\u003eOrdering"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eReplicate value \u003cem\u003en\u003c/em\u003e times.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec2)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereplicate 1 :: Vec2 Int\n\u003c/code\u003e\u003c/strong\u003efromList [1,1]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereplicate 2 :: (Double,Double,Double)\n\u003c/code\u003e\u003c/strong\u003e(2.0,2.0,2.0)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec4)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereplicate \"foo\" :: Vec4 String\n\u003c/code\u003e\u003c/strong\u003efromList [\"foo\",\"foo\",\"foo\",\"foo\"]\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Replicate value times Examples import Data.Vector.Fixed.Boxed Vec2 replicate Vec2 Int fromList replicate Double Double Double import Data.Vector.Fixed.Boxed Vec4 replicate foo Vec4 String fromList foo foo foo foo",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "replicate",
        "normalized": "a-\u003eb a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eExecute monadic action for every element of vector.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec2,Vec3)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereplicateM (Just 3) :: Maybe (Vec3 Int)\n\u003c/code\u003e\u003c/strong\u003eJust fromList [3,3,3]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereplicateM (putStrLn \"Hi!\") :: IO (Vec2 ())\n\u003c/code\u003e\u003c/strong\u003eHi!\nHi!\nfromList [(),()]\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "m a -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute monadic action for every element of vector Examples import Data.Vector.Fixed.Boxed Vec2 Vec3 replicateM Just Maybe Vec3 Int Just fromList replicateM putStrLn Hi IO Vec2 Hi Hi fromList",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "replicateM",
        "normalized": "a b-\u003ea(c b)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "m a-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003eReverse order of elements in the vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse order of elements in the vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "reverse",
        "normalized": "a b-\u003ea b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:sequence",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate every action in the vector from left to right.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v (m a) -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#sequence",
        "fct-type": "function",
        "title": "sequence"
      },
      "index": {
        "description": "Evaluate every action in the vector from left to right",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "sequence",
        "normalized": "a(b c)-\u003eb(a c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v(m a)-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:sequenceA",
      "description": {
        "fct-descr": "\u003cp\u003eAnalog of \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v (f a) -\u003e f (v a)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#sequenceA",
        "fct-type": "function",
        "title": "sequenceA"
      },
      "index": {
        "description": "Analog of sequenceA from Traversable",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "sequenceA",
        "normalized": "a(b c)-\u003eb(a c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v(f a)-\u003ef(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:sequence_",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate every action in the vector from left to right and ignore result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v (m a) -\u003e m ()",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#sequence_",
        "fct-type": "function",
        "title": "sequence_"
      },
      "index": {
        "description": "Evaluate every action in the vector from left to right and ignore result",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "sequence_",
        "normalized": "a(b c)-\u003eb()",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v(m a)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003eAppend element to the vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "a -\u003e v a -\u003e w a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append element to the vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "snoc",
        "normalized": "a-\u003eb a-\u003ec a",
        "package": "fixed-vector",
        "partial": "",
        "signature": "a-\u003ev a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003eSum all elements in the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "Sum all elements in the vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "sum",
        "normalized": "a b-\u003eb",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003eTail of vector.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Complex\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etail (1,2,3) :: Complex Double\n\u003c/code\u003e\u003c/strong\u003e2.0 :+ 3.0\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e w a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Tail of vector Examples import Data.Complex tail Complex Double",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "tail",
        "normalized": "a b-\u003ec b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert vector to the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "v a -\u003e [a]",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to the list",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "toList",
        "normalized": "a b-\u003e[b]",
        "package": "fixed-vector",
        "partial": "List",
        "signature": "v a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:traverse",
      "description": {
        "fct-descr": "\u003cp\u003eAnalog of \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e f b) -\u003e v a -\u003e f (v b)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#traverse",
        "fct-type": "function",
        "title": "traverse"
      },
      "index": {
        "description": "Analog of traverse from Traversable",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "traverse",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(a-\u003ef b)-\u003ev a-\u003ef(v b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:unFun",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "Fn n a b",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#Fun",
        "fct-type": "function",
        "title": "unFun"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "unFun",
        "normalized": "",
        "package": "fixed-vector",
        "partial": "Fun",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003eUnfold vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(b -\u003e (a, b)) -\u003e b -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Unfold vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "unfoldr",
        "normalized": "(a-\u003e(b,a))-\u003ea-\u003ec b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "(b-\u003e(a,b))-\u003eb-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:vector",
      "description": {
        "fct-descr": "\u003cp\u003eConvert continuation to the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "ContVec n a -\u003e v a",
        "fct-source": "src/Data-Vector-Fixed-Cont.html#vector",
        "fct-type": "function",
        "title": "vector"
      },
      "index": {
        "description": "Convert continuation to the vector",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "vector",
        "normalized": "ContVec a b-\u003ec b",
        "package": "fixed-vector",
        "partial": "",
        "signature": "ContVec n a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using function.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Vector.Fixed.Boxed (Vec3)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet b0 = basis 0 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet b1 = basis 1 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet b2 = basis 2 :: Vec3 Int\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet vplus x y = zipWith (+) x y\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003evplus b0 b1\n\u003c/code\u003e\u003c/strong\u003efromList [1,1,0]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003evplus b0 b2\n\u003c/code\u003e\u003c/strong\u003efromList [1,0,1]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003evplus b1 b2\n\u003c/code\u003e\u003c/strong\u003efromList [0,1,1]\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e v a -\u003e v b -\u003e v c",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "Zip two vector together using function Examples import Data.Vector.Fixed.Boxed Vec3 let b0 basis Vec3 Int let b1 basis Vec3 Int let b2 basis Vec3 Int let vplus zipWith vplus b0 b1 fromList vplus b0 b2 fromList vplus b1 b2 fromList",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003ev a-\u003ev b-\u003ev c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/fixed-vector/docs/Data-Vector-Fixed.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003eZip two vector together using monadic function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fixed",
        "fct-package": "fixed-vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e v a -\u003e v b -\u003e m (v c)",
        "fct-source": "src/Data-Vector-Fixed-Internal.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "Zip two vector together using monadic function",
        "hierarchy": "Data Vector Fixed",
        "module": "Data.Vector.Fixed",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003ee a-\u003ee b-\u003ec(e d)",
        "package": "fixed-vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003ev a-\u003ev b-\u003em(v c)"
      }
    }
  }
]
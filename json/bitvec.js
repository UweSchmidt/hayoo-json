[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Bit.html#",
      "description": {
        "fct-module": "Data.Bit",
        "fct-package": "bitvec",
        "fct-signature": "module",
        "fct-source": "src/Data-Bit.html",
        "fct-type": "module",
        "title": "Bit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Bit",
        "module": "Data.Bit",
        "name": "Bit",
        "normalized": "",
        "package": "bitvec",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Bit.html#t:Bit",
      "description": {
        "fct-module": "Data.Bit",
        "fct-package": "bitvec",
        "fct-signature": "data",
        "fct-source": "src/Data-Bit-Internal.html#Bit",
        "fct-type": "data",
        "title": "Bit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Bit",
        "module": "Data.Bit",
        "name": "Bit",
        "normalized": "",
        "package": "bitvec",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Bit.html#v:fromBool",
      "description": {
        "fct-module": "Data.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Bool -\u003e Bit",
        "fct-source": "src/Data-Bit-Internal.html#fromBool",
        "fct-type": "function",
        "title": "fromBool"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Bit",
        "module": "Data.Bit",
        "name": "fromBool",
        "normalized": "Bool-\u003eBit",
        "package": "bitvec",
        "partial": "Bool",
        "signature": "Bool-\u003eBit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Bit.html#v:toBool",
      "description": {
        "fct-module": "Data.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Bit -\u003e Bool",
        "fct-source": "src/Data-Bit-Internal.html#toBool",
        "fct-type": "function",
        "title": "toBool"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Bit",
        "module": "Data.Bit",
        "name": "toBool",
        "normalized": "Bit-\u003eBool",
        "package": "bitvec",
        "partial": "Bool",
        "signature": "Bit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html",
        "fct-type": "module",
        "title": "Bit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "Bit",
        "normalized": "",
        "package": "bitvec",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:all",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector Bit -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eVector Bit-\u003eBool",
        "package": "bitvec",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector Bit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:allBits",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Bit -\u003e Vector Bit -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#allBits",
        "fct-type": "function",
        "title": "allBits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "allBits",
        "normalized": "Bit-\u003eVector Bit-\u003eBool",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "Bit-\u003eVector Bit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if all bits in the vector are set\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "True if all bits in the vector are set",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "and",
        "normalized": "Vector Bit-\u003eBool",
        "package": "bitvec",
        "partial": "",
        "signature": "Vector Bit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:any",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector Bit -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eVector Bit-\u003eBool",
        "package": "bitvec",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector Bit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:anyBits",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Bit -\u003e Vector Bit -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#anyBits",
        "fct-type": "function",
        "title": "anyBits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "anyBits",
        "normalized": "Bit-\u003eVector Bit-\u003eBool",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "Bit-\u003eVector Bit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:countBits",
      "description": {
        "fct-descr": "\u003cp\u003ereturn the number of ones in a bit vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#countBits",
        "fct-type": "function",
        "title": "countBits"
      },
      "index": {
        "description": "return the number of ones in bit vector",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "countBits",
        "normalized": "Vector Bit-\u003eInt",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "Vector Bit-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:difference",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#difference",
        "fct-type": "function",
        "title": "difference"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "difference",
        "normalized": "Vector Bit-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "",
        "signature": "Vector Bit-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:exclude",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a vector of bits and a vector of things, extract those things for which the corresponding bit is unset.\n\u003c/p\u003e\u003cp\u003eFor example, \u003ccode\u003eexclude (V.map (fromBool . p) x) x == V.filter (not . p) x\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "v1 Bit -\u003e v2 t -\u003e [t]",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#exclude",
        "fct-type": "function",
        "title": "exclude"
      },
      "index": {
        "description": "Given vector of bits and vector of things extract those things for which the corresponding bit is unset For example exclude V.map fromBool V.filter not",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "exclude",
        "normalized": "a Bit-\u003ea b-\u003e[b]",
        "package": "bitvec",
        "partial": "",
        "signature": "v Bit-\u003ev t-\u003e[t]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:excludeBits",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#excludeBits",
        "fct-type": "function",
        "title": "excludeBits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "excludeBits",
        "normalized": "Vector Bit-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "Vector Bit-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:findIndex",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector Bit -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eVector Bit-\u003eMaybe Int",
        "package": "bitvec",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003eVector Bit-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:first",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the address of the first bit in the vector with the specified value, if any\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Bit -\u003e Vector Bit -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#first",
        "fct-type": "function",
        "title": "first"
      },
      "index": {
        "description": "Return the address of the first bit in the vector with the specified value if any",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "first",
        "normalized": "Bit-\u003eVector Bit-\u003eMaybe Int",
        "package": "bitvec",
        "partial": "",
        "signature": "Bit-\u003eVector Bit-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:fromWords",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a number of bits and a vector of words, concatenate them to a vector of bits (interpreting the words in little-endian order, as described at \u003ccode\u003e\u003ca\u003eindexWord\u003c/a\u003e\u003c/code\u003e).  If there are not enough words for the number of bits requested, the vector will be zero-padded.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Int -\u003e Vector Word -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#fromWords",
        "fct-type": "function",
        "title": "fromWords"
      },
      "index": {
        "description": "Given number of bits and vector of words concatenate them to vector of bits interpreting the words in little-endian order as described at indexWord If there are not enough words for the number of bits requested the vector will be zero-padded",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "fromWords",
        "normalized": "Int-\u003eVector Word-\u003eVector Bit",
        "package": "bitvec",
        "partial": "Words",
        "signature": "Int-\u003eVector Word-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:indexWord",
      "description": {
        "fct-descr": "\u003cp\u003eread a word at the given bit offset in little-endian order (i.e., the LSB will correspond to the bit at the given address, the 2's bit will correspond to the address + 1, etc.).  If the offset is such that the word extends past the end of the vector, the result is zero-padded.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Int -\u003e Word",
        "fct-source": "src/Data-Vector-Unboxed-Bit-Internal.html#indexWord",
        "fct-type": "function",
        "title": "indexWord"
      },
      "index": {
        "description": "read word at the given bit offset in little-endian order i.e the LSB will correspond to the bit at the given address the bit will correspond to the address etc If the offset is such that the word extends past the end of the vector the result is zero-padded",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "indexWord",
        "normalized": "Vector Bit-\u003eInt-\u003eWord",
        "package": "bitvec",
        "partial": "Word",
        "signature": "Vector Bit-\u003eInt-\u003eWord"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:intersection",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#intersection",
        "fct-type": "function",
        "title": "intersection"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "intersection",
        "normalized": "Vector Bit-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "",
        "signature": "Vector Bit-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:intersections",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Int -\u003e [Vector Bit] -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#intersections",
        "fct-type": "function",
        "title": "intersections"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "intersections",
        "normalized": "Int-\u003e[Vector Bit]-\u003eVector Bit",
        "package": "bitvec",
        "partial": "",
        "signature": "Int-\u003e[Vector Bit]-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:invert",
      "description": {
        "fct-descr": "\u003cp\u003eFlip every bit in the given vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#invert",
        "fct-type": "function",
        "title": "invert"
      },
      "index": {
        "description": "Flip every bit in the given vector",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "invert",
        "normalized": "Vector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "",
        "signature": "Vector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:listBits",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e [Int]",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#listBits",
        "fct-type": "function",
        "title": "listBits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "listBits",
        "normalized": "Vector Bit-\u003e[Int]",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "Vector Bit-\u003e[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if any bit in the vector is set\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "True if any bit in the vector is set",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "or",
        "normalized": "Vector Bit-\u003eBool",
        "package": "bitvec",
        "partial": "",
        "signature": "Vector Bit-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:pad",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Int -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit-Internal.html#pad",
        "fct-type": "function",
        "title": "pad"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "pad",
        "normalized": "Int-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "",
        "signature": "Int-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:padWith",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Bit -\u003e Int -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit-Internal.html#padWith",
        "fct-type": "function",
        "title": "padWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "padWith",
        "normalized": "Bit-\u003eInt-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "With",
        "signature": "Bit-\u003eInt-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:reverse",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "reverse",
        "normalized": "Vector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "",
        "signature": "Vector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:select",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a vector of bits and a vector of things, extract those things for which the corresponding bit is set.\n\u003c/p\u003e\u003cp\u003eFor example, \u003ccode\u003eselect (V.map (fromBool . p) x) x == V.filter p x\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "v1 Bit -\u003e v2 t -\u003e [t]",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#select",
        "fct-type": "function",
        "title": "select"
      },
      "index": {
        "description": "Given vector of bits and vector of things extract those things for which the corresponding bit is set For example select V.map fromBool V.filter",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "select",
        "normalized": "a Bit-\u003ea b-\u003e[b]",
        "package": "bitvec",
        "partial": "",
        "signature": "v Bit-\u003ev t-\u003e[t]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:selectBits",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#selectBits",
        "fct-type": "function",
        "title": "selectBits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "selectBits",
        "normalized": "Vector Bit-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "Vector Bit-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:symDiff",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#symDiff",
        "fct-type": "function",
        "title": "symDiff"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "symDiff",
        "normalized": "Vector Bit-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "Diff",
        "signature": "Vector Bit-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:toWords",
      "description": {
        "fct-descr": "\u003cp\u003eGiven a vector of bits, extract an unboxed vector of words.  If the bits don't completely fill the words, the last word will be zero-padded.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Word",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#toWords",
        "fct-type": "function",
        "title": "toWords"
      },
      "index": {
        "description": "Given vector of bits extract an unboxed vector of words If the bits don completely fill the words the last word will be zero-padded",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "toWords",
        "normalized": "Vector Bit-\u003eVector Word",
        "package": "bitvec",
        "partial": "Words",
        "signature": "Vector Bit-\u003eVector Word"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:union",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#union",
        "fct-type": "function",
        "title": "union"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "union",
        "normalized": "Vector Bit-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "",
        "signature": "Vector Bit-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:unions",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Int -\u003e [Vector Bit] -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#unions",
        "fct-type": "function",
        "title": "unions"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "unions",
        "normalized": "Int-\u003e[Vector Bit]-\u003eVector Bit",
        "package": "bitvec",
        "partial": "",
        "signature": "Int-\u003e[Vector Bit]-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:wordLength",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#wordLength",
        "fct-type": "function",
        "title": "wordLength"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "wordLength",
        "normalized": "Vector Bit-\u003eInt",
        "package": "bitvec",
        "partial": "Length",
        "signature": "Vector Bit-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:wordSize",
      "description": {
        "fct-descr": "\u003cp\u003eThe number of \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es in a \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e.  A handy constant to have around when defining \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e-based bulk operations on bit vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Int",
        "fct-source": "src/Data-Bit-Internal.html#wordSize",
        "fct-type": "function",
        "title": "wordSize"
      },
      "index": {
        "description": "The number of Bit in Word handy constant to have around when defining Word based bulk operations on bit vectors",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "wordSize",
        "normalized": "",
        "package": "bitvec",
        "partial": "Size",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Bit.html#v:zipWords",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003ezipWords f xs ys\u003c/code\u003e = \u003ccode\u003efromWords (min (length xs) (length ys)) (zipWith f (toWords xs) (toWords ys))\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(Word -\u003e Word -\u003e Word) -\u003e Vector Bit -\u003e Vector Bit -\u003e Vector Bit",
        "fct-source": "src/Data-Vector-Unboxed-Bit.html#zipWords",
        "fct-type": "function",
        "title": "zipWords"
      },
      "index": {
        "description": "zipWords xs ys fromWords min length xs length ys zipWith toWords xs toWords ys",
        "hierarchy": "Data Vector Unboxed Bit",
        "module": "Data.Vector.Unboxed.Bit",
        "name": "zipWords",
        "normalized": "(Word-\u003eWord-\u003eWord)-\u003eVector Bit-\u003eVector Bit-\u003eVector Bit",
        "package": "bitvec",
        "partial": "Words",
        "signature": "(Word-\u003eWord-\u003eWord)-\u003eVector Bit-\u003eVector Bit-\u003eVector Bit"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html",
        "fct-type": "module",
        "title": "Bit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "Bit",
        "normalized": "",
        "package": "bitvec",
        "partial": "Bit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:all",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(Bit -\u003e Bool) -\u003e MVector (PrimState m) Bit -\u003e m Bool",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "all",
        "normalized": "(Bit-\u003eBool)-\u003eMVector(PrimState a)Bit-\u003ea Bool",
        "package": "bitvec",
        "partial": "",
        "signature": "(Bit-\u003eBool)-\u003eMVector(PrimState m)Bit-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:allBits",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Bit -\u003e MVector (PrimState m) Bit -\u003e m Bool",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#allBits",
        "fct-type": "function",
        "title": "allBits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "allBits",
        "normalized": "Bit-\u003eMVector(PrimState a)Bit-\u003ea Bool",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "Bit-\u003eMVector(PrimState m)Bit-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if all bits in the vector are set\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e m Bool",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "Returns True if all bits in the vector are set",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "and",
        "normalized": "MVector(PrimState a)Bit-\u003ea Bool",
        "package": "bitvec",
        "partial": "",
        "signature": "MVector(PrimState m)Bit-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:any",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(Bit -\u003e Bool) -\u003e MVector (PrimState m) Bit -\u003e m Bool",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "any",
        "normalized": "(Bit-\u003eBool)-\u003eMVector(PrimState a)Bit-\u003ea Bool",
        "package": "bitvec",
        "partial": "",
        "signature": "(Bit-\u003eBool)-\u003eMVector(PrimState m)Bit-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:anyBits",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Bit -\u003e MVector (PrimState m) Bit -\u003e m Bool",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#anyBits",
        "fct-type": "function",
        "title": "anyBits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "anyBits",
        "normalized": "Bit-\u003eMVector(PrimState a)Bit-\u003ea Bool",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "Bit-\u003eMVector(PrimState m)Bit-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:cloneFromWords",
      "description": {
        "fct-descr": "\u003cp\u003eClone a specified number of bits from a vector of words into a new vector of bits (interpreting the words in little-endian order, as described at \u003ccode\u003e\u003ca\u003eindexWord\u003c/a\u003e\u003c/code\u003e).  If there are not enough words for the number of bits requested, the vector will be zero-padded.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Int -\u003e MVector (PrimState m) Word -\u003e m (MVector (PrimState m) Bit)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#cloneFromWords",
        "fct-type": "function",
        "title": "cloneFromWords"
      },
      "index": {
        "description": "Clone specified number of bits from vector of words into new vector of bits interpreting the words in little-endian order as described at indexWord If there are not enough words for the number of bits requested the vector will be zero-padded",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "cloneFromWords",
        "normalized": "Int-\u003eMVector(PrimState a)Word-\u003ea(MVector(PrimState a)Bit)",
        "package": "bitvec",
        "partial": "From Words",
        "signature": "Int-\u003eMVector(PrimState m)Word-\u003em(MVector(PrimState m)Bit)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:cloneToWords",
      "description": {
        "fct-descr": "\u003cp\u003eclone a vector of bits to a new unboxed vector of words.  If the bits don't completely fill the words, the last word will be zero-padded.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e m (MVector (PrimState m) Word)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#cloneToWords",
        "fct-type": "function",
        "title": "cloneToWords"
      },
      "index": {
        "description": "clone vector of bits to new unboxed vector of words If the bits don completely fill the words the last word will be zero-padded",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "cloneToWords",
        "normalized": "MVector(PrimState a)Bit-\u003ea(MVector(PrimState a)Word)",
        "package": "bitvec",
        "partial": "To Words",
        "signature": "MVector(PrimState m)Bit-\u003em(MVector(PrimState m)Word)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:countBits",
      "description": {
        "fct-descr": "\u003cp\u003ereturn the number of ones in a bit vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e m Int",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#countBits",
        "fct-type": "function",
        "title": "countBits"
      },
      "index": {
        "description": "return the number of ones in bit vector",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "countBits",
        "normalized": "MVector(PrimState a)Bit-\u003ea Int",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "MVector(PrimState m)Bit-\u003em Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:differenceInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e Vector Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#differenceInPlace",
        "fct-type": "function",
        "title": "differenceInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "differenceInPlace",
        "normalized": "MVector(PrimState a)Bit-\u003eVector Bit-\u003ea()",
        "package": "bitvec",
        "partial": "In Place",
        "signature": "MVector(PrimState m)Bit-\u003eVector Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:excludeBitsInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e MVector (PrimState m) Bit -\u003e m Int",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#excludeBitsInPlace",
        "fct-type": "function",
        "title": "excludeBitsInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "excludeBitsInPlace",
        "normalized": "Vector Bit-\u003eMVector(PrimState a)Bit-\u003ea Int",
        "package": "bitvec",
        "partial": "Bits In Place",
        "signature": "Vector Bit-\u003eMVector(PrimState m)Bit-\u003em Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:intersectionInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e Vector Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#intersectionInPlace",
        "fct-type": "function",
        "title": "intersectionInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "intersectionInPlace",
        "normalized": "MVector(PrimState a)Bit-\u003eVector Bit-\u003ea()",
        "package": "bitvec",
        "partial": "In Place",
        "signature": "MVector(PrimState m)Bit-\u003eVector Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:invertInPlace",
      "description": {
        "fct-descr": "\u003cp\u003eFlip every bit in the given vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#invertInPlace",
        "fct-type": "function",
        "title": "invertInPlace"
      },
      "index": {
        "description": "Flip every bit in the given vector",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "invertInPlace",
        "normalized": "MVector(PrimState a)Bit-\u003ea()",
        "package": "bitvec",
        "partial": "In Place",
        "signature": "MVector(PrimState m)Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:listBits",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e m [Int]",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#listBits",
        "fct-type": "function",
        "title": "listBits"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "listBits",
        "normalized": "MVector(PrimState a)Bit-\u003ea[Int]",
        "package": "bitvec",
        "partial": "Bits",
        "signature": "MVector(PrimState m)Bit-\u003em[Int]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:mapInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(Word -\u003e Word) -\u003e MVector (PrimState m) Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#mapInPlace",
        "fct-type": "function",
        "title": "mapInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "mapInPlace",
        "normalized": "(Word-\u003eWord)-\u003eMVector(PrimState a)Bit-\u003ea()",
        "package": "bitvec",
        "partial": "In Place",
        "signature": "(Word-\u003eWord)-\u003eMVector(PrimState m)Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:mapInPlaceWithIndex",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(Int -\u003e Word -\u003e Word) -\u003e MVector (PrimState m) Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#mapInPlaceWithIndex",
        "fct-type": "function",
        "title": "mapInPlaceWithIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "mapInPlaceWithIndex",
        "normalized": "(Int-\u003eWord-\u003eWord)-\u003eMVector(PrimState a)Bit-\u003ea()",
        "package": "bitvec",
        "partial": "In Place With Index",
        "signature": "(Int-\u003eWord-\u003eWord)-\u003eMVector(PrimState m)Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:mapMInPlace",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003emapMInPlaceWithIndex\u003c/a\u003e\u003c/code\u003e but without the index.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(Word -\u003e m Word) -\u003e MVector (PrimState m) Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#mapMInPlace",
        "fct-type": "function",
        "title": "mapMInPlace"
      },
      "index": {
        "description": "Same as mapMInPlaceWithIndex but without the index",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "mapMInPlace",
        "normalized": "(Word-\u003ea Word)-\u003eMVector(PrimState a)Bit-\u003ea()",
        "package": "bitvec",
        "partial": "MIn Place",
        "signature": "(Word-\u003em Word)-\u003eMVector(PrimState m)Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:mapMInPlaceWithIndex",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a bit vector one \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e at a time (\u003ccode\u003e\u003ca\u003ewordSize\u003c/a\u003e\u003c/code\u003e bits at a time).  The function will be passed the bit index (which will always be \u003ccode\u003e\u003ca\u003ewordSize\u003c/a\u003e\u003c/code\u003e-aligned) and the current value of the corresponding word.  The returned word will be written back to the vector.  If there is a partial word at the end of the vector, it will be zero-padded when passed to the function and truncated when the result is written back to the array.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(Int -\u003e Word -\u003e m Word) -\u003e MVector (PrimState m) Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#mapMInPlaceWithIndex",
        "fct-type": "function",
        "title": "mapMInPlaceWithIndex"
      },
      "index": {
        "description": "Map function over bit vector one Word at time wordSize bits at time The function will be passed the bit index which will always be wordSize aligned and the current value of the corresponding word The returned word will be written back to the vector If there is partial word at the end of the vector it will be zero-padded when passed to the function and truncated when the result is written back to the array",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "mapMInPlaceWithIndex",
        "normalized": "(Int-\u003eWord-\u003ea Word)-\u003eMVector(PrimState a)Bit-\u003ea()",
        "package": "bitvec",
        "partial": "MIn Place With Index",
        "signature": "(Int-\u003eWord-\u003em Word)-\u003eMVector(PrimState m)Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if any bit in the vector is set\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e m Bool",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "Returns True if any bit in the vector is set",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "or",
        "normalized": "MVector(PrimState a)Bit-\u003ea Bool",
        "package": "bitvec",
        "partial": "",
        "signature": "MVector(PrimState m)Bit-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:readWord",
      "description": {
        "fct-descr": "\u003cp\u003eread a word at the given bit offset in little-endian order (i.e., the LSB will correspond to the bit at the given address, the 2's bit will correspond to the address + 1, etc.).  If the offset is such that the word extends past the end of the vector, the result is zero-padded.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e Int -\u003e m Word",
        "fct-source": "src/Data-Vector-Unboxed-Bit-Internal.html#readWord",
        "fct-type": "function",
        "title": "readWord"
      },
      "index": {
        "description": "read word at the given bit offset in little-endian order i.e the LSB will correspond to the bit at the given address the bit will correspond to the address etc If the offset is such that the word extends past the end of the vector the result is zero-padded",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "readWord",
        "normalized": "MVector(PrimState a)Bit-\u003eInt-\u003ea Word",
        "package": "bitvec",
        "partial": "Word",
        "signature": "MVector(PrimState m)Bit-\u003eInt-\u003em Word"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:reverseInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#reverseInPlace",
        "fct-type": "function",
        "title": "reverseInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "reverseInPlace",
        "normalized": "MVector(PrimState a)Bit-\u003ea()",
        "package": "bitvec",
        "partial": "In Place",
        "signature": "MVector(PrimState m)Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:selectBitsInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Vector Bit -\u003e MVector (PrimState m) Bit -\u003e m Int",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#selectBitsInPlace",
        "fct-type": "function",
        "title": "selectBitsInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "selectBitsInPlace",
        "normalized": "Vector Bit-\u003eMVector(PrimState a)Bit-\u003ea Int",
        "package": "bitvec",
        "partial": "Bits In Place",
        "signature": "Vector Bit-\u003eMVector(PrimState m)Bit-\u003em Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:symDiffInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e Vector Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#symDiffInPlace",
        "fct-type": "function",
        "title": "symDiffInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "symDiffInPlace",
        "normalized": "MVector(PrimState a)Bit-\u003eVector Bit-\u003ea()",
        "package": "bitvec",
        "partial": "Diff In Place",
        "signature": "MVector(PrimState m)Bit-\u003eVector Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:unionInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e Vector Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#unionInPlace",
        "fct-type": "function",
        "title": "unionInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "unionInPlace",
        "normalized": "MVector(PrimState a)Bit-\u003eVector Bit-\u003ea()",
        "package": "bitvec",
        "partial": "In Place",
        "signature": "MVector(PrimState m)Bit-\u003eVector Bit-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:wordLength",
      "description": {
        "fct-descr": "\u003cp\u003eGet the length of the vector that would be created by \u003ccode\u003e\u003ca\u003ecloneToWords\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector s Bit -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#wordLength",
        "fct-type": "function",
        "title": "wordLength"
      },
      "index": {
        "description": "Get the length of the vector that would be created by cloneToWords",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "wordLength",
        "normalized": "MVector a Bit-\u003eInt",
        "package": "bitvec",
        "partial": "Length",
        "signature": "MVector s Bit-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:wordSize",
      "description": {
        "fct-descr": "\u003cp\u003eThe number of \u003ccode\u003e\u003ca\u003eBit\u003c/a\u003e\u003c/code\u003es in a \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e.  A handy constant to have around when defining \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e-based bulk operations on bit vectors.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "Int",
        "fct-source": "src/Data-Bit-Internal.html#wordSize",
        "fct-type": "function",
        "title": "wordSize"
      },
      "index": {
        "description": "The number of Bit in Word handy constant to have around when defining Word based bulk operations on bit vectors",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "wordSize",
        "normalized": "",
        "package": "bitvec",
        "partial": "Size",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:writeWord",
      "description": {
        "fct-descr": "\u003cp\u003ewrite a word at the given bit offset in little-endian order (i.e., the LSB will correspond to the bit at the given address, the 2's bit will correspond to the address + 1, etc.).  If the offset is such that the word extends past the end of the vector, the word is truncated and as many low-order bits as possible are written.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "MVector (PrimState m) Bit -\u003e Int -\u003e Word -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Bit-Internal.html#writeWord",
        "fct-type": "function",
        "title": "writeWord"
      },
      "index": {
        "description": "write word at the given bit offset in little-endian order i.e the LSB will correspond to the bit at the given address the bit will correspond to the address etc If the offset is such that the word extends past the end of the vector the word is truncated and as many low-order bits as possible are written",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "writeWord",
        "normalized": "MVector(PrimState a)Bit-\u003eInt-\u003eWord-\u003ea()",
        "package": "bitvec",
        "partial": "Word",
        "signature": "MVector(PrimState m)Bit-\u003eInt-\u003eWord-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/bitvec/docs/Data-Vector-Unboxed-Mutable-Bit.html#v:zipInPlace",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable.Bit",
        "fct-package": "bitvec",
        "fct-signature": "(Word -\u003e Word -\u003e Word) -\u003e MVector (PrimState m) Bit -\u003e Vector Bit -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable-Bit.html#zipInPlace",
        "fct-type": "function",
        "title": "zipInPlace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable Bit",
        "module": "Data.Vector.Unboxed.Mutable.Bit",
        "name": "zipInPlace",
        "normalized": "(Word-\u003eWord-\u003eWord)-\u003eMVector(PrimState a)Bit-\u003eVector Bit-\u003ea()",
        "package": "bitvec",
        "partial": "In Place",
        "signature": "(Word-\u003eWord-\u003eWord)-\u003eMVector(PrimState m)Bit-\u003eVector Bit-\u003em()"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-DHoley.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFilling and extracting derivatives (one-hole contexts)\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.DHoley",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-DHoley.html",
        "fct-type": "module",
        "title": "DHoley"
      },
      "index": {
        "description": "Filling and extracting derivatives one-hole contexts",
        "hierarchy": "FunctorCombo DHoley",
        "module": "FunctorCombo.DHoley",
        "name": "DHoley",
        "normalized": "",
        "package": "functor-combo",
        "partial": "DHoley",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-DHoley.html#t:Holey",
      "description": {
        "fct-module": "FunctorCombo.DHoley",
        "fct-package": "functor-combo",
        "fct-signature": "class",
        "fct-source": "src/FunctorCombo-DHoley.html#Holey",
        "fct-type": "class",
        "title": "Holey"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo DHoley",
        "module": "FunctorCombo.DHoley",
        "name": "Holey",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Holey",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-DHoley.html#v:extract",
      "description": {
        "fct-descr": "\u003cp\u003eAll extractions\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.DHoley",
        "fct-package": "functor-combo",
        "fct-signature": "f a -\u003e f (Loc f a)",
        "fct-source": "src/FunctorCombo-DHoley.html#extract",
        "fct-type": "method",
        "title": "extract"
      },
      "index": {
        "description": "All extractions",
        "hierarchy": "FunctorCombo DHoley",
        "module": "FunctorCombo.DHoley",
        "name": "extract",
        "normalized": "a b-\u003ea(Loc a b)",
        "package": "functor-combo",
        "partial": "",
        "signature": "f a-\u003ef(Loc f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-DHoley.html#v:fill",
      "description": {
        "fct-descr": "\u003cp\u003eAlternative interface for \u003ccode\u003e\u003ca\u003efillC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.DHoley",
        "fct-package": "functor-combo",
        "fct-signature": "Loc f a -\u003e f a",
        "fct-source": "src/FunctorCombo-DHoley.html#fill",
        "fct-type": "function",
        "title": "fill"
      },
      "index": {
        "description": "Alternative interface for fillC",
        "hierarchy": "FunctorCombo DHoley",
        "module": "FunctorCombo.DHoley",
        "name": "fill",
        "normalized": "Loc a b-\u003ea b",
        "package": "functor-combo",
        "partial": "",
        "signature": "Loc f a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-DHoley.html#v:fillC",
      "description": {
        "fct-descr": "\u003cp\u003eFill a hole\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.DHoley",
        "fct-package": "functor-combo",
        "fct-signature": "Der f a -\u003e a -\u003e f a",
        "fct-source": "src/FunctorCombo-DHoley.html#fillC",
        "fct-type": "method",
        "title": "fillC"
      },
      "index": {
        "description": "Fill hole",
        "hierarchy": "FunctorCombo DHoley",
        "module": "FunctorCombo.DHoley",
        "name": "fillC",
        "normalized": "Der a b-\u003eb-\u003ea b",
        "package": "functor-combo",
        "partial": "",
        "signature": "Der f a-\u003ea-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Derivative.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerivatives (one-hole contexts) for standard Functor combinators\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.Derivative",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-Derivative.html",
        "fct-type": "module",
        "title": "Derivative"
      },
      "index": {
        "description": "Derivatives one-hole contexts for standard Functor combinators",
        "hierarchy": "FunctorCombo Derivative",
        "module": "FunctorCombo.Derivative",
        "name": "Derivative",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Derivative",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Derivative.html#t:Der",
      "description": {
        "fct-descr": "\u003cp\u003eA derivative, i.e., a one-hole context for a container f (probably a functor).\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Derivative",
        "fct-package": "functor-combo",
        "fct-signature": "Der",
        "fct-type": "function",
        "title": "Der"
      },
      "index": {
        "description": "derivative i.e one-hole context for container probably functor",
        "hierarchy": "FunctorCombo Derivative",
        "module": "FunctorCombo.Derivative",
        "name": "Der",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Der",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStandard building blocks for functors\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-Functor.html",
        "fct-type": "module",
        "title": "Functor"
      },
      "index": {
        "description": "Standard building blocks for functors",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Functor",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Functor",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t::-42-:",
      "description": {
        "fct-descr": "\u003cp\u003eProduct on unary type constructors\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2A%3A",
        "fct-type": "data",
        "title": ":*:"
      },
      "index": {
        "description": "Product on unary type constructors",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": ":*:",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t::-42-:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eStrict product functor\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2A%3A%21",
        "fct-type": "data",
        "title": ":*:!"
      },
      "index": {
        "description": "Strict product functor",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": ":*:!",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t::-43-:",
      "description": {
        "fct-descr": "\u003cp\u003eSum on unary type constructors\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2B%3A",
        "fct-type": "data",
        "title": ":+:"
      },
      "index": {
        "description": "Sum on unary type constructors",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": ":+:",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t::-43-:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eStrict sum functor\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2B%3A%21",
        "fct-type": "data",
        "title": ":+:!"
      },
      "index": {
        "description": "Strict sum functor",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": ":+:!",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t::.",
      "description": {
        "fct-descr": "\u003cp\u003eComposition of unary type constructors\n\u003c/p\u003e\u003cp\u003eThere are (at least) two useful \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e instances, so you'll have to\npick one and type-specialize it (filling in all or parts of \u003ccode\u003eg\u003c/code\u003e and/or \u003ccode\u003ef\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e     -- standard Monoid instance for Applicative applied to Monoid\n     instance (Applicative (g :. f), Monoid a) =\u003e Monoid ((g :. f) a) where\n       { mempty = pure mempty; mappend = liftA2 mappend }\n     -- Especially handy when g is a Monoid_f.\n     instance Monoid (g (f a)) =\u003e Monoid ((g :. f) a) where\n       { mempty = O mempty; mappend = inO2 mappend }\n\u003c/pre\u003e\u003cp\u003eCorresponding to the first and second definitions above,\n\u003c/p\u003e\u003cpre\u003e     instance (Applicative g, Monoid_f f) =\u003e Monoid_f (g :. f) where\n       { mempty_f = O (pure mempty_f); mappend_f = inO2 (liftA2 mappend_f) }\n     instance Monoid_f g =\u003e Monoid_f (g :. f) where\n       { mempty_f = O mempty_f; mappend_f = inO2 mappend_f }\n\u003c/pre\u003e\u003cp\u003eSimilarly, there are two useful \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instances and two useful\n\u003ccode\u003e\u003ca\u003eContraFunctor\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003cpre\u003e     instance (      Functor g,       Functor f) =\u003e Functor (g :. f) where fmap = fmapFF\n     instance (ContraFunctor g, ContraFunctor f) =\u003e Functor (g :. f) where fmap = fmapCC\n \n     instance (      Functor g, ContraFunctor f) =\u003e ContraFunctor (g :. f) where contraFmap = contraFmapFC\n     instance (ContraFunctor g,       Functor f) =\u003e ContraFunctor (g :. f) where contraFmap = contraFmapCF\n\u003c/pre\u003e\u003cp\u003eHowever, it's such a bother to define the Functor instances per\ncomposition type, I've left the fmapFF case in.  If you want the fmapCC\none, you're out of luck for now.  I'd love to hear a good solution.  Maybe\nsomeday Haskell will do Prolog-style search for instances, subgoaling the\nconstraints, rather than just matching instance heads.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "newtype",
        "fct-type": "newtype",
        "title": ":."
      },
      "index": {
        "description": "Composition of unary type constructors There are at least two useful Monoid instances so you ll have to pick one and type-specialize it filling in all or parts of and or standard Monoid instance for Applicative applied to Monoid instance Applicative Monoid Monoid where mempty pure mempty mappend liftA2 mappend Especially handy when is Monoid instance Monoid Monoid where mempty mempty mappend inO2 mappend Corresponding to the first and second definitions above instance Applicative Monoid Monoid where mempty pure mempty mappend inO2 liftA2 mappend instance Monoid Monoid where mempty mempty mappend inO2 mappend Similarly there are two useful Functor instances and two useful ContraFunctor instances instance Functor Functor Functor where fmap fmapFF instance ContraFunctor ContraFunctor Functor where fmap fmapCC instance Functor ContraFunctor ContraFunctor where contraFmap contraFmapFC instance ContraFunctor Functor ContraFunctor where contraFmap contraFmapCF However it such bother to define the Functor instances per composition type ve left the fmapFF case in If you want the fmapCC one you re out of luck for now love to hear good solution Maybe someday Haskell will do Prolog-style search for instances subgoaling the constraints rather than just matching instance heads",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": ":.",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t:Const",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "newtype",
        "fct-type": "newtype",
        "title": "Const"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Const",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Const",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t:EncodeF",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "class",
        "fct-source": "src/FunctorCombo-Functor.html#EncodeF",
        "fct-type": "class",
        "title": "EncodeF"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "EncodeF",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Encode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t:Id",
      "description": {
        "fct-descr": "\u003cp\u003eIdentity type constructor.  Until there's a better place to find it.\n I'd use \u003ca\u003eControl.Monad.Identity\u003c/a\u003e, but I don't want to introduce a\n dependency on mtl just for Id.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "newtype",
        "fct-type": "newtype",
        "title": "Id"
      },
      "index": {
        "description": "Identity type constructor Until there better place to find it use Control.Monad.Identity but don want to introduce dependency on mtl just for Id",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Id",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t:Lift",
      "description": {
        "fct-descr": "\u003cp\u003eAdd a bottom to a type\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Functor.html#Lift",
        "fct-type": "data",
        "title": "Lift"
      },
      "index": {
        "description": "Add bottom to type",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Lift",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Lift",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t:Unit",
      "description": {
        "fct-descr": "\u003cp\u003eUnit type constructor (one inhabitant)\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-Functor.html#Unit",
        "fct-type": "type",
        "title": "Unit"
      },
      "index": {
        "description": "Unit type constructor one inhabitant",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Unit",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Unit",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#t:Void",
      "description": {
        "fct-descr": "\u003cp\u003eEmpty/zero type constructor (no inhabitants)\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Functor.html#Void",
        "fct-type": "data",
        "title": "Void"
      },
      "index": {
        "description": "Empty zero type constructor no inhabitants",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Void",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Void",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:-126--62-",
      "description": {
        "fct-descr": "\u003cp\u003eAdd pre- and post processing\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "cat a' a -\u003e cat b b' -\u003e cat a b -\u003e cat a' b'",
        "fct-type": "function",
        "title": "(~\u003e)"
      },
      "index": {
        "description": "Add pre and post processing",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "(~\u003e) ~\u003e",
        "normalized": "a b c-\u003ea d e-\u003ea c d-\u003ea b e",
        "package": "functor-combo",
        "partial": "",
        "signature": "cat a' a-\u003ecat b b'-\u003ecat a b-\u003ecat a' b'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:-60--126-",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "cat b b' -\u003e cat a' a -\u003e cat a b -\u003e cat a' b'",
        "fct-type": "function",
        "title": "(\u003c~)"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "(\u003c~) \u003c~",
        "normalized": "a b c-\u003ea d e-\u003ea e b-\u003ea d c",
        "package": "functor-combo",
        "partial": "",
        "signature": "cat b b'-\u003ecat a' a-\u003ecat a b-\u003ecat a' b'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v::-42-:",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f a) :*: (g a)",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2A%3A",
        "fct-type": "function",
        "title": ":*:"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": ":*:",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v::-42-:-33-",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "!(f a) :*:! !(g a)",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2A%3A%21",
        "fct-type": "function",
        "title": ":*:!"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": ":*:!",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:Const",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "Const",
        "fct-type": "function",
        "title": "Const"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Const",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Const",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:Id",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "Id a",
        "fct-type": "function",
        "title": "Id"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Id",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:InL",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "InL (f a)",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2B%3A",
        "fct-type": "function",
        "title": "InL"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "InL",
        "normalized": "",
        "package": "functor-combo",
        "partial": "In",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:InL-39-",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "InL' !(f a)",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2B%3A%21",
        "fct-type": "function",
        "title": "InL'"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "InL'",
        "normalized": "",
        "package": "functor-combo",
        "partial": "In L'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:InR",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "InR (g a)",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2B%3A",
        "fct-type": "function",
        "title": "InR"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "InR",
        "normalized": "",
        "package": "functor-combo",
        "partial": "In",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:InR-39-",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "InR' !(g a)",
        "fct-source": "src/FunctorCombo-Functor.html#%3A%2B%3A%21",
        "fct-type": "function",
        "title": "InR'"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "InR'",
        "normalized": "",
        "package": "functor-combo",
        "partial": "In R'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:Lift",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "Lift",
        "fct-source": "src/FunctorCombo-Functor.html#Lift",
        "fct-type": "function",
        "title": "Lift"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "Lift",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Lift",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:O",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "O (g (f a))",
        "fct-type": "function",
        "title": "O"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "O",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:asPair",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f :*: g) a -\u003e (f a, g a)",
        "fct-source": "src/FunctorCombo-Functor.html#asPair",
        "fct-type": "function",
        "title": "asPair"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "asPair",
        "normalized": "(a*b)c-\u003e(a c,b c)",
        "package": "functor-combo",
        "partial": "Pair",
        "signature": "(f*g)a-\u003e(f a,g a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:asProd",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f a, g a) -\u003e (f :*: g) a",
        "fct-source": "src/FunctorCombo-Functor.html#asProd",
        "fct-type": "function",
        "title": "asProd"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "asProd",
        "normalized": "(a b,c b)-\u003e(a*c)b",
        "package": "functor-combo",
        "partial": "Prod",
        "signature": "(f a,g a)-\u003e(f*g)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:decode",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "Enc f a -\u003e f a",
        "fct-source": "src/FunctorCombo-Functor.html#decode",
        "fct-type": "method",
        "title": "decode"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "decode",
        "normalized": "Enc a b-\u003ea b",
        "package": "functor-combo",
        "partial": "",
        "signature": "Enc f a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:eitherF",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f a -\u003e b) -\u003e (g a -\u003e b) -\u003e (f :+: g) a -\u003e b",
        "fct-source": "src/FunctorCombo-Functor.html#eitherF",
        "fct-type": "function",
        "title": "eitherF"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "eitherF",
        "normalized": "(a b-\u003ec)-\u003e(d b-\u003ec)-\u003e(a d)b-\u003ec",
        "package": "functor-combo",
        "partial": "",
        "signature": "(f a-\u003eb)-\u003e(g a-\u003eb)-\u003e(f g)a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:eitherF-39-",
      "description": {
        "fct-descr": "\u003cp\u003eCase analysis on strict sum functor\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f a -\u003e c) -\u003e (g a -\u003e c) -\u003e (f :+:! g) a -\u003e c",
        "fct-source": "src/FunctorCombo-Functor.html#eitherF%27",
        "fct-type": "function",
        "title": "eitherF'"
      },
      "index": {
        "description": "Case analysis on strict sum functor",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "eitherF'",
        "normalized": "(a b-\u003ec)-\u003e(d b-\u003ec)-\u003e(a d)b-\u003ec",
        "package": "functor-combo",
        "partial": "F'",
        "signature": "(f a-\u003ec)-\u003e(g a-\u003ec)-\u003e(f g)a-\u003ec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:encode",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "f a -\u003e Enc f a",
        "fct-source": "src/FunctorCombo-Functor.html#encode",
        "fct-type": "method",
        "title": "encode"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "encode",
        "normalized": "a b-\u003eEnc a b",
        "package": "functor-combo",
        "partial": "",
        "signature": "f a-\u003eEnc f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:fstF",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f :*: g) a -\u003e f a",
        "fct-source": "src/FunctorCombo-Functor.html#fstF",
        "fct-type": "function",
        "title": "fstF"
      },
      "index": {
        "description": "Like fst",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "fstF",
        "normalized": "(a*b)c-\u003ea c",
        "package": "functor-combo",
        "partial": "",
        "signature": "(f*g)a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:getConst",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "a",
        "fct-type": "function",
        "title": "getConst"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "getConst",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Const",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:inId",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(a -\u003e b) -\u003e Id a -\u003e Id b",
        "fct-type": "function",
        "title": "inId"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "inId",
        "normalized": "(a-\u003eb)-\u003eId a-\u003eId b",
        "package": "functor-combo",
        "partial": "Id",
        "signature": "(a-\u003eb)-\u003eId a-\u003eId b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:inId2",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e Id a -\u003e Id b -\u003e Id c",
        "fct-type": "function",
        "title": "inId2"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "inId2",
        "normalized": "(a-\u003eb-\u003ec)-\u003eId a-\u003eId b-\u003eId c",
        "package": "functor-combo",
        "partial": "Id",
        "signature": "(a-\u003eb-\u003ec)-\u003eId a-\u003eId b-\u003eId c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:inO",
      "description": {
        "fct-descr": "\u003cp\u003eApply a unary function within the \u003ccode\u003e\u003ca\u003eO\u003c/a\u003e\u003c/code\u003e constructor.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(g (f a) -\u003e g' (f' a')) -\u003e :. g f a -\u003e :. g' f' a'",
        "fct-type": "function",
        "title": "inO"
      },
      "index": {
        "description": "Apply unary function within the constructor",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "inO",
        "normalized": "(a(b c)-\u003ed(e f))-\u003ea b c-\u003ed e f",
        "package": "functor-combo",
        "partial": "",
        "signature": "(g(f a)-\u003eg'(f' a'))-\u003eg f a-\u003eg' f' a'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:inO2",
      "description": {
        "fct-descr": "\u003cp\u003eApply a binary function within the \u003ccode\u003e\u003ca\u003eO\u003c/a\u003e\u003c/code\u003e constructor.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(g (f a) -\u003e g' (f' a') -\u003e g'' (f'' a'')) -\u003e :. g f a -\u003e :. g' f' a' -\u003e :. g'' f'' a''",
        "fct-type": "function",
        "title": "inO2"
      },
      "index": {
        "description": "Apply binary function within the constructor",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "inO2",
        "normalized": "(a(b c)-\u003ed(e f)-\u003eg(h i))-\u003ea b c-\u003ed e f-\u003eg h i",
        "package": "functor-combo",
        "partial": "",
        "signature": "(g(f a)-\u003eg'(f' a')-\u003eg''(f'' a''))-\u003eg f a-\u003eg' f' a'-\u003eg'' f'' a''"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:inProd",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "((f a, g a) -\u003e (h b, i b)) -\u003e (f :*: g) a -\u003e (h :*: i) b",
        "fct-source": "src/FunctorCombo-Functor.html#inProd",
        "fct-type": "function",
        "title": "inProd"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "inProd",
        "normalized": "((a b,c b)-\u003e(d e,f e))-\u003e(a*c)b-\u003e(d*f)e",
        "package": "functor-combo",
        "partial": "Prod",
        "signature": "((f a,g a)-\u003e(h b,i b))-\u003e(f*g)a-\u003e(h*i)b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:inProd2",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "((f a, g a) -\u003e (h b, i b) -\u003e (j c, k c)) -\u003e (f :*: g) a -\u003e (h :*: i) b -\u003e (j :*: k) c",
        "fct-source": "src/FunctorCombo-Functor.html#inProd2",
        "fct-type": "function",
        "title": "inProd2"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "inProd2",
        "normalized": "((a b,c b)-\u003e(d e,f e)-\u003e(g h,i h))-\u003e(a*c)b-\u003e(d*f)e-\u003e(g*i)h",
        "package": "functor-combo",
        "partial": "Prod",
        "signature": "((f a,g a)-\u003e(h b,i b)-\u003e(j c,k c))-\u003e(f*g)a-\u003e(h*i)b-\u003e(j*k)c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:pairF",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f a, g a) -\u003e (f :*: g) a",
        "fct-source": "src/FunctorCombo-Functor.html#pairF",
        "fct-type": "function",
        "title": "pairF"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "pairF",
        "normalized": "(a b,c b)-\u003e(a*c)b",
        "package": "functor-combo",
        "partial": "",
        "signature": "(f a,g a)-\u003e(f*g)a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:sndF",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003esnd\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f :*: g) a -\u003e g a",
        "fct-source": "src/FunctorCombo-Functor.html#sndF",
        "fct-type": "function",
        "title": "sndF"
      },
      "index": {
        "description": "Like snd",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "sndF",
        "normalized": "(a*b)c-\u003eb c",
        "package": "functor-combo",
        "partial": "",
        "signature": "(f*g)a-\u003eg a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:unId",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "Id a -\u003e a",
        "fct-type": "function",
        "title": "unId"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "unId",
        "normalized": "Id a-\u003ea",
        "package": "functor-combo",
        "partial": "Id",
        "signature": "Id a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:unLift",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "a",
        "fct-source": "src/FunctorCombo-Functor.html#Lift",
        "fct-type": "function",
        "title": "unLift"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "unLift",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Lift",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:unO",
      "description": {
        "fct-descr": "\u003cp\u003eUnwrap a '(:.)'.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": ":. g f a -\u003e g (f a)",
        "fct-type": "function",
        "title": "unO"
      },
      "index": {
        "description": "Unwrap",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "unO",
        "normalized": "a b c-\u003ea(b c)",
        "package": "functor-combo",
        "partial": "",
        "signature": "g f a-\u003eg(f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:unPairF",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "(f :*: g) a -\u003e (f a, g a)",
        "fct-source": "src/FunctorCombo-Functor.html#unPairF",
        "fct-type": "function",
        "title": "unPairF"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "unPairF",
        "normalized": "(a*b)c-\u003e(a c,b c)",
        "package": "functor-combo",
        "partial": "Pair",
        "signature": "(f*g)a-\u003e(f a,g a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:unit",
      "description": {
        "fct-descr": "\u003cp\u003eThe unit value\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "Unit ()",
        "fct-source": "src/FunctorCombo-Functor.html#unit",
        "fct-type": "function",
        "title": "unit"
      },
      "index": {
        "description": "The unit value",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "unit",
        "normalized": "Unit()",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unit()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Functor.html#v:voidF",
      "description": {
        "fct-module": "FunctorCombo.Functor",
        "fct-package": "functor-combo",
        "fct-signature": "Void a -\u003e b",
        "fct-source": "src/FunctorCombo-Functor.html#voidF",
        "fct-type": "function",
        "title": "voidF"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Functor",
        "module": "FunctorCombo.Functor",
        "name": "voidF",
        "normalized": "Void a-\u003eb",
        "package": "functor-combo",
        "partial": "",
        "signature": "Void a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Holey.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFilling and extracting derivatives (one-hole contexts)\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.Holey",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-Holey.html",
        "fct-type": "module",
        "title": "Holey"
      },
      "index": {
        "description": "Filling and extracting derivatives one-hole contexts",
        "hierarchy": "FunctorCombo Holey",
        "module": "FunctorCombo.Holey",
        "name": "Holey",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Holey",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Holey.html#t:Holey",
      "description": {
        "fct-descr": "\u003cp\u003eFilling and creating one-hole contexts\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Holey",
        "fct-package": "functor-combo",
        "fct-signature": "class",
        "fct-source": "src/FunctorCombo-Holey.html#Holey",
        "fct-type": "class",
        "title": "Holey"
      },
      "index": {
        "description": "Filling and creating one-hole contexts",
        "hierarchy": "FunctorCombo Holey",
        "module": "FunctorCombo.Holey",
        "name": "Holey",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Holey",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Holey.html#t:Loc",
      "description": {
        "fct-descr": "\u003cp\u003eLocation, i.e., one-hole context and a value for the hole.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Holey",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-Holey.html#Loc",
        "fct-type": "type",
        "title": "Loc"
      },
      "index": {
        "description": "Location i.e one-hole context and value for the hole",
        "hierarchy": "FunctorCombo Holey",
        "module": "FunctorCombo.Holey",
        "name": "Loc",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Loc",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Holey.html#v:extract",
      "description": {
        "fct-module": "FunctorCombo.Holey",
        "fct-package": "functor-combo",
        "fct-signature": "extract",
        "fct-source": "src/FunctorCombo-Holey.html#extract",
        "fct-type": "method",
        "title": "extract"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Holey",
        "module": "FunctorCombo.Holey",
        "name": "extract",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Holey.html#v:fill",
      "description": {
        "fct-descr": "\u003cp\u003eAlternative interface for \u003ccode\u003e\u003ca\u003efillC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Holey",
        "fct-package": "functor-combo",
        "fct-signature": "Loc f a -\u003e f a",
        "fct-source": "src/FunctorCombo-Holey.html#fill",
        "fct-type": "function",
        "title": "fill"
      },
      "index": {
        "description": "Alternative interface for fillC",
        "hierarchy": "FunctorCombo Holey",
        "module": "FunctorCombo.Holey",
        "name": "fill",
        "normalized": "Loc a b-\u003ea b",
        "package": "functor-combo",
        "partial": "",
        "signature": "Loc f a-\u003ef a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Holey.html#v:fillC",
      "description": {
        "fct-module": "FunctorCombo.Holey",
        "fct-package": "functor-combo",
        "fct-signature": "fillC",
        "fct-source": "src/FunctorCombo-Holey.html#fillC",
        "fct-type": "method",
        "title": "fillC"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Holey",
        "module": "FunctorCombo.Holey",
        "name": "fillC",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-LubF.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLeast upper bounds for functor combinators\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.LubF",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-LubF.html",
        "fct-type": "module",
        "title": "LubF"
      },
      "index": {
        "description": "Least upper bounds for functor combinators",
        "hierarchy": "FunctorCombo LubF",
        "module": "FunctorCombo.LubF",
        "name": "LubF",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Lub",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-LubF.html#t:HasLubF",
      "description": {
        "fct-module": "FunctorCombo.LubF",
        "fct-package": "functor-combo",
        "fct-signature": "class",
        "fct-source": "src/FunctorCombo-LubF.html#HasLubF",
        "fct-type": "class",
        "title": "HasLubF"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo LubF",
        "module": "FunctorCombo.LubF",
        "name": "HasLubF",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Has Lub",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-NonstrictMemo.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctor-based memo tries.  See\n \u003ca\u003ehttp://conal.net/blog/posts/details-for-nonstrict-memoization-part-1/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.NonstrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-NonstrictMemo.html",
        "fct-type": "module",
        "title": "NonstrictMemo"
      },
      "index": {
        "description": "Functor-based memo tries See http conal.net blog posts details-for-nonstrict-memoization-part-1",
        "hierarchy": "FunctorCombo NonstrictMemo",
        "module": "FunctorCombo.NonstrictMemo",
        "name": "NonstrictMemo",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Nonstrict Memo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-NonstrictMemo.html#t::-45--62-:",
      "description": {
        "fct-module": "FunctorCombo.NonstrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-NonstrictMemo.html#%3A-%3E%3A",
        "fct-type": "type",
        "title": ":-\u003e:"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo NonstrictMemo",
        "module": "FunctorCombo.NonstrictMemo",
        "name": ":-\u003e:",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-NonstrictMemo.html#t:HasTrie",
      "description": {
        "fct-descr": "\u003cp\u003eDomain types with associated memo tries\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.NonstrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "class",
        "fct-source": "src/FunctorCombo-NonstrictMemo.html#HasTrie",
        "fct-type": "class",
        "title": "HasTrie"
      },
      "index": {
        "description": "Domain types with associated memo tries",
        "hierarchy": "FunctorCombo NonstrictMemo",
        "module": "FunctorCombo.NonstrictMemo",
        "name": "HasTrie",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Has Trie",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-NonstrictMemo.html#v:memo",
      "description": {
        "fct-descr": "\u003cp\u003eTrie-based function memoizer\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.NonstrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (k -\u003e v)",
        "fct-source": "src/FunctorCombo-NonstrictMemo.html#memo",
        "fct-type": "function",
        "title": "memo"
      },
      "index": {
        "description": "Trie-based function memoizer",
        "hierarchy": "FunctorCombo NonstrictMemo",
        "module": "FunctorCombo.NonstrictMemo",
        "name": "memo",
        "normalized": "Unop(a-\u003eb)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop(k-\u003ev)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-NonstrictMemo.html#v:memo2",
      "description": {
        "fct-descr": "\u003cp\u003eMemoize a binary function, on its first argument and then on its\n second.  Take care to exploit any partial evaluation.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.NonstrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (s -\u003e t -\u003e a)",
        "fct-source": "src/FunctorCombo-NonstrictMemo.html#memo2",
        "fct-type": "function",
        "title": "memo2"
      },
      "index": {
        "description": "Memoize binary function on its first argument and then on its second Take care to exploit any partial evaluation",
        "hierarchy": "FunctorCombo NonstrictMemo",
        "module": "FunctorCombo.NonstrictMemo",
        "name": "memo2",
        "normalized": "Unop(a-\u003eb-\u003ec)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop(s-\u003et-\u003ea)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-NonstrictMemo.html#v:memo3",
      "description": {
        "fct-descr": "\u003cp\u003eMemoize a ternary function on successive arguments.  Take care to\n exploit any partial evaluation.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.NonstrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (r -\u003e s -\u003e t -\u003e a)",
        "fct-source": "src/FunctorCombo-NonstrictMemo.html#memo3",
        "fct-type": "function",
        "title": "memo3"
      },
      "index": {
        "description": "Memoize ternary function on successive arguments Take care to exploit any partial evaluation",
        "hierarchy": "FunctorCombo NonstrictMemo",
        "module": "FunctorCombo.NonstrictMemo",
        "name": "memo3",
        "normalized": "Unop(a-\u003eb-\u003ec-\u003ed)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop(r-\u003es-\u003et-\u003ea)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-NonstrictMemo.html#v:sTrie",
      "description": {
        "fct-descr": "\u003cp\u003eCreate the trie for the entire domain of a function\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.NonstrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "(k -\u003e v) -\u003e k :-\u003e v",
        "fct-source": "src/FunctorCombo-NonstrictMemo.html#sTrie",
        "fct-type": "method",
        "title": "sTrie"
      },
      "index": {
        "description": "Create the trie for the entire domain of function",
        "hierarchy": "FunctorCombo NonstrictMemo",
        "module": "FunctorCombo.NonstrictMemo",
        "name": "sTrie",
        "normalized": "(a-\u003eb)-\u003ea-\u003eb",
        "package": "functor-combo",
        "partial": "Trie",
        "signature": "(k-\u003ev)-\u003ek-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-NonstrictMemo.html#v:sUntrie",
      "description": {
        "fct-descr": "\u003cp\u003eConvert k trie to k function, i.e., access k field of the trie\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.NonstrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "(k :-\u003e v) -\u003e k -\u003e v",
        "fct-source": "src/FunctorCombo-NonstrictMemo.html#sUntrie",
        "fct-type": "method",
        "title": "sUntrie"
      },
      "index": {
        "description": "Convert trie to function i.e access field of the trie",
        "hierarchy": "FunctorCombo NonstrictMemo",
        "module": "FunctorCombo.NonstrictMemo",
        "name": "sUntrie",
        "normalized": "(a-\u003eb)-\u003ea-\u003eb",
        "package": "functor-combo",
        "partial": "Untrie",
        "signature": "(k-\u003ev)-\u003ek-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePair functor\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-Pair.html",
        "fct-type": "module",
        "title": "Pair"
      },
      "index": {
        "description": "Pair functor",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "Pair",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Pair",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#t:Pair",
      "description": {
        "fct-descr": "\u003cp\u003eUniform pairs\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Pair.html#Pair",
        "fct-type": "data",
        "title": "Pair"
      },
      "index": {
        "description": "Uniform pairs",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "Pair",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Pair",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v::-35-",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "a :# a",
        "fct-source": "src/FunctorCombo-Pair.html#Pair",
        "fct-type": "function",
        "title": ":#"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": ":#",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:curryP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "(Pair a -\u003e b) -\u003e a -\u003e a -\u003e b",
        "fct-source": "src/FunctorCombo-Pair.html#curryP",
        "fct-type": "function",
        "title": "curryP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "curryP",
        "normalized": "(Pair a-\u003eb)-\u003ea-\u003ea-\u003eb",
        "package": "functor-combo",
        "partial": "",
        "signature": "(Pair a-\u003eb)-\u003ea-\u003ea-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:firstP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Unop a -\u003e Unop (Pair a)",
        "fct-source": "src/FunctorCombo-Pair.html#firstP",
        "fct-type": "function",
        "title": "firstP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "firstP",
        "normalized": "Unop a-\u003eUnop(Pair a)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop a-\u003eUnop(Pair a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:fromP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Pair a -\u003e (a, a)",
        "fct-source": "src/FunctorCombo-Pair.html#fromP",
        "fct-type": "function",
        "title": "fromP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "fromP",
        "normalized": "Pair a-\u003e(a,a)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Pair a-\u003e(a,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:fstP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Pair a -\u003e a",
        "fct-source": "src/FunctorCombo-Pair.html#fstP",
        "fct-type": "function",
        "title": "fstP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "fstP",
        "normalized": "Pair a-\u003ea",
        "package": "functor-combo",
        "partial": "",
        "signature": "Pair a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:inP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (a, a) -\u003e Unop (Pair a)",
        "fct-source": "src/FunctorCombo-Pair.html#inP",
        "fct-type": "function",
        "title": "inP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "inP",
        "normalized": "Unop(a,a)-\u003eUnop(Pair a)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop(a,a)-\u003eUnop(Pair a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:inZipA",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (f (Pair a)) -\u003e Unop (Pair (f a))",
        "fct-source": "src/FunctorCombo-Pair.html#inZipA",
        "fct-type": "function",
        "title": "inZipA"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "inZipA",
        "normalized": "Unop(a(Pair b))-\u003eUnop(Pair(a b))",
        "package": "functor-combo",
        "partial": "Zip",
        "signature": "Unop(f(Pair a))-\u003eUnop(Pair(f a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:preScanP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Pair (f o, o) -\u003e (Pair (f o), o)",
        "fct-source": "src/FunctorCombo-Pair.html#preScanP",
        "fct-type": "function",
        "title": "preScanP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "preScanP",
        "normalized": "Pair(a b,b)-\u003e(Pair(a b),b)",
        "package": "functor-combo",
        "partial": "Scan",
        "signature": "Pair(f o,o)-\u003e(Pair(f o),o)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:secondP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Unop a -\u003e Unop (Pair a)",
        "fct-source": "src/FunctorCombo-Pair.html#secondP",
        "fct-type": "function",
        "title": "secondP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "secondP",
        "normalized": "Unop a-\u003eUnop(Pair a)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop a-\u003eUnop(Pair a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:sndP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Pair a -\u003e a",
        "fct-source": "src/FunctorCombo-Pair.html#sndP",
        "fct-type": "function",
        "title": "sndP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "sndP",
        "normalized": "Pair a-\u003ea",
        "package": "functor-combo",
        "partial": "",
        "signature": "Pair a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:sufScanP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Pair (o, f o) -\u003e (o, Pair (f o))",
        "fct-source": "src/FunctorCombo-Pair.html#sufScanP",
        "fct-type": "function",
        "title": "sufScanP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "sufScanP",
        "normalized": "Pair(a,b a)-\u003e(a,Pair(b a))",
        "package": "functor-combo",
        "partial": "Scan",
        "signature": "Pair(o,f o)-\u003e(o,Pair(f o))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:swapP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (Pair a)",
        "fct-source": "src/FunctorCombo-Pair.html#swapP",
        "fct-type": "function",
        "title": "swapP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "swapP",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:toP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "(a, a) -\u003e Pair a",
        "fct-source": "src/FunctorCombo-Pair.html#toP",
        "fct-type": "function",
        "title": "toP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "toP",
        "normalized": "(a,a)-\u003ePair a",
        "package": "functor-combo",
        "partial": "",
        "signature": "(a,a)-\u003ePair a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:uncurryP",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "(a -\u003e a -\u003e b) -\u003e Pair a -\u003e b",
        "fct-source": "src/FunctorCombo-Pair.html#uncurryP",
        "fct-type": "function",
        "title": "uncurryP"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "uncurryP",
        "normalized": "(a-\u003ea-\u003eb)-\u003ePair a-\u003eb",
        "package": "functor-combo",
        "partial": "",
        "signature": "(a-\u003ea-\u003eb)-\u003ePair a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:unzipA",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "f (Pair a) -\u003e Pair (f a)",
        "fct-source": "src/FunctorCombo-Pair.html#unzipA",
        "fct-type": "function",
        "title": "unzipA"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "unzipA",
        "normalized": "a(Pair b)-\u003ePair(a b)",
        "package": "functor-combo",
        "partial": "",
        "signature": "f(Pair a)-\u003ePair(f a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Pair.html#v:zipA",
      "description": {
        "fct-module": "FunctorCombo.Pair",
        "fct-package": "functor-combo",
        "fct-signature": "Pair (f a) -\u003e f (Pair a)",
        "fct-source": "src/FunctorCombo-Pair.html#zipA",
        "fct-type": "function",
        "title": "zipA"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Pair",
        "module": "FunctorCombo.Pair",
        "name": "zipA",
        "normalized": "Pair(a b)-\u003ea(Pair b)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Pair(f a)-\u003ef(Pair a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComposable parallel scanning from\n \u003ca\u003ehttp://conal.net/blog/posts/composable-parallel-scanning/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-ParScan.html",
        "fct-type": "module",
        "title": "ParScan"
      },
      "index": {
        "description": "Composable parallel scanning from http conal.net blog posts composable-parallel-scanning",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "ParScan",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Par Scan",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#t:PreScanO",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-ParScan.html#PreScanO",
        "fct-type": "type",
        "title": "PreScanO"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "PreScanO",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Pre Scan",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#t:Scan",
      "description": {
        "fct-descr": "\u003cp\u003eParallel scans. \u003ccode\u003e\u003ca\u003eprefixScan\u003c/a\u003e\u003c/code\u003e accumulates moving left-to-right, while\n \u003ccode\u003e\u003ca\u003esuffixScan\u003c/a\u003e\u003c/code\u003e accumulates moving right-to-left.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "class",
        "fct-source": "src/FunctorCombo-ParScan.html#Scan",
        "fct-type": "class",
        "title": "Scan"
      },
      "index": {
        "description": "Parallel scans prefixScan accumulates moving left-to-right while suffixScan accumulates moving right-to-left",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "Scan",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Scan",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#t:SufScanO",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-ParScan.html#SufScanO",
        "fct-type": "type",
        "title": "SufScanO"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "SufScanO",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Suf Scan",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#v:preScanTweak",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "(a -\u003e b) -\u003e PreScanO f a -\u003e PreScanO f b",
        "fct-source": "src/FunctorCombo-ParScan.html#preScanTweak",
        "fct-type": "function",
        "title": "preScanTweak"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "preScanTweak",
        "normalized": "(a-\u003eb)-\u003ePreScanO c a-\u003ePreScanO c b",
        "package": "functor-combo",
        "partial": "Scan Tweak",
        "signature": "(a-\u003eb)-\u003ePreScanO f a-\u003ePreScanO f b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#v:prefixScan",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "f m -\u003e PreScanO f m",
        "fct-source": "src/FunctorCombo-ParScan.html#prefixScan",
        "fct-type": "method",
        "title": "prefixScan"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "prefixScan",
        "normalized": "a b-\u003ePreScanO a b",
        "package": "functor-combo",
        "partial": "Scan",
        "signature": "f m-\u003ePreScanO f m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#v:prefixScanEnc",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "f m -\u003e PreScanO f m",
        "fct-source": "src/FunctorCombo-ParScan.html#prefixScanEnc",
        "fct-type": "function",
        "title": "prefixScanEnc"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "prefixScanEnc",
        "normalized": "a b-\u003ePreScanO a b",
        "package": "functor-combo",
        "partial": "Scan Enc",
        "signature": "f m-\u003ePreScanO f m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#v:prefixSums",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "f a -\u003e PreScanO f a",
        "fct-source": "src/FunctorCombo-ParScan.html#prefixSums",
        "fct-type": "function",
        "title": "prefixSums"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "prefixSums",
        "normalized": "a b-\u003ePreScanO a b",
        "package": "functor-combo",
        "partial": "Sums",
        "signature": "f a-\u003ePreScanO f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#v:sufScanTweak",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "(a -\u003e b) -\u003e SufScanO f a -\u003e SufScanO f b",
        "fct-source": "src/FunctorCombo-ParScan.html#sufScanTweak",
        "fct-type": "function",
        "title": "sufScanTweak"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "sufScanTweak",
        "normalized": "(a-\u003eb)-\u003eSufScanO c a-\u003eSufScanO c b",
        "package": "functor-combo",
        "partial": "Scan Tweak",
        "signature": "(a-\u003eb)-\u003eSufScanO f a-\u003eSufScanO f b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#v:suffixScan",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "f m -\u003e SufScanO f m",
        "fct-source": "src/FunctorCombo-ParScan.html#suffixScan",
        "fct-type": "method",
        "title": "suffixScan"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "suffixScan",
        "normalized": "a b-\u003eSufScanO a b",
        "package": "functor-combo",
        "partial": "Scan",
        "signature": "f m-\u003eSufScanO f m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#v:suffixScanEnc",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "f m -\u003e SufScanO f m",
        "fct-source": "src/FunctorCombo-ParScan.html#suffixScanEnc",
        "fct-type": "function",
        "title": "suffixScanEnc"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "suffixScanEnc",
        "normalized": "a b-\u003eSufScanO a b",
        "package": "functor-combo",
        "partial": "Scan Enc",
        "signature": "f m-\u003eSufScanO f m"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ParScan.html#v:suffixSums",
      "description": {
        "fct-module": "FunctorCombo.ParScan",
        "fct-package": "functor-combo",
        "fct-signature": "f a -\u003e SufScanO f a",
        "fct-source": "src/FunctorCombo-ParScan.html#suffixSums",
        "fct-type": "function",
        "title": "suffixSums"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ParScan",
        "module": "FunctorCombo.ParScan",
        "name": "suffixSums",
        "normalized": "a b-\u003eSufScanO a b",
        "package": "functor-combo",
        "partial": "Sums",
        "signature": "f a-\u003eSufScanO f a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Regular.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRegular data types\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.Regular",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-Regular.html",
        "fct-type": "module",
        "title": "Regular"
      },
      "index": {
        "description": "Regular data types",
        "hierarchy": "FunctorCombo Regular",
        "module": "FunctorCombo.Regular",
        "name": "Regular",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Regular",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Regular.html#t:Regular",
      "description": {
        "fct-module": "FunctorCombo.Regular",
        "fct-package": "functor-combo",
        "fct-signature": "class",
        "fct-source": "src/FunctorCombo-Regular.html#Regular",
        "fct-type": "class",
        "title": "Regular"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Regular",
        "module": "FunctorCombo.Regular",
        "name": "Regular",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Regular",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Regular.html#v:unwrap",
      "description": {
        "fct-module": "FunctorCombo.Regular",
        "fct-package": "functor-combo",
        "fct-signature": "t -\u003e PF t t",
        "fct-source": "src/FunctorCombo-Regular.html#unwrap",
        "fct-type": "method",
        "title": "unwrap"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Regular",
        "module": "FunctorCombo.Regular",
        "name": "unwrap",
        "normalized": "a-\u003ePF a a",
        "package": "functor-combo",
        "partial": "",
        "signature": "t-\u003ePF t t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Regular.html#v:wrap",
      "description": {
        "fct-module": "FunctorCombo.Regular",
        "fct-package": "functor-combo",
        "fct-signature": "PF t t -\u003e t",
        "fct-source": "src/FunctorCombo-Regular.html#wrap",
        "fct-type": "method",
        "title": "wrap"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Regular",
        "module": "FunctorCombo.Regular",
        "name": "wrap",
        "normalized": "PF a a-\u003ea",
        "package": "functor-combo",
        "partial": "",
        "signature": "PF t t-\u003et"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStrict products and sums.Strict\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-Strict.html",
        "fct-type": "module",
        "title": "Strict"
      },
      "index": {
        "description": "Strict products and sums.Strict",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": "Strict",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Strict",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#t::-42--33-",
      "description": {
        "fct-descr": "\u003cp\u003eStrict pair\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Strict.html#%3A%2A%21",
        "fct-type": "data",
        "title": ":*!"
      },
      "index": {
        "description": "Strict pair",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": ":*!",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#t::-43--33-",
      "description": {
        "fct-descr": "\u003cp\u003eStrict sum\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-Strict.html#%3A%2B%21",
        "fct-type": "data",
        "title": ":+!"
      },
      "index": {
        "description": "Strict sum",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": ":+!",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#v::-42--33-",
      "description": {
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "!a :*! !b",
        "fct-source": "src/FunctorCombo-Strict.html#%3A%2A%21",
        "fct-type": "function",
        "title": ":*!"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": ":*!",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#v:Left-39-",
      "description": {
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "Left' !a",
        "fct-source": "src/FunctorCombo-Strict.html#%3A%2B%21",
        "fct-type": "function",
        "title": "Left'"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": "Left'",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Left'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#v:Right-39-",
      "description": {
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "Right' !b",
        "fct-source": "src/FunctorCombo-Strict.html#%3A%2B%21",
        "fct-type": "function",
        "title": "Right'"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": "Right'",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Right'",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#v:curry-39-",
      "description": {
        "fct-descr": "\u003cp\u003eCurry on strict pairs\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "((a :*! b) -\u003e c) -\u003e a -\u003e b -\u003e c",
        "fct-source": "src/FunctorCombo-Strict.html#curry%27",
        "fct-type": "function",
        "title": "curry'"
      },
      "index": {
        "description": "Curry on strict pairs",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": "curry'",
        "normalized": "((a*b)-\u003ec)-\u003ea-\u003eb-\u003ec",
        "package": "functor-combo",
        "partial": "",
        "signature": "((a*b)-\u003ec)-\u003ea-\u003eb-\u003ec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#v:either-39-",
      "description": {
        "fct-descr": "\u003cp\u003eCase analysis for strict sums.  Like \u003ccode\u003e\u003ca\u003eeither\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "(a -\u003e c) -\u003e (b -\u003e c) -\u003e (a :+! b) -\u003e c",
        "fct-source": "src/FunctorCombo-Strict.html#either%27",
        "fct-type": "function",
        "title": "either'"
      },
      "index": {
        "description": "Case analysis for strict sums Like either",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": "either'",
        "normalized": "(a-\u003eb)-\u003e(c-\u003eb)-\u003e(a c)-\u003eb",
        "package": "functor-combo",
        "partial": "",
        "signature": "(a-\u003ec)-\u003e(b-\u003ec)-\u003e(a b)-\u003ec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-Strict.html#v:uncurry-39-",
      "description": {
        "fct-descr": "\u003cp\u003eUncurry on strict pairs\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.Strict",
        "fct-package": "functor-combo",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e (a :*! b) -\u003e c",
        "fct-source": "src/FunctorCombo-Strict.html#uncurry%27",
        "fct-type": "function",
        "title": "uncurry'"
      },
      "index": {
        "description": "Uncurry on strict pairs",
        "hierarchy": "FunctorCombo Strict",
        "module": "FunctorCombo.Strict",
        "name": "uncurry'",
        "normalized": "(a-\u003eb-\u003ec)-\u003e(a*b)-\u003ec",
        "package": "functor-combo",
        "partial": "",
        "signature": "(a-\u003eb-\u003ec)-\u003e(a*b)-\u003ec"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctor-based memo tries (strict for now)\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-StrictMemo.html",
        "fct-type": "module",
        "title": "StrictMemo"
      },
      "index": {
        "description": "Functor-based memo tries strict for now",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "StrictMemo",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Strict Memo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#t::-45--62-:",
      "description": {
        "fct-descr": "\u003cp\u003eMemo trie from k to v\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-StrictMemo.html#%3A-%3E%3A",
        "fct-type": "type",
        "title": ":-\u003e:"
      },
      "index": {
        "description": "Memo trie from to",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": ":-\u003e:",
        "normalized": "",
        "package": "functor-combo",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#t:HasTrie",
      "description": {
        "fct-descr": "\u003cp\u003eDomain types with associated memo tries\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "class",
        "fct-source": "src/FunctorCombo-StrictMemo.html#HasTrie",
        "fct-type": "class",
        "title": "HasTrie"
      },
      "index": {
        "description": "Domain types with associated memo tries",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "HasTrie",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Has Trie",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#t:TrieTree",
      "description": {
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "data",
        "fct-source": "src/FunctorCombo-StrictMemo.html#TrieTree",
        "fct-type": "data",
        "title": "TrieTree"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "TrieTree",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Trie Tree",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eIndexing. Synonym for \u003ccode\u003e\u003ca\u003euntrie\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "(k :-\u003e: v) -\u003e k -\u003e v",
        "fct-source": "src/FunctorCombo-StrictMemo.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Indexing Synonym for untrie",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "(!) !",
        "normalized": "(a-\u003eb)-\u003ea-\u003eb",
        "package": "functor-combo",
        "partial": "",
        "signature": "(k-\u003ev)-\u003ek-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:B",
      "description": {
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "(k :-\u003e: TrieTree n k a) -\u003e TrieTree (S n) k a",
        "fct-source": "src/FunctorCombo-StrictMemo.html#TrieTree",
        "fct-type": "function",
        "title": "B"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "B",
        "normalized": "(a-\u003eTrieTree b a c)-\u003eTrieTree(S b)a c",
        "package": "functor-combo",
        "partial": "",
        "signature": "(k-\u003eTrieTree n k a)-\u003eTrieTree(S n)k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:L",
      "description": {
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "a -\u003e TrieTree Z k a",
        "fct-source": "src/FunctorCombo-StrictMemo.html#TrieTree",
        "fct-type": "function",
        "title": "L"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "L",
        "normalized": "a-\u003eTrieTree Z b a",
        "package": "functor-combo",
        "partial": "",
        "signature": "a-\u003eTrieTree Z k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:idTrie",
      "description": {
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "k :-\u003e: k",
        "fct-source": "src/FunctorCombo-StrictMemo.html#idTrie",
        "fct-type": "function",
        "title": "idTrie"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "idTrie",
        "normalized": "a-\u003ea",
        "package": "functor-combo",
        "partial": "Trie",
        "signature": "k-\u003ek"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:memo",
      "description": {
        "fct-descr": "\u003cp\u003eTrie-based function memoizer\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (k -\u003e v)",
        "fct-source": "src/FunctorCombo-StrictMemo.html#memo",
        "fct-type": "function",
        "title": "memo"
      },
      "index": {
        "description": "Trie-based function memoizer",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "memo",
        "normalized": "Unop(a-\u003eb)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop(k-\u003ev)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:memo2",
      "description": {
        "fct-descr": "\u003cp\u003eMemoize a binary function, on its first argument and then on its\n second.  Take care to exploit any partial evaluation.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (s -\u003e t -\u003e a)",
        "fct-source": "src/FunctorCombo-StrictMemo.html#memo2",
        "fct-type": "function",
        "title": "memo2"
      },
      "index": {
        "description": "Memoize binary function on its first argument and then on its second Take care to exploit any partial evaluation",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "memo2",
        "normalized": "Unop(a-\u003eb-\u003ec)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop(s-\u003et-\u003ea)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:memo3",
      "description": {
        "fct-descr": "\u003cp\u003eMemoize a ternary function on successive arguments.  Take care to\n exploit any partial evaluation.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "Unop (r -\u003e s -\u003e t -\u003e a)",
        "fct-source": "src/FunctorCombo-StrictMemo.html#memo3",
        "fct-type": "function",
        "title": "memo3"
      },
      "index": {
        "description": "Memoize ternary function on successive arguments Take care to exploit any partial evaluation",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "memo3",
        "normalized": "Unop(a-\u003eb-\u003ec-\u003ed)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Unop(r-\u003es-\u003et-\u003ea)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:onUntrie",
      "description": {
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "((a -\u003e a') -\u003e b -\u003e b') -\u003e (a :-\u003e: a') -\u003e b :-\u003e: b'",
        "fct-source": "src/FunctorCombo-StrictMemo.html#onUntrie",
        "fct-type": "function",
        "title": "onUntrie"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "onUntrie",
        "normalized": "((a-\u003eb)-\u003ec-\u003ed)-\u003e(a-\u003eb)-\u003ec-\u003ed",
        "package": "functor-combo",
        "partial": "Untrie",
        "signature": "((a-\u003ea')-\u003eb-\u003eb')-\u003e(a-\u003ea')-\u003eb-\u003eb'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:onUntrie2",
      "description": {
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "((a -\u003e a') -\u003e (b -\u003e b') -\u003e c -\u003e c') -\u003e (a :-\u003e: a') -\u003e (b :-\u003e: b') -\u003e c :-\u003e: c'",
        "fct-source": "src/FunctorCombo-StrictMemo.html#onUntrie2",
        "fct-type": "function",
        "title": "onUntrie2"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "onUntrie2",
        "normalized": "((a-\u003eb)-\u003e(c-\u003ed)-\u003ee-\u003ef)-\u003e(a-\u003eb)-\u003e(c-\u003ed)-\u003ee-\u003ef",
        "package": "functor-combo",
        "partial": "Untrie",
        "signature": "((a-\u003ea')-\u003e(b-\u003eb')-\u003ec-\u003ec')-\u003e(a-\u003ea')-\u003e(b-\u003eb')-\u003ec-\u003ec'"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:trie",
      "description": {
        "fct-descr": "\u003cp\u003eCreate the trie for the entire domain of a function\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "(k -\u003e v) -\u003e k :-\u003e: v",
        "fct-source": "src/FunctorCombo-StrictMemo.html#trie",
        "fct-type": "method",
        "title": "trie"
      },
      "index": {
        "description": "Create the trie for the entire domain of function",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "trie",
        "normalized": "(a-\u003eb)-\u003ea-\u003eb",
        "package": "functor-combo",
        "partial": "",
        "signature": "(k-\u003ev)-\u003ek-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-StrictMemo.html#v:untrie",
      "description": {
        "fct-descr": "\u003cp\u003eConvert k trie to k function, i.e., access k field of the trie\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.StrictMemo",
        "fct-package": "functor-combo",
        "fct-signature": "(k :-\u003e: v) -\u003e k -\u003e v",
        "fct-source": "src/FunctorCombo-StrictMemo.html#untrie",
        "fct-type": "method",
        "title": "untrie"
      },
      "index": {
        "description": "Convert trie to function i.e access field of the trie",
        "hierarchy": "FunctorCombo StrictMemo",
        "module": "FunctorCombo.StrictMemo",
        "name": "untrie",
        "normalized": "(a-\u003eb)-\u003ea-\u003eb",
        "package": "functor-combo",
        "partial": "",
        "signature": "(k-\u003ev)-\u003ek-\u003ev"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperFix.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eZippers for functor fixpoints\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "FunctorCombo.ZipperFix",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-ZipperFix.html",
        "fct-type": "module",
        "title": "ZipperFix"
      },
      "index": {
        "description": "Zippers for functor fixpoints",
        "hierarchy": "FunctorCombo ZipperFix",
        "module": "FunctorCombo.ZipperFix",
        "name": "ZipperFix",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Zipper Fix",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperFix.html#t:Context",
      "description": {
        "fct-descr": "\u003cp\u003eContext for functor fixpoints\n\u003c/p\u003e\u003cp\u003eContext for a regular type\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ZipperFix",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-ZipperFix.html#Context",
        "fct-type": "type",
        "title": "Context"
      },
      "index": {
        "description": "Context for functor fixpoints Context for regular type",
        "hierarchy": "FunctorCombo ZipperFix",
        "module": "FunctorCombo.ZipperFix",
        "name": "Context",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Context",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperFix.html#t:Zipper",
      "description": {
        "fct-descr": "\u003cp\u003eZipper for a functor tree.  Also called \"location\"\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ZipperFix",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-ZipperFix.html#Zipper",
        "fct-type": "type",
        "title": "Zipper"
      },
      "index": {
        "description": "Zipper for functor tree Also called location",
        "hierarchy": "FunctorCombo ZipperFix",
        "module": "FunctorCombo.ZipperFix",
        "name": "Zipper",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Zipper",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperFix.html#v:down",
      "description": {
        "fct-module": "FunctorCombo.ZipperFix",
        "fct-package": "functor-combo",
        "fct-signature": "Zipper f -\u003e f (Zipper f)",
        "fct-source": "src/FunctorCombo-ZipperFix.html#down",
        "fct-type": "function",
        "title": "down"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ZipperFix",
        "module": "FunctorCombo.ZipperFix",
        "name": "down",
        "normalized": "Zipper a-\u003ea(Zipper a)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Zipper f-\u003ef(Zipper f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperFix.html#v:up",
      "description": {
        "fct-descr": "\u003cp\u003eMove upward.  Error if empty context.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ZipperFix",
        "fct-package": "functor-combo",
        "fct-signature": "Zipper f -\u003e Zipper f",
        "fct-source": "src/FunctorCombo-ZipperFix.html#up",
        "fct-type": "function",
        "title": "up"
      },
      "index": {
        "description": "Move upward Error if empty context",
        "hierarchy": "FunctorCombo ZipperFix",
        "module": "FunctorCombo.ZipperFix",
        "name": "up",
        "normalized": "Zipper a-\u003eZipper a",
        "package": "functor-combo",
        "partial": "",
        "signature": "Zipper f-\u003eZipper f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperFix.html#v:up-39-",
      "description": {
        "fct-descr": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eup\u003c/a\u003e\u003c/code\u003e.  \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if empty context.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ZipperFix",
        "fct-package": "functor-combo",
        "fct-signature": "Zipper f -\u003e Maybe (Zipper f)",
        "fct-source": "src/FunctorCombo-ZipperFix.html#up%27",
        "fct-type": "function",
        "title": "up'"
      },
      "index": {
        "description": "Variant of up Nothing if empty context",
        "hierarchy": "FunctorCombo ZipperFix",
        "module": "FunctorCombo.ZipperFix",
        "name": "up'",
        "normalized": "Zipper a-\u003eMaybe(Zipper a)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Zipper f-\u003eMaybe(Zipper f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperReg.html#",
      "description": {
        "fct-module": "FunctorCombo.ZipperReg",
        "fct-package": "functor-combo",
        "fct-signature": "module",
        "fct-source": "src/FunctorCombo-ZipperReg.html",
        "fct-type": "module",
        "title": "ZipperReg"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ZipperReg",
        "module": "FunctorCombo.ZipperReg",
        "name": "ZipperReg",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Zipper Reg",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperReg.html#t:Context",
      "description": {
        "fct-descr": "\u003cp\u003eContext for a regular type\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ZipperReg",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-ZipperReg.html#Context",
        "fct-type": "type",
        "title": "Context"
      },
      "index": {
        "description": "Context for regular type",
        "hierarchy": "FunctorCombo ZipperReg",
        "module": "FunctorCombo.ZipperReg",
        "name": "Context",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Context",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperReg.html#t:Zipper",
      "description": {
        "fct-descr": "\u003cp\u003eZipper for a regular type.  Also called \"location\"\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ZipperReg",
        "fct-package": "functor-combo",
        "fct-signature": "type",
        "fct-source": "src/FunctorCombo-ZipperReg.html#Zipper",
        "fct-type": "type",
        "title": "Zipper"
      },
      "index": {
        "description": "Zipper for regular type Also called location",
        "hierarchy": "FunctorCombo ZipperReg",
        "module": "FunctorCombo.ZipperReg",
        "name": "Zipper",
        "normalized": "",
        "package": "functor-combo",
        "partial": "Zipper",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperReg.html#v:down",
      "description": {
        "fct-module": "FunctorCombo.ZipperReg",
        "fct-package": "functor-combo",
        "fct-signature": "Zipper t -\u003e PF t (Zipper t)",
        "fct-source": "src/FunctorCombo-ZipperReg.html#down",
        "fct-type": "function",
        "title": "down"
      },
      "index": {
        "description": "",
        "hierarchy": "FunctorCombo ZipperReg",
        "module": "FunctorCombo.ZipperReg",
        "name": "down",
        "normalized": "Zipper a-\u003ePF a(Zipper a)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Zipper t-\u003ePF t(Zipper t)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperReg.html#v:up",
      "description": {
        "fct-descr": "\u003cp\u003eMove upward.  Error if empty context.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ZipperReg",
        "fct-package": "functor-combo",
        "fct-signature": "Zipper t -\u003e Zipper t",
        "fct-source": "src/FunctorCombo-ZipperReg.html#up",
        "fct-type": "function",
        "title": "up"
      },
      "index": {
        "description": "Move upward Error if empty context",
        "hierarchy": "FunctorCombo ZipperReg",
        "module": "FunctorCombo.ZipperReg",
        "name": "up",
        "normalized": "Zipper a-\u003eZipper a",
        "package": "functor-combo",
        "partial": "",
        "signature": "Zipper t-\u003eZipper t"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/functor-combo/docs/FunctorCombo-ZipperReg.html#v:up-39-",
      "description": {
        "fct-descr": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eup\u003c/a\u003e\u003c/code\u003e.  \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if empty context.\n\u003c/p\u003e",
        "fct-module": "FunctorCombo.ZipperReg",
        "fct-package": "functor-combo",
        "fct-signature": "Zipper t -\u003e Maybe (Zipper t)",
        "fct-source": "src/FunctorCombo-ZipperReg.html#up%27",
        "fct-type": "function",
        "title": "up'"
      },
      "index": {
        "description": "Variant of up Nothing if empty context",
        "hierarchy": "FunctorCombo ZipperReg",
        "module": "FunctorCombo.ZipperReg",
        "name": "up'",
        "normalized": "Zipper a-\u003eMaybe(Zipper a)",
        "package": "functor-combo",
        "partial": "",
        "signature": "Zipper t-\u003eMaybe(Zipper t)"
      }
    }
  }
]
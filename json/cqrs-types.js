[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Aggregate.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAggregate type class.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CQRS.Aggregate",
        "fct-package": "cqrs-types",
        "fct-signature": "module",
        "fct-source": "src/Data-CQRS-Aggregate.html",
        "fct-type": "module",
        "title": "Aggregate"
      },
      "index": {
        "description": "Aggregate type class",
        "hierarchy": "Data CQRS Aggregate",
        "module": "Data.CQRS.Aggregate",
        "name": "Aggregate",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Aggregate",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Aggregate.html#t:Aggregate",
      "description": {
        "fct-descr": "\u003cp\u003eType class for aggregates.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.Aggregate",
        "fct-package": "cqrs-types",
        "fct-signature": "class",
        "fct-source": "src/Data-CQRS-Aggregate.html#Aggregate",
        "fct-type": "class",
        "title": "Aggregate"
      },
      "index": {
        "description": "Type class for aggregates",
        "hierarchy": "Data CQRS Aggregate",
        "module": "Data.CQRS.Aggregate",
        "name": "Aggregate",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Aggregate",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEvent store backend. You only need to import this\n module if you're planning on implementing a custom\n event store backend.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "module",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html",
        "fct-type": "module",
        "title": "Backend"
      },
      "index": {
        "description": "Event store backend You only need to import this module if you re planning on implementing custom event store backend",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "Backend",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Backend",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#t:EventStoreBackend",
      "description": {
        "fct-descr": "\u003cp\u003eEvent stores are the backend used for reading and storing all the\n information about recorded events.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "class",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#EventStoreBackend",
        "fct-type": "class",
        "title": "EventStoreBackend"
      },
      "index": {
        "description": "Event stores are the backend used for reading and storing all the information about recorded events",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "EventStoreBackend",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Event Store Backend",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#t:RawEvent",
      "description": {
        "fct-descr": "\u003cp\u003eRaw event type. The data associated with an event is not\n translated in any way.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "type",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#RawEvent",
        "fct-type": "type",
        "title": "RawEvent"
      },
      "index": {
        "description": "Raw event type The data associated with an event is not translated in any way",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "RawEvent",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Raw Event",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#t:RawSnapshot",
      "description": {
        "fct-descr": "\u003cp\u003eRaw snapshot.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "data",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#RawSnapshot",
        "fct-type": "data",
        "title": "RawSnapshot"
      },
      "index": {
        "description": "Raw snapshot",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "RawSnapshot",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Raw Snapshot",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:RawSnapshot",
      "description": {
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "RawSnapshot",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#RawSnapshot",
        "fct-type": "function",
        "title": "RawSnapshot"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "RawSnapshot",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Raw Snapshot",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:esbEnumerateAllEvents",
      "description": {
        "fct-descr": "\u003cp\u003eEnumerate all events. There is no guarantee on the ordering\n of events \u003cem\u003eexcept\u003c/em\u003e that events for any specific aggregate root\n are returned in order of version number.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "esb -\u003e Source (ResourceT IO) RawEvent",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#esbEnumerateAllEvents",
        "fct-type": "method",
        "title": "esbEnumerateAllEvents"
      },
      "index": {
        "description": "Enumerate all events There is no guarantee on the ordering of events except that events for any specific aggregate root are returned in order of version number",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "esbEnumerateAllEvents",
        "normalized": "a-\u003eSource(ResourceT IO)RawEvent",
        "package": "cqrs-types",
        "partial": "Enumerate All Events",
        "signature": "esb-\u003eSource(ResourceT IO)RawEvent"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:esbGetLatestSnapshot",
      "description": {
        "fct-descr": "\u003cp\u003eGet latest snapshot of an aggregate identified by GUID.\n Returns the version number of the snapshot in addition to the\n data. An event store which does not support snapshots is\n permitted to return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e in all cases.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "esb -\u003e GUID -\u003e IO (Maybe RawSnapshot)",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#esbGetLatestSnapshot",
        "fct-type": "method",
        "title": "esbGetLatestSnapshot"
      },
      "index": {
        "description": "Get latest snapshot of an aggregate identified by GUID Returns the version number of the snapshot in addition to the data An event store which does not support snapshots is permitted to return Nothing in all cases",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "esbGetLatestSnapshot",
        "normalized": "a-\u003eGUID-\u003eIO(Maybe RawSnapshot)",
        "package": "cqrs-types",
        "partial": "Get Latest Snapshot",
        "signature": "esb-\u003eGUID-\u003eIO(Maybe RawSnapshot)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:esbRetrieveEvents",
      "description": {
        "fct-descr": "\u003cp\u003eRetrieve the sequence of events associated with the aggregate\n identified by the given GUID. Only events at or after the given\n version number are retrieved. The events are returned in\n increasing order of version number.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "esb -\u003e GUID -\u003e Int -\u003e Source (ResourceT IO) RawEvent",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#esbRetrieveEvents",
        "fct-type": "method",
        "title": "esbRetrieveEvents"
      },
      "index": {
        "description": "Retrieve the sequence of events associated with the aggregate identified by the given GUID Only events at or after the given version number are retrieved The events are returned in increasing order of version number",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "esbRetrieveEvents",
        "normalized": "a-\u003eGUID-\u003eInt-\u003eSource(ResourceT IO)RawEvent",
        "package": "cqrs-types",
        "partial": "Retrieve Events",
        "signature": "esb-\u003eGUID-\u003eInt-\u003eSource(ResourceT IO)RawEvent"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:esbStoreEvents",
      "description": {
        "fct-descr": "\u003cp\u003eStore a sequence of events for aggregate identified by GUID\n into the event store, starting at the provided version number.\n If the version number does not match the expected value, a\n failure occurs.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "esb -\u003e GUID -\u003e Int -\u003e [RawEvent] -\u003e IO ()",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#esbStoreEvents",
        "fct-type": "method",
        "title": "esbStoreEvents"
      },
      "index": {
        "description": "Store sequence of events for aggregate identified by GUID into the event store starting at the provided version number If the version number does not match the expected value failure occurs",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "esbStoreEvents",
        "normalized": "a-\u003eGUID-\u003eInt-\u003e[RawEvent]-\u003eIO()",
        "package": "cqrs-types",
        "partial": "Store Events",
        "signature": "esb-\u003eGUID-\u003eInt-\u003e[RawEvent]-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:esbWithTransaction",
      "description": {
        "fct-descr": "\u003cp\u003eRun transaction against the event store. The transaction is\n expected to commit if the supplied IO action runs to completion\n (i.e. doesn't throw an exception) and to rollback otherwise.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "forall a.  esb -\u003e IO a -\u003e IO a",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#esbWithTransaction",
        "fct-type": "method",
        "title": "esbWithTransaction"
      },
      "index": {
        "description": "Run transaction against the event store The transaction is expected to commit if the supplied IO action runs to completion i.e doesn throw an exception and to rollback otherwise",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "esbWithTransaction",
        "normalized": "a b c-\u003eIO d-\u003eIO d",
        "package": "cqrs-types",
        "partial": "With Transaction",
        "signature": "forall a. esb-\u003eIO a-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:esbWriteSnapshot",
      "description": {
        "fct-descr": "\u003cp\u003eWrite snapshot for aggregate identified by GUID and\n the given version number. The version number is NOT checked\n for validity. If the event store does not support snapshots\n this function may do nothing.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "esb -\u003e GUID -\u003e RawSnapshot -\u003e IO ()",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#esbWriteSnapshot",
        "fct-type": "method",
        "title": "esbWriteSnapshot"
      },
      "index": {
        "description": "Write snapshot for aggregate identified by GUID and the given version number The version number is NOT checked for validity If the event store does not support snapshots this function may do nothing",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "esbWriteSnapshot",
        "normalized": "a-\u003eGUID-\u003eRawSnapshot-\u003eIO()",
        "package": "cqrs-types",
        "partial": "Write Snapshot",
        "signature": "esb-\u003eGUID-\u003eRawSnapshot-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:rsSnapshotData",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "ByteString",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#RawSnapshot",
        "fct-type": "function",
        "title": "rsSnapshotData"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "rsSnapshotData",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Snapshot Data",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-EventStore-Backend.html#v:rsVersion",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.CQRS.EventStore.Backend",
        "fct-package": "cqrs-types",
        "fct-signature": "Int",
        "fct-source": "src/Data-CQRS-EventStore-Backend.html#RawSnapshot",
        "fct-type": "function",
        "title": "rsVersion"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CQRS EventStore Backend",
        "module": "Data.CQRS.EventStore.Backend",
        "name": "rsVersion",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Version",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Eventable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEventable type class.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CQRS.Eventable",
        "fct-package": "cqrs-types",
        "fct-signature": "module",
        "fct-source": "src/Data-CQRS-Eventable.html",
        "fct-type": "module",
        "title": "Eventable"
      },
      "index": {
        "description": "Eventable type class",
        "hierarchy": "Data CQRS Eventable",
        "module": "Data.CQRS.Eventable",
        "name": "Eventable",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Eventable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Eventable.html#t:Eventable",
      "description": {
        "fct-descr": "\u003cp\u003eType class for applying events to aggregates.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.Eventable",
        "fct-package": "cqrs-types",
        "fct-signature": "class",
        "fct-source": "src/Data-CQRS-Eventable.html#Eventable",
        "fct-type": "class",
        "title": "Eventable"
      },
      "index": {
        "description": "Type class for applying events to aggregates",
        "hierarchy": "Data CQRS Eventable",
        "module": "Data.CQRS.Eventable",
        "name": "Eventable",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Eventable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Eventable.html#v:applyEvent",
      "description": {
        "fct-descr": "\u003cp\u003eApply an event to the aggregate and return the updated aggregate.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.Eventable",
        "fct-package": "cqrs-types",
        "fct-signature": "Maybe a -\u003e e -\u003e Maybe a",
        "fct-source": "src/Data-CQRS-Eventable.html#applyEvent",
        "fct-type": "method",
        "title": "applyEvent"
      },
      "index": {
        "description": "Apply an event to the aggregate and return the updated aggregate",
        "hierarchy": "Data CQRS Eventable",
        "module": "Data.CQRS.Eventable",
        "name": "applyEvent",
        "normalized": "Maybe a-\u003eb-\u003eMaybe a",
        "package": "cqrs-types",
        "partial": "Event",
        "signature": "Maybe a-\u003ee-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGlobally Unique IDentifiers.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "module",
        "fct-source": "src/Data-CQRS-GUID.html",
        "fct-type": "module",
        "title": "GUID"
      },
      "index": {
        "description": "Globally Unique IDentifiers",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "GUID",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "GUID",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#t:GUID",
      "description": {
        "fct-descr": "\u003cp\u003eA Globally Unique IDentifier.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "data",
        "fct-source": "src/Data-CQRS-GUID.html#GUID",
        "fct-type": "data",
        "title": "GUID"
      },
      "index": {
        "description": "Globally Unique IDentifier",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "GUID",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "GUID",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#v:base64Decode",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a GUID from base64 representation.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "ByteString -\u003e Maybe GUID",
        "fct-source": "src/Data-CQRS-GUID.html#base64Decode",
        "fct-type": "function",
        "title": "base64Decode"
      },
      "index": {
        "description": "Decode GUID from base64 representation",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "base64Decode",
        "normalized": "ByteString-\u003eMaybe GUID",
        "package": "cqrs-types",
        "partial": "Decode",
        "signature": "ByteString-\u003eMaybe GUID"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#v:base64Encode",
      "description": {
        "fct-descr": "\u003cp\u003eBase64 encode a GUID.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "GUID -\u003e ByteString",
        "fct-source": "src/Data-CQRS-GUID.html#base64Encode",
        "fct-type": "function",
        "title": "base64Encode"
      },
      "index": {
        "description": "Base64 encode GUID",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "base64Encode",
        "normalized": "GUID-\u003eByteString",
        "package": "cqrs-types",
        "partial": "Encode",
        "signature": "GUID-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#v:fromByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert from ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "ByteString -\u003e GUID",
        "fct-source": "src/Data-CQRS-GUID.html#fromByteString",
        "fct-type": "function",
        "title": "fromByteString"
      },
      "index": {
        "description": "Convert from ByteString",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "fromByteString",
        "normalized": "ByteString-\u003eGUID",
        "package": "cqrs-types",
        "partial": "Byte String",
        "signature": "ByteString-\u003eGUID"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#v:hexDecode",
      "description": {
        "fct-descr": "\u003cp\u003eDecode a GUID from hex representation.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "ByteString -\u003e Maybe GUID",
        "fct-source": "src/Data-CQRS-GUID.html#hexDecode",
        "fct-type": "function",
        "title": "hexDecode"
      },
      "index": {
        "description": "Decode GUID from hex representation",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "hexDecode",
        "normalized": "ByteString-\u003eMaybe GUID",
        "package": "cqrs-types",
        "partial": "Decode",
        "signature": "ByteString-\u003eMaybe GUID"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#v:hexEncode",
      "description": {
        "fct-descr": "\u003cp\u003eHex encode a GUID.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "GUID -\u003e ByteString",
        "fct-source": "src/Data-CQRS-GUID.html#hexEncode",
        "fct-type": "function",
        "title": "hexEncode"
      },
      "index": {
        "description": "Hex encode GUID",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "hexEncode",
        "normalized": "GUID-\u003eByteString",
        "package": "cqrs-types",
        "partial": "Encode",
        "signature": "GUID-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#v:newGUID",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new random GUID.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "IO GUID",
        "fct-source": "src/Data-CQRS-GUID.html#newGUID",
        "fct-type": "function",
        "title": "newGUID"
      },
      "index": {
        "description": "Create new random GUID",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "newGUID",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "GUID",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-GUID.html#v:toByteString",
      "description": {
        "fct-descr": "\u003cp\u003eConvert to ByteString.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.GUID",
        "fct-package": "cqrs-types",
        "fct-signature": "GUID -\u003e ByteString",
        "fct-source": "src/Data-CQRS-GUID.html#toByteString",
        "fct-type": "function",
        "title": "toByteString"
      },
      "index": {
        "description": "Convert to ByteString",
        "hierarchy": "Data CQRS GUID",
        "module": "Data.CQRS.GUID",
        "name": "toByteString",
        "normalized": "GUID-\u003eByteString",
        "package": "cqrs-types",
        "partial": "Byte String",
        "signature": "GUID-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-PersistedEvent.html#",
      "description": {
        "fct-module": "Data.CQRS.PersistedEvent",
        "fct-package": "cqrs-types",
        "fct-signature": "module",
        "fct-source": "src/Data-CQRS-PersistedEvent.html",
        "fct-type": "module",
        "title": "PersistedEvent"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CQRS PersistedEvent",
        "module": "Data.CQRS.PersistedEvent",
        "name": "PersistedEvent",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Persisted Event",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-PersistedEvent.html#t:PersistedEvent",
      "description": {
        "fct-descr": "\u003cp\u003ePersisted Event.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.PersistedEvent",
        "fct-package": "cqrs-types",
        "fct-signature": "data",
        "fct-source": "src/Data-CQRS-PersistedEvent.html#PersistedEvent",
        "fct-type": "data",
        "title": "PersistedEvent"
      },
      "index": {
        "description": "Persisted Event",
        "hierarchy": "Data CQRS PersistedEvent",
        "module": "Data.CQRS.PersistedEvent",
        "name": "PersistedEvent",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Persisted Event",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-PersistedEvent.html#v:PersistedEvent",
      "description": {
        "fct-module": "Data.CQRS.PersistedEvent",
        "fct-package": "cqrs-types",
        "fct-signature": "PersistedEvent",
        "fct-source": "src/Data-CQRS-PersistedEvent.html#PersistedEvent",
        "fct-type": "function",
        "title": "PersistedEvent"
      },
      "index": {
        "description": "",
        "hierarchy": "Data CQRS PersistedEvent",
        "module": "Data.CQRS.PersistedEvent",
        "name": "PersistedEvent",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Persisted Event",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-PersistedEvent.html#v:peAggregateGUID",
      "description": {
        "fct-descr": "\u003cp\u003eGUID of the aggregate.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.PersistedEvent",
        "fct-package": "cqrs-types",
        "fct-signature": "!GUID",
        "fct-source": "src/Data-CQRS-PersistedEvent.html#PersistedEvent",
        "fct-type": "function",
        "title": "peAggregateGUID"
      },
      "index": {
        "description": "GUID of the aggregate",
        "hierarchy": "Data CQRS PersistedEvent",
        "module": "Data.CQRS.PersistedEvent",
        "name": "peAggregateGUID",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Aggregate GUID",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-PersistedEvent.html#v:peEvent",
      "description": {
        "fct-descr": "\u003cp\u003eEvent.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.PersistedEvent",
        "fct-package": "cqrs-types",
        "fct-signature": "!e",
        "fct-source": "src/Data-CQRS-PersistedEvent.html#PersistedEvent",
        "fct-type": "function",
        "title": "peEvent"
      },
      "index": {
        "description": "Event",
        "hierarchy": "Data CQRS PersistedEvent",
        "module": "Data.CQRS.PersistedEvent",
        "name": "peEvent",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Event",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-PersistedEvent.html#v:peSequenceNumber",
      "description": {
        "fct-descr": "\u003cp\u003eSequence number within the aggregate.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.PersistedEvent",
        "fct-package": "cqrs-types",
        "fct-signature": "!Int",
        "fct-source": "src/Data-CQRS-PersistedEvent.html#PersistedEvent",
        "fct-type": "function",
        "title": "peSequenceNumber"
      },
      "index": {
        "description": "Sequence number within the aggregate",
        "hierarchy": "Data CQRS PersistedEvent",
        "module": "Data.CQRS.PersistedEvent",
        "name": "peSequenceNumber",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Sequence Number",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Serializable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSerialization support. This is mainly used for compatibility\n with whatever serialization library you want to use.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.CQRS.Serializable",
        "fct-package": "cqrs-types",
        "fct-signature": "module",
        "fct-source": "src/Data-CQRS-Serializable.html",
        "fct-type": "module",
        "title": "Serializable"
      },
      "index": {
        "description": "Serialization support This is mainly used for compatibility with whatever serialization library you want to use",
        "hierarchy": "Data CQRS Serializable",
        "module": "Data.CQRS.Serializable",
        "name": "Serializable",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Serializable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Serializable.html#t:Serializable",
      "description": {
        "fct-descr": "\u003cp\u003eSerialization support for values of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.Serializable",
        "fct-package": "cqrs-types",
        "fct-signature": "class",
        "fct-source": "src/Data-CQRS-Serializable.html#Serializable",
        "fct-type": "class",
        "title": "Serializable"
      },
      "index": {
        "description": "Serialization support for values of type",
        "hierarchy": "Data CQRS Serializable",
        "module": "Data.CQRS.Serializable",
        "name": "Serializable",
        "normalized": "",
        "package": "cqrs-types",
        "partial": "Serializable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Serializable.html#v:deserialize",
      "description": {
        "fct-descr": "\u003cp\u003eDe-serialize a value from a byte string. Should return\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if decoding is not possible due to a now-invalid\n representation.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.Serializable",
        "fct-package": "cqrs-types",
        "fct-signature": "ByteString -\u003e Maybe a",
        "fct-source": "src/Data-CQRS-Serializable.html#deserialize",
        "fct-type": "method",
        "title": "deserialize"
      },
      "index": {
        "description": "De-serialize value from byte string Should return Nothing if decoding is not possible due to now-invalid representation",
        "hierarchy": "Data CQRS Serializable",
        "module": "Data.CQRS.Serializable",
        "name": "deserialize",
        "normalized": "ByteString-\u003eMaybe a",
        "package": "cqrs-types",
        "partial": "",
        "signature": "ByteString-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/cqrs-types/docs/Data-CQRS-Serializable.html#v:serialize",
      "description": {
        "fct-descr": "\u003cp\u003eSerialize a value. The serialized representation\n should contain some metadata (a UUID for example)\n which can be used to check reliably whether the encoded\n representation is semantically valid upon decoding.\n\u003c/p\u003e",
        "fct-module": "Data.CQRS.Serializable",
        "fct-package": "cqrs-types",
        "fct-signature": "a -\u003e ByteString",
        "fct-source": "src/Data-CQRS-Serializable.html#serialize",
        "fct-type": "method",
        "title": "serialize"
      },
      "index": {
        "description": "Serialize value The serialized representation should contain some metadata UUID for example which can be used to check reliably whether the encoded representation is semantically valid upon decoding",
        "hierarchy": "Data CQRS Serializable",
        "module": "Data.CQRS.Serializable",
        "name": "serialize",
        "normalized": "a-\u003eByteString",
        "package": "cqrs-types",
        "partial": "",
        "signature": "a-\u003eByteString"
      }
    }
  }
]
[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonadic stream combinators.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html",
        "fct-type": "module",
        "title": "Monadic"
      },
      "index": {
        "description": "Monadic stream combinators",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "Monadic",
        "normalized": "",
        "package": "vector",
        "partial": "Monadic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#t:SPEC",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#SPEC",
        "fct-type": "data",
        "title": "SPEC"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "SPEC",
        "normalized": "",
        "package": "vector",
        "partial": "SPEC",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#t:Step",
      "description": {
        "fct-descr": "\u003cp\u003eResult of taking a single step in a stream\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Step",
        "fct-type": "data",
        "title": "Step"
      },
      "index": {
        "description": "Result of taking single step in stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "Step",
        "normalized": "",
        "package": "vector",
        "partial": "Step",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#t:Stream",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic streams\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Stream",
        "fct-type": "data",
        "title": "Stream"
      },
      "index": {
        "description": "Monadic streams",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "Stream",
        "normalized": "",
        "package": "vector",
        "partial": "Stream",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:-33--33-",
      "description": {
        "fct-descr": "\u003cp\u003eElement at the given position\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#%21%21",
        "fct-type": "function",
        "title": "(!!)"
      },
      "index": {
        "description": "Element at the given position",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "(!!) !!",
        "normalized": "Stream a b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eElement at the given position or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if out of bounds\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Int -\u003e m (Maybe a)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Element at the given position or Nothing if out of bounds",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "(!?) !?",
        "normalized": "Stream a b-\u003eInt-\u003ea(Maybe b)",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eInt-\u003em(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003eConcatenate two \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "(++) ++",
        "normalized": "Stream a b-\u003eStream a b-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:Done",
      "description": {
        "fct-descr": "\u003cp\u003eend of stream\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Done",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Step",
        "fct-type": "function",
        "title": "Done"
      },
      "index": {
        "description": "end of stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "Done",
        "normalized": "",
        "package": "vector",
        "partial": "Done",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:SPEC",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "SPEC",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#SPEC",
        "fct-type": "function",
        "title": "SPEC"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "SPEC",
        "normalized": "",
        "package": "vector",
        "partial": "SPEC",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:SPEC2",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "SPEC2",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#SPEC",
        "fct-type": "function",
        "title": "SPEC2"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "SPEC2",
        "normalized": "",
        "package": "vector",
        "partial": "SPEC",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:Skip",
      "description": {
        "fct-descr": "\u003cp\u003ejust a new seed\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Skip s",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Step",
        "fct-type": "function",
        "title": "Skip"
      },
      "index": {
        "description": "just new seed",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "Skip",
        "normalized": "",
        "package": "vector",
        "partial": "Skip",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:Stream",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "forall s . Stream (s -\u003e m (Step s a)) s Size",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Stream",
        "fct-type": "function",
        "title": "Stream"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "Stream",
        "normalized": "a b Stream(b-\u003ec(Step b d))b Size",
        "package": "vector",
        "partial": "Stream",
        "signature": "forall s Stream(s-\u003em(Step s a))s Size"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:Yield",
      "description": {
        "fct-descr": "\u003cp\u003ea new element and a new seed\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Yield a s",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Step",
        "fct-type": "function",
        "title": "Yield"
      },
      "index": {
        "description": "new element and new seed",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "Yield",
        "normalized": "",
        "package": "vector",
        "partial": "Yield",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:and",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m Bool -\u003e m Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "and",
        "normalized": "Stream a Bool-\u003ea Bool",
        "package": "vector",
        "partial": "",
        "signature": "Stream m Bool-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:concatMap",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Stream m b) -\u003e Stream m a -\u003e Stream m b",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "concatMap",
        "normalized": "(a-\u003eStream b c)-\u003eStream b a-\u003eStream b c",
        "package": "vector",
        "partial": "Map",
        "signature": "(a-\u003eStream m b)-\u003eStream m a-\u003eStream m b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:concatMapM",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m (Stream m b)) -\u003e Stream m a -\u003e Stream m b",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#concatMapM",
        "fct-type": "function",
        "title": "concatMapM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "concatMapM",
        "normalized": "(a-\u003eb(Stream b c))-\u003eStream b a-\u003eStream b c",
        "package": "vector",
        "partial": "Map",
        "signature": "(a-\u003em(Stream m b))-\u003eStream m a-\u003eStream m b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003ePrepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "cons",
        "normalized": "a-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003eAll but the first \u003ccode\u003en\u003c/code\u003e elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "All but the first elements",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "drop",
        "normalized": "Int-\u003eStream a b-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003eDrop the longest prefix of elements that satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "dropWhile",
        "normalized": "(a-\u003eBool)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:dropWhileM",
      "description": {
        "fct-descr": "\u003cp\u003eDrop the longest prefix of elements that satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#dropWhileM",
        "fct-type": "function",
        "title": "dropWhileM"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the monadic predicate",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "dropWhileM",
        "normalized": "(a-\u003eb Bool)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003em Bool)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Stream m a -\u003e m Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check whether the Stream contains an element",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "elem",
        "normalized": "a-\u003eStream b a-\u003eb Bool",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eStream m a-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003eEmpty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "empty",
        "normalized": "",
        "package": "vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:enumFromStepN",
      "description": {
        "fct-descr": "\u003cp\u003eYield a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Int -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#enumFromStepN",
        "fct-type": "function",
        "title": "enumFromStepN"
      },
      "index": {
        "description": "Yield Stream of the given length containing the values etc",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "enumFromStepN",
        "normalized": "a-\u003ea-\u003eInt-\u003eStream b a",
        "package": "vector",
        "partial": "From Step",
        "signature": "a-\u003ea-\u003eInt-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:enumFromThenTo",
      "description": {
        "fct-descr": "\u003cp\u003eEnumerate values with a given step.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation is very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#enumFromThenTo",
        "fct-type": "function",
        "title": "enumFromThenTo"
      },
      "index": {
        "description": "Enumerate values with given step WARNING This operation is very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "enumFromThenTo",
        "normalized": "a-\u003ea-\u003ea-\u003eStream b a",
        "package": "vector",
        "partial": "From Then To",
        "signature": "a-\u003ea-\u003ea-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003eEnumerate values\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Enumerate values WARNING This operation can be very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "enumFromTo",
        "normalized": "a-\u003ea-\u003eStream b a",
        "package": "vector",
        "partial": "From To",
        "signature": "a-\u003ea-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003eDrop elements which do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements which do not satisfy the predicate",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "filter",
        "normalized": "(a-\u003eBool)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003eDrop elements which do not satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Drop elements which do not satisfy the monadic predicate",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "filterM",
        "normalized": "(a-\u003eb Bool)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003eYield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element that satisfies the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream m a -\u003e m (Maybe a)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element that satisfies the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "find",
        "normalized": "(a-\u003eBool)-\u003eStream b a-\u003eb(Maybe a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eStream m a-\u003em(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003eYield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element that satisfies the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream m a -\u003e m (Maybe Int)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element that satisfies the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eStream b a-\u003eb(Maybe Int)",
        "package": "vector",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003eStream m a-\u003em(Maybe Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:findIndexM",
      "description": {
        "fct-descr": "\u003cp\u003eYield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element that satisfies the monadic\n predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Stream m a -\u003e m (Maybe Int)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#findIndexM",
        "fct-type": "function",
        "title": "findIndexM"
      },
      "index": {
        "description": "Yield Just the index of the first element that satisfies the monadic predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "findIndexM",
        "normalized": "(a-\u003eb Bool)-\u003eStream b a-\u003eb(Maybe Int)",
        "package": "vector",
        "partial": "Index",
        "signature": "(a-\u003em Bool)-\u003eStream m a-\u003em(Maybe Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:findM",
      "description": {
        "fct-descr": "\u003cp\u003eYield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element that satisfies the monadic predicate or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Stream m a -\u003e m (Maybe a)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#findM",
        "fct-type": "function",
        "title": "findM"
      },
      "index": {
        "description": "Yield Just the first element that satisfies the monadic predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "findM",
        "normalized": "(a-\u003eb Bool)-\u003eStream b a-\u003eb(Maybe a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003eStream m a-\u003em(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:flatten",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e of values from a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e of streamable things\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m s) -\u003e (s -\u003e m (Step s b)) -\u003e Size -\u003e Stream m a -\u003e Stream m b",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#flatten",
        "fct-type": "function",
        "title": "flatten"
      },
      "index": {
        "description": "Create Stream of values from Stream of streamable things",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "flatten",
        "normalized": "(a-\u003eb c)-\u003e(c-\u003eb(Step c d))-\u003eSize-\u003eStream b a-\u003eStream b d",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em s)-\u003e(s-\u003em(Step s b))-\u003eSize-\u003eStream m a-\u003eStream m b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003efoldl1M\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Same as foldl1M",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "fold1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream b a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003efoldl1M'\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Same as foldl1M",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "fold1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream b a-\u003eb a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003efoldlM\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Same as foldlM",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003efoldlM'\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Same as foldlM",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003ec a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream m b -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream c b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream m b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream m b -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream c b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream m b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold over non-empty Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream b a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold over non-empty Stream with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream b a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldl1M",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldl1M",
        "fct-type": "function",
        "title": "foldl1M"
      },
      "index": {
        "description": "Left fold over non-empty Stream with monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldl1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream b a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldl1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with a strict accumulator and a\n monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldl1M%27",
        "fct-type": "function",
        "title": "foldl1M'"
      },
      "index": {
        "description": "Left fold over non-empty Stream with strict accumulator and monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldl1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream b a-\u003eb a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldlM",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold with a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldlM",
        "fct-type": "function",
        "title": "foldlM"
      },
      "index": {
        "description": "Left fold with monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldlM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldlM-39-",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold with a strict accumulator and a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldlM%27",
        "fct-type": "function",
        "title": "foldlM'"
      },
      "index": {
        "description": "Left fold with strict accumulator and monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldlM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003ec a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Stream m a -\u003e m b",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eStream c a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eStream m a-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold over a non-empty stream\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold over non-empty stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream b a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldr1M",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold over a non-empty stream with a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldr1M",
        "fct-type": "function",
        "title": "foldr1M"
      },
      "index": {
        "description": "Right fold over non-empty stream with monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldr1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream b a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:foldrM",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold with a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m b) -\u003e b -\u003e Stream m a -\u003e m b",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#foldrM",
        "fct-type": "function",
        "title": "foldrM"
      },
      "index": {
        "description": "Right fold with monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "foldrM",
        "normalized": "(a-\u003eb-\u003ec b)-\u003eb-\u003eStream c a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em b)-\u003eb-\u003eStream m a-\u003em b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a list to a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "[a] -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "fromList",
        "normalized": "[a]-\u003eStream b a",
        "package": "vector",
        "partial": "List",
        "signature": "[a]-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003eConvert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e [a] -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Convert the first elements of list to Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "fromListN",
        "normalized": "Int-\u003e[a]-\u003eStream b a",
        "package": "vector",
        "partial": "List",
        "signature": "Int-\u003e[a]-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:generate",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e a) -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003ea)-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003ea)-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate a stream from its indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e m a) -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Generate stream from its indices",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "generateM",
        "normalized": "Int-\u003e(Int-\u003ea b)-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003em a)-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003eFirst element of the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e or error if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element of the Stream or error if empty",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "head",
        "normalized": "Stream a b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:indexed",
      "description": {
        "fct-descr": "\u003cp\u003ePair each element in a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m (Int, a)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#indexed",
        "fct-type": "function",
        "title": "indexed"
      },
      "index": {
        "description": "Pair each element in Stream with its index",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "indexed",
        "normalized": "Stream a b-\u003eStream a(Int,b)",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:indexedR",
      "description": {
        "fct-descr": "\u003cp\u003ePair each element in a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with its index, starting from the right\n and counting down\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Stream m a -\u003e Stream m (Int, a)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#indexedR",
        "fct-type": "function",
        "title": "indexedR"
      },
      "index": {
        "description": "Pair each element in Stream with its index starting from the right and counting down",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "indexedR",
        "normalized": "Int-\u003eStream a b-\u003eStream a(Int,b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eStream m a-\u003eStream m(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003eAll but the last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "All but the last element",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "init",
        "normalized": "Stream a b-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003eApply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function times to value Zeroth element is original value",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "iterateN",
        "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:iterateNM",
      "description": {
        "fct-descr": "\u003cp\u003eApply monadic function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (a -\u003e m a) -\u003e a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#iterateNM",
        "fct-type": "function",
        "title": "iterateNM"
      },
      "index": {
        "description": "Apply monadic function times to value Zeroth element is original value",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "iterateNM",
        "normalized": "Int-\u003e(a-\u003eb a)-\u003ea-\u003eStream b a",
        "package": "vector",
        "partial": "NM",
        "signature": "Int-\u003e(a-\u003em a)-\u003ea-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003eLast element of the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e or error if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element of the Stream or error if empty",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "last",
        "normalized": "Stream a b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e m Int",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "length",
        "normalized": "Stream a b-\u003ea Int",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003em Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b) -\u003e Stream m a -\u003e Stream m b",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003eStream c a-\u003eStream c b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eStream m a-\u003eStream m b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003eMap a monadic function over a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Stream m a -\u003e Stream m b",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Map monadic function over Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003eStream b a-\u003eStream b c",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eStream m a-\u003eStream m b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003eExecute a monadic action for each element of the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Stream m a -\u003e m ()",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Execute monadic action for each element of the Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003eStream b a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eStream m a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Stream m a -\u003e m Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Inverse of elem",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "notElem",
        "normalized": "a-\u003eStream b a-\u003eb Bool",
        "package": "vector",
        "partial": "Elem",
        "signature": "a-\u003eStream m a-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck if a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e m Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check if Stream is empty",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "null",
        "normalized": "Stream a b-\u003ea Bool",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:or",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m Bool -\u003e m Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "or",
        "normalized": "Stream a Bool-\u003ea Bool",
        "package": "vector",
        "partial": "",
        "signature": "Stream m Bool-\u003em Bool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003eSuffix scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Suffix scan",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "postscanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003eSuffix scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Suffix scan with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "postscanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:postscanlM",
      "description": {
        "fct-descr": "\u003cp\u003eSuffix scan with a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#postscanlM",
        "fct-type": "function",
        "title": "postscanlM"
      },
      "index": {
        "description": "Suffix scan with monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "postscanlM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:postscanlM-39-",
      "description": {
        "fct-descr": "\u003cp\u003eSuffix scan with strict acccumulator and a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#postscanlM%27",
        "fct-type": "function",
        "title": "postscanlM'"
      },
      "index": {
        "description": "Suffix scan with strict acccumulator and monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "postscanlM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003ePrefix scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prefix scan",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "prescanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003ePrefix scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prefix scan with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "prescanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:prescanlM",
      "description": {
        "fct-descr": "\u003cp\u003ePrefix scan with a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#prescanlM",
        "fct-type": "function",
        "title": "prescanlM"
      },
      "index": {
        "description": "Prefix scan with monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "prescanlM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:prescanlM-39-",
      "description": {
        "fct-descr": "\u003cp\u003ePrefix scan with strict accumulator and a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#prescanlM%27",
        "fct-type": "function",
        "title": "prescanlM'"
      },
      "index": {
        "description": "Prefix scan with strict accumulator and monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "prescanlM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eReplicate a value to a given length\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Replicate value to given length",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eYield a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e of values obtained by performing the monadic action the\n given number of times\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Yield Stream of values obtained by performing the monadic action the given number of times",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003eHaskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003eHaskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "scanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003eScan over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "scanl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003eScan over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty Stream with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "scanl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:scanl1M",
      "description": {
        "fct-descr": "\u003cp\u003eScan over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#scanl1M",
        "fct-type": "function",
        "title": "scanl1M"
      },
      "index": {
        "description": "Scan over non-empty Stream with monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "scanl1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:scanl1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003eScan over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with a strict accumulator and a monadic\n operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#scanl1M%27",
        "fct-type": "function",
        "title": "scanl1M'"
      },
      "index": {
        "description": "Scan over non-empty Stream with strict accumulator and monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "scanl1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:scanlM",
      "description": {
        "fct-descr": "\u003cp\u003eHaskell-style scan with a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#scanlM",
        "fct-type": "function",
        "title": "scanlM"
      },
      "index": {
        "description": "Haskell-style scan with monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "scanlM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:scanlM-39-",
      "description": {
        "fct-descr": "\u003cp\u003eHaskell-style scan with strict accumulator and a monadic operator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream m b -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#scanlM%27",
        "fct-type": "function",
        "title": "scanlM'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator and monadic operator",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "scanlM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream c b-\u003eStream c a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream m b-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003eSingleton \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Singleton Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "singleton",
        "normalized": "a-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:size",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e hint of a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Size",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#size",
        "fct-type": "function",
        "title": "size"
      },
      "index": {
        "description": "Size hint of Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "size",
        "normalized": "Stream a b-\u003eSize",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eSize"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:sized",
      "description": {
        "fct-descr": "\u003cp\u003eAttach a \u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e hint to a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Size -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#sized",
        "fct-type": "function",
        "title": "sized"
      },
      "index": {
        "description": "Attach Size hint to Stream",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "sized",
        "normalized": "Stream a b-\u003eSize-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eSize-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eExtract a substream of the given length starting at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Stream m a-\u003e Stream m a",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Extract substream of the given length starting at the given position",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eStream a b-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003eAppend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "snoc",
        "normalized": "Stream a b-\u003eb-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003ea-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003eAll but the first element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "All but the first element",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "tail",
        "normalized": "Stream a b-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003eThe first \u003ccode\u003en\u003c/code\u003e elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "The first elements",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "take",
        "normalized": "Int-\u003eStream a b-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003eLongest prefix of elements that satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Longest prefix of elements that satisfy the predicate",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "takeWhile",
        "normalized": "(a-\u003eBool)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:takeWhileM",
      "description": {
        "fct-descr": "\u003cp\u003eLongest prefix of elements that satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Stream m a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#takeWhileM",
        "fct-type": "function",
        "title": "takeWhileM"
      },
      "index": {
        "description": "Longest prefix of elements that satisfy the monadic predicate",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "takeWhileM",
        "normalized": "(a-\u003eb Bool)-\u003eStream b a-\u003eStream b a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003em Bool)-\u003eStream m a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e m [a]",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert Stream to list",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "toList",
        "normalized": "Stream a b-\u003ea[b]",
        "package": "vector",
        "partial": "List",
        "signature": "Stream m a-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:trans",
      "description": {
        "fct-descr": "\u003cp\u003eTransform a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e to use a different monad\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(forall a.  m a -\u003e m' a) -\u003e Stream m a -\u003e Stream m' a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#trans",
        "fct-type": "function",
        "title": "trans"
      },
      "index": {
        "description": "Transform Stream to use different monad",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "trans",
        "normalized": "(a b c d-\u003ee d)-\u003eStream c d-\u003eStream e d",
        "package": "vector",
        "partial": "",
        "signature": "(forall a. m a-\u003em' a)-\u003eStream m a-\u003eStream m' a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:unbox",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m (Box a) -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#unbox",
        "fct-type": "function",
        "title": "unbox"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "unbox",
        "normalized": "Stream a(Box b)-\u003eStream a b",
        "package": "vector",
        "partial": "",
        "signature": "Stream m(Box a)-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003eUnfold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(s -\u003e Maybe (a, s)) -\u003e s -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Unfold",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eStream c b",
        "package": "vector",
        "partial": "",
        "signature": "(s-\u003eMaybe(a,s))-\u003es-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:unfoldrM",
      "description": {
        "fct-descr": "\u003cp\u003eUnfold with a monadic function\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(s -\u003e m (Maybe (a, s))) -\u003e s -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#unfoldrM",
        "fct-type": "function",
        "title": "unfoldrM"
      },
      "index": {
        "description": "Unfold with monadic function",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "unfoldrM",
        "normalized": "(a-\u003eb(Maybe(c,a)))-\u003ea-\u003eStream b c",
        "package": "vector",
        "partial": "",
        "signature": "(s-\u003em(Maybe(a,s)))-\u003es-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003eUnfold at most \u003ccode\u003en\u003c/code\u003e elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (s -\u003e Maybe (a, s)) -\u003e s -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Unfold at most elements",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003eStream c b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(s-\u003eMaybe(a,s))-\u003es-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:unfoldrNM",
      "description": {
        "fct-descr": "\u003cp\u003eUnfold at most \u003ccode\u003en\u003c/code\u003e elements with a monadic functions\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (s -\u003e m (Maybe (a, s))) -\u003e s -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#unfoldrNM",
        "fct-type": "function",
        "title": "unfoldrNM"
      },
      "index": {
        "description": "Unfold at most elements with monadic functions",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "unfoldrNM",
        "normalized": "Int-\u003e(a-\u003eb(Maybe(c,a)))-\u003ea-\u003eStream b c",
        "package": "vector",
        "partial": "NM",
        "signature": "Int-\u003e(s-\u003em(Maybe(a,s)))-\u003es-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:unsafeFromList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a list to a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with the given \u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e hint. \n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Size -\u003e [a] -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#unsafeFromList",
        "fct-type": "function",
        "title": "unsafeFromList"
      },
      "index": {
        "description": "Convert list to Stream with the given Size hint",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "unsafeFromList",
        "normalized": "Size-\u003e[a]-\u003eStream b a",
        "package": "vector",
        "partial": "From List",
        "signature": "Size-\u003e[a]-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zip",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m b -\u003e Stream m (a, b)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zip",
        "normalized": "Stream a b-\u003eStream a c-\u003eStream a(b,c)",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m b-\u003eStream m(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zip3",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m (a, b, c)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zip3",
        "fct-type": "function",
        "title": "zip3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zip3",
        "normalized": "Stream a b-\u003eStream a c-\u003eStream a d-\u003eStream a(b,c,d)",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m b-\u003eStream m c-\u003eStream m(a,b,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zip4",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m (a, b, c, d)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zip4",
        "fct-type": "function",
        "title": "zip4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zip4",
        "normalized": "Stream a b-\u003eStream a c-\u003eStream a d-\u003eStream a e-\u003eStream a(b,c,d,e)",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m(a,b,c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zip5",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m e -\u003e Stream m (a, b, c, d, e)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zip5",
        "fct-type": "function",
        "title": "zip5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zip5",
        "normalized": "Stream a b-\u003eStream a c-\u003eStream a d-\u003eStream a e-\u003eStream a f-\u003eStream a(b,c,d,e,f)",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m e-\u003eStream m(a,b,c,d,e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zip6",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m e -\u003e Stream m f -\u003e Stream m (a, b, c, d, e, f)",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zip6",
        "fct-type": "function",
        "title": "zip6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zip6",
        "normalized": "Stream a b-\u003eStream a c-\u003eStream a d-\u003eStream a e-\u003eStream a f-\u003eStream a g-\u003eStream a(b,c,d,e,f,g)",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m e-\u003eStream m f-\u003eStream m(a,b,c,d,e,f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003eStream d a-\u003eStream d b-\u003eStream d c",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eStream m a-\u003eStream m b-\u003eStream m c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith3",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eStream e a-\u003eStream e b-\u003eStream e c-\u003eStream e d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eStream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith3M",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e m d) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith3M",
        "fct-type": "function",
        "title": "zipWith3M"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith3M",
        "normalized": "(a-\u003eb-\u003ec-\u003ed e)-\u003eStream d a-\u003eStream d b-\u003eStream d c-\u003eStream d e",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003em d)-\u003eStream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m e",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith4",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eStream f a-\u003eStream f b-\u003eStream f c-\u003eStream f d-\u003eStream f e",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eStream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith4M",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e m e) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m e",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith4M",
        "fct-type": "function",
        "title": "zipWith4M"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith4M",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee f)-\u003eStream e a-\u003eStream e b-\u003eStream e c-\u003eStream e d-\u003eStream e f",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003em e)-\u003eStream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m e -\u003e Stream m f",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith5",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eStream g a-\u003eStream g b-\u003eStream g c-\u003eStream g d-\u003eStream g e-\u003eStream g f",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eStream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m e-\u003eStream m f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith5M",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e m f) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m e -\u003e Stream m f",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith5M",
        "fct-type": "function",
        "title": "zipWith5M"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith5M",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef g)-\u003eStream f a-\u003eStream f b-\u003eStream f c-\u003eStream f d-\u003eStream f e-\u003eStream f g",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003em f)-\u003eStream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m e-\u003eStream m f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m e -\u003e Stream m f -\u003e Stream m g",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith6",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eStream h a-\u003eStream h b-\u003eStream h c-\u003eStream h d-\u003eStream h e-\u003eStream h f-\u003eStream h g",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eStream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m e-\u003eStream m f-\u003eStream m g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWith6M",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e m g) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c -\u003e Stream m d -\u003e Stream m e -\u003e Stream m f -\u003e Stream m g",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWith6M",
        "fct-type": "function",
        "title": "zipWith6M"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWith6M",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg h)-\u003eStream g a-\u003eStream g b-\u003eStream g c-\u003eStream g d-\u003eStream g e-\u003eStream g f-\u003eStream g h",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003em g)-\u003eStream m a-\u003eStream m b-\u003eStream m c-\u003eStream m d-\u003eStream m e-\u003eStream m f-\u003eStream m g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003eZip two \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es with the given monadic function\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Stream m a -\u003e Stream m b -\u003e Stream m c",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "Zip two Stream with the given monadic function",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eStream c a-\u003eStream c b-\u003eStream c d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eStream m a-\u003eStream m b-\u003eStream m c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Monadic.html#v:zipWithM_",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream.Monadic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Stream m a -\u003e Stream m b -\u003e m ()",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream Monadic",
        "module": "Data.Vector.Fusion.Stream.Monadic",
        "name": "zipWithM_",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eStream c a-\u003eStream c b-\u003ec()",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eStream m a-\u003eStream m b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSize hints for streams.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html",
        "fct-type": "module",
        "title": "Size"
      },
      "index": {
        "description": "Size hints for streams",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "Size",
        "normalized": "",
        "package": "vector",
        "partial": "Size",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#t:Size",
      "description": {
        "fct-descr": "\u003cp\u003eSize hint\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html#Size",
        "fct-type": "data",
        "title": "Size"
      },
      "index": {
        "description": "Size hint",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "Size",
        "normalized": "",
        "package": "vector",
        "partial": "Size",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#v:Exact",
      "description": {
        "fct-descr": "\u003cp\u003eExact size\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "Exact Int",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html#Size",
        "fct-type": "function",
        "title": "Exact"
      },
      "index": {
        "description": "Exact size",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "Exact",
        "normalized": "",
        "package": "vector",
        "partial": "Exact",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#v:Max",
      "description": {
        "fct-descr": "\u003cp\u003eUpper bound on the size\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "Max Int",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html#Size",
        "fct-type": "function",
        "title": "Max"
      },
      "index": {
        "description": "Upper bound on the size",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "Max",
        "normalized": "",
        "package": "vector",
        "partial": "Max",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#v:Unknown",
      "description": {
        "fct-descr": "\u003cp\u003eUnknown size\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "Unknown",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html#Size",
        "fct-type": "function",
        "title": "Unknown"
      },
      "index": {
        "description": "Unknown size",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "Unknown",
        "normalized": "",
        "package": "vector",
        "partial": "Unknown",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#v:larger",
      "description": {
        "fct-descr": "\u003cp\u003eMaximum of two size hints\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "Size -\u003e Size -\u003e Size",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html#larger",
        "fct-type": "function",
        "title": "larger"
      },
      "index": {
        "description": "Maximum of two size hints",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "larger",
        "normalized": "Size-\u003eSize-\u003eSize",
        "package": "vector",
        "partial": "",
        "signature": "Size-\u003eSize-\u003eSize"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#v:smaller",
      "description": {
        "fct-descr": "\u003cp\u003eMinimum of two size hints\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "Size -\u003e Size -\u003e Size",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html#smaller",
        "fct-type": "function",
        "title": "smaller"
      },
      "index": {
        "description": "Minimum of two size hints",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "smaller",
        "normalized": "Size-\u003eSize-\u003eSize",
        "package": "vector",
        "partial": "",
        "signature": "Size-\u003eSize-\u003eSize"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#v:toMax",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a size hint to an upper bound\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "Size -\u003e Size",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html#toMax",
        "fct-type": "function",
        "title": "toMax"
      },
      "index": {
        "description": "Convert size hint to an upper bound",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "toMax",
        "normalized": "Size-\u003eSize",
        "package": "vector",
        "partial": "Max",
        "signature": "Size-\u003eSize"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream-Size.html#v:upperBound",
      "description": {
        "fct-descr": "\u003cp\u003eCompute the maximum size from a size hint if possible\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream.Size",
        "fct-package": "vector",
        "fct-signature": "Size -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Fusion-Stream-Size.html#upperBound",
        "fct-type": "function",
        "title": "upperBound"
      },
      "index": {
        "description": "Compute the maximum size from size hint if possible",
        "hierarchy": "Data Vector Fusion Stream Size",
        "module": "Data.Vector.Fusion.Stream.Size",
        "name": "upperBound",
        "normalized": "Size-\u003eMaybe Int",
        "package": "vector",
        "partial": "Bound",
        "signature": "Size-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStreams for stream fusion\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fusion-Stream.html",
        "fct-type": "module",
        "title": "Stream"
      },
      "index": {
        "description": "Streams for stream fusion",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "Stream",
        "normalized": "",
        "package": "vector",
        "partial": "Stream",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#t:MStream",
      "description": {
        "fct-descr": "\u003cp\u003eAlternative name for monadic streams\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#MStream",
        "fct-type": "type",
        "title": "MStream"
      },
      "index": {
        "description": "Alternative name for monadic streams",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "MStream",
        "normalized": "",
        "package": "vector",
        "partial": "MStream",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#t:Step",
      "description": {
        "fct-descr": "\u003cp\u003eResult of taking a single step in a stream\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Step",
        "fct-type": "data",
        "title": "Step"
      },
      "index": {
        "description": "Result of taking single step in stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "Step",
        "normalized": "",
        "package": "vector",
        "partial": "Step",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#t:Stream",
      "description": {
        "fct-descr": "\u003cp\u003eThe type of pure streams \n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#Stream",
        "fct-type": "type",
        "title": "Stream"
      },
      "index": {
        "description": "The type of pure streams",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "Stream",
        "normalized": "",
        "package": "vector",
        "partial": "Stream",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:-33--33-",
      "description": {
        "fct-descr": "\u003cp\u003eElement at the given position\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#%21%21",
        "fct-type": "function",
        "title": "(!!)"
      },
      "index": {
        "description": "Element at the given position",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "(!!) !!",
        "normalized": "Stream a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eElement at the given position or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if out of bounds\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Int -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Element at the given position or Nothing if out of bounds",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "(!?) !?",
        "normalized": "Stream a-\u003eInt-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eInt-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003eConcatenate two \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "(++) ++",
        "normalized": "Stream a-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:Done",
      "description": {
        "fct-descr": "\u003cp\u003eend of stream\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Done",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Step",
        "fct-type": "function",
        "title": "Done"
      },
      "index": {
        "description": "end of stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "Done",
        "normalized": "",
        "package": "vector",
        "partial": "Done",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:Skip",
      "description": {
        "fct-descr": "\u003cp\u003ejust a new seed\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Skip s",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Step",
        "fct-type": "function",
        "title": "Skip"
      },
      "index": {
        "description": "just new seed",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "Skip",
        "normalized": "",
        "package": "vector",
        "partial": "Skip",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:Yield",
      "description": {
        "fct-descr": "\u003cp\u003ea new element and a new seed\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Yield a s",
        "fct-source": "src/Data-Vector-Fusion-Stream-Monadic.html#Step",
        "fct-type": "function",
        "title": "Yield"
      },
      "index": {
        "description": "new element and new seed",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "Yield",
        "normalized": "",
        "package": "vector",
        "partial": "Yield",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:and",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "and",
        "normalized": "Stream Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Stream Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:cmp",
      "description": {
        "fct-descr": "\u003cp\u003eLexicographically compare two \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream a -\u003e Ordering",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#cmp",
        "fct-type": "function",
        "title": "cmp"
      },
      "index": {
        "description": "Lexicographically compare two Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "cmp",
        "normalized": "Stream a-\u003eStream a-\u003eOrdering",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream a-\u003eOrdering"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:concatMap",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Stream b) -\u003e Stream a -\u003e Stream b",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "concatMap",
        "normalized": "(a-\u003eStream b)-\u003eStream a-\u003eStream b",
        "package": "vector",
        "partial": "Map",
        "signature": "(a-\u003eStream b)-\u003eStream a-\u003eStream b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003ePrepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "cons",
        "normalized": "a-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003eAll but the first \u003ccode\u003en\u003c/code\u003e elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "All but the first elements",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "drop",
        "normalized": "Int-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003eDrop the longest prefix of elements that satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "dropWhile",
        "normalized": "(a-\u003eBool)-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Stream a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check whether the Stream contains an element",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "elem",
        "normalized": "a-\u003eStream a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eStream a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003eEmpty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "empty",
        "normalized": "",
        "package": "vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:enumFromStepN",
      "description": {
        "fct-descr": "\u003cp\u003eYield a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Int -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#enumFromStepN",
        "fct-type": "function",
        "title": "enumFromStepN"
      },
      "index": {
        "description": "Yield Stream of the given length containing the values etc",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "enumFromStepN",
        "normalized": "a-\u003ea-\u003eInt-\u003eStream a",
        "package": "vector",
        "partial": "From Step",
        "signature": "a-\u003ea-\u003eInt-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:enumFromThenTo",
      "description": {
        "fct-descr": "\u003cp\u003eEnumerate values with a given step.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operations is very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#enumFromThenTo",
        "fct-type": "function",
        "title": "enumFromThenTo"
      },
      "index": {
        "description": "Enumerate values with given step WARNING This operations is very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "enumFromThenTo",
        "normalized": "a-\u003ea-\u003ea-\u003eStream a",
        "package": "vector",
        "partial": "From Then To",
        "signature": "a-\u003ea-\u003ea-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003eEnumerate values\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operations can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Enumerate values WARNING This operations can be very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "enumFromTo",
        "normalized": "a-\u003ea-\u003eStream a",
        "package": "vector",
        "partial": "From To",
        "signature": "a-\u003ea-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:eq",
      "description": {
        "fct-descr": "\u003cp\u003eCheck if two \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es are equal\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#eq",
        "fct-type": "function",
        "title": "eq"
      },
      "index": {
        "description": "Check if two Stream are equal",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "eq",
        "normalized": "Stream a-\u003eStream a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003eDrop elements which do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements which do not satisfy the predicate",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "filter",
        "normalized": "(a-\u003eBool)-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003eYield a monadic stream of elements that satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Stream a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Yield monadic stream of elements that satisfy the monadic predicate",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "filterM",
        "normalized": "(a-\u003eb Bool)-\u003eStream a-\u003eStream b a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003eStream a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003eYield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no\n such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream a -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "find",
        "normalized": "(a-\u003eBool)-\u003eStream a-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eStream a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003eYield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eStream a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003eStream a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:flatten",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e of values from a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e of streamable things\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e s) -\u003e (s -\u003e Step s b) -\u003e Size -\u003e Stream a -\u003e Stream b",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#flatten",
        "fct-type": "function",
        "title": "flatten"
      },
      "index": {
        "description": "Create Stream of values from Stream of streamable things",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "flatten",
        "normalized": "(a-\u003eb)-\u003e(b-\u003eStep b c)-\u003eSize-\u003eStream a-\u003eStream c",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003es)-\u003e(s-\u003eStep s b)-\u003eSize-\u003eStream a-\u003eStream b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic fold over non-empty stream\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Monadic fold over non-empty stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "fold1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003eMonad fold over non-empty stream with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Stream a -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Monad fold over non-empty stream with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "fold1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eStream a-\u003eb a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eStream a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream b -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Stream b -\u003e m a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Monadic fold with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "foldM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eStream b-\u003ec a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eStream b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream b -\u003e a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream b -\u003e a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "foldl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold on non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream a -\u003e a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold on non-empty Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003eLeft fold on non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream a -\u003e a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold on non-empty Stream with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "foldl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Stream a -\u003e b",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eStream a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eStream a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003eRight fold on non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream a -\u003e a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold on non-empty Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "foldr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e from a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "[a] -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Create Stream from list",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "fromList",
        "normalized": "[a]-\u003eStream a",
        "package": "vector",
        "partial": "List",
        "signature": "[a]-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e from the first \u003ccode\u003en\u003c/code\u003e elements of a list\n\u003c/p\u003e\u003cpre\u003e fromListN n xs = fromList (take n xs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e [a] -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Create Stream from the first elements of list fromListN xs fromList take xs",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "fromListN",
        "normalized": "Int-\u003e[a]-\u003eStream a",
        "package": "vector",
        "partial": "List",
        "signature": "Int-\u003e[a]-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003eGenerate a stream from its indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e a) -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Generate stream from its indices",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003ea)-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003ea)-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003eFirst element of the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e or error if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element of the Stream or error if empty",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "head",
        "normalized": "Stream a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:indexed",
      "description": {
        "fct-descr": "\u003cp\u003ePair each element in a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream (Int, a)",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#indexed",
        "fct-type": "function",
        "title": "indexed"
      },
      "index": {
        "description": "Pair each element in Stream with its index",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "indexed",
        "normalized": "Stream a-\u003eStream(Int,a)",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:indexedR",
      "description": {
        "fct-descr": "\u003cp\u003ePair each element in a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with its index, starting from the right\n and counting down\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Stream a -\u003e Stream (Int, a)",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#indexedR",
        "fct-type": "function",
        "title": "indexedR"
      },
      "index": {
        "description": "Pair each element in Stream with its index starting from the right and counting down",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "indexedR",
        "normalized": "Int-\u003eStream a-\u003eStream(Int,a)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eStream a-\u003eStream(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003eAll but the last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "All but the last element",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "init",
        "normalized": "Stream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:inplace",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream m a -\u003e Stream m b) -\u003e Stream a -\u003e Stream b",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#inplace",
        "fct-type": "function",
        "title": "inplace"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "inplace",
        "normalized": "Stream a b-\u003eStream a c)-\u003eStream b-\u003eStream c",
        "package": "vector",
        "partial": "",
        "signature": "Stream m a-\u003eStream m b)-\u003eStream a-\u003eStream b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003eApply function n-1 times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function n-1 times to value Zeroth element is original value",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "iterateN",
        "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003eLast element of the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e or error if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element of the Stream or error if empty",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "last",
        "normalized": "Stream a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Int",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "length",
        "normalized": "Stream a-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:liftStream",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a pure stream to a monadic stream\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream m a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#liftStream",
        "fct-type": "function",
        "title": "liftStream"
      },
      "index": {
        "description": "Convert pure stream to monadic stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "liftStream",
        "normalized": "Stream a-\u003eStream b a",
        "package": "vector",
        "partial": "Stream",
        "signature": "Stream a-\u003eStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b) -\u003e Stream a -\u003e Stream b",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003eStream a-\u003eStream b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eStream a-\u003eStream b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003eApply a monadic action to each element of the stream, producing a monadic\n stream of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Stream a -\u003e Stream m b",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Apply monadic action to each element of the stream producing monadic stream of results",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003eStream a-\u003eStream b c",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eStream a-\u003eStream m b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003eApply a monadic action to each element of the stream\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Stream a -\u003e m ()",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply monadic action to each element of the stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003eStream a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eStream a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Stream a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Inverse of elem",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "notElem",
        "normalized": "a-\u003eStream a-\u003eBool",
        "package": "vector",
        "partial": "Elem",
        "signature": "a-\u003eStream a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck if a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check if Stream is empty",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "null",
        "normalized": "Stream a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:or",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "or",
        "normalized": "Stream Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Stream Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003eSuffix scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream b -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Suffix scan",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "postscanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003eSuffix scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream b -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Suffix scan with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "postscanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003ePrefix scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream b -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prefix scan",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "prescanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003ePrefix scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream b -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prefix scan with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "prescanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eReplicate a value to a given length\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Replicate value to given length",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003eHaskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream b -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003eHaskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Stream b -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "scanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eStream b-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003eScan over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "scanl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003eScan over a non-empty \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty Stream with strict accumulator",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "scanl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003eSingleton \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Singleton Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "singleton",
        "normalized": "a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:size",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e hint of a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Size",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#size",
        "fct-type": "function",
        "title": "size"
      },
      "index": {
        "description": "Size hint of Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "size",
        "normalized": "Stream a-\u003eSize",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eSize"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:sized",
      "description": {
        "fct-descr": "\u003cp\u003eAttach a \u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e hint to a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Size -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#sized",
        "fct-type": "function",
        "title": "sized"
      },
      "index": {
        "description": "Attach Size hint to Stream",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "sized",
        "normalized": "Stream a-\u003eSize-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eSize-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eExtract a substream of the given length starting at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Stream a-\u003e Stream a",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Extract substream of the given length starting at the given position",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003eAppend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "snoc",
        "normalized": "Stream a-\u003ea-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003ea-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003eAll but the first element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "All but the first element",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "tail",
        "normalized": "Stream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003eThe first \u003ccode\u003en\u003c/code\u003e elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "The first elements",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "take",
        "normalized": "Int-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003eLongest prefix of elements that satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Longest prefix of elements that satisfy the predicate",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "takeWhile",
        "normalized": "(a-\u003eBool)-\u003eStream a-\u003eStream a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eStream a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e [a]",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert Stream to list",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "toList",
        "normalized": "Stream a-\u003e[a]",
        "package": "vector",
        "partial": "List",
        "signature": "Stream a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:unbox",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream (Box a) -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#unbox",
        "fct-type": "function",
        "title": "unbox"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "unbox",
        "normalized": "Stream(Box a)-\u003eStream a",
        "package": "vector",
        "partial": "",
        "signature": "Stream(Box a)-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003eUnfold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(s -\u003e Maybe (a, s)) -\u003e s -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Unfold",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eStream b",
        "package": "vector",
        "partial": "",
        "signature": "(s-\u003eMaybe(a,s))-\u003es-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003eUnfold at most \u003ccode\u003en\u003c/code\u003e elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (s -\u003e Maybe (a, s)) -\u003e s -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Unfold at most elements",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003eStream b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(s-\u003eMaybe(a,s))-\u003es-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:unsafeFromList",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Size -\u003e [a] -\u003e Stream a",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#unsafeFromList",
        "fct-type": "function",
        "title": "unsafeFromList"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "unsafeFromList",
        "normalized": "Size-\u003e[a]-\u003eStream a",
        "package": "vector",
        "partial": "From List",
        "signature": "Size-\u003e[a]-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zip",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream b -\u003e Stream (a, b)",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zip",
        "normalized": "Stream a-\u003eStream b-\u003eStream(a,b)",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream b-\u003eStream(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zip3",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream b -\u003e Stream c -\u003e Stream (a, b, c)",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zip3",
        "fct-type": "function",
        "title": "zip3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zip3",
        "normalized": "Stream a-\u003eStream b-\u003eStream c-\u003eStream(a,b,c)",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream b-\u003eStream c-\u003eStream(a,b,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zip4",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream b -\u003e Stream c -\u003e Stream d -\u003e Stream (a, b, c, d)",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zip4",
        "fct-type": "function",
        "title": "zip4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zip4",
        "normalized": "Stream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream(a,b,c,d)",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream(a,b,c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zip5",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream b -\u003e Stream c -\u003e Stream d -\u003e Stream e -\u003e Stream (a, b, c, d, e)",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zip5",
        "fct-type": "function",
        "title": "zip5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zip5",
        "normalized": "Stream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e-\u003eStream(a,b,c,d,e)",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e-\u003eStream(a,b,c,d,e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zip6",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e Stream b -\u003e Stream c -\u003e Stream d -\u003e Stream e -\u003e Stream f -\u003e Stream (a, b, c, d, e, f)",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zip6",
        "fct-type": "function",
        "title": "zip6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zip6",
        "normalized": "Stream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e-\u003eStream f-\u003eStream(a,b,c,d,e,f)",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e-\u003eStream f-\u003eStream(a,b,c,d,e,f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003eZip two \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es with the given function\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e Stream a -\u003e Stream b -\u003e Stream c",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "Zip two Stream with the given function",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003eStream a-\u003eStream b-\u003eStream c",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eStream a-\u003eStream b-\u003eStream c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003es with the given function\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e Stream a -\u003e Stream b -\u003e Stream c -\u003e Stream d",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "Zip three Stream with the given function",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zipWith3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eStream a-\u003eStream b-\u003eStream c-\u003eStream d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eStream a-\u003eStream b-\u003eStream c-\u003eStream d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Stream a -\u003e Stream b -\u003e Stream c -\u003e Stream d -\u003e Stream e",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zipWith4",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eStream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eStream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Stream a -\u003e Stream b -\u003e Stream c -\u003e Stream d -\u003e Stream e -\u003e Stream f",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zipWith5",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eStream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e-\u003eStream f",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eStream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e-\u003eStream f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Stream a -\u003e Stream b -\u003e Stream c -\u003e Stream d -\u003e Stream e -\u003e Stream f -\u003e Stream g",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zipWith6",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eStream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e-\u003eStream f-\u003eStream g",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eStream a-\u003eStream b-\u003eStream c-\u003eStream d-\u003eStream e-\u003eStream f-\u003eStream g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zipWithM",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Stream a -\u003e Stream b -\u003e Stream m c",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eStream a-\u003eStream b-\u003eStream c d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eStream a-\u003eStream b-\u003eStream m c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Stream.html#v:zipWithM_",
      "description": {
        "fct-module": "Data.Vector.Fusion.Stream",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Stream a -\u003e Stream b -\u003e m ()",
        "fct-source": "src/Data-Vector-Fusion-Stream.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Stream",
        "module": "Data.Vector.Fusion.Stream",
        "name": "zipWithM_",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eStream a-\u003eStream b-\u003ec()",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eStream a-\u003eStream b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFusion-related utility types\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Fusion-Util.html",
        "fct-type": "module",
        "title": "Util"
      },
      "index": {
        "description": "Fusion-related utility types",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "Util",
        "normalized": "",
        "package": "vector",
        "partial": "Util",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#t:Box",
      "description": {
        "fct-descr": "\u003cp\u003eBox monad\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Fusion-Util.html#Box",
        "fct-type": "data",
        "title": "Box"
      },
      "index": {
        "description": "Box monad",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "Box",
        "normalized": "",
        "package": "vector",
        "partial": "Box",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#t:Id",
      "description": {
        "fct-descr": "\u003cp\u003eIdentity monad\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "newtype",
        "fct-source": "src/Data-Vector-Fusion-Util.html#Id",
        "fct-type": "newtype",
        "title": "Id"
      },
      "index": {
        "description": "Identity monad",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "Id",
        "normalized": "",
        "package": "vector",
        "partial": "Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#v:Box",
      "description": {
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "Box",
        "fct-source": "src/Data-Vector-Fusion-Util.html#Box",
        "fct-type": "function",
        "title": "Box"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "Box",
        "normalized": "",
        "package": "vector",
        "partial": "Box",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#v:Id",
      "description": {
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "Id",
        "fct-source": "src/Data-Vector-Fusion-Util.html#Id",
        "fct-type": "function",
        "title": "Id"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "Id",
        "normalized": "",
        "package": "vector",
        "partial": "Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#v:delay_inline",
      "description": {
        "fct-descr": "\u003cp\u003eDelay inlining a function until late in the game (simplifier phase 0).\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b) -\u003e a -\u003e b",
        "fct-source": "src/Data-Vector-Fusion-Util.html#delay_inline",
        "fct-type": "function",
        "title": "delay_inline"
      },
      "index": {
        "description": "Delay inlining function until late in the game simplifier phase",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "delay_inline",
        "normalized": "(a-\u003eb)-\u003ea-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003ea-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#v:delayed_min",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emin\u003c/a\u003e\u003c/code\u003e inlined in phase 0\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Int -\u003e Int",
        "fct-source": "src/Data-Vector-Fusion-Util.html#delayed_min",
        "fct-type": "function",
        "title": "delayed_min"
      },
      "index": {
        "description": "min inlined in phase",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "delayed_min",
        "normalized": "Int-\u003eInt-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#v:unBox",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "a",
        "fct-source": "src/Data-Vector-Fusion-Util.html#Box",
        "fct-type": "function",
        "title": "unBox"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "unBox",
        "normalized": "",
        "package": "vector",
        "partial": "Box",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Fusion-Util.html#v:unId",
      "description": {
        "fct-descr": "&#160;",
        "fct-module": "Data.Vector.Fusion.Util",
        "fct-package": "vector",
        "fct-signature": "a",
        "fct-source": "src/Data-Vector-Fusion-Util.html#Id",
        "fct-type": "function",
        "title": "unId"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Fusion Util",
        "module": "Data.Vector.Fusion.Util",
        "name": "unId",
        "normalized": "",
        "package": "vector",
        "partial": "Id",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneric interface to mutable vectors\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Generic-Mutable.html",
        "fct-type": "module",
        "title": "Mutable"
      },
      "index": {
        "description": "Generic interface to mutable vectors",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "vector",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eClass of mutable vectors parametrised with a primitive state token.\n\u003c/p\u003e\u003cp\u003eMinimum complete implementation:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicLength\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicUnsafeSlice\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicOverlaps\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicUnsafeNew\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicUnsafeRead\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicUnsafeWrite\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#MVector",
        "fct-type": "class",
        "title": "MVector"
      },
      "index": {
        "description": "Class of mutable vectors parametrised with primitive state token Minimum complete implementation basicLength basicUnsafeSlice basicOverlaps basicUnsafeNew basicUnsafeRead basicUnsafeWrite",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:accum",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e v (PrimState m) a -\u003e Stream (Int, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#accum",
        "fct-type": "function",
        "title": "accum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "accum",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec(PrimState d)a-\u003eStream(Int,b)-\u003ed()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ev(PrimState m)a-\u003eStream(Int,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicClear",
      "description": {
        "fct-descr": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed\n vectors. This method should not be called directly, use \u003ccode\u003e\u003ca\u003eclear\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicClear",
        "fct-type": "method",
        "title": "basicClear"
      },
      "index": {
        "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors This method should not be called directly use clear instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicClear",
        "normalized": "a(PrimState b)c-\u003eb()",
        "package": "vector",
        "partial": "Clear",
        "signature": "v(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicLength",
      "description": {
        "fct-descr": "\u003cp\u003eLength of the mutable vector. This method should not be\n called directly, use \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e Int",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicLength",
        "fct-type": "method",
        "title": "basicLength"
      },
      "index": {
        "description": "Length of the mutable vector This method should not be called directly use length instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicLength",
        "normalized": "a b c-\u003eInt",
        "package": "vector",
        "partial": "Length",
        "signature": "v s a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicOverlaps",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e v s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicOverlaps",
        "fct-type": "method",
        "title": "basicOverlaps"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicOverlaps",
        "normalized": "a b c-\u003ea b c-\u003eBool",
        "package": "vector",
        "partial": "Overlaps",
        "signature": "v s a-\u003ev s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicSet",
      "description": {
        "fct-descr": "\u003cp\u003eSet all elements of the vector to the given value. This method should\n not be called directly, use \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicSet",
        "fct-type": "method",
        "title": "basicSet"
      },
      "index": {
        "description": "Set all elements of the vector to the given value This method should not be called directly use set instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicSet",
        "normalized": "a(PrimState b)c-\u003ec-\u003eb()",
        "package": "vector",
        "partial": "Set",
        "signature": "v(PrimState m)a-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicUnsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors may not overlap. This method should not\n be called directly, use \u003ccode\u003e\u003ca\u003eunsafeCopy\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "basicUnsafeCopy",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicUnsafeCopy",
        "fct-type": "method",
        "title": "basicUnsafeCopy"
      },
      "index": {
        "description": "Copy vector The two vectors may not overlap This method should not be called directly use unsafeCopy instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicUnsafeCopy",
        "normalized": "",
        "package": "vector",
        "partial": "Unsafe Copy",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicUnsafeGrow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. This method should not be\n called directly, use \u003ccode\u003e\u003ca\u003eunsafeGrow\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicUnsafeGrow",
        "fct-type": "method",
        "title": "basicUnsafeGrow"
      },
      "index": {
        "description": "Grow vector by the given number of elements This method should not be called directly use unsafeGrow instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicUnsafeGrow",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb(a(PrimState b)c)",
        "package": "vector",
        "partial": "Unsafe Grow",
        "signature": "v(PrimState m)a-\u003eInt-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicUnsafeMove",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors may overlap. This method\n should not be called directly, use \u003ccode\u003e\u003ca\u003eunsafeMove\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "basicUnsafeMove",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicUnsafeMove",
        "fct-type": "method",
        "title": "basicUnsafeMove"
      },
      "index": {
        "description": "Move the contents of vector The two vectors may overlap This method should not be called directly use unsafeMove instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicUnsafeMove",
        "normalized": "",
        "package": "vector",
        "partial": "Unsafe Move",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicUnsafeNew",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length. This method should not be\n called directly, use \u003ccode\u003e\u003ca\u003eunsafeNew\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicUnsafeNew",
        "fct-type": "method",
        "title": "basicUnsafeNew"
      },
      "index": {
        "description": "Create mutable vector of the given length This method should not be called directly use unsafeNew instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicUnsafeNew",
        "normalized": "Int-\u003ea(b(PrimState a)c)",
        "package": "vector",
        "partial": "Unsafe New",
        "signature": "Int-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicUnsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position. This method should not be\n called directly, use \u003ccode\u003e\u003ca\u003eunsafeRead\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicUnsafeRead",
        "fct-type": "method",
        "title": "basicUnsafeRead"
      },
      "index": {
        "description": "Yield the element at the given position This method should not be called directly use unsafeRead instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicUnsafeRead",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
        "package": "vector",
        "partial": "Unsafe Read",
        "signature": "v(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicUnsafeReplicate",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length and fill it with an\n initial value. This method should not be called directly, use\n \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicUnsafeReplicate",
        "fct-type": "method",
        "title": "basicUnsafeReplicate"
      },
      "index": {
        "description": "Create mutable vector of the given length and fill it with an initial value This method should not be called directly use replicate instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicUnsafeReplicate",
        "normalized": "Int-\u003ea-\u003eb(c(PrimState b)a)",
        "package": "vector",
        "partial": "Unsafe Replicate",
        "signature": "Int-\u003ea-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicUnsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it. This method\n should not be called directly, use \u003ccode\u003e\u003ca\u003eunsafeSlice\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "basicUnsafeSlice",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicUnsafeSlice",
        "fct-type": "method",
        "title": "basicUnsafeSlice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it This method should not be called directly use unsafeSlice instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicUnsafeSlice",
        "normalized": "",
        "package": "vector",
        "partial": "Unsafe Slice",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:basicUnsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position. This method should not be\n called directly, use \u003ccode\u003e\u003ca\u003eunsafeWrite\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#basicUnsafeWrite",
        "fct-type": "method",
        "title": "basicUnsafeWrite"
      },
      "index": {
        "description": "Replace the element at the given position This method should not be called directly use unsafeWrite instead",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "basicUnsafeWrite",
        "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
        "package": "vector",
        "partial": "Unsafe Write",
        "signature": "v(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:clear",
      "description": {
        "fct-descr": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed vectors. \n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#clear",
        "fct-type": "function",
        "title": "clear"
      },
      "index": {
        "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "clear",
        "normalized": "a(PrimState b)c-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a copy of a mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Create copy of mutable vector",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "clone",
        "normalized": "a(PrimState b)c-\u003eb(a(PrimState b)c)",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e v (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "copy",
        "normalized": "a(PrimState b)c-\u003ea(PrimState b)c-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003ev(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:drop",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "drop",
        "normalized": "Int-\u003ea b c-\u003ea b c",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ev s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:fill",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e MStream m a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#fill",
        "fct-type": "function",
        "title": "fill"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "fill",
        "normalized": "a(PrimState b)c-\u003eMStream b c-\u003eb(a(PrimState b)c)",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eMStream m a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:fillR",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e MStream m a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#fillR",
        "fct-type": "function",
        "title": "fillR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "fillR",
        "normalized": "a(PrimState b)c-\u003eMStream b c-\u003eb(a(PrimState b)c)",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eMStream m a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:grow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#grow",
        "fct-type": "function",
        "title": "grow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "grow",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb(a(PrimState b)c)",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eInt-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:init",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "init",
        "normalized": "a b c-\u003ea b c",
        "package": "vector",
        "partial": "",
        "signature": "v s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e Int",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of the mutable vector",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "length",
        "normalized": "a b c-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "v s a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:move",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003ecopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e v (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#move",
        "fct-type": "function",
        "title": "move"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length If the vectors do not overlap then this is equivalent to copy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "move",
        "normalized": "a(PrimState b)c-\u003ea(PrimState b)c-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003ev(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:mstream",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e MStream m a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#mstream",
        "fct-type": "function",
        "title": "mstream"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "mstream",
        "normalized": "a(PrimState b)c-\u003eMStream b c",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eMStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:mstreamR",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e MStream m a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#mstreamR",
        "fct-type": "function",
        "title": "mstreamR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "mstreamR",
        "normalized": "a(PrimState b)c-\u003eMStream b c",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eMStream m a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:munstream",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new mutable vector and fill it with elements from the monadic\n stream. The vector will grow exponentially if the maximum size of the stream\n is unknown.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "MStream m a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#munstream",
        "fct-type": "function",
        "title": "munstream"
      },
      "index": {
        "description": "Create new mutable vector and fill it with elements from the monadic stream The vector will grow exponentially if the maximum size of the stream is unknown",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "munstream",
        "normalized": "MStream a b-\u003ea(c(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MStream m a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:munstreamR",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new mutable vector and fill it with elements from the monadic\n stream from right to left. The vector will grow exponentially if the maximum\n size of the stream is unknown.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "MStream m a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#munstreamR",
        "fct-type": "function",
        "title": "munstreamR"
      },
      "index": {
        "description": "Create new mutable vector and fill it with elements from the monadic stream from right to left The vector will grow exponentially if the maximum size of the stream is unknown",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "munstreamR",
        "normalized": "MStream a b-\u003ea(c(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MStream m a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "Create mutable vector of the given length",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "new",
        "normalized": "Int-\u003ea(b(PrimState a)c)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check whether the vector is empty",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "null",
        "normalized": "a b c-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "v s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:overlaps",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e v s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#overlaps",
        "fct-type": "function",
        "title": "overlaps"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "overlaps",
        "normalized": "a b c-\u003ea b c-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "v s a-\u003ev s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:partitionStream",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream a -\u003e m (v (PrimState m) a, v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#partitionStream",
        "fct-type": "function",
        "title": "partitionStream"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "partitionStream",
        "normalized": "(a-\u003eBool)-\u003eStream a-\u003eb(c(PrimState b)a,c(PrimState b)a)",
        "package": "vector",
        "partial": "Stream",
        "signature": "(a-\u003eBool)-\u003eStream a-\u003em(v(PrimState m)a,v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Yield the element at the given position",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "read",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with an initial value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with an initial value",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eb(c(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with values produced by repeatedly executing the monadic action.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with values produced by repeatedly executing the monadic action",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(c(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:reverse",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "reverse",
        "normalized": "a(PrimState b)c-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003eSet all elements of the vector to the given value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#set",
        "fct-type": "function",
        "title": "set"
      },
      "index": {
        "description": "Set all elements of the vector to the given value",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "set",
        "normalized": "a(PrimState b)c-\u003ec-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Int -\u003e v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003ea b c-\u003ea b c",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003ev s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:splitAt",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v s a -\u003e (v s a, v s a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "splitAt",
        "normalized": "Int-\u003ea b c-\u003e(a b c,a b c)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003ev s a-\u003e(v s a,v s a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:swap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "Swap the elements at the given positions",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "swap",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eInt-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "tail",
        "normalized": "a b c-\u003ea b c",
        "package": "vector",
        "partial": "",
        "signature": "v s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:take",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "take",
        "normalized": "Int-\u003ea b c-\u003ea b c",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ev s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:transform",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "(MStream m a -\u003e MStream m a) -\u003e v (PrimState m) a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#transform",
        "fct-type": "function",
        "title": "transform"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "transform",
        "normalized": "(MStream a b-\u003eMStream a b)-\u003ec(PrimState a)b-\u003ea(c(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "(MStream m a-\u003eMStream m a)-\u003ev(PrimState m)a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:transformR",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "(MStream m a -\u003e MStream m a) -\u003e v (PrimState m) a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#transformR",
        "fct-type": "function",
        "title": "transformR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "transformR",
        "normalized": "(MStream a b-\u003eMStream a b)-\u003ec(PrimState a)b-\u003ea(c(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "(MStream m a-\u003eMStream m a)-\u003ev(PrimState m)a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeAccum",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e v (PrimState m) a -\u003e Stream (Int, b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeAccum",
        "fct-type": "function",
        "title": "unsafeAccum"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeAccum",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec(PrimState d)a-\u003eStream(Int,b)-\u003ed()",
        "package": "vector",
        "partial": "Accum",
        "signature": "(a-\u003eb-\u003ea)-\u003ev(PrimState m)a-\u003eStream(Int,b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a-\u003e v (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap This is not checked",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeCopy",
        "normalized": "a(PrimState b)c-\u003ea(PrimState b)c-\u003eb()",
        "package": "vector",
        "partial": "Copy",
        "signature": "v(PrimState m)a-\u003ev(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeDrop",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeDrop",
        "normalized": "Int-\u003ea b c-\u003ea b c",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003ev s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeGrow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeGrow",
        "fct-type": "function",
        "title": "unsafeGrow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive but this is not checked",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeGrow",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb(a(PrimState b)c)",
        "package": "vector",
        "partial": "Grow",
        "signature": "v(PrimState m)a-\u003eInt-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeInit",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeInit",
        "normalized": "a b c-\u003ea b c",
        "package": "vector",
        "partial": "Init",
        "signature": "v s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeMove",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length, but this is not checked.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003eunsafeCopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a-\u003e v (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeMove"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length but this is not checked If the vectors do not overlap then this is equivalent to unsafeCopy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeMove",
        "normalized": "a(PrimState b)c-\u003ea(PrimState b)c-\u003eb()",
        "package": "vector",
        "partial": "Move",
        "signature": "v(PrimState m)a-\u003ev(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeNew",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length. The length is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeNew",
        "fct-type": "function",
        "title": "unsafeNew"
      },
      "index": {
        "description": "Create mutable vector of the given length The length is not checked",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeNew",
        "normalized": "Int-\u003ea(b(PrimState a)c)",
        "package": "vector",
        "partial": "New",
        "signature": "Int-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeRead",
        "fct-type": "function",
        "title": "unsafeRead"
      },
      "index": {
        "description": "Yield the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeRead",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
        "package": "vector",
        "partial": "Read",
        "signature": "v(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it. No bounds checks\n are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e v s a-\u003e v s a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it No bounds checks are performed",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003ea b c-\u003ea b c",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003ev s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeSwap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeSwap",
        "fct-type": "function",
        "title": "unsafeSwap"
      },
      "index": {
        "description": "Swap the elements at the given positions No bounds checks are performed",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeSwap",
        "normalized": "a(PrimState b)c-\u003eInt-\u003eInt-\u003eb()",
        "package": "vector",
        "partial": "Swap",
        "signature": "v(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeTail",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeTail",
        "normalized": "a b c-\u003ea b c",
        "package": "vector",
        "partial": "Tail",
        "signature": "v s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeTake",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v s a -\u003e v s a",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeTake",
        "normalized": "Int-\u003ea b c-\u003ea b c",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003ev s a-\u003ev s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeUpdate",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Stream (Int, a) -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeUpdate",
        "fct-type": "function",
        "title": "unsafeUpdate"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeUpdate",
        "normalized": "a(PrimState b)c-\u003eStream(Int,c)-\u003eb()",
        "package": "vector",
        "partial": "Update",
        "signature": "v(PrimState m)a-\u003eStream(Int,a)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unsafeWrite",
        "fct-type": "function",
        "title": "unsafeWrite"
      },
      "index": {
        "description": "Replace the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unsafeWrite",
        "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
        "package": "vector",
        "partial": "Write",
        "signature": "v(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unstablePartition",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v (PrimState m) a -\u003e m Int",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unstablePartition",
        "fct-type": "function",
        "title": "unstablePartition"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unstablePartition",
        "normalized": "(a-\u003eBool)-\u003eb(PrimState c)a-\u003ec Int",
        "package": "vector",
        "partial": "Partition",
        "signature": "(a-\u003eBool)-\u003ev(PrimState m)a-\u003em Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unstablePartitionStream",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Stream a -\u003e m (v (PrimState m) a, v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unstablePartitionStream",
        "fct-type": "function",
        "title": "unstablePartitionStream"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unstablePartitionStream",
        "normalized": "(a-\u003eBool)-\u003eStream a-\u003eb(c(PrimState b)a,c(PrimState b)a)",
        "package": "vector",
        "partial": "Partition Stream",
        "signature": "(a-\u003eBool)-\u003eStream a-\u003em(v(PrimState m)a,v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unstream",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new mutable vector and fill it with elements from the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e.\n The vector will grow exponentially if the maximum size of the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e is\n unknown.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unstream",
        "fct-type": "function",
        "title": "unstream"
      },
      "index": {
        "description": "Create new mutable vector and fill it with elements from the Stream The vector will grow exponentially if the maximum size of the Stream is unknown",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unstream",
        "normalized": "Stream a-\u003eb(c(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:unstreamR",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a new mutable vector and fill it with elements from the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n from right to left. The vector will grow exponentially if the maximum size\n of the \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e is unknown.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e m (v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#unstreamR",
        "fct-type": "function",
        "title": "unstreamR"
      },
      "index": {
        "description": "Create new mutable vector and fill it with elements from the Stream from right to left The vector will grow exponentially if the maximum size of the Stream is unknown",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "unstreamR",
        "normalized": "Stream a-\u003eb(c(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003em(v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:update",
      "description": {
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Stream (Int, a) -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#update",
        "fct-type": "function",
        "title": "update"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "update",
        "normalized": "a(PrimState b)c-\u003eStream(Int,c)-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eStream(Int,a)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-Mutable.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic.Mutable",
        "fct-package": "vector",
        "fct-signature": "v (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Mutable.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Replace the element at the given position",
        "hierarchy": "Data Vector Generic Mutable",
        "module": "Data.Vector.Generic.Mutable",
        "name": "write",
        "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePurely functional interface to initialisation of mutable vectors\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Generic-New.html",
        "fct-type": "module",
        "title": "New"
      },
      "index": {
        "description": "Purely functional interface to initialisation of mutable vectors",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "New",
        "normalized": "",
        "package": "vector",
        "partial": "New",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#t:New",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Generic-New.html#New",
        "fct-type": "data",
        "title": "New"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "New",
        "normalized": "",
        "package": "vector",
        "partial": "New",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:New",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "New (forall s.  ST s (Mutable v s a))",
        "fct-source": "src/Data-Vector-Generic-New.html#New",
        "fct-type": "function",
        "title": "New"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "New",
        "normalized": "",
        "package": "vector",
        "partial": "New",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:apply",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "(forall s.  Mutable v s a -\u003e Mutable v s a) -\u003e New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#apply",
        "fct-type": "function",
        "title": "apply"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "apply",
        "normalized": "(a b Mutable c d e-\u003eMutable c d e)-\u003eNew c e-\u003eNew c e",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. Mutable v s a-\u003eMutable v s a)-\u003eNew v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:create",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "(forall s.  ST s (Mutable v s a)) -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "create",
        "normalized": "(a b ST c(Mutable d c e))-\u003eNew d e",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. ST s(Mutable v s a))-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:drop",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "drop",
        "normalized": "Int-\u003eNew a b-\u003eNew a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eNew v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:init",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "init",
        "normalized": "New a b-\u003eNew a b",
        "package": "vector",
        "partial": "",
        "signature": "New v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:modify",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "(forall s.  Mutable v s a -\u003e ST s ()) -\u003e New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#modify",
        "fct-type": "function",
        "title": "modify"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "modify",
        "normalized": "(a b Mutable c d e-\u003eST d())-\u003eNew c e-\u003eNew c e",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. Mutable v s a-\u003eST s())-\u003eNew v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:modifyWithStream",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "(forall s.  Mutable v s a -\u003e Stream b -\u003e ST s ()) -\u003e New v a -\u003e Stream b -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#modifyWithStream",
        "fct-type": "function",
        "title": "modifyWithStream"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "modifyWithStream",
        "normalized": "(a b Mutable c d e-\u003eStream f-\u003eST d())-\u003eNew c e-\u003eStream f-\u003eNew c e",
        "package": "vector",
        "partial": "With Stream",
        "signature": "(forall s. Mutable v s a-\u003eStream b-\u003eST s())-\u003eNew v a-\u003eStream b-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:run",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "New v a -\u003e ST s (Mutable v s a)",
        "fct-source": "src/Data-Vector-Generic-New.html#run",
        "fct-type": "function",
        "title": "run"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "run",
        "normalized": "New a b-\u003eST c(Mutable a c b)",
        "package": "vector",
        "partial": "",
        "signature": "New v a-\u003eST s(Mutable v s a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:runPrim",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "New v a -\u003e m (Mutable v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-New.html#runPrim",
        "fct-type": "function",
        "title": "runPrim"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "runPrim",
        "normalized": "New a b-\u003ec(Mutable a(PrimState c)b)",
        "package": "vector",
        "partial": "Prim",
        "signature": "New v a-\u003em(Mutable v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:slice",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Int -\u003e New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eNew a b-\u003eNew a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eNew v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "tail",
        "normalized": "New a b-\u003eNew a b",
        "package": "vector",
        "partial": "",
        "signature": "New v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:take",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "take",
        "normalized": "Int-\u003eNew a b-\u003eNew a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eNew v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:transform",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "MStream m a -\u003e MStream m a) -\u003e New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#transform",
        "fct-type": "function",
        "title": "transform"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "transform",
        "normalized": "MStream a b-\u003eMStream a b)-\u003eNew c b-\u003eNew c b",
        "package": "vector",
        "partial": "",
        "signature": "MStream m a-\u003eMStream m a)-\u003eNew v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:transformR",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "MStream m a -\u003e MStream m a) -\u003e New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#transformR",
        "fct-type": "function",
        "title": "transformR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "transformR",
        "normalized": "MStream a b-\u003eMStream a b)-\u003eNew c b-\u003eNew c b",
        "package": "vector",
        "partial": "",
        "signature": "MStream m a-\u003eMStream m a)-\u003eNew v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:unsafeInit",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "unsafeInit",
        "normalized": "New a b-\u003eNew a b",
        "package": "vector",
        "partial": "Init",
        "signature": "New v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:unsafeSlice",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Int -\u003e New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#unsafeSlice",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eNew a b-\u003eNew a b",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eNew v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:unsafeTail",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "New v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "unsafeTail",
        "normalized": "New a b-\u003eNew a b",
        "package": "vector",
        "partial": "Tail",
        "signature": "New v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:unstream",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#unstream",
        "fct-type": "function",
        "title": "unstream"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "unstream",
        "normalized": "Stream a-\u003eNew b a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic-New.html#v:unstreamR",
      "description": {
        "fct-module": "Data.Vector.Generic.New",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic-New.html#unstreamR",
        "fct-type": "function",
        "title": "unstreamR"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic New",
        "module": "Data.Vector.Generic.New",
        "name": "unstreamR",
        "normalized": "Stream a-\u003eNew b a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneric interface to pure vectors.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Generic.html",
        "fct-type": "module",
        "title": "Generic"
      },
      "index": {
        "description": "Generic interface to pure vectors",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "Generic",
        "normalized": "",
        "package": "vector",
        "partial": "Generic",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#t:Mutable",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003eMutable v s a\u003c/code\u003e is the mutable version of the pure vector type \u003ccode\u003ev a\u003c/code\u003e with\n the state token \u003ccode\u003es\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Mutable",
        "fct-type": "function",
        "title": "Mutable"
      },
      "index": {
        "description": "Mutable is the mutable version of the pure vector type with the state token",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "Mutable",
        "normalized": "",
        "package": "vector",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#t:Vector",
      "description": {
        "fct-descr": "\u003cp\u003eClass of immutable vectors. Every immutable vector is associated with its\n mutable version through the \u003ccode\u003e\u003ca\u003eMutable\u003c/a\u003e\u003c/code\u003e type family. Methods of this class\n should not be used directly. Instead, \u003ca\u003eData.Vector.Generic\u003c/a\u003e and other\n Data.Vector modules provide safe and fusible wrappers.\n\u003c/p\u003e\u003cp\u003eMinimum complete implementation:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicUnsafeFreeze\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicUnsafeThaw\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicLength\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicUnsafeSlice\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ebasicUnsafeIndexM\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Generic-Base.html#Vector",
        "fct-type": "class",
        "title": "Vector"
      },
      "index": {
        "description": "Class of immutable vectors Every immutable vector is associated with its mutable version through the Mutable type family Methods of this class should not be used directly Instead Data.Vector.Generic and other Data.Vector modules provide safe and fusible wrappers Minimum complete implementation basicUnsafeFreeze basicUnsafeThaw basicLength basicUnsafeSlice basicUnsafeIndexM",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "Vector",
        "normalized": "",
        "package": "vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Indexing",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "(!) !",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Safe indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Generic.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Safe indexing",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "(!?) !?",
        "normalized": "a b-\u003eInt-\u003eMaybe b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003eInt-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e Concatenate two vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two vectors",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "(++) ++",
        "normalized": "a b-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:-47--47-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the list, replace the vector\n element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003c5,9,2,7\u003e // [(2,1),(0,3),(2,8)] = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a-\u003e [(Int, a)]-\u003e v a",
        "fct-type": "function",
        "title": "(//)"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "(//) //",
        "normalized": "a b-\u003e[(Int,b)]-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003e[(Int,a)]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:accum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the list, replace the vector element\n \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accum (+) \u003c5,9,2\u003e [(2,4),(1,6),(0,3),(1,7)] = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e [(Int, b)]-\u003e v a",
        "fct-type": "function",
        "title": "accum"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by accum",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "accum",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003e[(Int,b)]-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003e[(Int,b)]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:accumulate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the vector of pairs, replace the vector\n element \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate (+) \u003c5,9,2\u003e \u003c(2,4),(1,6),(0,3),(1,7)\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e v (Int, b)-\u003e v a",
        "fct-type": "function",
        "title": "accumulate"
      },
      "index": {
        "description": "For each pair from the vector of pairs replace the vector element at position by accumulate",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "accumulate",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ec(Int,b)-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev(Int,b)-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:accumulate_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003eb\u003c/code\u003e from the the value vector,\n replace the element of the initial vector at\n position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate_ (+) \u003c5,9,2\u003e \u003c2,1,0,1\u003e \u003c4,6,3,7\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e\u003cp\u003eThis function is useful for instances of \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e that cannot store pairs.\n Otherwise, \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e is probably more convenient:\n\u003c/p\u003e\u003cpre\u003e\n accumulate_ f as is bs = \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e f as (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is bs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e v Int-\u003e v b-\u003e v a",
        "fct-type": "function",
        "title": "accumulate_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the the value vector replace the element of the initial vector at position by accumulate This function is useful for instances of Vector that cannot store pairs Otherwise accumulate is probably more convenient accumulate as is bs accumulate as zip is bs",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "accumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ec Int-\u003ec b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev Int-\u003ev b-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Check if all elements satisfy the predicate",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements are \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "Check if all elements are True",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "and",
        "normalized": "a Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "v Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Check if any element satisfies the predicate",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:backpermute",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the vector obtained by replacing each element \u003ccode\u003ei\u003c/code\u003e of the\n index vector by \u003ccode\u003exs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003ei\u003c/code\u003e. This is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (xs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e) is\u003c/code\u003e but is\n often much more efficient.\n\u003c/p\u003e\u003cpre\u003e backpermute \u003ca,b,c,d\u003e \u003c0,3,2,3,1,0\u003e = \u003ca,d,c,d,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a-\u003e v Int-\u003e v a",
        "fct-type": "function",
        "title": "backpermute"
      },
      "index": {
        "description": "Yield the vector obtained by replacing each element of the index vector by xs This is equivalent to map xs is but is often much more efficient backpermute",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "backpermute",
        "normalized": "a b-\u003ea Int-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev Int-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:basicLength",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eAssumed complexity: O(1)\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eYield the length of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Generic-Base.html#basicLength",
        "fct-type": "method",
        "title": "basicLength"
      },
      "index": {
        "description": "Assumed complexity Yield the length of the vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "basicLength",
        "normalized": "a b-\u003eInt",
        "package": "vector",
        "partial": "Length",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:basicUnsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eAssumed complexity: O(n)\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eCopy an immutable vector into a mutable one. The two vectors must have\n the same length but this is not checked.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e should redefine this method if they wish to support\n an efficient block copy operation.\n\u003c/p\u003e\u003cp\u003eDefault definition: copying basic on \u003ccode\u003e\u003ca\u003ebasicUnsafeIndexM\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003ebasicUnsafeWrite\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Mutable v (PrimState m) a -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic-Base.html#basicUnsafeCopy",
        "fct-type": "method",
        "title": "basicUnsafeCopy"
      },
      "index": {
        "description": "Assumed complexity Copy an immutable vector into mutable one The two vectors must have the same length but this is not checked Instances of Vector should redefine this method if they wish to support an efficient block copy operation Default definition copying basic on basicUnsafeIndexM and basicUnsafeWrite",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "basicUnsafeCopy",
        "normalized": "Mutable a(PrimState b)c-\u003ea c-\u003eb()",
        "package": "vector",
        "partial": "Unsafe Copy",
        "signature": "Mutable v(PrimState m)a-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:basicUnsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eAssumed complexity: O(1)\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eUnsafely convert a mutable vector to its immutable version\n without copying. The mutable vector may not be used after\n this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Mutable v (PrimState m) a -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Generic-Base.html#basicUnsafeFreeze",
        "fct-type": "method",
        "title": "basicUnsafeFreeze"
      },
      "index": {
        "description": "Assumed complexity Unsafely convert mutable vector to its immutable version without copying The mutable vector may not be used after this operation",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "basicUnsafeFreeze",
        "normalized": "Mutable a(PrimState b)c-\u003eb(a c)",
        "package": "vector",
        "partial": "Unsafe Freeze",
        "signature": "Mutable v(PrimState m)a-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:basicUnsafeIndexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eAssumed complexity: O(1)\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eYield the element at the given position in a monad. No range checks are\n performed.\n\u003c/p\u003e\u003cp\u003eThe monad allows us to be strict in the vector if we want. Suppose we had\n\u003c/p\u003e\u003cpre\u003e unsafeIndex :: v a -\u003e Int -\u003e a\n\u003c/pre\u003e\u003cp\u003einstead. Now, if we wanted to copy a vector, we'd do something like\n\u003c/p\u003e\u003cpre\u003e copy mv v ... = ... unsafeWrite mv i (unsafeIndex v i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, the indexing would not be evaluated which means that we\n would retain a reference to the original vector in each element we write.\n This is not what we want!\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003ebasicUnsafeIndexM\u003c/a\u003e\u003c/code\u003e, we can do\n\u003c/p\u003e\u003cpre\u003e copy mv v ... = ... case basicUnsafeIndexM v i of\n                       Box x -\u003e unsafeWrite mv i x ...\n\u003c/pre\u003e\u003cp\u003ewhich does not have this problem because indexing (but not the returned\n element!) is evaluated immediately.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Generic-Base.html#basicUnsafeIndexM",
        "fct-type": "method",
        "title": "basicUnsafeIndexM"
      },
      "index": {
        "description": "Assumed complexity Yield the element at the given position in monad No range checks are performed The monad allows us to be strict in the vector if we want Suppose we had unsafeIndex Int instead Now if we wanted to copy vector we do something like copy mv unsafeWrite mv unsafeIndex For lazy vectors the indexing would not be evaluated which means that we would retain reference to the original vector in each element we write This is not what we want With basicUnsafeIndexM we can do copy mv case basicUnsafeIndexM of Box unsafeWrite mv which does not have this problem because indexing but not the returned element is evaluated immediately",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "basicUnsafeIndexM",
        "normalized": "a b-\u003eInt-\u003ec b",
        "package": "vector",
        "partial": "Unsafe Index",
        "signature": "v a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:basicUnsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eAssumed complexity: O(1)\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eYield a slice of the vector without copying it. No range checks are\n performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "basicUnsafeSlice",
        "fct-source": "src/Data-Vector-Generic-Base.html#basicUnsafeSlice",
        "fct-type": "method",
        "title": "basicUnsafeSlice"
      },
      "index": {
        "description": "Assumed complexity Yield slice of the vector without copying it No range checks are performed",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "basicUnsafeSlice",
        "normalized": "",
        "package": "vector",
        "partial": "Unsafe Slice",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:basicUnsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eAssumed complexity: O(1)\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eUnsafely convert an immutable vector to its mutable version without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e m (Mutable v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic-Base.html#basicUnsafeThaw",
        "fct-type": "method",
        "title": "basicUnsafeThaw"
      },
      "index": {
        "description": "Assumed complexity Unsafely convert an immutable vector to its mutable version without copying The immutable vector may not be used after this operation",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "basicUnsafeThaw",
        "normalized": "a b-\u003ec(Mutable a(PrimState c)b)",
        "package": "vector",
        "partial": "Unsafe Thaw",
        "signature": "v a-\u003em(Mutable v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that do not\n satisfy the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e (v a, v a)",
        "fct-source": "src/Data-Vector-Generic.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that do not satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "break",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003e(b a,b a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003e(v a,v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a vector to an initialiser which, when run, produces a copy of\n the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e New v a",
        "fct-source": "src/Data-Vector-Generic.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Convert vector to an initialiser which when run produces copy of the vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "clone",
        "normalized": "a b-\u003eNew a b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003eNew v a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:cmp",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compare two vectors lexicographically. All \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e instances are\n also instances of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and it is usually more appropriate to use those. This\n function is primarily intended for implementing \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instances for new\n vector types.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a -\u003e Ordering",
        "fct-source": "src/Data-Vector-Generic.html#cmp",
        "fct-type": "function",
        "title": "cmp"
      },
      "index": {
        "description": "Compare two vectors lexicographically All Vector instances are also instances of Ord and it is usually more appropriate to use those This function is primarily intended for implementing Ord instances for new vector types",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "cmp",
        "normalized": "a b-\u003ea b-\u003eOrdering",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev a-\u003eOrdering"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate all vectors in the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "[v a] -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate all vectors in the list",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "concat",
        "normalized": "[a b]-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "[v a]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a vector and concatenate the results.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e v b) -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over vector and concatenate the results",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "concatMap",
        "normalized": "(a-\u003eb c)-\u003eb a-\u003eb c",
        "package": "vector",
        "partial": "Map",
        "signature": "(a-\u003ev b)-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "cons",
        "normalized": "a-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:constructN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements by repeatedly applying the\n generator function to the already constructed part of the vector.\n\u003c/p\u003e\u003cpre\u003e constructN 3 f = let a = f \u003c\u003e ; b = f \u003ca\u003e ; c = f \u003ca,b\u003e in f \u003ca,b,c\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (v a -\u003e a) -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#constructN",
        "fct-type": "function",
        "title": "constructN"
      },
      "index": {
        "description": "Construct vector with elements by repeatedly applying the generator function to the already constructed part of the vector constructN let in",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "constructN",
        "normalized": "Int-\u003e(a b-\u003eb)-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(v a-\u003ea)-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:constructrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements from right to left by\n repeatedly applying the generator function to the already constructed part\n of the vector.\n\u003c/p\u003e\u003cpre\u003e constructrN 3 f = let a = f \u003c\u003e ; b = f\u003ca\u003e ; c = f \u003cb,a\u003e in f \u003cc,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (v a -\u003e a) -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#constructrN",
        "fct-type": "function",
        "title": "constructrN"
      },
      "index": {
        "description": "Construct vector with elements from right to left by repeatedly applying the generator function to the already constructed part of the vector constructrN let in",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "constructrN",
        "normalized": "Int-\u003e(a b-\u003eb)-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(v a-\u003ea)-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:convert",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert different vector types\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e w a",
        "fct-source": "src/Data-Vector-Generic.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "Convert different vector types",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "convert",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Mutable v (PrimState m) a -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "copy",
        "normalized": "Mutable a(PrimState b)c-\u003ea c-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "Mutable v(PrimState m)a-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:create",
      "description": {
        "fct-descr": "\u003cp\u003eExecute the monadic action and freeze the resulting vector.\n\u003c/p\u003e\u003cpre\u003e\n create (do { v \u003c- \u003ccode\u003e\u003ca\u003enew\u003c/a\u003e\u003c/code\u003e 2; \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e v 0 'a'; \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e v 1 'b'; return v }) = \u003c\u003ccode\u003ea\u003c/code\u003e,\u003ccode\u003eb\u003c/code\u003e\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(forall s.  ST s (Mutable v s a)) -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "Execute the monadic action and freeze the resulting vector create do new write write return",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "create",
        "normalized": "(a b ST c(Mutable d c e))-\u003ed e",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. ST s(Mutable v s a))-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:dataCast",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "c (t d)) -\u003e Maybe (c (v a))",
        "fct-source": "src/Data-Vector-Generic.html#dataCast",
        "fct-type": "function",
        "title": "dataCast"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "dataCast",
        "normalized": "a(b c))-\u003eMaybe(a(d e))",
        "package": "vector",
        "partial": "Cast",
        "signature": "c(t d))-\u003eMaybe(c(v a))"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case an empty vector is returned.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector may contain less than elements in which case an empty vector is returned",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "drop",
        "normalized": "Int-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop the longest prefix of elements that satisfy the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate without copying",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "dropWhile",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check if the vector contains an element",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "elem",
        "normalized": "a-\u003eb a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first occurence of the given element or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the vector does not contain the element. This is a specialised\n version of \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e v a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Generic.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "Yield Just the index of the first occurence of the given element or Nothing if the vector does not contain the element This is specialised version of findIndex",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "elemIndex",
        "normalized": "a-\u003eb a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "a-\u003ev a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of all occurences of the given element in\n ascending order. This is a specialised version of \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e v a -\u003e v Int",
        "fct-source": "src/Data-Vector-Generic.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "Yield the indices of all occurences of the given element in ascending order This is specialised version of findIndices",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "elemIndices",
        "normalized": "a-\u003eb a-\u003eb Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "a-\u003ev a-\u003ev Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:elemseq",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate \u003ccode\u003ea\u003c/code\u003e as far as storing it in a vector would and yield \u003ccode\u003eb\u003c/code\u003e.\n The \u003ccode\u003ev a\u003c/code\u003e argument only fixes the type and is not touched. The method is\n only used for optimisation purposes. Thus, it is safe for instances of\n \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e to evaluate \u003ccode\u003ea\u003c/code\u003e less than it would be when stored in a vector\n although this might result in suboptimal code.\n\u003c/p\u003e\u003cpre\u003e elemseq v x y = (singleton x `asTypeOf` v) `seq` y\n\u003c/pre\u003e\u003cp\u003eDefault defintion: \u003ccode\u003ea\u003c/code\u003e is not evaluated at all\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a -\u003e b -\u003e b",
        "fct-source": "src/Data-Vector-Generic-Base.html#elemseq",
        "fct-type": "method",
        "title": "elemseq"
      },
      "index": {
        "description": "Evaluate as far as storing it in vector would and yield The argument only fixes the type and is not touched The method is only used for optimisation purposes Thus it is safe for instances of Vector to evaluate less than it would be when stored in vector although this might result in suboptimal code elemseq singleton asTypeOf seq Default defintion is not evaluated at all",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "elemseq",
        "normalized": "a b-\u003eb-\u003ec-\u003ec",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ea-\u003eb-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a",
        "fct-source": "src/Data-Vector-Generic.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "empty",
        "normalized": "",
        "package": "vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:enumFromN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+1\u003c/code\u003e\n etc. This operation is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromN 5 3 = \u003c5,6,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Int -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#enumFromN",
        "fct-type": "function",
        "title": "enumFromN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operation is usually more efficient than enumFromTo enumFromN",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "enumFromN",
        "normalized": "a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "From",
        "signature": "a-\u003eInt-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:enumFromStepN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc. This operations is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromThenTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromStepN 1 0.1 5 = \u003c1,1.1,1.2,1.3,1.4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Int -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#enumFromStepN",
        "fct-type": "function",
        "title": "enumFromStepN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operations is usually more efficient than enumFromThenTo enumFromStepN",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "enumFromStepN",
        "normalized": "a-\u003ea-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "From Step",
        "signature": "a-\u003ea-\u003eInt-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:enumFromThenTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e with a specific step \u003ccode\u003ez\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#enumFromThenTo",
        "fct-type": "function",
        "title": "enumFromThenTo"
      },
      "index": {
        "description": "Enumerate values from to with specific step WARNING This operation can be very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "enumFromThenTo",
        "normalized": "a-\u003ea-\u003ea-\u003eb a",
        "package": "vector",
        "partial": "From Then To",
        "signature": "a-\u003ea-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Enumerate values from to WARNING This operation can be very inefficient If at all possible use enumFromN instead",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "enumFromTo",
        "normalized": "a-\u003ea-\u003eb a",
        "package": "vector",
        "partial": "From To",
        "signature": "a-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:eq",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if two vectors are equal. All \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e instances are also\n instances of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e and it is usually more appropriate to use those. This\n function is primarily intended for implementing \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e instances for new\n vector types.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic.html#eq",
        "fct-type": "function",
        "title": "eq"
      },
      "index": {
        "description": "Check if two vectors are equal All Vector instances are also instances of Eq and it is usually more appropriate to use those This function is primarily intended for implementing Eq instances for new vector types",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "eq",
        "normalized": "a b-\u003ea b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "filter",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e v a -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Generic.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Drop elements that do not satisfy the monadic predicate",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "filterM",
        "normalized": "(a-\u003eb Bool)-\u003ec a-\u003eb(c a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003ev a-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Generic.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "find",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Generic.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003ev a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of elements satisfying the predicate in ascending\n order.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e v Int",
        "fct-source": "src/Data-Vector-Generic.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "Yield the indices of elements satisfying the predicate in ascending order",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "findIndices",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eb Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "(a-\u003eBool)-\u003ev a-\u003ev Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "fold1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "fold1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:fold1M-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monad fold over non-empty vectors with strict accumulator\n that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#fold1M%27_",
        "fct-type": "function",
        "title": "fold1M'_"
      },
      "index": {
        "description": "Monad fold over non-empty vectors with strict accumulator that discards the result",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "fold1M'_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:fold1M_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#fold1M_",
        "fct-type": "function",
        "title": "fold1M_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors that discards the result",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "fold1M_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Monadic fold with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldM-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#foldM%27_",
        "fct-type": "function",
        "title": "foldM'_"
      },
      "index": {
        "description": "Monadic fold with strict accumulator that discards the result",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldM'_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#foldM_",
        "fct-type": "function",
        "title": "foldM_"
      },
      "index": {
        "description": "Monadic fold that discards the result",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldM_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold on non-empty vectors",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Generic.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Generic.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold on non-empty vectors",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "Right fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "foldr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:forM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results. Equvalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e (a -\u003e m b) -\u003e m (v b)",
        "fct-source": "src/Data-Vector-Generic.html#forM",
        "fct-type": "function",
        "title": "forM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results Equvalent to flip mapM",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "forM",
        "normalized": "a b-\u003e(b-\u003ec d)-\u003ec(a d)",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003e(a-\u003em b)-\u003em(v b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:forM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results. Equivalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e (a -\u003e m b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#forM_",
        "fct-type": "function",
        "title": "forM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results Equivalent to flip mapM",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "forM_",
        "normalized": "a b-\u003e(b-\u003ec d)-\u003ec()",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003e(a-\u003em b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:force",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the argument but force it not to retain any extra memory,\n possibly by copying it.\n\u003c/p\u003e\u003cp\u003eThis is especially useful when dealing with slices. For example:\n\u003c/p\u003e\u003cpre\u003e force (slice 0 2 \u003chuge vector\u003e)\n\u003c/pre\u003e\u003cp\u003eHere, the slice retains a reference to the huge vector. Forcing it creates\n a copy of just the elements that belong to the slice and allows the huge\n vector to be garbage collected.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#force",
        "fct-type": "function",
        "title": "force"
      },
      "index": {
        "description": "Yield the argument but force it not to retain any extra memory possibly by copying it This is especially useful when dealing with slices For example force slice huge vector Here the slice retains reference to the huge vector Forcing it creates copy of just the elements that belong to the slice and allows the huge vector to be garbage collected",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "force",
        "normalized": "a b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:freeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield an immutable copy of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Mutable v (PrimState m) a -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Generic.html#freeze",
        "fct-type": "function",
        "title": "freeze"
      },
      "index": {
        "description": "Yield an immutable copy of the mutable vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "freeze",
        "normalized": "Mutable a(PrimState b)c-\u003eb(a c)",
        "package": "vector",
        "partial": "",
        "signature": "Mutable v(PrimState m)a-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a list to a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "[a] -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "fromList",
        "normalized": "[a]-\u003eb a",
        "package": "vector",
        "partial": "List",
        "signature": "[a]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a vector\n\u003c/p\u003e\u003cpre\u003e\n fromListN n xs = \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e [a] -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Convert the first elements of list to vector fromListN xs fromList take xs",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "fromListN",
        "normalized": "Int-\u003e[a]-\u003eb a",
        "package": "vector",
        "partial": "List",
        "signature": "Int-\u003e[a]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the function to\n each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e a) -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Construct vector of the given length by applying the function to each index",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003ea)-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003ea)-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the monadic\n action to each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e m a) -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Generic.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Construct vector of the given length by applying the monadic action to each index",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "generateM",
        "normalized": "Int-\u003e(Int-\u003ea b)-\u003ea(c b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003em a)-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:gfoldl",
      "description": {
        "fct-descr": "\u003cp\u003eGeneric definion of \u003ccode\u003e\u003ca\u003egfoldl\u003c/a\u003e\u003c/code\u003e that views a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e as a\n list.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "c (d -\u003e b) -\u003e d -\u003e c b) -\u003e (forall g.  g -\u003e c g) -\u003e v a -\u003e c (v a)",
        "fct-source": "src/Data-Vector-Generic.html#gfoldl",
        "fct-type": "function",
        "title": "gfoldl"
      },
      "index": {
        "description": "Generic definion of gfoldl that views Vector as list",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "gfoldl",
        "normalized": "a(b-\u003ec)-\u003eb-\u003ea c)-\u003e(d e f-\u003ea f)-\u003eg h-\u003ea(g h)",
        "package": "vector",
        "partial": "",
        "signature": "c(d-\u003eb)-\u003ed-\u003ec b)-\u003e(forall g. g-\u003ec g)-\u003ev a-\u003ec(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "head",
        "normalized": "a b-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:headM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#headM",
        "fct-type": "function",
        "title": "headM"
      },
      "index": {
        "description": "First element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "headM",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:ifilter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate which is applied to\n values and their indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e Bool) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#ifilter",
        "fct-type": "function",
        "title": "ifilter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate which is applied to values and their indices",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "ifilter",
        "normalized": "(Int-\u003ea-\u003eBool)-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eBool)-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold function applied to each element and its index",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:ifoldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator (function applied to each element\n and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#ifoldl%27",
        "fct-type": "function",
        "title": "ifoldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "ifoldl'",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Generic.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Right fold function applied to each element and its index",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:ifoldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with strict accumulator (function applied to each\n element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
        "fct-source": "src/Data-Vector-Generic.html#ifoldr%27",
        "fct-type": "function",
        "title": "ifoldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "ifoldr'",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply a function to every element of a vector and its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of vector and its index",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003eb)-\u003ec a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:indexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad.\n\u003c/p\u003e\u003cp\u003eThe monad allows operations to be strict in the vector when necessary.\n Suppose vector copying is implemented like this:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... write mv i (v ! i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, \u003ccode\u003ev ! i\u003c/code\u003e would not be evaluated which means that \u003ccode\u003emv\u003c/code\u003e\n would unnecessarily retain a reference to \u003ccode\u003ev\u003c/code\u003e in each element written.\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e, copying can be implemented like this instead:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... do\n                   x \u003c- indexM v i\n                   write mv i x\n\u003c/pre\u003e\u003cp\u003eHere, no references to \u003ccode\u003ev\u003c/code\u003e are retained because indexing (but \u003cem\u003enot\u003c/em\u003e the\n elements) is evaluated eagerly.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#indexM",
        "fct-type": "function",
        "title": "indexM"
      },
      "index": {
        "description": "Indexing in monad The monad allows operations to be strict in the vector when necessary Suppose vector copying is implemented like this copy mv write mv For lazy vectors would not be evaluated which means that mv would unnecessarily retain reference to in each element written With indexM copying can be implemented like this instead copy mv do indexM write mv Here no references to are retained because indexing but not the elements is evaluated eagerly",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "indexM",
        "normalized": "a b-\u003eInt-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:indexed",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Pair each element in a vector with its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v (Int, a)",
        "fct-source": "src/Data-Vector-Generic.html#indexed",
        "fct-type": "function",
        "title": "indexed"
      },
      "index": {
        "description": "Pair each element in vector with its index",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "indexed",
        "normalized": "a b-\u003ea(Int,b)",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "init",
        "normalized": "a b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function times to value Zeroth element is original value",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "iterateN",
        "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with a function that also takes the\n elements' indices.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e v a -\u003e v b -\u003e v c",
        "fct-source": "src/Data-Vector-Generic.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "min Zip two vectors with function that also takes the elements indices",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003ev a-\u003ev b-\u003ev c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:izipWith3",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d) -\u003e v a -\u003e v b -\u003e v c -\u003e v d",
        "fct-source": "src/Data-Vector-Generic.html#izipWith3",
        "fct-type": "function",
        "title": "izipWith3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "izipWith3",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ee b-\u003ee c-\u003ee d",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003ev a-\u003ev b-\u003ev c-\u003ev d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:izipWith4",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e",
        "fct-source": "src/Data-Vector-Generic.html#izipWith4",
        "fct-type": "function",
        "title": "izipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "izipWith4",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:izipWith5",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f",
        "fct-source": "src/Data-Vector-Generic.html#izipWith5",
        "fct-type": "function",
        "title": "izipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "izipWith5",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eg a-\u003eg b-\u003eg c-\u003eg d-\u003eg e-\u003eg f",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:izipWith6",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f -\u003e v g",
        "fct-source": "src/Data-Vector-Generic.html#izipWith6",
        "fct-type": "function",
        "title": "izipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "izipWith6",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eh a-\u003eh b-\u003eh c-\u003eh d-\u003eh e-\u003eh f-\u003eh g",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f-\u003ev g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "last",
        "normalized": "a b-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:lastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#lastM",
        "fct-type": "function",
        "title": "lastM"
      },
      "index": {
        "description": "Last element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "lastM",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the length of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Generic.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Yield the length of the vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "length",
        "normalized": "a b-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Map a function over a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b) -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e v a -\u003e m (v b)",
        "fct-source": "src/Data-Vector-Generic.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003ev a-\u003em(v b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003ed a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:maxIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Generic.html#maxIndex",
        "fct-type": "function",
        "title": "maxIndex"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "maxIndex",
        "normalized": "a b-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:maxIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e Int",
        "fct-source": "src/Data-Vector-Generic.html#maxIndexBy",
        "fct-type": "function",
        "title": "maxIndexBy"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "maxIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Yield the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "maximum",
        "normalized": "a b-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:maximumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#maximumBy",
        "fct-type": "function",
        "title": "maximumBy"
      },
      "index": {
        "description": "Yield the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "maximumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:minIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int",
        "fct-source": "src/Data-Vector-Generic.html#minIndex",
        "fct-type": "function",
        "title": "minIndex"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "minIndex",
        "normalized": "a b-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "v a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:minIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e Int",
        "fct-source": "src/Data-Vector-Generic.html#minIndexBy",
        "fct-type": "function",
        "title": "minIndexBy"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "minIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Yield the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "minimum",
        "normalized": "a b-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:minimumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#minimumBy",
        "fct-type": "function",
        "title": "minimumBy"
      },
      "index": {
        "description": "Yield the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "minimumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:mkType",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "String -\u003e DataType",
        "fct-source": "src/Data-Vector-Generic.html#mkType",
        "fct-type": "function",
        "title": "mkType"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "mkType",
        "normalized": "String-\u003eDataType",
        "package": "vector",
        "partial": "Type",
        "signature": "String-\u003eDataType"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:modify",
      "description": {
        "fct-descr": "\u003cp\u003eApply a destructive operation to a vector. The operation will be\n performed in place if it is safe to do so and will modify a copy of the\n vector otherwise.\n\u003c/p\u003e\u003cpre\u003e\n modify (\\v -\u003e \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e v 0 'x') (\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e 3 'a') = \u003c'x','a','a'\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(forall s.  Mutable v s a -\u003e ST s ()) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#modify",
        "fct-type": "function",
        "title": "modify"
      },
      "index": {
        "description": "Apply destructive operation to vector The operation will be performed in place if it is safe to do so and will modify copy of the vector otherwise modify write replicate",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "modify",
        "normalized": "(a b Mutable c d e-\u003eST d())-\u003ec e-\u003ec e",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. Mutable v s a-\u003eST s())-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a vector from a monadic initialiser.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "New v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "Construct vector from monadic initialiser",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "new",
        "normalized": "New a b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "New v a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector does not contain an element (inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Check if the vector does not contain an element inverse of elem",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "notElem",
        "normalized": "a-\u003eb a-\u003eBool",
        "package": "vector",
        "partial": "Elem",
        "signature": "a-\u003ev a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a vector if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether vector if empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "null",
        "normalized": "a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Generic.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "Check if any element is True",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "or",
        "normalized": "a Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "v Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't. The\n relative order of the elements is preserved at the cost of a sometimes\n reduced performance compared to \u003ccode\u003e\u003ca\u003eunstablePartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e (v a, v a)",
        "fct-source": "src/Data-Vector-Generic.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The relative order of the elements is preserved at the cost of sometimes reduced performance compared to unstablePartition",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "partition",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003e(b a,b a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003e(v a,v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan\n\u003c/p\u003e\u003cpre\u003e\n postscanl f z = \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003epostscanl (+) 0 \u003c1,2,3,4\u003e = \u003c1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Scan postscanl tail scanl Example postscanl",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "postscanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Scan with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "postscanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:postscanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#postscanr",
        "fct-type": "function",
        "title": "postscanr"
      },
      "index": {
        "description": "Right-to-left scan",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "postscanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:postscanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#postscanr%27",
        "fct-type": "function",
        "title": "postscanr'"
      },
      "index": {
        "description": "Right-to-left scan with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "postscanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanl f z = \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003eprescanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prescan prescanl init scanl Example prescanl",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "prescanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prescan with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "prescanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:prescanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanr f z = \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eprescanl\u003c/a\u003e\u003c/code\u003e (flip f) z . \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#prescanr",
        "fct-type": "function",
        "title": "prescanr"
      },
      "index": {
        "description": "Right-to-left prescan prescanr reverse prescanl flip reverse",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "prescanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:prescanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#prescanr%27",
        "fct-type": "function",
        "title": "prescanr'"
      },
      "index": {
        "description": "Right-to-left prescan with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "prescanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:product",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the produce of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#product",
        "fct-type": "function",
        "title": "product"
      },
      "index": {
        "description": "Compute the produce of the elements",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "product",
        "normalized": "a b-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:readPrec",
      "description": {
        "fct-descr": "\u003cp\u003eGeneric definition of \u003ccode\u003e\u003ca\u003ereadPrec\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "ReadPrec (v a)",
        "fct-source": "src/Data-Vector-Generic.html#readPrec",
        "fct-type": "function",
        "title": "readPrec"
      },
      "index": {
        "description": "Generic definition of readPrec",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "readPrec",
        "normalized": "",
        "package": "vector",
        "partial": "Prec",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Vector of the given length with the same value in each position\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Vector of the given length with the same value in each position",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Execute the monadic action the given number of times and store the\n results in a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Generic.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute the monadic action the given number of times and store the results in vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(c b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Reverse a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "reverse",
        "normalized": "a b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan\n\u003c/p\u003e\u003cpre\u003e scanl f z \u003cx1,...,xn\u003e = \u003cy1,...,y(n+1)\u003e\n   where y1 = z\n         yi = f y(i-1) x(i-1)\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003escanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan scanl x1 xn y1 where y1 yi i-1 i-1 Example scanl",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "scanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector\n\u003c/p\u003e\u003cpre\u003e scanl f \u003cx1,...,xn\u003e = \u003cy1,...,yn\u003e\n   where y1 = x1\n         yi = f y(i-1) xi\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty vector scanl x1 xn y1 yn where y1 x1 yi i-1 xi",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "scanl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "scanl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "scanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:scanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
        "fct-source": "src/Data-Vector-Generic.html#scanr%27",
        "fct-type": "function",
        "title": "scanr'"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "scanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "scanr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:scanr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector with a strict\n accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#scanr1%27",
        "fct-type": "function",
        "title": "scanr1'"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "scanr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:sequence",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate each action and collect the results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v (m a) -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Generic.html#sequence",
        "fct-type": "function",
        "title": "sequence"
      },
      "index": {
        "description": "Evaluate each action and collect the results",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "sequence",
        "normalized": "a(b c)-\u003eb(a c)",
        "package": "vector",
        "partial": "",
        "signature": "v(m a)-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:sequence_",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate each action and discard the results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v (m a) -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#sequence_",
        "fct-type": "function",
        "title": "sequence_"
      },
      "index": {
        "description": "Evaluate each action and discard the results",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "sequence_",
        "normalized": "a(b c)-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "v(m a)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:showsPrec",
      "description": {
        "fct-descr": "\u003cp\u003eGeneric definition of \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v a -\u003e ShowS",
        "fct-source": "src/Data-Vector-Generic.html#showsPrec",
        "fct-type": "function",
        "title": "showsPrec"
      },
      "index": {
        "description": "Generic definition of showsPrec",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "showsPrec",
        "normalized": "Int-\u003ea b-\u003eShowS",
        "package": "vector",
        "partial": "Prec",
        "signature": "Int-\u003ev a-\u003eShowS"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Vector with exactly one element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Vector with exactly one element",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "singleton",
        "normalized": "a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying it. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e v a-\u003e v a",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield slice of the vector without copying it The vector must contain at least elements",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "snoc",
        "normalized": "a b-\u003eb-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ea-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that satisfy\n the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e (v a, v a)",
        "fct-source": "src/Data-Vector-Generic.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "span",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003e(b a,b a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003ev a-\u003e(v a,v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements paired with the remainder without copying.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e n v\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n v, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n v)\u003c/code\u003e\n but slightly more efficient.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v a -\u003e (v a, v a)",
        "fct-source": "src/Data-Vector-Generic.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "Yield the first elements paired with the remainder without copying Note that splitAt is equivalent to take drop but slightly more efficient",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "splitAt",
        "normalized": "Int-\u003ea b-\u003e(a b,a b)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003ev a-\u003e(v a,v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:stream",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Convert a vector to a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Generic.html#stream",
        "fct-type": "function",
        "title": "stream"
      },
      "index": {
        "description": "Convert vector to Stream",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "stream",
        "normalized": "a b-\u003eStream b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:streamR",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Convert a vector to a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e, proceeding from right to left\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Stream a",
        "fct-source": "src/Data-Vector-Generic.html#streamR",
        "fct-type": "function",
        "title": "streamR"
      },
      "index": {
        "description": "Convert vector to Stream proceeding from right to left",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "streamR",
        "normalized": "a b-\u003eStream b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003eStream a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the sum of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "Compute the sum of the elements",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "sum",
        "normalized": "a b-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "tail",
        "normalized": "a b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case it is returned unchanged.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "Yield the first elements without copying The vector may contain less than elements in which case it is returned unchanged",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "take",
        "normalized": "Int-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the longest prefix of elements satisfying the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Yield the longest prefix of elements satisfying the predicate without copying",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "takeWhile",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:thaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a mutable copy of the immutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e m (Mutable v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic.html#thaw",
        "fct-type": "function",
        "title": "thaw"
      },
      "index": {
        "description": "Yield mutable copy of the immutable vector",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "thaw",
        "normalized": "a b-\u003ec(Mutable a(PrimState c)b)",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003em(Mutable v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a vector to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e [a]",
        "fct-source": "src/Data-Vector-Generic.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to list",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "toList",
        "normalized": "a b-\u003e[b]",
        "package": "vector",
        "partial": "List",
        "signature": "v a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector by repeatedly applying the generator function\n to a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the next element and the\n new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\n -\u003e if n == 0 then Nothing else Just (n,n-1)) 10\n  = \u003c10,9,8,7,6,5,4,3,2,1\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Construct vector by repeatedly applying the generator function to seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldr if then Nothing else Just n-1",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with at most \u003ccode\u003en\u003c/code\u003e by repeatedly applying the\n generator function to the a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the\n next element and the new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldrN 3 (\\n -\u003e Just (n,n-1)) 10 = \u003c10,9,8\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (b -\u003e Maybe (a, b)) -\u003e b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Construct vector with at most by repeatedly applying the generator function to the seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldrN Just n-1",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(b-\u003eMaybe(a,b))-\u003eb-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeAccum",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccum\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e [(Int, b)] -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeAccum",
        "fct-type": "function",
        "title": "unsafeAccum"
      },
      "index": {
        "description": "Same as accum but without bounds checking",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeAccum",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003e[(Int,b)]-\u003ec a",
        "package": "vector",
        "partial": "Accum",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003e[(Int,b)]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeAccumulate",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e v (Int, b) -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeAccumulate",
        "fct-type": "function",
        "title": "unsafeAccumulate"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeAccumulate",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ec(Int,b)-\u003ec a",
        "package": "vector",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev(Int,b)-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeAccumulate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e v Int -\u003e v b -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeAccumulate_",
        "fct-type": "function",
        "title": "unsafeAccumulate_"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeAccumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ec Int-\u003ec b-\u003ec a",
        "package": "vector",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev Int-\u003ev b-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeBackpermute",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ebackpermute\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v Int -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeBackpermute",
        "fct-type": "function",
        "title": "unsafeBackpermute"
      },
      "index": {
        "description": "Same as backpermute but without bounds checking",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeBackpermute",
        "normalized": "a b-\u003ea Int-\u003ea b",
        "package": "vector",
        "partial": "Backpermute",
        "signature": "v a-\u003ev Int-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Mutable v (PrimState m) a -\u003e v a -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#unsafeCopy",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length This is not checked",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeCopy",
        "normalized": "Mutable a(PrimState b)c-\u003ea c-\u003eb()",
        "package": "vector",
        "partial": "Copy",
        "signature": "Mutable v(PrimState m)a-\u003ev a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeDrop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector\n must contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeDrop",
        "normalized": "Int-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe convert a mutable vector to an immutable one without\n copying. The mutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Mutable v (PrimState m) a -\u003e m (v a)",
        "fct-source": "src/Data-Vector-Generic.html#unsafeFreeze",
        "fct-type": "function",
        "title": "unsafeFreeze"
      },
      "index": {
        "description": "Unsafe convert mutable vector to an immutable one without copying The mutable vector may not be used after this operation",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeFreeze",
        "normalized": "Mutable a(PrimState b)c-\u003eb(a c)",
        "package": "vector",
        "partial": "Freeze",
        "signature": "Mutable v(PrimState m)a-\u003em(v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeHead",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeHead",
        "fct-type": "function",
        "title": "unsafeHead"
      },
      "index": {
        "description": "First element without checking if the vector is empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeHead",
        "normalized": "a b-\u003eb",
        "package": "vector",
        "partial": "Head",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeHeadM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeHeadM",
        "fct-type": "function",
        "title": "unsafeHeadM"
      },
      "index": {
        "description": "First element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeHeadM",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "Head",
        "signature": "v a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe indexing without bounds checking\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeIndex",
        "fct-type": "function",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Unsafe indexing without bounds checking",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeIndex",
        "normalized": "a b-\u003eInt-\u003eb",
        "package": "vector",
        "partial": "Index",
        "signature": "v a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeIndexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad without bounds checks. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeIndexM",
        "fct-type": "function",
        "title": "unsafeIndexM"
      },
      "index": {
        "description": "Indexing in monad without bounds checks See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeIndexM",
        "normalized": "a b-\u003eInt-\u003ec b",
        "package": "vector",
        "partial": "Index",
        "signature": "v a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeInit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeInit",
        "normalized": "a b-\u003ea b",
        "package": "vector",
        "partial": "Init",
        "signature": "v a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeLast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeLast",
        "fct-type": "function",
        "title": "unsafeLast"
      },
      "index": {
        "description": "Last element without checking if the vector is empty",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeLast",
        "normalized": "a b-\u003eb",
        "package": "vector",
        "partial": "Last",
        "signature": "v a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeLastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e m a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeLastM",
        "fct-type": "function",
        "title": "unsafeLastM"
      },
      "index": {
        "description": "Last element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeLastM",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "Last",
        "signature": "v a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e v a-\u003e v a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield slice of the vector without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeTail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeTail",
        "normalized": "a b-\u003ea b",
        "package": "vector",
        "partial": "Tail",
        "signature": "v a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeTake",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector must\n contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "Yield the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeTake",
        "normalized": "Int-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely convert an immutable vector to a mutable one without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e m (Mutable v (PrimState m) a)",
        "fct-source": "src/Data-Vector-Generic.html#unsafeThaw",
        "fct-type": "function",
        "title": "unsafeThaw"
      },
      "index": {
        "description": "Unsafely convert an immutable vector to mutable one without copying The immutable vector may not be used after this operation",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeThaw",
        "normalized": "a b-\u003ec(Mutable a(PrimState c)b)",
        "package": "vector",
        "partial": "Thaw",
        "signature": "v a-\u003em(Mutable v(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeUpd",
      "description": {
        "fct-descr": "\u003cp\u003eSame as (\u003ccode\u003e\u003ca\u003e//\u003c/a\u003e\u003c/code\u003e) but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e [(Int, a)] -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeUpd",
        "fct-type": "function",
        "title": "unsafeUpd"
      },
      "index": {
        "description": "Same as but without bounds checking",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeUpd",
        "normalized": "a b-\u003e[(Int,b)]-\u003ea b",
        "package": "vector",
        "partial": "Upd",
        "signature": "v a-\u003e[(Int,a)]-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeUpdate",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v (Int, a) -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeUpdate",
        "fct-type": "function",
        "title": "unsafeUpdate"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeUpdate",
        "normalized": "a b-\u003ea(Int,b)-\u003ea b",
        "package": "vector",
        "partial": "Update",
        "signature": "v a-\u003ev(Int,a)-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unsafeUpdate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v Int -\u003e v a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unsafeUpdate_",
        "fct-type": "function",
        "title": "unsafeUpdate_"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unsafeUpdate_",
        "normalized": "a b-\u003ea Int-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "Update",
        "signature": "v a-\u003ev Int-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unstablePartition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't.\n The order of the elements is not preserved but the operation is often\n faster than \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e v a -\u003e (v a, v a)",
        "fct-source": "src/Data-Vector-Generic.html#unstablePartition",
        "fct-type": "function",
        "title": "unstablePartition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The order of the elements is not preserved but the operation is often faster than partition",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unstablePartition",
        "normalized": "(a-\u003eBool)-\u003eb a-\u003e(b a,b a)",
        "package": "vector",
        "partial": "Partition",
        "signature": "(a-\u003eBool)-\u003ev a-\u003e(v a,v a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unstream",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector from a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unstream",
        "fct-type": "function",
        "title": "unstream"
      },
      "index": {
        "description": "Construct vector from Stream",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unstream",
        "normalized": "Stream a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unstreamR",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector from a \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e, proceeding from right to left\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "Stream a -\u003e v a",
        "fct-source": "src/Data-Vector-Generic.html#unstreamR",
        "fct-type": "function",
        "title": "unstreamR"
      },
      "index": {
        "description": "Construct vector from Stream proceeding from right to left",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unstreamR",
        "normalized": "Stream a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Stream a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Unzip a vector of pairs.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v (a, b) -\u003e (v a, v b)",
        "fct-source": "src/Data-Vector-Generic.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "min Unzip vector of pairs",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unzip",
        "normalized": "a(b,c)-\u003e(a b,a c)",
        "package": "vector",
        "partial": "",
        "signature": "v(a,b)-\u003e(v a,v b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unzip3",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v (a, b, c) -\u003e (v a, v b, v c)",
        "fct-source": "src/Data-Vector-Generic.html#unzip3",
        "fct-type": "function",
        "title": "unzip3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unzip3",
        "normalized": "a(b,c,d)-\u003e(a b,a c,a d)",
        "package": "vector",
        "partial": "",
        "signature": "v(a,b,c)-\u003e(v a,v b,v c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unzip4",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v (a, b, c, d) -\u003e (v a, v b, v c, v d)",
        "fct-source": "src/Data-Vector-Generic.html#unzip4",
        "fct-type": "function",
        "title": "unzip4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unzip4",
        "normalized": "a(b,c,d,e)-\u003e(a b,a c,a d,a e)",
        "package": "vector",
        "partial": "",
        "signature": "v(a,b,c,d)-\u003e(v a,v b,v c,v d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unzip5",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v (a, b, c, d, e) -\u003e (v a, v b, v c, v d, v e)",
        "fct-source": "src/Data-Vector-Generic.html#unzip5",
        "fct-type": "function",
        "title": "unzip5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unzip5",
        "normalized": "a(b,c,d,e,f)-\u003e(a b,a c,a d,a e,a f)",
        "package": "vector",
        "partial": "",
        "signature": "v(a,b,c,d,e)-\u003e(v a,v b,v c,v d,v e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:unzip6",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v (a, b, c, d, e, f) -\u003e (v a, v b, v c, v d, v e, v f)",
        "fct-source": "src/Data-Vector-Generic.html#unzip6",
        "fct-type": "function",
        "title": "unzip6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "unzip6",
        "normalized": "a(b,c,d,e,f,g)-\u003e(a b,a c,a d,a e,a f,a g)",
        "package": "vector",
        "partial": "",
        "signature": "v(a,b,c,d,e,f)-\u003e(v a,v b,v c,v d,v e,v f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:update",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the vector of index/value pairs,\n replace the vector element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update \u003c5,9,2,7\u003e \u003c(2,1),(0,3),(2,8)\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a-\u003e v (Int, a)-\u003e v a",
        "fct-type": "function",
        "title": "update"
      },
      "index": {
        "description": "For each pair from the vector of index value pairs replace the vector element at position by update",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "update",
        "normalized": "a b-\u003ea(Int,b)-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev(Int,a)-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:update_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003ea\u003c/code\u003e from the value vector, replace the element of the\n initial vector at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update_ \u003c5,9,2,7\u003e  \u003c2,0,2\u003e \u003c1,3,8\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e\u003cp\u003eThis function is useful for instances of \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e that cannot store pairs.\n Otherwise, \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e is probably more convenient.\n\u003c/p\u003e\u003cpre\u003e\n update_ xs is ys = \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e xs (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is ys)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a-\u003e v Int-\u003e v a-\u003e v a",
        "fct-type": "function",
        "title": "update_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the value vector replace the element of the initial vector at position by update This function is useful for instances of Vector that cannot store pairs Otherwise update is probably more convenient update xs is ys update xs zip is ys",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "update_",
        "normalized": "a b-\u003ea Int-\u003ea b-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev Int-\u003ev a-\u003ev a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v b -\u003e v (a, b)",
        "fct-source": "src/Data-Vector-Generic.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "min Zip two vectors",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zip",
        "normalized": "a b-\u003ea c-\u003ea(b,c)",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev b-\u003ev(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zip3",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v b -\u003e v c -\u003e v (a, b, c)",
        "fct-source": "src/Data-Vector-Generic.html#zip3",
        "fct-type": "function",
        "title": "zip3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zip3",
        "normalized": "a b-\u003ea c-\u003ea d-\u003ea(b,c,d)",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev b-\u003ev c-\u003ev(a,b,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zip4",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v b -\u003e v c -\u003e v d -\u003e v (a, b, c, d)",
        "fct-source": "src/Data-Vector-Generic.html#zip4",
        "fct-type": "function",
        "title": "zip4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zip4",
        "normalized": "a b-\u003ea c-\u003ea d-\u003ea e-\u003ea(b,c,d,e)",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev b-\u003ev c-\u003ev d-\u003ev(a,b,c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zip5",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v (a, b, c, d, e)",
        "fct-source": "src/Data-Vector-Generic.html#zip5",
        "fct-type": "function",
        "title": "zip5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zip5",
        "normalized": "a b-\u003ea c-\u003ea d-\u003ea e-\u003ea f-\u003ea(b,c,d,e,f)",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev(a,b,c,d,e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zip6",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f -\u003e v (a, b, c, d, e, f)",
        "fct-source": "src/Data-Vector-Generic.html#zip6",
        "fct-type": "function",
        "title": "zip6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zip6",
        "normalized": "a b-\u003ea c-\u003ea d-\u003ea e-\u003ea f-\u003ea g-\u003ea(b,c,d,e,f,g)",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f-\u003ev(a,b,c,d,e,f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e v a -\u003e v b -\u003e v c",
        "fct-source": "src/Data-Vector-Generic.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "min Zip two vectors with the given function",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003ev a-\u003ev b-\u003ev c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e v a -\u003e v b -\u003e v c -\u003e v d",
        "fct-source": "src/Data-Vector-Generic.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "Zip three vectors with the given function",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zipWith3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ee b-\u003ee c-\u003ee d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003ev a-\u003ev b-\u003ev c-\u003ev d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e",
        "fct-source": "src/Data-Vector-Generic.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zipWith4",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f",
        "fct-source": "src/Data-Vector-Generic.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zipWith5",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eg a-\u003eg b-\u003eg c-\u003eg d-\u003eg e-\u003eg f",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f -\u003e v g",
        "fct-source": "src/Data-Vector-Generic.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zipWith6",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eh a-\u003eh b-\u003eh c-\u003eh d-\u003eh e-\u003eh f-\u003eh g",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f-\u003ev g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and yield a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e v a -\u003e v b -\u003e m (v c)",
        "fct-source": "src/Data-Vector-Generic.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and yield vector of results",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003ee a-\u003ee b-\u003ec(e d)",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003ev a-\u003ev b-\u003em(v c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Generic.html#v:zipWithM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Generic",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e v a -\u003e v b -\u003e m ()",
        "fct-source": "src/Data-Vector-Generic.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and ignore the results",
        "hierarchy": "Data Vector Generic",
        "module": "Data.Vector.Generic",
        "name": "zipWithM_",
        "normalized": "(a-\u003eb-\u003ec d)-\u003ee a-\u003ee b-\u003ec()",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003ev a-\u003ev b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBounds checking infrastructure\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Internal-Check.html",
        "fct-type": "module",
        "title": "Check"
      },
      "index": {
        "description": "Bounds checking infrastructure",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "Check",
        "normalized": "",
        "package": "vector",
        "partial": "Check",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#t:Checks",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Internal-Check.html#Checks",
        "fct-type": "data",
        "title": "Checks"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "Checks",
        "normalized": "",
        "package": "vector",
        "partial": "Checks",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:Bounds",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "Bounds",
        "fct-source": "src/Data-Vector-Internal-Check.html#Checks",
        "fct-type": "function",
        "title": "Bounds"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "Bounds",
        "normalized": "",
        "package": "vector",
        "partial": "Bounds",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:Internal",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "Internal",
        "fct-source": "src/Data-Vector-Internal-Check.html#Checks",
        "fct-type": "function",
        "title": "Internal"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "Internal",
        "normalized": "",
        "package": "vector",
        "partial": "Internal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:Unsafe",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "Unsafe",
        "fct-source": "src/Data-Vector-Internal-Check.html#Checks",
        "fct-type": "function",
        "title": "Unsafe"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "Unsafe",
        "normalized": "",
        "package": "vector",
        "partial": "Unsafe",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:check",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "String -\u003e Int -\u003e Checks -\u003e String -\u003e String -\u003e Bool -\u003e a -\u003e a",
        "fct-source": "src/Data-Vector-Internal-Check.html#check",
        "fct-type": "function",
        "title": "check"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "check",
        "normalized": "String-\u003eInt-\u003eChecks-\u003eString-\u003eString-\u003eBool-\u003ea-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "String-\u003eInt-\u003eChecks-\u003eString-\u003eString-\u003eBool-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:checkIndex",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "String -\u003e Int -\u003e Checks -\u003e String -\u003e Int -\u003e Int -\u003e a -\u003e a",
        "fct-source": "src/Data-Vector-Internal-Check.html#checkIndex",
        "fct-type": "function",
        "title": "checkIndex"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "checkIndex",
        "normalized": "String-\u003eInt-\u003eChecks-\u003eString-\u003eInt-\u003eInt-\u003ea-\u003ea",
        "package": "vector",
        "partial": "Index",
        "signature": "String-\u003eInt-\u003eChecks-\u003eString-\u003eInt-\u003eInt-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:checkLength",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "String -\u003e Int -\u003e Checks -\u003e String -\u003e Int -\u003e a -\u003e a",
        "fct-source": "src/Data-Vector-Internal-Check.html#checkLength",
        "fct-type": "function",
        "title": "checkLength"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "checkLength",
        "normalized": "String-\u003eInt-\u003eChecks-\u003eString-\u003eInt-\u003ea-\u003ea",
        "package": "vector",
        "partial": "Length",
        "signature": "String-\u003eInt-\u003eChecks-\u003eString-\u003eInt-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:checkSlice",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "String -\u003e Int -\u003e Checks -\u003e String -\u003e Int -\u003e Int -\u003e Int -\u003e a -\u003e a",
        "fct-source": "src/Data-Vector-Internal-Check.html#checkSlice",
        "fct-type": "function",
        "title": "checkSlice"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "checkSlice",
        "normalized": "String-\u003eInt-\u003eChecks-\u003eString-\u003eInt-\u003eInt-\u003eInt-\u003ea-\u003ea",
        "package": "vector",
        "partial": "Slice",
        "signature": "String-\u003eInt-\u003eChecks-\u003eString-\u003eInt-\u003eInt-\u003eInt-\u003ea-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:doChecks",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "Checks -\u003e Bool",
        "fct-source": "src/Data-Vector-Internal-Check.html#doChecks",
        "fct-type": "function",
        "title": "doChecks"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "doChecks",
        "normalized": "Checks-\u003eBool",
        "package": "vector",
        "partial": "Checks",
        "signature": "Checks-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:error",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "String -\u003e Int -\u003e String -\u003e String -\u003e a",
        "fct-source": "src/Data-Vector-Internal-Check.html#error",
        "fct-type": "function",
        "title": "error"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "error",
        "normalized": "String-\u003eInt-\u003eString-\u003eString-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "String-\u003eInt-\u003eString-\u003eString-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Internal-Check.html#v:internalError",
      "description": {
        "fct-module": "Data.Vector.Internal.Check",
        "fct-package": "vector",
        "fct-signature": "String -\u003e Int -\u003e String -\u003e String -\u003e a",
        "fct-source": "src/Data-Vector-Internal-Check.html#internalError",
        "fct-type": "function",
        "title": "internalError"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Internal Check",
        "module": "Data.Vector.Internal.Check",
        "name": "internalError",
        "normalized": "String-\u003eInt-\u003eString-\u003eString-\u003ea",
        "package": "vector",
        "partial": "Error",
        "signature": "String-\u003eInt-\u003eString-\u003eString-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable boxed vectors.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Mutable.html",
        "fct-type": "module",
        "title": "Mutable"
      },
      "index": {
        "description": "Mutable boxed vectors",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "vector",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#t:IOVector",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Mutable.html#IOVector",
        "fct-type": "type",
        "title": "IOVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "IOVector",
        "normalized": "",
        "package": "vector",
        "partial": "IOVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eMutable boxed vectors keyed on the monad they live in (\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ccode\u003eST\u003c/code\u003e s\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Mutable.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "Mutable boxed vectors keyed on the monad they live in IO or ST",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#t:STVector",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Mutable.html#STVector",
        "fct-type": "type",
        "title": "STVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "STVector",
        "normalized": "",
        "package": "vector",
        "partial": "STVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:MVector",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector !Int !Int !(MutableArray s a)",
        "fct-source": "src/Data-Vector-Mutable.html#MVector",
        "fct-type": "function",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:clear",
      "description": {
        "fct-descr": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed vectors. \n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mutable.html#clear",
        "fct-type": "function",
        "title": "clear"
      },
      "index": {
        "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "clear",
        "normalized": "MVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a copy of a mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mutable.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Create copy of mutable vector",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "clone",
        "normalized": "MVector(PrimState a)b-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mutable.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "copy",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:drop",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "drop",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:grow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mutable.html#grow",
        "fct-type": "function",
        "title": "grow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "grow",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:init",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "init",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e Int",
        "fct-source": "src/Data-Vector-Mutable.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of the mutable vector",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "length",
        "normalized": "MVector a b-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:move",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003ecopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mutable.html#move",
        "fct-type": "function",
        "title": "move"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length If the vectors do not overlap then this is equivalent to copy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "move",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mutable.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "Create mutable vector of the given length",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "new",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mutable.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check whether the vector is empty",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "null",
        "normalized": "MVector a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:overlaps",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Mutable.html#overlaps",
        "fct-type": "function",
        "title": "overlaps"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "overlaps",
        "normalized": "MVector a b-\u003eMVector a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Mutable.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Yield the element at the given position",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "read",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with an initial value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mutable.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with an initial value",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with values produced by repeatedly executing the monadic action.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mutable.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with values produced by repeatedly executing the monadic action",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003eSet all elements of the vector to the given value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mutable.html#set",
        "fct-type": "function",
        "title": "set"
      },
      "index": {
        "description": "Set all elements of the vector to the given value",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "set",
        "normalized": "MVector(PrimState a)b-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:splitAt",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e (MVector s a, MVector s a)",
        "fct-source": "src/Data-Vector-Mutable.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "splitAt",
        "normalized": "Int-\u003eMVector a b-\u003e(MVector a b,MVector a b)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003eMVector s a-\u003e(MVector s a,MVector s a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:swap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Mutable.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "Swap the elements at the given positions",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "swap",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eInt-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "tail",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:take",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "take",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a-\u003e MVector (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap This is not checked",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeCopy",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "Copy",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeDrop",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeGrow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeGrow",
        "fct-type": "function",
        "title": "unsafeGrow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive but this is not checked",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeGrow",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "Grow",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeInit",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeInit",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Init",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeMove",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length, but this is not checked.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003eunsafeCopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a-\u003e MVector (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeMove"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length but this is not checked If the vectors do not overlap then this is equivalent to unsafeCopy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeMove",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "Move",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeNew",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length. The length is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeNew",
        "fct-type": "function",
        "title": "unsafeNew"
      },
      "index": {
        "description": "Create mutable vector of the given length The length is not checked",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeNew",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "New",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeRead",
        "fct-type": "function",
        "title": "unsafeRead"
      },
      "index": {
        "description": "Yield the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeRead",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "Read",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it. No bounds checks\n are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e MVector s a-\u003e MVector s a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it No bounds checks are performed",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeSwap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeSwap",
        "fct-type": "function",
        "title": "unsafeSwap"
      },
      "index": {
        "description": "Swap the elements at the given positions No bounds checks are performed",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeSwap",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eInt-\u003ea()",
        "package": "vector",
        "partial": "Swap",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeTail",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeTail",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Tail",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeTake",
      "description": {
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeTake",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:unsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mutable.html#unsafeWrite",
        "fct-type": "function",
        "title": "unsafeWrite"
      },
      "index": {
        "description": "Replace the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "unsafeWrite",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "Write",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Mutable.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Replace the element at the given position",
        "hierarchy": "Data Vector Mutable",
        "module": "Data.Vector.Mutable",
        "name": "write",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable primitive vectors.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html",
        "fct-type": "module",
        "title": "Mutable"
      },
      "index": {
        "description": "Mutable primitive vectors",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "vector",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#t:IOVector",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#IOVector",
        "fct-type": "type",
        "title": "IOVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "IOVector",
        "normalized": "",
        "package": "vector",
        "partial": "IOVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eMutable vectors of primitive types.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "Mutable vectors of primitive types",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#t:Prim",
      "description": {
        "fct-descr": "\u003cp\u003eClass of types supporting primitive array operations\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "class",
        "fct-type": "class",
        "title": "Prim"
      },
      "index": {
        "description": "Class of types supporting primitive array operations",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "Prim",
        "normalized": "",
        "package": "vector",
        "partial": "Prim",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#t:STVector",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#STVector",
        "fct-type": "type",
        "title": "STVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "STVector",
        "normalized": "",
        "package": "vector",
        "partial": "STVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:MVector",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector !Int !Int !(MutableByteArray s)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#MVector",
        "fct-type": "function",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:clear",
      "description": {
        "fct-descr": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed vectors. \n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#clear",
        "fct-type": "function",
        "title": "clear"
      },
      "index": {
        "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "clear",
        "normalized": "MVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a copy of a mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Create copy of mutable vector",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "clone",
        "normalized": "MVector(PrimState a)b-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "copy",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:drop",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "drop",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:grow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#grow",
        "fct-type": "function",
        "title": "grow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "grow",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:init",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "init",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e Int",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of the mutable vector",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "length",
        "normalized": "MVector a b-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:move",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003ecopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#move",
        "fct-type": "function",
        "title": "move"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length If the vectors do not overlap then this is equivalent to copy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "move",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "Create mutable vector of the given length",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "new",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check whether the vector is empty",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "null",
        "normalized": "MVector a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:overlaps",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#overlaps",
        "fct-type": "function",
        "title": "overlaps"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "overlaps",
        "normalized": "MVector a b-\u003eMVector a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Yield the element at the given position",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "read",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with an initial value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with an initial value",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with values produced by repeatedly executing the monadic action.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with values produced by repeatedly executing the monadic action",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003eSet all elements of the vector to the given value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#set",
        "fct-type": "function",
        "title": "set"
      },
      "index": {
        "description": "Set all elements of the vector to the given value",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "set",
        "normalized": "MVector(PrimState a)b-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:splitAt",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e (MVector s a, MVector s a)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "splitAt",
        "normalized": "Int-\u003eMVector a b-\u003e(MVector a b,MVector a b)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003eMVector s a-\u003e(MVector s a,MVector s a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:swap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "Swap the elements at the given positions",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "swap",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eInt-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "tail",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:take",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "take",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a-\u003e MVector (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap This is not checked",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeCopy",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "Copy",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeDrop",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeGrow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeGrow",
        "fct-type": "function",
        "title": "unsafeGrow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive but this is not checked",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeGrow",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "Grow",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeInit",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeInit",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Init",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeMove",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length, but this is not checked.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003eunsafeCopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a-\u003e MVector (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeMove"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length but this is not checked If the vectors do not overlap then this is equivalent to unsafeCopy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeMove",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "Move",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeNew",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length. The length is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeNew",
        "fct-type": "function",
        "title": "unsafeNew"
      },
      "index": {
        "description": "Create mutable vector of the given length The length is not checked",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeNew",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "New",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeRead",
        "fct-type": "function",
        "title": "unsafeRead"
      },
      "index": {
        "description": "Yield the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeRead",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "Read",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it. No bounds checks\n are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e MVector s a-\u003e MVector s a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it No bounds checks are performed",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeSwap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeSwap",
        "fct-type": "function",
        "title": "unsafeSwap"
      },
      "index": {
        "description": "Swap the elements at the given positions No bounds checks are performed",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeSwap",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eInt-\u003ea()",
        "package": "vector",
        "partial": "Swap",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeTail",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeTail",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Tail",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeTake",
      "description": {
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeTake",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:unsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#unsafeWrite",
        "fct-type": "function",
        "title": "unsafeWrite"
      },
      "index": {
        "description": "Replace the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "unsafeWrite",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "Write",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive-Mutable.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Replace the element at the given position",
        "hierarchy": "Data Vector Primitive Mutable",
        "module": "Data.Vector.Primitive.Mutable",
        "name": "write",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnboxed vectors of primitive types. The use of this module is not\n recommended except in very special cases. Adaptive unboxed vectors defined\n in \u003ca\u003eData.Vector.Unboxed\u003c/a\u003e are significantly more flexible at no performance\n cost.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Primitive.html",
        "fct-type": "module",
        "title": "Primitive"
      },
      "index": {
        "description": "Unboxed vectors of primitive types The use of this module is not recommended except in very special cases Adaptive unboxed vectors defined in Data.Vector.Unboxed are significantly more flexible at no performance cost",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "Primitive",
        "normalized": "",
        "package": "vector",
        "partial": "Primitive",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eMutable vectors of primitive types.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "Mutable vectors of primitive types",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#t:Prim",
      "description": {
        "fct-descr": "\u003cp\u003eClass of types supporting primitive array operations\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "class",
        "fct-type": "class",
        "title": "Prim"
      },
      "index": {
        "description": "Class of types supporting primitive array operations",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "Prim",
        "normalized": "",
        "package": "vector",
        "partial": "Prim",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#t:Vector",
      "description": {
        "fct-descr": "\u003cp\u003eUnboxed vectors of primitive types\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Primitive.html#Vector",
        "fct-type": "data",
        "title": "Vector"
      },
      "index": {
        "description": "Unboxed vectors of primitive types",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "Vector",
        "normalized": "",
        "package": "vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Indexing",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "(!) !",
        "normalized": "Vector a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Safe indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Primitive.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Safe indexing",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "(!?) !?",
        "normalized": "Vector a-\u003eInt-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e Concatenate two vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two vectors",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "(++) ++",
        "normalized": "Vector a-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:-47--47-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the list, replace the vector\n element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003c5,9,2,7\u003e // [(2,1),(0,3),(2,8)] = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e [(Int, a)]-\u003e Vector a",
        "fct-type": "function",
        "title": "(//)"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "(//) //",
        "normalized": "Vector a-\u003e[(Int,a)]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:MVector",
      "description": {
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "MVector !Int !Int !(MutableByteArray s)",
        "fct-source": "src/Data-Vector-Primitive-Mutable.html#MVector",
        "fct-type": "function",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:accum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the list, replace the vector element\n \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accum (+) \u003c5,9,2\u003e [(2,4),(1,6),(0,3),(1,7)] = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e [(Int, b)]-\u003e Vector a",
        "fct-type": "function",
        "title": "accum"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by accum",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "accum",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:accumulate_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003eb\u003c/code\u003e from the the value vector,\n replace the element of the initial vector at\n position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate_ (+) \u003c5,9,2\u003e \u003c2,1,0,1\u003e \u003c4,6,3,7\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e Vector Int-\u003e Vector b-\u003e Vector a",
        "fct-type": "function",
        "title": "accumulate_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the the value vector replace the element of the initial vector at position by accumulate",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "accumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Primitive.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Check if all elements satisfy the predicate",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Primitive.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Check if any element satisfies the predicate",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:backpermute",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the vector obtained by replacing each element \u003ccode\u003ei\u003c/code\u003e of the\n index vector by \u003ccode\u003exs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003ei\u003c/code\u003e. This is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (xs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e) is\u003c/code\u003e but is\n often much more efficient.\n\u003c/p\u003e\u003cpre\u003e backpermute \u003ca,b,c,d\u003e \u003c0,3,2,3,1,0\u003e = \u003ca,d,c,d,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#backpermute",
        "fct-type": "function",
        "title": "backpermute"
      },
      "index": {
        "description": "Yield the vector obtained by replacing each element of the index vector by xs This is equivalent to map xs is but is often much more efficient backpermute",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "backpermute",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that do not\n satisfy the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that do not satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "break",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate all vectors in the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "[Vector a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate all vectors in the list",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "concat",
        "normalized": "[Vector a]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "[Vector a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a vector and concatenate the results.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Vector b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over vector and concatenate the results",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "concatMap",
        "normalized": "(a-\u003eVector b)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "Map",
        "signature": "(a-\u003eVector b)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "cons",
        "normalized": "a-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:constructN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements by repeatedly applying the\n generator function to the already constructed part of the vector.\n\u003c/p\u003e\u003cpre\u003e constructN 3 f = let a = f \u003c\u003e ; b = f \u003ca\u003e ; c = f \u003ca,b\u003e in f \u003ca,b,c\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#constructN",
        "fct-type": "function",
        "title": "constructN"
      },
      "index": {
        "description": "Construct vector with elements by repeatedly applying the generator function to the already constructed part of the vector constructN let in",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "constructN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:constructrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements from right to left by\n repeatedly applying the generator function to the already constructed part\n of the vector.\n\u003c/p\u003e\u003cpre\u003e constructrN 3 f = let a = f \u003c\u003e ; b = f\u003ca\u003e ; c = f \u003cb,a\u003e in f \u003cc,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#constructrN",
        "fct-type": "function",
        "title": "constructrN"
      },
      "index": {
        "description": "Construct vector with elements from right to left by repeatedly applying the generator function to the already constructed part of the vector constructrN let in",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "constructrN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:convert",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert different vector types\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e w a",
        "fct-source": "src/Data-Vector-Generic.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "Convert different vector types",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "convert",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "copy",
        "normalized": "MVector(PrimState a)b-\u003eVector b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:create",
      "description": {
        "fct-descr": "\u003cp\u003eExecute the monadic action and freeze the resulting vector.\n\u003c/p\u003e\u003cpre\u003e\n create (do { v \u003c- new 2; write v 0 'a'; write v 1 'b'; return v }) = \u003c\u003ccode\u003ea\u003c/code\u003e,\u003ccode\u003eb\u003c/code\u003e\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(forall s.  ST s (MVector s a)) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "Execute the monadic action and freeze the resulting vector create do new write write return",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "create",
        "normalized": "(a b ST c(MVector c d))-\u003eVector d",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. ST s(MVector s a))-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case an empty vector is returned.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector may contain less than elements in which case an empty vector is returned",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "drop",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop the longest prefix of elements that satisfy the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate without copying",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "dropWhile",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Primitive.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check if the vector contains an element",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "elem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first occurence of the given element or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the vector does not contain the element. This is a specialised\n version of \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Primitive.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "Yield Just the index of the first occurence of the given element or Nothing if the vector does not contain the element This is specialised version of findIndex",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "elemIndex",
        "normalized": "a-\u003eVector a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "a-\u003eVector a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of all occurences of the given element in\n ascending order. This is a specialised version of \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Vector Int",
        "fct-source": "src/Data-Vector-Primitive.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "Yield the indices of all occurences of the given element in ascending order This is specialised version of findIndices",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "elemIndices",
        "normalized": "a-\u003eVector a-\u003eVector Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "a-\u003eVector a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "empty",
        "normalized": "",
        "package": "vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:enumFromN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+1\u003c/code\u003e\n etc. This operation is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromN 5 3 = \u003c5,6,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#enumFromN",
        "fct-type": "function",
        "title": "enumFromN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operation is usually more efficient than enumFromTo enumFromN",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "enumFromN",
        "normalized": "a-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From",
        "signature": "a-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:enumFromStepN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc. This operations is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromThenTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromStepN 1 0.1 5 = \u003c1,1.1,1.2,1.3,1.4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#enumFromStepN",
        "fct-type": "function",
        "title": "enumFromStepN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operations is usually more efficient than enumFromThenTo enumFromStepN",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "enumFromStepN",
        "normalized": "a-\u003ea-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From Step",
        "signature": "a-\u003ea-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:enumFromThenTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e with a specific step \u003ccode\u003ez\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#enumFromThenTo",
        "fct-type": "function",
        "title": "enumFromThenTo"
      },
      "index": {
        "description": "Enumerate values from to with specific step WARNING This operation can be very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "enumFromThenTo",
        "normalized": "a-\u003ea-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "From Then To",
        "signature": "a-\u003ea-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Enumerate values from to WARNING This operation can be very inefficient If at all possible use enumFromN instead",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "enumFromTo",
        "normalized": "a-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "From To",
        "signature": "a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "filter",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Vector a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Drop elements that do not satisfy the monadic predicate",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "filterM",
        "normalized": "(a-\u003eb Bool)-\u003eVector a-\u003eb(Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003eVector a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Primitive.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "find",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Primitive.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of elements satisfying the predicate in ascending\n order.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector Int",
        "fct-source": "src/Data-Vector-Primitive.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "Yield the indices of elements satisfying the predicate in ascending order",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "findIndices",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "fold1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "fold1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:fold1M-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#fold1M%27_",
        "fct-type": "function",
        "title": "fold1M'_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator that discards the result",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "fold1M'_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:fold1M_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#fold1M_",
        "fct-type": "function",
        "title": "fold1M_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors that discards the result",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "fold1M_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Monadic fold with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldM-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#foldM%27_",
        "fct-type": "function",
        "title": "foldM'_"
      },
      "index": {
        "description": "Monadic fold with strict accumulator that discards the result",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldM'_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#foldM_",
        "fct-type": "function",
        "title": "foldM_"
      },
      "index": {
        "description": "Monadic fold that discards the result",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldM_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold on non-empty vectors",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Primitive.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Primitive.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold on non-empty vectors",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "Right fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "foldr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:forM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results. Equvalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (a -\u003e m b) -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector-Primitive.html#forM",
        "fct-type": "function",
        "title": "forM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results Equvalent to flip mapM",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "forM",
        "normalized": "Vector a-\u003e(a-\u003eb c)-\u003eb(Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e(a-\u003em b)-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:forM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results. Equivalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (a -\u003e m b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#forM_",
        "fct-type": "function",
        "title": "forM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results Equivalent to flip mapM",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "forM_",
        "normalized": "Vector a-\u003e(a-\u003eb c)-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e(a-\u003em b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:force",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the argument but force it not to retain any extra memory,\n possibly by copying it.\n\u003c/p\u003e\u003cp\u003eThis is especially useful when dealing with slices. For example:\n\u003c/p\u003e\u003cpre\u003e force (slice 0 2 \u003chuge vector\u003e)\n\u003c/pre\u003e\u003cp\u003eHere, the slice retains a reference to the huge vector. Forcing it creates\n a copy of just the elements that belong to the slice and allows the huge\n vector to be garbage collected.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#force",
        "fct-type": "function",
        "title": "force"
      },
      "index": {
        "description": "Yield the argument but force it not to retain any extra memory possibly by copying it This is especially useful when dealing with slices For example force slice huge vector Here the slice retains reference to the huge vector Forcing it creates copy of just the elements that belong to the slice and allows the huge vector to be garbage collected",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "force",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:freeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield an immutable copy of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#freeze",
        "fct-type": "function",
        "title": "freeze"
      },
      "index": {
        "description": "Yield an immutable copy of the mutable vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "freeze",
        "normalized": "MVector(PrimState a)b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a list to a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "[a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "fromList",
        "normalized": "[a]-\u003eVector a",
        "package": "vector",
        "partial": "List",
        "signature": "[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a vector\n\u003c/p\u003e\u003cpre\u003e\n fromListN n xs = \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e [a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Convert the first elements of list to vector fromListN xs fromList take xs",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "fromListN",
        "normalized": "Int-\u003e[a]-\u003eVector a",
        "package": "vector",
        "partial": "List",
        "signature": "Int-\u003e[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the function to\n each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Construct vector of the given length by applying the function to each index",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the monadic\n action to each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e m a) -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Construct vector of the given length by applying the monadic action to each index",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "generateM",
        "normalized": "Int-\u003e(Int-\u003ea b)-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003em a)-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "head",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:headM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#headM",
        "fct-type": "function",
        "title": "headM"
      },
      "index": {
        "description": "First element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "headM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:ifilter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate which is applied to\n values and their indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#ifilter",
        "fct-type": "function",
        "title": "ifilter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate which is applied to values and their indices",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "ifilter",
        "normalized": "(Int-\u003ea-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold function applied to each element and its index",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:ifoldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator (function applied to each element\n and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#ifoldl%27",
        "fct-type": "function",
        "title": "ifoldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "ifoldl'",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Primitive.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Right fold function applied to each element and its index",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:ifoldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with strict accumulator (function applied to each\n element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Primitive.html#ifoldr%27",
        "fct-type": "function",
        "title": "ifoldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "ifoldr'",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply a function to every element of a vector and its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of vector and its index",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:indexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad.\n\u003c/p\u003e\u003cp\u003eThe monad allows operations to be strict in the vector when necessary.\n Suppose vector copying is implemented like this:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... write mv i (v ! i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, \u003ccode\u003ev ! i\u003c/code\u003e would not be evaluated which means that \u003ccode\u003emv\u003c/code\u003e\n would unnecessarily retain a reference to \u003ccode\u003ev\u003c/code\u003e in each element written.\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e, copying can be implemented like this instead:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... do\n                   x \u003c- indexM v i\n                   write mv i x\n\u003c/pre\u003e\u003cp\u003eHere, no references to \u003ccode\u003ev\u003c/code\u003e are retained because indexing (but \u003cem\u003enot\u003c/em\u003e the\n elements) is evaluated eagerly.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#indexM",
        "fct-type": "function",
        "title": "indexM"
      },
      "index": {
        "description": "Indexing in monad The monad allows operations to be strict in the vector when necessary Suppose vector copying is implemented like this copy mv write mv For lazy vectors would not be evaluated which means that mv would unnecessarily retain reference to in each element written With indexM copying can be implemented like this instead copy mv do indexM write mv Here no references to are retained because indexing but not the elements is evaluated eagerly",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "indexM",
        "normalized": "Vector a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "init",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function times to value Zeroth element is original value",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "iterateN",
        "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with a function that also takes the\n elements' indices.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
        "fct-source": "src/Data-Vector-Primitive.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "min Zip two vectors with function that also takes the elements indices",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:izipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors and their indices with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d",
        "fct-source": "src/Data-Vector-Primitive.html#izipWith3",
        "fct-type": "function",
        "title": "izipWith3"
      },
      "index": {
        "description": "Zip three vectors and their indices with the given function",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "izipWith3",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:izipWith4",
      "description": {
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e",
        "fct-source": "src/Data-Vector-Primitive.html#izipWith4",
        "fct-type": "function",
        "title": "izipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "izipWith4",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:izipWith5",
      "description": {
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f",
        "fct-source": "src/Data-Vector-Primitive.html#izipWith5",
        "fct-type": "function",
        "title": "izipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "izipWith5",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:izipWith6",
      "description": {
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector g",
        "fct-source": "src/Data-Vector-Primitive.html#izipWith6",
        "fct-type": "function",
        "title": "izipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "izipWith6",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "last",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:lastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#lastM",
        "fct-type": "function",
        "title": "lastM"
      },
      "index": {
        "description": "Last element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "lastM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the length of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Primitive.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Yield the length of the vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "length",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Map a function over a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Vector a -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector-Primitive.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb(Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eVector a-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:maxIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Primitive.html#maxIndex",
        "fct-type": "function",
        "title": "maxIndex"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "maxIndex",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:maxIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Primitive.html#maxIndexBy",
        "fct-type": "function",
        "title": "maxIndexBy"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "maxIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Yield the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "maximum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:maximumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#maximumBy",
        "fct-type": "function",
        "title": "maximumBy"
      },
      "index": {
        "description": "Yield the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "maximumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:minIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Primitive.html#minIndex",
        "fct-type": "function",
        "title": "minIndex"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "minIndex",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:minIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Primitive.html#minIndexBy",
        "fct-type": "function",
        "title": "minIndexBy"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "minIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Yield the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "minimum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:minimumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#minimumBy",
        "fct-type": "function",
        "title": "minimumBy"
      },
      "index": {
        "description": "Yield the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "minimumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:modify",
      "description": {
        "fct-descr": "\u003cp\u003eApply a destructive operation to a vector. The operation will be\n performed in place if it is safe to do so and will modify a copy of the\n vector otherwise.\n\u003c/p\u003e\u003cpre\u003e\n modify (\\v -\u003e write v 0 'x') (\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e 3 'a') = \u003c'x','a','a'\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(forall s.  MVector s a -\u003e ST s ()) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#modify",
        "fct-type": "function",
        "title": "modify"
      },
      "index": {
        "description": "Apply destructive operation to vector The operation will be performed in place if it is safe to do so and will modify copy of the vector otherwise modify write replicate",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "modify",
        "normalized": "(a b MVector c d-\u003eST c())-\u003eVector d-\u003eVector d",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. MVector s a-\u003eST s())-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector does not contain an element (inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Primitive.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Check if the vector does not contain an element inverse of elem",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "notElem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "Elem",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a vector if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Primitive.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether vector if empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "null",
        "normalized": "Vector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't. The\n relative order of the elements is preserved at the cost of a sometimes\n reduced performance compared to \u003ccode\u003e\u003ca\u003eunstablePartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The relative order of the elements is preserved at the cost of sometimes reduced performance compared to unstablePartition",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "partition",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan\n\u003c/p\u003e\u003cpre\u003e\n postscanl f z = \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003epostscanl (+) 0 \u003c1,2,3,4\u003e = \u003c1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Scan postscanl tail scanl Example postscanl",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "postscanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Scan with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "postscanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:postscanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#postscanr",
        "fct-type": "function",
        "title": "postscanr"
      },
      "index": {
        "description": "Right-to-left scan",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "postscanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:postscanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#postscanr%27",
        "fct-type": "function",
        "title": "postscanr'"
      },
      "index": {
        "description": "Right-to-left scan with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "postscanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanl f z = \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003eprescanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prescan prescanl init scanl Example prescanl",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "prescanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prescan with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "prescanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:prescanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanr f z = \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eprescanl\u003c/a\u003e\u003c/code\u003e (flip f) z . \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#prescanr",
        "fct-type": "function",
        "title": "prescanr"
      },
      "index": {
        "description": "Right-to-left prescan prescanr reverse prescanl flip reverse",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "prescanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:prescanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#prescanr%27",
        "fct-type": "function",
        "title": "prescanr'"
      },
      "index": {
        "description": "Right-to-left prescan with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "prescanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:product",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the produce of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#product",
        "fct-type": "function",
        "title": "product"
      },
      "index": {
        "description": "Compute the produce of the elements",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "product",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Vector of the given length with the same value in each position\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Vector of the given length with the same value in each position",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Execute the monadic action the given number of times and store the\n results in a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute the monadic action the given number of times and store the results in vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Reverse a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "reverse",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan\n\u003c/p\u003e\u003cpre\u003e scanl f z \u003cx1,...,xn\u003e = \u003cy1,...,y(n+1)\u003e\n   where y1 = z\n         yi = f y(i-1) x(i-1)\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003escanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan scanl x1 xn y1 where y1 yi i-1 i-1 Example scanl",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "scanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector\n\u003c/p\u003e\u003cpre\u003e scanl f \u003cx1,...,xn\u003e = \u003cy1,...,yn\u003e\n   where y1 = x1\n         yi = f y(i-1) xi\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty vector scanl x1 xn y1 yn where y1 x1 yi i-1 xi",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "scanl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "scanl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "scanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:scanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Primitive.html#scanr%27",
        "fct-type": "function",
        "title": "scanr'"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "scanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "scanr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:scanr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector with a strict\n accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#scanr1%27",
        "fct-type": "function",
        "title": "scanr1'"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "scanr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Vector with exactly one element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Vector with exactly one element",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "singleton",
        "normalized": "a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying it. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield slice of the vector without copying it The vector must contain at least elements",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "snoc",
        "normalized": "Vector a-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that satisfy\n the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "span",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements paired with the remainder without copying.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e n v\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n v, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n v)\u003c/code\u003e\n but slightly more efficient.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "Yield the first elements paired with the remainder without copying Note that splitAt is equivalent to take drop but slightly more efficient",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "splitAt",
        "normalized": "Int-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the sum of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "Compute the sum of the elements",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "sum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "tail",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield at the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case it is returned unchanged.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "Yield at the first elements without copying The vector may contain less than elements in which case it is returned unchanged",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "take",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the longest prefix of elements satisfying the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Yield the longest prefix of elements satisfying the predicate without copying",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "takeWhile",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:thaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a mutable copy of the immutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive.html#thaw",
        "fct-type": "function",
        "title": "thaw"
      },
      "index": {
        "description": "Yield mutable copy of the immutable vector",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "thaw",
        "normalized": "Vector a-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a vector to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e [a]",
        "fct-source": "src/Data-Vector-Primitive.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to list",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "toList",
        "normalized": "Vector a-\u003e[a]",
        "package": "vector",
        "partial": "List",
        "signature": "Vector a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector by repeatedly applying the generator function\n to a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the next element and the\n new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\n -\u003e if n == 0 then Nothing else Just (n,n-1)) 10\n  = \u003c10,9,8,7,6,5,4,3,2,1\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Construct vector by repeatedly applying the generator function to seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldr if then Nothing else Just n-1",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with at most \u003ccode\u003en\u003c/code\u003e by repeatedly applying the\n generator function to the a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the\n next element and the new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldrN 3 (\\n -\u003e Just (n,n-1)) 10 = \u003c10,9,8\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Construct vector with at most by repeatedly applying the generator function to the seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldrN Just n-1",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeAccum",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccum\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e [(Int, b)] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeAccum",
        "fct-type": "function",
        "title": "unsafeAccum"
      },
      "index": {
        "description": "Same as accum but without bounds checking",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeAccum",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a",
        "package": "vector",
        "partial": "Accum",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeAccumulate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e Vector Int -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeAccumulate_",
        "fct-type": "function",
        "title": "unsafeAccumulate_"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeAccumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeBackpermute",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ebackpermute\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeBackpermute",
        "fct-type": "function",
        "title": "unsafeBackpermute"
      },
      "index": {
        "description": "Same as backpermute but without bounds checking",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeBackpermute",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a",
        "package": "vector",
        "partial": "Backpermute",
        "signature": "Vector a-\u003eVector Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeCopy",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length This is not checked",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeCopy",
        "normalized": "MVector(PrimState a)b-\u003eVector b-\u003ea()",
        "package": "vector",
        "partial": "Copy",
        "signature": "MVector(PrimState m)a-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeDrop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector\n must contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe convert a mutable vector to an immutable one without\n copying. The mutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeFreeze",
        "fct-type": "function",
        "title": "unsafeFreeze"
      },
      "index": {
        "description": "Unsafe convert mutable vector to an immutable one without copying The mutable vector may not be used after this operation",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeFreeze",
        "normalized": "MVector(PrimState a)b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "Freeze",
        "signature": "MVector(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeHead",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeHead",
        "fct-type": "function",
        "title": "unsafeHead"
      },
      "index": {
        "description": "First element without checking if the vector is empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeHead",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "Head",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeHeadM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeHeadM",
        "fct-type": "function",
        "title": "unsafeHeadM"
      },
      "index": {
        "description": "First element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeHeadM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "Head",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe indexing without bounds checking\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeIndex",
        "fct-type": "function",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Unsafe indexing without bounds checking",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeIndex",
        "normalized": "Vector a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeIndexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad without bounds checks. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeIndexM",
        "fct-type": "function",
        "title": "unsafeIndexM"
      },
      "index": {
        "description": "Indexing in monad without bounds checks See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeIndexM",
        "normalized": "Vector a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeInit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeInit",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "Init",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeLast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeLast",
        "fct-type": "function",
        "title": "unsafeLast"
      },
      "index": {
        "description": "Last element without checking if the vector is empty",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeLast",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "Last",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeLastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeLastM",
        "fct-type": "function",
        "title": "unsafeLastM"
      },
      "index": {
        "description": "Last element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeLastM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "Last",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield slice of the vector without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeTail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeTail",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "Tail",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeTake",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector must\n contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "Yield the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeTake",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely convert an immutable vector to a mutable one without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeThaw",
        "fct-type": "function",
        "title": "unsafeThaw"
      },
      "index": {
        "description": "Unsafely convert an immutable vector to mutable one without copying The immutable vector may not be used after this operation",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeThaw",
        "normalized": "Vector a-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "Thaw",
        "signature": "Vector a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeUpd",
      "description": {
        "fct-descr": "\u003cp\u003eSame as (\u003ccode\u003e\u003ca\u003e//\u003c/a\u003e\u003c/code\u003e) but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e [(Int, a)] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeUpd",
        "fct-type": "function",
        "title": "unsafeUpd"
      },
      "index": {
        "description": "Same as but without bounds checking",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeUpd",
        "normalized": "Vector a-\u003e[(Int,a)]-\u003eVector a",
        "package": "vector",
        "partial": "Upd",
        "signature": "Vector a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unsafeUpdate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Primitive.html#unsafeUpdate_",
        "fct-type": "function",
        "title": "unsafeUpdate_"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unsafeUpdate_",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Update",
        "signature": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:unstablePartition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't.\n The order of the elements is not preserved but the operation is often\n faster than \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Primitive.html#unstablePartition",
        "fct-type": "function",
        "title": "unstablePartition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The order of the elements is not preserved but the operation is often faster than partition",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "unstablePartition",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "Partition",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:update_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003ea\u003c/code\u003e from the value vector, replace the element of the\n initial vector at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update_ \u003c5,9,2,7\u003e  \u003c2,0,2\u003e \u003c1,3,8\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e Vector Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "update_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the value vector replace the element of the initial vector at position by update",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "update_",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
        "fct-source": "src/Data-Vector-Primitive.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "min Zip two vectors with the given function",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:zipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d",
        "fct-source": "src/Data-Vector-Primitive.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "Zip three vectors with the given function",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "zipWith3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e",
        "fct-source": "src/Data-Vector-Primitive.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "zipWith4",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f",
        "fct-source": "src/Data-Vector-Primitive.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "zipWith5",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector g",
        "fct-source": "src/Data-Vector-Primitive.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "zipWith6",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and yield a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Vector a -\u003e Vector b -\u003e m (Vector c)",
        "fct-source": "src/Data-Vector-Primitive.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and yield vector of results",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eVector a-\u003eVector b-\u003ec(Vector d)",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eVector a-\u003eVector b-\u003em(Vector c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Primitive.html#v:zipWithM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Primitive",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Vector a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Primitive.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and ignore the results",
        "hierarchy": "Data Vector Primitive",
        "module": "Data.Vector.Primitive",
        "name": "zipWithM_",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eVector a-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eVector a-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Internal.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUgly internal utility functions for implementing \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e-based vectors.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Storable.Internal",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Storable-Internal.html",
        "fct-type": "module",
        "title": "Internal"
      },
      "index": {
        "description": "Ugly internal utility functions for implementing Storable based vectors",
        "hierarchy": "Data Vector Storable Internal",
        "module": "Data.Vector.Storable.Internal",
        "name": "Internal",
        "normalized": "",
        "package": "vector",
        "partial": "Internal",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Internal.html#v:getPtr",
      "description": {
        "fct-module": "Data.Vector.Storable.Internal",
        "fct-package": "vector",
        "fct-signature": "ForeignPtr a -\u003e Ptr a",
        "fct-source": "src/Data-Vector-Storable-Internal.html#getPtr",
        "fct-type": "function",
        "title": "getPtr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Internal",
        "module": "Data.Vector.Storable.Internal",
        "name": "getPtr",
        "normalized": "ForeignPtr a-\u003ePtr a",
        "package": "vector",
        "partial": "Ptr",
        "signature": "ForeignPtr a-\u003ePtr a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Internal.html#v:setPtr",
      "description": {
        "fct-module": "Data.Vector.Storable.Internal",
        "fct-package": "vector",
        "fct-signature": "ForeignPtr a -\u003e Ptr a -\u003e ForeignPtr a",
        "fct-source": "src/Data-Vector-Storable-Internal.html#setPtr",
        "fct-type": "function",
        "title": "setPtr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Internal",
        "module": "Data.Vector.Storable.Internal",
        "name": "setPtr",
        "normalized": "ForeignPtr a-\u003ePtr a-\u003eForeignPtr a",
        "package": "vector",
        "partial": "Ptr",
        "signature": "ForeignPtr a-\u003ePtr a-\u003eForeignPtr a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Internal.html#v:updPtr",
      "description": {
        "fct-module": "Data.Vector.Storable.Internal",
        "fct-package": "vector",
        "fct-signature": "(Ptr a -\u003e Ptr a) -\u003e ForeignPtr a -\u003e ForeignPtr a",
        "fct-source": "src/Data-Vector-Storable-Internal.html#updPtr",
        "fct-type": "function",
        "title": "updPtr"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Internal",
        "module": "Data.Vector.Storable.Internal",
        "name": "updPtr",
        "normalized": "(Ptr a-\u003ePtr a)-\u003eForeignPtr a-\u003eForeignPtr a",
        "package": "vector",
        "partial": "Ptr",
        "signature": "(Ptr a-\u003ePtr a)-\u003eForeignPtr a-\u003eForeignPtr a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable vectors based on Storable.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Storable-Mutable.html",
        "fct-type": "module",
        "title": "Mutable"
      },
      "index": {
        "description": "Mutable vectors based on Storable",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "vector",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#t:IOVector",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#IOVector",
        "fct-type": "type",
        "title": "IOVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "IOVector",
        "normalized": "",
        "package": "vector",
        "partial": "IOVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eMutable \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e-based vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "Mutable Storable based vectors",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#t:STVector",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#STVector",
        "fct-type": "type",
        "title": "STVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "STVector",
        "normalized": "",
        "package": "vector",
        "partial": "STVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#t:Storable",
      "description": {
        "fct-descr": "\u003cp\u003eThe member functions of this class facilitate writing values of\nprimitive types to raw memory (which may have been allocated with the\nabove mentioned routines) and reading values from blocks of raw\nmemory.  The class, furthermore, includes support for computing the\nstorage requirements and alignment restrictions of storable types.\n\u003c/p\u003e\u003cp\u003eMemory addresses are represented as values of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e, for some\n\u003ccode\u003ea\u003c/code\u003e which is an instance of class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e.  The type argument to\n\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e helps provide some valuable type safety in FFI code (you can't\nmix pointers of different types without an explicit cast), while\nhelping the Haskell type system figure out which marshalling method is\nneeded for a given pointer.\n\u003c/p\u003e\u003cp\u003eAll marshalling between Haskell and a foreign language ultimately\nboils down to translating Haskell data structures into the binary\nrepresentation of a corresponding data structure of the foreign\nlanguage and vice versa.  To code this marshalling in Haskell, it is\nnecessary to manipulate primitive data types stored in unstructured\nmemory blocks.  The class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e facilitates this manipulation on\nall types for which it is instantiated, which are the standard basic\ntypes of Haskell, the fixed size \u003ccode\u003eInt\u003c/code\u003e types (\u003ccode\u003e\u003ca\u003eInt8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e), the fixed size \u003ccode\u003eWord\u003c/code\u003e types (\u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eWord32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord64\u003c/a\u003e\u003c/code\u003e), \u003ccode\u003e\u003ca\u003eStablePtr\u003c/a\u003e\u003c/code\u003e, all types from \u003ca\u003eForeign.C.Types\u003c/a\u003e,\nas well as \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003esizeOf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ealignment\u003c/a\u003e\u003c/code\u003e, one of \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003epeekElemOff\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epeekByteOff\u003c/a\u003e\u003c/code\u003e, and one of \u003ccode\u003e\u003ca\u003epoke\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epokeElemOff\u003c/a\u003e\u003c/code\u003e and\n\u003ccode\u003e\u003ca\u003epokeByteOff\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "class",
        "fct-type": "class",
        "title": "Storable"
      },
      "index": {
        "description": "The member functions of this class facilitate writing values of primitive types to raw memory which may have been allocated with the above mentioned routines and reading values from blocks of raw memory The class furthermore includes support for computing the storage requirements and alignment restrictions of storable types Memory addresses are represented as values of type Ptr for some which is an instance of class Storable The type argument to Ptr helps provide some valuable type safety in FFI code you can mix pointers of different types without an explicit cast while helping the Haskell type system figure out which marshalling method is needed for given pointer All marshalling between Haskell and foreign language ultimately boils down to translating Haskell data structures into the binary representation of corresponding data structure of the foreign language and vice versa To code this marshalling in Haskell it is necessary to manipulate primitive data types stored in unstructured memory blocks The class Storable facilitates this manipulation on all types for which it is instantiated which are the standard basic types of Haskell the fixed size Int types Int8 Int16 Int32 Int64 the fixed size Word types Word8 Word16 Word32 Word64 StablePtr all types from Foreign.C.Types as well as Ptr Minimal complete definition sizeOf alignment one of peek peekElemOff and peekByteOff and one of poke pokeElemOff and pokeByteOff",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "Storable",
        "normalized": "",
        "package": "vector",
        "partial": "Storable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:MVector",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector !Int !(ForeignPtr a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#MVector",
        "fct-type": "function",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:clear",
      "description": {
        "fct-descr": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed vectors. \n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#clear",
        "fct-type": "function",
        "title": "clear"
      },
      "index": {
        "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "clear",
        "normalized": "MVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a copy of a mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Create copy of mutable vector",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "clone",
        "normalized": "MVector(PrimState a)b-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "copy",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:drop",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "drop",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:grow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#grow",
        "fct-type": "function",
        "title": "grow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "grow",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:init",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "init",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e Int",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of the mutable vector",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "length",
        "normalized": "MVector a b-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:move",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003ecopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#move",
        "fct-type": "function",
        "title": "move"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length If the vectors do not overlap then this is equivalent to copy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "move",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "Create mutable vector of the given length",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "new",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check whether the vector is empty",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "null",
        "normalized": "MVector a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:overlaps",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#overlaps",
        "fct-type": "function",
        "title": "overlaps"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "overlaps",
        "normalized": "MVector a b-\u003eMVector a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Yield the element at the given position",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "read",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with an initial value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with an initial value",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with values produced by repeatedly executing the monadic action.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with values produced by repeatedly executing the monadic action",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003eSet all elements of the vector to the given value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#set",
        "fct-type": "function",
        "title": "set"
      },
      "index": {
        "description": "Set all elements of the vector to the given value",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "set",
        "normalized": "MVector(PrimState a)b-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:splitAt",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e (MVector s a, MVector s a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "splitAt",
        "normalized": "Int-\u003eMVector a b-\u003e(MVector a b,MVector a b)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003eMVector s a-\u003e(MVector s a,MVector s a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:swap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "Swap the elements at the given positions",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "swap",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eInt-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "tail",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:take",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "take",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeCast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely cast a mutable vector from one element type to another.\n The operation just changes the type of the underlying pointer and does not\n modify the elements.\n\u003c/p\u003e\u003cp\u003eThe resulting vector contains as many elements as can fit into the\n underlying memory block.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s b",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeCast",
        "fct-type": "function",
        "title": "unsafeCast"
      },
      "index": {
        "description": "Unsafely cast mutable vector from one element type to another The operation just changes the type of the underlying pointer and does not modify the elements The resulting vector contains as many elements as can fit into the underlying memory block",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeCast",
        "normalized": "MVector a b-\u003eMVector a c",
        "package": "vector",
        "partial": "Cast",
        "signature": "MVector s a-\u003eMVector s b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a-\u003e MVector (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap This is not checked",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeCopy",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "Copy",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeDrop",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeFromForeignPtr",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector from a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e with an offset and a length.\n\u003c/p\u003e\u003cp\u003eModifying data through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e afterwards is unsafe if the vector\n could have been frozen before the modification.\n\u003c/p\u003e\u003cp\u003eIf your offset is 0 it is more efficient to use \u003ccode\u003e\u003ca\u003eunsafeFromForeignPtr0\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "ForeignPtr a-\u003e Int-\u003e Int-\u003e MVector s a",
        "fct-type": "function",
        "title": "unsafeFromForeignPtr"
      },
      "index": {
        "description": "Create mutable vector from ForeignPtr with an offset and length Modifying data through the ForeignPtr afterwards is unsafe if the vector could have been frozen before the modification If your offset is it is more efficient to use unsafeFromForeignPtr0",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeFromForeignPtr",
        "normalized": "ForeignPtr a-\u003eInt-\u003eInt-\u003eMVector b a",
        "package": "vector",
        "partial": "From Foreign Ptr",
        "signature": "ForeignPtr a-\u003eInt-\u003eInt-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeFromForeignPtr0",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Create a mutable vector from a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e and a length.\n\u003c/p\u003e\u003cp\u003eIt is assumed the pointer points directly to the data (no offset).\n Use \u003ccode\u003e\u003ca\u003eunsafeFromForeignPtr\u003c/a\u003e\u003c/code\u003e if you need to specify an offset.\n\u003c/p\u003e\u003cp\u003eModifying data through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e afterwards is unsafe if the vector\n could have been frozen before the modification.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "ForeignPtr a-\u003e Int-\u003e MVector s a",
        "fct-type": "function",
        "title": "unsafeFromForeignPtr0"
      },
      "index": {
        "description": "Create mutable vector from ForeignPtr and length It is assumed the pointer points directly to the data no offset Use unsafeFromForeignPtr if you need to specify an offset Modifying data through the ForeignPtr afterwards is unsafe if the vector could have been frozen before the modification",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeFromForeignPtr0",
        "normalized": "ForeignPtr a-\u003eInt-\u003eMVector b a",
        "package": "vector",
        "partial": "From Foreign Ptr",
        "signature": "ForeignPtr a-\u003eInt-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeGrow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeGrow",
        "fct-type": "function",
        "title": "unsafeGrow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive but this is not checked",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeGrow",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "Grow",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeInit",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeInit",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Init",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeMove",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length, but this is not checked.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003eunsafeCopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a-\u003e MVector (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeMove"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length but this is not checked If the vectors do not overlap then this is equivalent to unsafeCopy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeMove",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "Move",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeNew",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length. The length is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeNew",
        "fct-type": "function",
        "title": "unsafeNew"
      },
      "index": {
        "description": "Create mutable vector of the given length The length is not checked",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeNew",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "New",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeRead",
        "fct-type": "function",
        "title": "unsafeRead"
      },
      "index": {
        "description": "Yield the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeRead",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "Read",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it. No bounds checks\n are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e MVector s a-\u003e MVector s a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it No bounds checks are performed",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeSwap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeSwap",
        "fct-type": "function",
        "title": "unsafeSwap"
      },
      "index": {
        "description": "Swap the elements at the given positions No bounds checks are performed",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeSwap",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eInt-\u003ea()",
        "package": "vector",
        "partial": "Swap",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeTail",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeTail",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Tail",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeTake",
      "description": {
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeTake",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeToForeignPtr",
      "description": {
        "fct-descr": "\u003cp\u003eYield the underlying \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e together with the offset to the data\n and its length. Modifying the data through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e is\n unsafe if the vector could have frozen before the modification.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e (ForeignPtr a, Int, Int)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeToForeignPtr",
        "fct-type": "function",
        "title": "unsafeToForeignPtr"
      },
      "index": {
        "description": "Yield the underlying ForeignPtr together with the offset to the data and its length Modifying the data through the ForeignPtr is unsafe if the vector could have frozen before the modification",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeToForeignPtr",
        "normalized": "MVector a b-\u003e(ForeignPtr b,Int,Int)",
        "package": "vector",
        "partial": "To Foreign Ptr",
        "signature": "MVector s a-\u003e(ForeignPtr a,Int,Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeToForeignPtr0",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the underlying \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e together with its length.\n\u003c/p\u003e\u003cp\u003eYou can assume the pointer points directly to the data (no offset).\n\u003c/p\u003e\u003cp\u003eModifying the data through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e is unsafe if the vector could\n have frozen before the modification.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e (ForeignPtr a, Int)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeToForeignPtr0",
        "fct-type": "function",
        "title": "unsafeToForeignPtr0"
      },
      "index": {
        "description": "Yield the underlying ForeignPtr together with its length You can assume the pointer points directly to the data no offset Modifying the data through the ForeignPtr is unsafe if the vector could have frozen before the modification",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeToForeignPtr0",
        "normalized": "MVector a b-\u003e(ForeignPtr b,Int)",
        "package": "vector",
        "partial": "To Foreign Ptr",
        "signature": "MVector s a-\u003e(ForeignPtr a,Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeWith",
      "description": {
        "fct-descr": "\u003cp\u003ePass a pointer to the vector's data to the IO action. Modifying data\n through the pointer is unsafe if the vector could have been frozen before\n the modification.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "IOVector a -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeWith",
        "fct-type": "function",
        "title": "unsafeWith"
      },
      "index": {
        "description": "Pass pointer to the vector data to the IO action Modifying data through the pointer is unsafe if the vector could have been frozen before the modification",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeWith",
        "normalized": "IOVector a-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
        "package": "vector",
        "partial": "With",
        "signature": "IOVector a-\u003e(Ptr a-\u003eIO b)-\u003eIO b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:unsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#unsafeWrite",
        "fct-type": "function",
        "title": "unsafeWrite"
      },
      "index": {
        "description": "Replace the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "unsafeWrite",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "Write",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Replace the element at the given position",
        "hierarchy": "Data Vector Storable Mutable",
        "module": "Data.Vector.Storable.Mutable",
        "name": "write",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e-based vectors.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Storable.html",
        "fct-type": "module",
        "title": "Storable"
      },
      "index": {
        "description": "Storable based vectors",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "Storable",
        "normalized": "",
        "package": "vector",
        "partial": "Storable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eMutable \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e-based vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "Mutable Storable based vectors",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#t:Storable",
      "description": {
        "fct-descr": "\u003cp\u003eThe member functions of this class facilitate writing values of\nprimitive types to raw memory (which may have been allocated with the\nabove mentioned routines) and reading values from blocks of raw\nmemory.  The class, furthermore, includes support for computing the\nstorage requirements and alignment restrictions of storable types.\n\u003c/p\u003e\u003cp\u003eMemory addresses are represented as values of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e, for some\n\u003ccode\u003ea\u003c/code\u003e which is an instance of class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e.  The type argument to\n\u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e helps provide some valuable type safety in FFI code (you can't\nmix pointers of different types without an explicit cast), while\nhelping the Haskell type system figure out which marshalling method is\nneeded for a given pointer.\n\u003c/p\u003e\u003cp\u003eAll marshalling between Haskell and a foreign language ultimately\nboils down to translating Haskell data structures into the binary\nrepresentation of a corresponding data structure of the foreign\nlanguage and vice versa.  To code this marshalling in Haskell, it is\nnecessary to manipulate primitive data types stored in unstructured\nmemory blocks.  The class \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e facilitates this manipulation on\nall types for which it is instantiated, which are the standard basic\ntypes of Haskell, the fixed size \u003ccode\u003eInt\u003c/code\u003e types (\u003ccode\u003e\u003ca\u003eInt8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e), the fixed size \u003ccode\u003eWord\u003c/code\u003e types (\u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eWord32\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord64\u003c/a\u003e\u003c/code\u003e), \u003ccode\u003e\u003ca\u003eStablePtr\u003c/a\u003e\u003c/code\u003e, all types from \u003ca\u003eForeign.C.Types\u003c/a\u003e,\nas well as \u003ccode\u003e\u003ca\u003ePtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003esizeOf\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ealignment\u003c/a\u003e\u003c/code\u003e, one of \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003epeekElemOff\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epeekByteOff\u003c/a\u003e\u003c/code\u003e, and one of \u003ccode\u003e\u003ca\u003epoke\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epokeElemOff\u003c/a\u003e\u003c/code\u003e and\n\u003ccode\u003e\u003ca\u003epokeByteOff\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "class",
        "fct-type": "class",
        "title": "Storable"
      },
      "index": {
        "description": "The member functions of this class facilitate writing values of primitive types to raw memory which may have been allocated with the above mentioned routines and reading values from blocks of raw memory The class furthermore includes support for computing the storage requirements and alignment restrictions of storable types Memory addresses are represented as values of type Ptr for some which is an instance of class Storable The type argument to Ptr helps provide some valuable type safety in FFI code you can mix pointers of different types without an explicit cast while helping the Haskell type system figure out which marshalling method is needed for given pointer All marshalling between Haskell and foreign language ultimately boils down to translating Haskell data structures into the binary representation of corresponding data structure of the foreign language and vice versa To code this marshalling in Haskell it is necessary to manipulate primitive data types stored in unstructured memory blocks The class Storable facilitates this manipulation on all types for which it is instantiated which are the standard basic types of Haskell the fixed size Int types Int8 Int16 Int32 Int64 the fixed size Word types Word8 Word16 Word32 Word64 StablePtr all types from Foreign.C.Types as well as Ptr Minimal complete definition sizeOf alignment one of peek peekElemOff and peekByteOff and one of poke pokeElemOff and pokeByteOff",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "Storable",
        "normalized": "",
        "package": "vector",
        "partial": "Storable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#t:Vector",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e-based vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Storable.html#Vector",
        "fct-type": "data",
        "title": "Vector"
      },
      "index": {
        "description": "Storable based vectors",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "Vector",
        "normalized": "",
        "package": "vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Indexing",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "(!) !",
        "normalized": "Vector a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Safe indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Storable.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Safe indexing",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "(!?) !?",
        "normalized": "Vector a-\u003eInt-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e Concatenate two vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two vectors",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "(++) ++",
        "normalized": "Vector a-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:-47--47-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the list, replace the vector\n element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003c5,9,2,7\u003e // [(2,1),(0,3),(2,8)] = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e [(Int, a)]-\u003e Vector a",
        "fct-type": "function",
        "title": "(//)"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "(//) //",
        "normalized": "Vector a-\u003e[(Int,a)]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:MVector",
      "description": {
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "MVector !Int !(ForeignPtr a)",
        "fct-source": "src/Data-Vector-Storable-Mutable.html#MVector",
        "fct-type": "function",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:accum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the list, replace the vector element\n \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accum (+) \u003c5,9,2\u003e [(2,4),(1,6),(0,3),(1,7)] = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e [(Int, b)]-\u003e Vector a",
        "fct-type": "function",
        "title": "accum"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by accum",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "accum",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:accumulate_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003eb\u003c/code\u003e from the the value vector,\n replace the element of the initial vector at\n position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate_ (+) \u003c5,9,2\u003e \u003c2,1,0,1\u003e \u003c4,6,3,7\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e Vector Int-\u003e Vector b-\u003e Vector a",
        "fct-type": "function",
        "title": "accumulate_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the the value vector replace the element of the initial vector at position by accumulate",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "accumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Check if all elements satisfy the predicate",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements are \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "Check if all elements are True",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "and",
        "normalized": "Vector Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Check if any element satisfies the predicate",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:backpermute",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the vector obtained by replacing each element \u003ccode\u003ei\u003c/code\u003e of the\n index vector by \u003ccode\u003exs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003ei\u003c/code\u003e. This is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (xs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e) is\u003c/code\u003e but is\n often much more efficient.\n\u003c/p\u003e\u003cpre\u003e backpermute \u003ca,b,c,d\u003e \u003c0,3,2,3,1,0\u003e = \u003ca,d,c,d,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#backpermute",
        "fct-type": "function",
        "title": "backpermute"
      },
      "index": {
        "description": "Yield the vector obtained by replacing each element of the index vector by xs This is equivalent to map xs is but is often much more efficient backpermute",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "backpermute",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that do not\n satisfy the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that do not satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "break",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate all vectors in the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "[Vector a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate all vectors in the list",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "concat",
        "normalized": "[Vector a]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "[Vector a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a vector and concatenate the results.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Vector b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over vector and concatenate the results",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "concatMap",
        "normalized": "(a-\u003eVector b)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "Map",
        "signature": "(a-\u003eVector b)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "cons",
        "normalized": "a-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:constructN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements by repeatedly applying the\n generator function to the already constructed part of the vector.\n\u003c/p\u003e\u003cpre\u003e constructN 3 f = let a = f \u003c\u003e ; b = f \u003ca\u003e ; c = f \u003ca,b\u003e in f \u003ca,b,c\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#constructN",
        "fct-type": "function",
        "title": "constructN"
      },
      "index": {
        "description": "Construct vector with elements by repeatedly applying the generator function to the already constructed part of the vector constructN let in",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "constructN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:constructrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements from right to left by\n repeatedly applying the generator function to the already constructed part\n of the vector.\n\u003c/p\u003e\u003cpre\u003e constructrN 3 f = let a = f \u003c\u003e ; b = f\u003ca\u003e ; c = f \u003cb,a\u003e in f \u003cc,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#constructrN",
        "fct-type": "function",
        "title": "constructrN"
      },
      "index": {
        "description": "Construct vector with elements from right to left by repeatedly applying the generator function to the already constructed part of the vector constructrN let in",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "constructrN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:convert",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert different vector types\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e w a",
        "fct-source": "src/Data-Vector-Generic.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "Convert different vector types",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "convert",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "copy",
        "normalized": "MVector(PrimState a)b-\u003eVector b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:create",
      "description": {
        "fct-descr": "\u003cp\u003eExecute the monadic action and freeze the resulting vector.\n\u003c/p\u003e\u003cpre\u003e\n create (do { v \u003c- new 2; write v 0 'a'; write v 1 'b'; return v }) = \u003c\u003ccode\u003ea\u003c/code\u003e,\u003ccode\u003eb\u003c/code\u003e\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(forall s.  ST s (MVector s a)) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "Execute the monadic action and freeze the resulting vector create do new write write return",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "create",
        "normalized": "(a b ST c(MVector c d))-\u003eVector d",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. ST s(MVector s a))-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case an empty vector is returned.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector may contain less than elements in which case an empty vector is returned",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "drop",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop the longest prefix of elements that satisfy the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate without copying",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "dropWhile",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check if the vector contains an element",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "elem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first occurence of the given element or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the vector does not contain the element. This is a specialised\n version of \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Storable.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "Yield Just the index of the first occurence of the given element or Nothing if the vector does not contain the element This is specialised version of findIndex",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "elemIndex",
        "normalized": "a-\u003eVector a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "a-\u003eVector a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of all occurences of the given element in\n ascending order. This is a specialised version of \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Vector Int",
        "fct-source": "src/Data-Vector-Storable.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "Yield the indices of all occurences of the given element in ascending order This is specialised version of findIndices",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "elemIndices",
        "normalized": "a-\u003eVector a-\u003eVector Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "a-\u003eVector a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a",
        "fct-source": "src/Data-Vector-Storable.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "empty",
        "normalized": "",
        "package": "vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:enumFromN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+1\u003c/code\u003e\n etc. This operation is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromN 5 3 = \u003c5,6,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#enumFromN",
        "fct-type": "function",
        "title": "enumFromN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operation is usually more efficient than enumFromTo enumFromN",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "enumFromN",
        "normalized": "a-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From",
        "signature": "a-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:enumFromStepN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc. This operations is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromThenTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromStepN 1 0.1 5 = \u003c1,1.1,1.2,1.3,1.4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#enumFromStepN",
        "fct-type": "function",
        "title": "enumFromStepN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operations is usually more efficient than enumFromThenTo enumFromStepN",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "enumFromStepN",
        "normalized": "a-\u003ea-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From Step",
        "signature": "a-\u003ea-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:enumFromThenTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e with a specific step \u003ccode\u003ez\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#enumFromThenTo",
        "fct-type": "function",
        "title": "enumFromThenTo"
      },
      "index": {
        "description": "Enumerate values from to with specific step WARNING This operation can be very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "enumFromThenTo",
        "normalized": "a-\u003ea-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "From Then To",
        "signature": "a-\u003ea-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Enumerate values from to WARNING This operation can be very inefficient If at all possible use enumFromN instead",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "enumFromTo",
        "normalized": "a-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "From To",
        "signature": "a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "filter",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Vector a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Drop elements that do not satisfy the monadic predicate",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "filterM",
        "normalized": "(a-\u003eb Bool)-\u003eVector a-\u003eb(Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003eVector a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Storable.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "find",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Storable.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of elements satisfying the predicate in ascending\n order.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector Int",
        "fct-source": "src/Data-Vector-Storable.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "Yield the indices of elements satisfying the predicate in ascending order",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "findIndices",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "fold1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "fold1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:fold1M-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#fold1M%27_",
        "fct-type": "function",
        "title": "fold1M'_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator that discards the result",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "fold1M'_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:fold1M_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#fold1M_",
        "fct-type": "function",
        "title": "fold1M_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors that discards the result",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "fold1M_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Monadic fold with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldM-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#foldM%27_",
        "fct-type": "function",
        "title": "foldM'_"
      },
      "index": {
        "description": "Monadic fold with strict accumulator that discards the result",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldM'_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#foldM_",
        "fct-type": "function",
        "title": "foldM_"
      },
      "index": {
        "description": "Monadic fold that discards the result",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldM_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold on non-empty vectors",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Storable.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Storable.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold on non-empty vectors",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "Right fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "foldr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:forM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results. Equvalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (a -\u003e m b) -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector-Storable.html#forM",
        "fct-type": "function",
        "title": "forM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results Equvalent to flip mapM",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "forM",
        "normalized": "Vector a-\u003e(a-\u003eb c)-\u003eb(Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e(a-\u003em b)-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:forM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results. Equivalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (a -\u003e m b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#forM_",
        "fct-type": "function",
        "title": "forM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results Equivalent to flip mapM",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "forM_",
        "normalized": "Vector a-\u003e(a-\u003eb c)-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e(a-\u003em b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:force",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the argument but force it not to retain any extra memory,\n possibly by copying it.\n\u003c/p\u003e\u003cp\u003eThis is especially useful when dealing with slices. For example:\n\u003c/p\u003e\u003cpre\u003e force (slice 0 2 \u003chuge vector\u003e)\n\u003c/pre\u003e\u003cp\u003eHere, the slice retains a reference to the huge vector. Forcing it creates\n a copy of just the elements that belong to the slice and allows the huge\n vector to be garbage collected.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#force",
        "fct-type": "function",
        "title": "force"
      },
      "index": {
        "description": "Yield the argument but force it not to retain any extra memory possibly by copying it This is especially useful when dealing with slices For example force slice huge vector Here the slice retains reference to the huge vector Forcing it creates copy of just the elements that belong to the slice and allows the huge vector to be garbage collected",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "force",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:freeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield an immutable copy of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#freeze",
        "fct-type": "function",
        "title": "freeze"
      },
      "index": {
        "description": "Yield an immutable copy of the mutable vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "freeze",
        "normalized": "MVector(PrimState a)b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a list to a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "[a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "fromList",
        "normalized": "[a]-\u003eVector a",
        "package": "vector",
        "partial": "List",
        "signature": "[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a vector\n\u003c/p\u003e\u003cpre\u003e\n fromListN n xs = \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e [a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Convert the first elements of list to vector fromListN xs fromList take xs",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "fromListN",
        "normalized": "Int-\u003e[a]-\u003eVector a",
        "package": "vector",
        "partial": "List",
        "signature": "Int-\u003e[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the function to\n each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Construct vector of the given length by applying the function to each index",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the monadic\n action to each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e m a) -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Construct vector of the given length by applying the monadic action to each index",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "generateM",
        "normalized": "Int-\u003e(Int-\u003ea b)-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003em a)-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "head",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:headM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#headM",
        "fct-type": "function",
        "title": "headM"
      },
      "index": {
        "description": "First element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "headM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:ifilter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate which is applied to\n values and their indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#ifilter",
        "fct-type": "function",
        "title": "ifilter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate which is applied to values and their indices",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "ifilter",
        "normalized": "(Int-\u003ea-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold function applied to each element and its index",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:ifoldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator (function applied to each element\n and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#ifoldl%27",
        "fct-type": "function",
        "title": "ifoldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "ifoldl'",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Storable.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Right fold function applied to each element and its index",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:ifoldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with strict accumulator (function applied to each\n element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Storable.html#ifoldr%27",
        "fct-type": "function",
        "title": "ifoldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "ifoldr'",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply a function to every element of a vector and its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of vector and its index",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:indexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad.\n\u003c/p\u003e\u003cp\u003eThe monad allows operations to be strict in the vector when necessary.\n Suppose vector copying is implemented like this:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... write mv i (v ! i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, \u003ccode\u003ev ! i\u003c/code\u003e would not be evaluated which means that \u003ccode\u003emv\u003c/code\u003e\n would unnecessarily retain a reference to \u003ccode\u003ev\u003c/code\u003e in each element written.\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e, copying can be implemented like this instead:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... do\n                   x \u003c- indexM v i\n                   write mv i x\n\u003c/pre\u003e\u003cp\u003eHere, no references to \u003ccode\u003ev\u003c/code\u003e are retained because indexing (but \u003cem\u003enot\u003c/em\u003e the\n elements) is evaluated eagerly.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#indexM",
        "fct-type": "function",
        "title": "indexM"
      },
      "index": {
        "description": "Indexing in monad The monad allows operations to be strict in the vector when necessary Suppose vector copying is implemented like this copy mv write mv For lazy vectors would not be evaluated which means that mv would unnecessarily retain reference to in each element written With indexM copying can be implemented like this instead copy mv do indexM write mv Here no references to are retained because indexing but not the elements is evaluated eagerly",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "indexM",
        "normalized": "Vector a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "init",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function times to value Zeroth element is original value",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "iterateN",
        "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with a function that also takes the\n elements' indices.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
        "fct-source": "src/Data-Vector-Storable.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "min Zip two vectors with function that also takes the elements indices",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:izipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors and their indices with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d",
        "fct-source": "src/Data-Vector-Storable.html#izipWith3",
        "fct-type": "function",
        "title": "izipWith3"
      },
      "index": {
        "description": "Zip three vectors and their indices with the given function",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "izipWith3",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:izipWith4",
      "description": {
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e",
        "fct-source": "src/Data-Vector-Storable.html#izipWith4",
        "fct-type": "function",
        "title": "izipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "izipWith4",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:izipWith5",
      "description": {
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f",
        "fct-source": "src/Data-Vector-Storable.html#izipWith5",
        "fct-type": "function",
        "title": "izipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "izipWith5",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:izipWith6",
      "description": {
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector g",
        "fct-source": "src/Data-Vector-Storable.html#izipWith6",
        "fct-type": "function",
        "title": "izipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "izipWith6",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "last",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:lastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#lastM",
        "fct-type": "function",
        "title": "lastM"
      },
      "index": {
        "description": "Last element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "lastM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the length of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Storable.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Yield the length of the vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "length",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Map a function over a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Vector a -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector-Storable.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb(Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eVector a-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:maxIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Storable.html#maxIndex",
        "fct-type": "function",
        "title": "maxIndex"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "maxIndex",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:maxIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Storable.html#maxIndexBy",
        "fct-type": "function",
        "title": "maxIndexBy"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "maxIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Yield the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "maximum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:maximumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#maximumBy",
        "fct-type": "function",
        "title": "maximumBy"
      },
      "index": {
        "description": "Yield the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "maximumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:minIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Storable.html#minIndex",
        "fct-type": "function",
        "title": "minIndex"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "minIndex",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:minIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Storable.html#minIndexBy",
        "fct-type": "function",
        "title": "minIndexBy"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "minIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Yield the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "minimum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:minimumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#minimumBy",
        "fct-type": "function",
        "title": "minimumBy"
      },
      "index": {
        "description": "Yield the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "minimumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:modify",
      "description": {
        "fct-descr": "\u003cp\u003eApply a destructive operation to a vector. The operation will be\n performed in place if it is safe to do so and will modify a copy of the\n vector otherwise.\n\u003c/p\u003e\u003cpre\u003e\n modify (\\v -\u003e write v 0 'x') (\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e 3 'a') = \u003c'x','a','a'\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(forall s.  MVector s a -\u003e ST s ()) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#modify",
        "fct-type": "function",
        "title": "modify"
      },
      "index": {
        "description": "Apply destructive operation to vector The operation will be performed in place if it is safe to do so and will modify copy of the vector otherwise modify write replicate",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "modify",
        "normalized": "(a b MVector c d-\u003eST c())-\u003eVector d-\u003eVector d",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. MVector s a-\u003eST s())-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector does not contain an element (inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Check if the vector does not contain an element inverse of elem",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "notElem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "Elem",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a vector if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether vector if empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "null",
        "normalized": "Vector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Storable.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "Check if any element is True",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "or",
        "normalized": "Vector Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't. The\n relative order of the elements is preserved at the cost of a sometimes\n reduced performance compared to \u003ccode\u003e\u003ca\u003eunstablePartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The relative order of the elements is preserved at the cost of sometimes reduced performance compared to unstablePartition",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "partition",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan\n\u003c/p\u003e\u003cpre\u003e\n postscanl f z = \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003epostscanl (+) 0 \u003c1,2,3,4\u003e = \u003c1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Scan postscanl tail scanl Example postscanl",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "postscanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Scan with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "postscanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:postscanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#postscanr",
        "fct-type": "function",
        "title": "postscanr"
      },
      "index": {
        "description": "Right-to-left scan",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "postscanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:postscanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#postscanr%27",
        "fct-type": "function",
        "title": "postscanr'"
      },
      "index": {
        "description": "Right-to-left scan with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "postscanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanl f z = \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003eprescanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prescan prescanl init scanl Example prescanl",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "prescanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prescan with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "prescanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:prescanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanr f z = \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eprescanl\u003c/a\u003e\u003c/code\u003e (flip f) z . \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#prescanr",
        "fct-type": "function",
        "title": "prescanr"
      },
      "index": {
        "description": "Right-to-left prescan prescanr reverse prescanl flip reverse",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "prescanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:prescanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#prescanr%27",
        "fct-type": "function",
        "title": "prescanr'"
      },
      "index": {
        "description": "Right-to-left prescan with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "prescanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:product",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the produce of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#product",
        "fct-type": "function",
        "title": "product"
      },
      "index": {
        "description": "Compute the produce of the elements",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "product",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Vector of the given length with the same value in each position\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Vector of the given length with the same value in each position",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Execute the monadic action the given number of times and store the\n results in a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute the monadic action the given number of times and store the results in vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Reverse a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "reverse",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan\n\u003c/p\u003e\u003cpre\u003e scanl f z \u003cx1,...,xn\u003e = \u003cy1,...,y(n+1)\u003e\n   where y1 = z\n         yi = f y(i-1) x(i-1)\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003escanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan scanl x1 xn y1 where y1 yi i-1 i-1 Example scanl",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "scanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector\n\u003c/p\u003e\u003cpre\u003e scanl f \u003cx1,...,xn\u003e = \u003cy1,...,yn\u003e\n   where y1 = x1\n         yi = f y(i-1) xi\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty vector scanl x1 xn y1 yn where y1 x1 yi i-1 xi",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "scanl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "scanl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "scanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:scanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#scanr%27",
        "fct-type": "function",
        "title": "scanr'"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "scanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "scanr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:scanr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector with a strict\n accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#scanr1%27",
        "fct-type": "function",
        "title": "scanr1'"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "scanr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Vector with exactly one element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Vector with exactly one element",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "singleton",
        "normalized": "a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying it. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield slice of the vector without copying it The vector must contain at least elements",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "snoc",
        "normalized": "Vector a-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that satisfy\n the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "span",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements paired with the remainder without copying.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e n v\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n v, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n v)\u003c/code\u003e\n but slightly more efficient.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "Yield the first elements paired with the remainder without copying Note that splitAt is equivalent to take drop but slightly more efficient",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "splitAt",
        "normalized": "Int-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the sum of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "Compute the sum of the elements",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "sum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "tail",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield at the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case it is returned unchanged.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "Yield at the first elements without copying The vector may contain less than elements in which case it is returned unchanged",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "take",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the longest prefix of elements satisfying the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Yield the longest prefix of elements satisfying the predicate without copying",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "takeWhile",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:thaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a mutable copy of the immutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable.html#thaw",
        "fct-type": "function",
        "title": "thaw"
      },
      "index": {
        "description": "Yield mutable copy of the immutable vector",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "thaw",
        "normalized": "Vector a-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a vector to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e [a]",
        "fct-source": "src/Data-Vector-Storable.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to list",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "toList",
        "normalized": "Vector a-\u003e[a]",
        "package": "vector",
        "partial": "List",
        "signature": "Vector a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector by repeatedly applying the generator function\n to a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the next element and the\n new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\n -\u003e if n == 0 then Nothing else Just (n,n-1)) 10\n  = \u003c10,9,8,7,6,5,4,3,2,1\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Construct vector by repeatedly applying the generator function to seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldr if then Nothing else Just n-1",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with at most \u003ccode\u003en\u003c/code\u003e by repeatedly applying the\n generator function to the a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the\n next element and the new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldrN 3 (\\n -\u003e Just (n,n-1)) 10 = \u003c10,9,8\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Construct vector with at most by repeatedly applying the generator function to the seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldrN Just n-1",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeAccum",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccum\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e [(Int, b)] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeAccum",
        "fct-type": "function",
        "title": "unsafeAccum"
      },
      "index": {
        "description": "Same as accum but without bounds checking",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeAccum",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a",
        "package": "vector",
        "partial": "Accum",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeAccumulate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e Vector Int -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeAccumulate_",
        "fct-type": "function",
        "title": "unsafeAccumulate_"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeAccumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeBackpermute",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ebackpermute\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeBackpermute",
        "fct-type": "function",
        "title": "unsafeBackpermute"
      },
      "index": {
        "description": "Same as backpermute but without bounds checking",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeBackpermute",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a",
        "package": "vector",
        "partial": "Backpermute",
        "signature": "Vector a-\u003eVector Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeCast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely cast a vector from one element type to another.\n The operation just changes the type of the underlying pointer and does not\n modify the elements.\n\u003c/p\u003e\u003cp\u003eThe resulting vector contains as many elements as can fit into the\n underlying memory block.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Storable.html#unsafeCast",
        "fct-type": "function",
        "title": "unsafeCast"
      },
      "index": {
        "description": "Unsafely cast vector from one element type to another The operation just changes the type of the underlying pointer and does not modify the elements The resulting vector contains as many elements as can fit into the underlying memory block",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeCast",
        "normalized": "Vector a-\u003eVector b",
        "package": "vector",
        "partial": "Cast",
        "signature": "Vector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#unsafeCopy",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length This is not checked",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeCopy",
        "normalized": "MVector(PrimState a)b-\u003eVector b-\u003ea()",
        "package": "vector",
        "partial": "Copy",
        "signature": "MVector(PrimState m)a-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeDrop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector\n must contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe convert a mutable vector to an immutable one without\n copying. The mutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#unsafeFreeze",
        "fct-type": "function",
        "title": "unsafeFreeze"
      },
      "index": {
        "description": "Unsafe convert mutable vector to an immutable one without copying The mutable vector may not be used after this operation",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeFreeze",
        "normalized": "MVector(PrimState a)b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "Freeze",
        "signature": "MVector(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeFromForeignPtr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Create a vector from a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e with an offset and a length.\n\u003c/p\u003e\u003cp\u003eThe data may not be modified through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e afterwards.\n\u003c/p\u003e\u003cp\u003eIf your offset is 0 it is more efficient to use \u003ccode\u003e\u003ca\u003eunsafeFromForeignPtr0\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "ForeignPtr a-\u003e Int-\u003e Int-\u003e Vector a",
        "fct-type": "function",
        "title": "unsafeFromForeignPtr"
      },
      "index": {
        "description": "Create vector from ForeignPtr with an offset and length The data may not be modified through the ForeignPtr afterwards If your offset is it is more efficient to use unsafeFromForeignPtr0",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeFromForeignPtr",
        "normalized": "ForeignPtr a-\u003eInt-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From Foreign Ptr",
        "signature": "ForeignPtr a-\u003eInt-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeFromForeignPtr0",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Create a vector from a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e and a length.\n\u003c/p\u003e\u003cp\u003eIt is assumed the pointer points directly to the data (no offset).\n Use \u003ccode\u003e\u003ca\u003eunsafeFromForeignPtr\u003c/a\u003e\u003c/code\u003e if you need to specify an offset.\n\u003c/p\u003e\u003cp\u003eThe data may not be modified through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e afterwards.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "ForeignPtr a-\u003e Int-\u003e Vector a",
        "fct-type": "function",
        "title": "unsafeFromForeignPtr0"
      },
      "index": {
        "description": "Create vector from ForeignPtr and length It is assumed the pointer points directly to the data no offset Use unsafeFromForeignPtr if you need to specify an offset The data may not be modified through the ForeignPtr afterwards",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeFromForeignPtr0",
        "normalized": "ForeignPtr a-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From Foreign Ptr",
        "signature": "ForeignPtr a-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeHead",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeHead",
        "fct-type": "function",
        "title": "unsafeHead"
      },
      "index": {
        "description": "First element without checking if the vector is empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeHead",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "Head",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeHeadM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeHeadM",
        "fct-type": "function",
        "title": "unsafeHeadM"
      },
      "index": {
        "description": "First element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeHeadM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "Head",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe indexing without bounds checking\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeIndex",
        "fct-type": "function",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Unsafe indexing without bounds checking",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeIndex",
        "normalized": "Vector a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeIndexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad without bounds checks. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeIndexM",
        "fct-type": "function",
        "title": "unsafeIndexM"
      },
      "index": {
        "description": "Indexing in monad without bounds checks See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeIndexM",
        "normalized": "Vector a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeInit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeInit",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "Init",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeLast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeLast",
        "fct-type": "function",
        "title": "unsafeLast"
      },
      "index": {
        "description": "Last element without checking if the vector is empty",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeLast",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "Last",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeLastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeLastM",
        "fct-type": "function",
        "title": "unsafeLastM"
      },
      "index": {
        "description": "Last element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeLastM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "Last",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield slice of the vector without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeTail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeTail",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "Tail",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeTake",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector must\n contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "Yield the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeTake",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely convert an immutable vector to a mutable one without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Storable.html#unsafeThaw",
        "fct-type": "function",
        "title": "unsafeThaw"
      },
      "index": {
        "description": "Unsafely convert an immutable vector to mutable one without copying The immutable vector may not be used after this operation",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeThaw",
        "normalized": "Vector a-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "Thaw",
        "signature": "Vector a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeToForeignPtr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the underlying \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e together with the offset to the\n data and its length. The data may not be modified through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (ForeignPtr a, Int, Int)",
        "fct-source": "src/Data-Vector-Storable.html#unsafeToForeignPtr",
        "fct-type": "function",
        "title": "unsafeToForeignPtr"
      },
      "index": {
        "description": "Yield the underlying ForeignPtr together with the offset to the data and its length The data may not be modified through the ForeignPtr",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeToForeignPtr",
        "normalized": "Vector a-\u003e(ForeignPtr a,Int,Int)",
        "package": "vector",
        "partial": "To Foreign Ptr",
        "signature": "Vector a-\u003e(ForeignPtr a,Int,Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeToForeignPtr0",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the underlying \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e together with its length.\n\u003c/p\u003e\u003cp\u003eYou can assume the pointer points directly to the data (no offset).\n\u003c/p\u003e\u003cp\u003eThe data may not be modified through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (ForeignPtr a, Int)",
        "fct-source": "src/Data-Vector-Storable.html#unsafeToForeignPtr0",
        "fct-type": "function",
        "title": "unsafeToForeignPtr0"
      },
      "index": {
        "description": "Yield the underlying ForeignPtr together with its length You can assume the pointer points directly to the data no offset The data may not be modified through the ForeignPtr",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeToForeignPtr0",
        "normalized": "Vector a-\u003e(ForeignPtr a,Int)",
        "package": "vector",
        "partial": "To Foreign Ptr",
        "signature": "Vector a-\u003e(ForeignPtr a,Int)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeUpd",
      "description": {
        "fct-descr": "\u003cp\u003eSame as (\u003ccode\u003e\u003ca\u003e//\u003c/a\u003e\u003c/code\u003e) but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e [(Int, a)] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeUpd",
        "fct-type": "function",
        "title": "unsafeUpd"
      },
      "index": {
        "description": "Same as but without bounds checking",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeUpd",
        "normalized": "Vector a-\u003e[(Int,a)]-\u003eVector a",
        "package": "vector",
        "partial": "Upd",
        "signature": "Vector a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeUpdate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Storable.html#unsafeUpdate_",
        "fct-type": "function",
        "title": "unsafeUpdate_"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeUpdate_",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Update",
        "signature": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unsafeWith",
      "description": {
        "fct-descr": "\u003cp\u003ePass a pointer to the vector's data to the IO action. The data may not be\n modified through the 'Ptr.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (Ptr a -\u003e IO b) -\u003e IO b",
        "fct-source": "src/Data-Vector-Storable.html#unsafeWith",
        "fct-type": "function",
        "title": "unsafeWith"
      },
      "index": {
        "description": "Pass pointer to the vector data to the IO action The data may not be modified through the Ptr",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unsafeWith",
        "normalized": "Vector a-\u003e(Ptr a-\u003eIO b)-\u003eIO b",
        "package": "vector",
        "partial": "With",
        "signature": "Vector a-\u003e(Ptr a-\u003eIO b)-\u003eIO b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:unstablePartition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't.\n The order of the elements is not preserved but the operation is often\n faster than \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Storable.html#unstablePartition",
        "fct-type": "function",
        "title": "unstablePartition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The order of the elements is not preserved but the operation is often faster than partition",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "unstablePartition",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "Partition",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:update_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003ea\u003c/code\u003e from the value vector, replace the element of the\n initial vector at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update_ \u003c5,9,2,7\u003e  \u003c2,0,2\u003e \u003c1,3,8\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e Vector Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "update_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the value vector replace the element of the initial vector at position by update",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "update_",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
        "fct-source": "src/Data-Vector-Storable.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "min Zip two vectors with the given function",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:zipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d",
        "fct-source": "src/Data-Vector-Storable.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "Zip three vectors with the given function",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "zipWith3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e",
        "fct-source": "src/Data-Vector-Storable.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "zipWith4",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f",
        "fct-source": "src/Data-Vector-Storable.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "zipWith5",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector g",
        "fct-source": "src/Data-Vector-Storable.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "zipWith6",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and yield a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Vector a -\u003e Vector b -\u003e m (Vector c)",
        "fct-source": "src/Data-Vector-Storable.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and yield vector of results",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eVector a-\u003eVector b-\u003ec(Vector d)",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eVector a-\u003eVector b-\u003em(Vector c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Storable.html#v:zipWithM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Storable",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Vector a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Storable.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and ignore the results",
        "hierarchy": "Data Vector Storable",
        "module": "Data.Vector.Storable",
        "name": "zipWithM_",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eVector a-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eVector a-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable adaptive unboxed vectors\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html",
        "fct-type": "module",
        "title": "Mutable"
      },
      "index": {
        "description": "Mutable adaptive unboxed vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "Mutable",
        "normalized": "",
        "package": "vector",
        "partial": "Mutable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#t:IOVector",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Unboxed-Base.html#IOVector",
        "fct-type": "type",
        "title": "IOVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "IOVector",
        "normalized": "",
        "package": "vector",
        "partial": "IOVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#t:MVector",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector",
        "fct-type": "function",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#t:STVector",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "type",
        "fct-source": "src/Data-Vector-Unboxed-Base.html#STVector",
        "fct-type": "type",
        "title": "STVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "STVector",
        "normalized": "",
        "package": "vector",
        "partial": "STVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#t:Unbox",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Unboxed-Base.html#Unbox",
        "fct-type": "class",
        "title": "Unbox"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "Unbox",
        "normalized": "",
        "package": "vector",
        "partial": "Unbox",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:clear",
      "description": {
        "fct-descr": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed vectors. \n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#clear",
        "fct-type": "function",
        "title": "clear"
      },
      "index": {
        "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "clear",
        "normalized": "MVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:clone",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a copy of a mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#clone",
        "fct-type": "function",
        "title": "clone"
      },
      "index": {
        "description": "Create copy of mutable vector",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "clone",
        "normalized": "MVector(PrimState a)b-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "copy",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:drop",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "drop",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:grow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#grow",
        "fct-type": "function",
        "title": "grow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "grow",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:init",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "init",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003eLength of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Length of the mutable vector",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "length",
        "normalized": "MVector a b-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:move",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003ecopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e MVector (PrimState m) a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#move",
        "fct-type": "function",
        "title": "move"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length If the vectors do not overlap then this is equivalent to copy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "move",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:new",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#new",
        "fct-type": "function",
        "title": "new"
      },
      "index": {
        "description": "Create mutable vector of the given length",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "new",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eCheck whether the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Check whether the vector is empty",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "null",
        "normalized": "MVector a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:overlaps",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#overlaps",
        "fct-type": "function",
        "title": "overlaps"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "overlaps",
        "normalized": "MVector a b-\u003eMVector a b-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:read",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#read",
        "fct-type": "function",
        "title": "read"
      },
      "index": {
        "description": "Yield the element at the given position",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "read",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with an initial value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with an initial value",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with values produced by repeatedly executing the monadic action.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Create mutable vector of the given length if the length is negative and fill it with values produced by repeatedly executing the monadic action",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:set",
      "description": {
        "fct-descr": "\u003cp\u003eSet all elements of the vector to the given value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#set",
        "fct-type": "function",
        "title": "set"
      },
      "index": {
        "description": "Set all elements of the vector to the given value",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "set",
        "normalized": "MVector(PrimState a)b-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#slice",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:splitAt",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e (MVector s a, MVector s a)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "splitAt",
        "normalized": "Int-\u003eMVector a b-\u003e(MVector a b,MVector a b)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003eMVector s a-\u003e(MVector s a,MVector s a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:swap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#swap",
        "fct-type": "function",
        "title": "swap"
      },
      "index": {
        "description": "Swap the elements at the given positions",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "swap",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eInt-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:tail",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "tail",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:take",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "take",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a-\u003e MVector (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy vector The two vectors must have the same length and may not overlap This is not checked",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeCopy",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "Copy",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeDrop",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeGrow",
      "description": {
        "fct-descr": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeGrow",
        "fct-type": "function",
        "title": "unsafeGrow"
      },
      "index": {
        "description": "Grow vector by the given number of elements The number must be positive but this is not checked",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeGrow",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "Grow",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeInit",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeInit",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Init",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeMove",
      "description": {
        "fct-descr": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length, but this is not checked.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003eunsafeCopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a-\u003e MVector (PrimState m) a-\u003e m ()",
        "fct-type": "function",
        "title": "unsafeMove"
      },
      "index": {
        "description": "Move the contents of vector The two vectors must have the same length but this is not checked If the vectors do not overlap then this is equivalent to unsafeCopy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeMove",
        "normalized": "MVector(PrimState a)b-\u003eMVector(PrimState a)b-\u003ea()",
        "package": "vector",
        "partial": "Move",
        "signature": "MVector(PrimState m)a-\u003eMVector(PrimState m)a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeNew",
      "description": {
        "fct-descr": "\u003cp\u003eCreate a mutable vector of the given length. The length is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeNew",
        "fct-type": "function",
        "title": "unsafeNew"
      },
      "index": {
        "description": "Create mutable vector of the given length The length is not checked",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeNew",
        "normalized": "Int-\u003ea(MVector(PrimState a)b)",
        "package": "vector",
        "partial": "New",
        "signature": "Int-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeRead",
      "description": {
        "fct-descr": "\u003cp\u003eYield the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeRead",
        "fct-type": "function",
        "title": "unsafeRead"
      },
      "index": {
        "description": "Yield the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeRead",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003ea b",
        "package": "vector",
        "partial": "Read",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003eYield a part of the mutable vector without copying it. No bounds checks\n are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e MVector s a-\u003e MVector s a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield part of the mutable vector without copying it No bounds checks are performed",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeSwap",
      "description": {
        "fct-descr": "\u003cp\u003eSwap the elements at the given positions. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeSwap",
        "fct-type": "function",
        "title": "unsafeSwap"
      },
      "index": {
        "description": "Swap the elements at the given positions No bounds checks are performed",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeSwap",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eInt-\u003ea()",
        "package": "vector",
        "partial": "Swap",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003eInt-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeTail",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeTail",
        "normalized": "MVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Tail",
        "signature": "MVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeTake",
      "description": {
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e MVector s a -\u003e MVector s a",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeTake",
        "normalized": "Int-\u003eMVector a b-\u003eMVector a b",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003eMVector s a-\u003eMVector s a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unsafeWrite",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unsafeWrite",
        "fct-type": "function",
        "title": "unsafeWrite"
      },
      "index": {
        "description": "Replace the element at the given position No bounds checks are performed",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unsafeWrite",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "Write",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 2 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s (a, b) -\u003e (MVector s a, MVector s b)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unzip",
        "normalized": "MVector a(b,c)-\u003e(MVector a b,MVector a c)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s(a,b)-\u003e(MVector s a,MVector s b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unzip3",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 3 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s (a, b, c) -\u003e (MVector s a, MVector s b, MVector s c)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unzip3",
        "fct-type": "function",
        "title": "unzip3"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unzip3",
        "normalized": "MVector a(b,c,d)-\u003e(MVector a b,MVector a c,MVector a d)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s(a,b,c)-\u003e(MVector s a,MVector s b,MVector s c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unzip4",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 4 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s (a, b, c, d) -\u003e (MVector s a, MVector s b, MVector s c, MVector s d)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unzip4",
        "fct-type": "function",
        "title": "unzip4"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unzip4",
        "normalized": "MVector a(b,c,d,e)-\u003e(MVector a b,MVector a c,MVector a d,MVector a e)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s(a,b,c,d)-\u003e(MVector s a,MVector s b,MVector s c,MVector s d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unzip5",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 5 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s (a, b, c, d, e) -\u003e (MVector s a, MVector s b, MVector s c, MVector s d, MVector s e)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unzip5",
        "fct-type": "function",
        "title": "unzip5"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unzip5",
        "normalized": "MVector a(b,c,d,e,f)-\u003e(MVector a b,MVector a c,MVector a d,MVector a e,MVector a f)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s(a,b,c,d,e)-\u003e(MVector s a,MVector s b,MVector s c,MVector s d,MVector s e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:unzip6",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 6 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s (a, b, c, d, e, f) -\u003e (MVector s a, MVector s b, MVector s c, MVector s d, MVector s e, MVector s f)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#unzip6",
        "fct-type": "function",
        "title": "unzip6"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "unzip6",
        "normalized": "MVector a(b,c,d,e,f,g)-\u003e(MVector a b,MVector a c,MVector a d,MVector a e,MVector a f,MVector a g)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s(a,b,c,d,e,f)-\u003e(MVector s a,MVector s b,MVector s c,MVector s d,MVector s e,MVector s f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:write",
      "description": {
        "fct-descr": "\u003cp\u003eReplace the element at the given position.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#write",
        "fct-type": "function",
        "title": "write"
      },
      "index": {
        "description": "Replace the element at the given position",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "write",
        "normalized": "MVector(PrimState a)b-\u003eInt-\u003eb-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eInt-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 2 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s b -\u003e MVector s (a, b)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "zip",
        "normalized": "MVector a b-\u003eMVector a c-\u003eMVector a(b,c)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s b-\u003eMVector s(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:zip3",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 3 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s b -\u003e MVector s c -\u003e MVector s (a, b, c)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#zip3",
        "fct-type": "function",
        "title": "zip3"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "zip3",
        "normalized": "MVector a b-\u003eMVector a c-\u003eMVector a d-\u003eMVector a(b,c,d)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s b-\u003eMVector s c-\u003eMVector s(a,b,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:zip4",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 4 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s b -\u003e MVector s c -\u003e MVector s d -\u003e MVector s (a, b, c, d)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#zip4",
        "fct-type": "function",
        "title": "zip4"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "zip4",
        "normalized": "MVector a b-\u003eMVector a c-\u003eMVector a d-\u003eMVector a e-\u003eMVector a(b,c,d,e)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s b-\u003eMVector s c-\u003eMVector s d-\u003eMVector s(a,b,c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:zip5",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 5 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s b -\u003e MVector s c -\u003e MVector s d -\u003e MVector s e -\u003e MVector s (a, b, c, d, e)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#zip5",
        "fct-type": "function",
        "title": "zip5"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "zip5",
        "normalized": "MVector a b-\u003eMVector a c-\u003eMVector a d-\u003eMVector a e-\u003eMVector a f-\u003eMVector a(b,c,d,e,f)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s b-\u003eMVector s c-\u003eMVector s d-\u003eMVector s e-\u003eMVector s(a,b,c,d,e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html#v:zip6",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 6 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed.Mutable",
        "fct-package": "vector",
        "fct-signature": "MVector s a -\u003e MVector s b -\u003e MVector s c -\u003e MVector s d -\u003e MVector s e -\u003e MVector s f -\u003e MVector s (a, b, c, d, e, f)",
        "fct-source": "src/Data-Vector-Unboxed-Mutable.html#zip6",
        "fct-type": "function",
        "title": "zip6"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed Mutable",
        "module": "Data.Vector.Unboxed.Mutable",
        "name": "zip6",
        "normalized": "MVector a b-\u003eMVector a c-\u003eMVector a d-\u003eMVector a e-\u003eMVector a f-\u003eMVector a g-\u003eMVector a(b,c,d,e,f,g)",
        "package": "vector",
        "partial": "",
        "signature": "MVector s a-\u003eMVector s b-\u003eMVector s c-\u003eMVector s d-\u003eMVector s e-\u003eMVector s f-\u003eMVector s(a,b,c,d,e,f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAdaptive unboxed vectors. The implementation is based on type families\n and picks an efficient, specialised representation for every element type.\n In particular, unboxed vectors of pairs are represented as pairs of unboxed\n vectors.\n\u003c/p\u003e\u003cp\u003eImplementing unboxed vectors for new data types can be very easy. Here is\n how the library does this for \u003ccode\u003eComplex\u003c/code\u003e by simply wrapping vectors of\n pairs.\n\u003c/p\u003e\u003cpre\u003e\n newtype instance \u003ccode\u003e\u003ca\u003eMVector\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003eComplex\u003c/code\u003e a) = MV_Complex (\u003ccode\u003e\u003ca\u003eMVector\u003c/a\u003e\u003c/code\u003e s (a,a))\n newtype instance \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e    (\u003ccode\u003eComplex\u003c/code\u003e a) = V_Complex  (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e    (a,a))\n\ninstance (\u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eUnbox\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eMVector\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMVector\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003eComplex\u003c/code\u003e a) where\n   {-# INLINE basicLength #-}\n   basicLength (MV_Complex v) = \u003ccode\u003e\u003ca\u003ebasicLength\u003c/a\u003e\u003c/code\u003e v\n   ...\n\ninstance (\u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eUnbox\u003c/a\u003e\u003c/code\u003e a) =\u003e Data.Vector.Generic.Vector \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003eComplex\u003c/code\u003e a) where\n   {-# INLINE basicLength #-}\n   basicLength (V_Complex v) = Data.Vector.Generic.basicLength v\n   ...\n\ninstance (\u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eUnbox\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eUnbox\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003eComplex\u003c/code\u003e a)\n\u003c/pre\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector-Unboxed.html",
        "fct-type": "module",
        "title": "Unboxed"
      },
      "index": {
        "description": "Adaptive unboxed vectors The implementation is based on type families and picks an efficient specialised representation for every element type In particular unboxed vectors of pairs are represented as pairs of unboxed vectors Implementing unboxed vectors for new data types can be very easy Here is how the library does this for Complex by simply wrapping vectors of pairs newtype instance MVector Complex MV Complex MVector newtype instance Vector Complex Complex Vector instance RealFloat Unbox MVector MVector Complex where INLINE basicLength basicLength MV Complex basicLength instance RealFloat Unbox Data.Vector.Generic.Vector Vector Complex where INLINE basicLength basicLength Complex Data.Vector.Generic.basicLength instance RealFloat Unbox Unbox Complex",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "Unboxed",
        "normalized": "",
        "package": "vector",
        "partial": "Unboxed",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#t:MVector",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "MVector",
        "fct-type": "function",
        "title": "MVector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#t:Unbox",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "class",
        "fct-source": "src/Data-Vector-Unboxed-Base.html#Unbox",
        "fct-type": "class",
        "title": "Unbox"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "Unbox",
        "normalized": "",
        "package": "vector",
        "partial": "Unbox",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#t:Vector",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector",
        "fct-type": "function",
        "title": "Vector"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "Vector",
        "normalized": "",
        "package": "vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Indexing",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "(!) !",
        "normalized": "Vector a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Safe indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Unboxed.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Safe indexing",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "(!?) !?",
        "normalized": "Vector a-\u003eInt-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e Concatenate two vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "(++) ++",
        "normalized": "Vector a-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:-47--47-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the list, replace the vector\n element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003c5,9,2,7\u003e // [(2,1),(0,3),(2,8)] = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e [(Int, a)]-\u003e Vector a",
        "fct-type": "function",
        "title": "(//)"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "(//) //",
        "normalized": "Vector a-\u003e[(Int,a)]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:accum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the list, replace the vector element\n \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accum (+) \u003c5,9,2\u003e [(2,4),(1,6),(0,3),(1,7)] = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e [(Int, b)]-\u003e Vector a",
        "fct-type": "function",
        "title": "accum"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by accum",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "accum",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:accumulate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the vector of pairs, replace the vector\n element \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate (+) \u003c5,9,2\u003e \u003c(2,4),(1,6),(0,3),(1,7)\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e Vector (Int, b)-\u003e Vector a",
        "fct-type": "function",
        "title": "accumulate"
      },
      "index": {
        "description": "For each pair from the vector of pairs replace the vector element at position by accumulate",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "accumulate",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector(Int,b)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector(Int,b)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:accumulate_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003eb\u003c/code\u003e from the the value vector,\n replace the element of the initial vector at\n position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate_ (+) \u003c5,9,2\u003e \u003c2,1,0,1\u003e \u003c4,6,3,7\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e provides the same functionality and is usually more\n convenient.\n\u003c/p\u003e\u003cpre\u003e\n accumulate_ f as is bs = \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e f as (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is bs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e Vector Int-\u003e Vector b-\u003e Vector a",
        "fct-type": "function",
        "title": "accumulate_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the the value vector replace the element of the initial vector at position by accumulate The function accumulate provides the same functionality and is usually more convenient accumulate as is bs accumulate as zip is bs",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "accumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Check if all elements satisfy the predicate",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements are \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "Check if all elements are True",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "and",
        "normalized": "Vector Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Check if any element satisfies the predicate",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:backpermute",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the vector obtained by replacing each element \u003ccode\u003ei\u003c/code\u003e of the\n index vector by \u003ccode\u003exs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003ei\u003c/code\u003e. This is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (xs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e) is\u003c/code\u003e but is\n often much more efficient.\n\u003c/p\u003e\u003cpre\u003e backpermute \u003ca,b,c,d\u003e \u003c0,3,2,3,1,0\u003e = \u003ca,d,c,d,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#backpermute",
        "fct-type": "function",
        "title": "backpermute"
      },
      "index": {
        "description": "Yield the vector obtained by replacing each element of the index vector by xs This is equivalent to map xs is but is often much more efficient backpermute",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "backpermute",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that do not\n satisfy the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that do not satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "break",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate all vectors in the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "[Vector a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate all vectors in the list",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "concat",
        "normalized": "[Vector a]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "[Vector a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a vector and concatenate the results.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Vector b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over vector and concatenate the results",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "concatMap",
        "normalized": "(a-\u003eVector b)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "Map",
        "signature": "(a-\u003eVector b)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "cons",
        "normalized": "a-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:constructN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements by repeatedly applying the\n generator function to the already constructed part of the vector.\n\u003c/p\u003e\u003cpre\u003e constructN 3 f = let a = f \u003c\u003e ; b = f \u003ca\u003e ; c = f \u003ca,b\u003e in f \u003ca,b,c\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#constructN",
        "fct-type": "function",
        "title": "constructN"
      },
      "index": {
        "description": "Construct vector with elements by repeatedly applying the generator function to the already constructed part of the vector constructN let in",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "constructN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:constructrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements from right to left by\n repeatedly applying the generator function to the already constructed part\n of the vector.\n\u003c/p\u003e\u003cpre\u003e constructrN 3 f = let a = f \u003c\u003e ; b = f\u003ca\u003e ; c = f \u003cb,a\u003e in f \u003cc,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#constructrN",
        "fct-type": "function",
        "title": "constructrN"
      },
      "index": {
        "description": "Construct vector with elements from right to left by repeatedly applying the generator function to the already constructed part of the vector constructrN let in",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "constructrN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:convert",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert different vector types\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e w a",
        "fct-source": "src/Data-Vector-Generic.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "Convert different vector types",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "convert",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "copy",
        "normalized": "MVector(PrimState a)b-\u003eVector b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:create",
      "description": {
        "fct-descr": "\u003cp\u003eExecute the monadic action and freeze the resulting vector.\n\u003c/p\u003e\u003cpre\u003e\n create (do { v \u003c- new 2; write v 0 'a'; write v 1 'b'; return v }) = \u003c\u003ccode\u003ea\u003c/code\u003e,\u003ccode\u003eb\u003c/code\u003e\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(forall s.  ST s (MVector s a)) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "Execute the monadic action and freeze the resulting vector create do new write write return",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "create",
        "normalized": "(a b ST c(MVector c d))-\u003eVector d",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. ST s(MVector s a))-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case an empty vector is returned.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector may contain less than elements in which case an empty vector is returned",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "drop",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop the longest prefix of elements that satisfy the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate without copying",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "dropWhile",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check if the vector contains an element",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "elem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first occurence of the given element or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the vector does not contain the element. This is a specialised\n version of \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Unboxed.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "Yield Just the index of the first occurence of the given element or Nothing if the vector does not contain the element This is specialised version of findIndex",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "elemIndex",
        "normalized": "a-\u003eVector a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "a-\u003eVector a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of all occurences of the given element in\n ascending order. This is a specialised version of \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Vector Int",
        "fct-source": "src/Data-Vector-Unboxed.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "Yield the indices of all occurences of the given element in ascending order This is specialised version of findIndices",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "elemIndices",
        "normalized": "a-\u003eVector a-\u003eVector Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "a-\u003eVector a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "empty",
        "normalized": "",
        "package": "vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:enumFromN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+1\u003c/code\u003e\n etc. This operation is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromN 5 3 = \u003c5,6,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#enumFromN",
        "fct-type": "function",
        "title": "enumFromN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operation is usually more efficient than enumFromTo enumFromN",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "enumFromN",
        "normalized": "a-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From",
        "signature": "a-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:enumFromStepN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc. This operations is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromThenTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromStepN 1 0.1 5 = \u003c1,1.1,1.2,1.3,1.4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#enumFromStepN",
        "fct-type": "function",
        "title": "enumFromStepN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operations is usually more efficient than enumFromThenTo enumFromStepN",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "enumFromStepN",
        "normalized": "a-\u003ea-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From Step",
        "signature": "a-\u003ea-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:enumFromThenTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e with a specific step \u003ccode\u003ez\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#enumFromThenTo",
        "fct-type": "function",
        "title": "enumFromThenTo"
      },
      "index": {
        "description": "Enumerate values from to with specific step WARNING This operation can be very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "enumFromThenTo",
        "normalized": "a-\u003ea-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "From Then To",
        "signature": "a-\u003ea-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Enumerate values from to WARNING This operation can be very inefficient If at all possible use enumFromN instead",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "enumFromTo",
        "normalized": "a-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "From To",
        "signature": "a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "filter",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Vector a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Drop elements that do not satisfy the monadic predicate",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "filterM",
        "normalized": "(a-\u003eb Bool)-\u003eVector a-\u003eb(Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003eVector a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Maybe a",
        "fct-source": "src/Data-Vector-Unboxed.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "find",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector-Unboxed.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of elements satisfying the predicate in ascending\n order.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector Int",
        "fct-source": "src/Data-Vector-Unboxed.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "Yield the indices of elements satisfying the predicate in ascending order",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "findIndices",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "fold1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "fold1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:fold1M-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#fold1M%27_",
        "fct-type": "function",
        "title": "fold1M'_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator that discards the result",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "fold1M'_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:fold1M_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#fold1M_",
        "fct-type": "function",
        "title": "fold1M_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors that discards the result",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "fold1M_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Monadic fold with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldM-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#foldM%27_",
        "fct-type": "function",
        "title": "foldM'_"
      },
      "index": {
        "description": "Monadic fold with strict accumulator that discards the result",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldM'_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#foldM_",
        "fct-type": "function",
        "title": "foldM_"
      },
      "index": {
        "description": "Monadic fold that discards the result",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldM_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold on non-empty vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Unboxed.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Unboxed.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold on non-empty vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "Right fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "foldr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:forM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results. Equvalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (a -\u003e m b) -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector-Unboxed.html#forM",
        "fct-type": "function",
        "title": "forM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results Equvalent to flip mapM",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "forM",
        "normalized": "Vector a-\u003e(a-\u003eb c)-\u003eb(Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e(a-\u003em b)-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:forM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results. Equivalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (a -\u003e m b) -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#forM_",
        "fct-type": "function",
        "title": "forM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results Equivalent to flip mapM",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "forM_",
        "normalized": "Vector a-\u003e(a-\u003eb c)-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e(a-\u003em b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:force",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the argument but force it not to retain any extra memory,\n possibly by copying it.\n\u003c/p\u003e\u003cp\u003eThis is especially useful when dealing with slices. For example:\n\u003c/p\u003e\u003cpre\u003e force (slice 0 2 \u003chuge vector\u003e)\n\u003c/pre\u003e\u003cp\u003eHere, the slice retains a reference to the huge vector. Forcing it creates\n a copy of just the elements that belong to the slice and allows the huge\n vector to be garbage collected.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#force",
        "fct-type": "function",
        "title": "force"
      },
      "index": {
        "description": "Yield the argument but force it not to retain any extra memory possibly by copying it This is especially useful when dealing with slices For example force slice huge vector Here the slice retains reference to the huge vector Forcing it creates copy of just the elements that belong to the slice and allows the huge vector to be garbage collected",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "force",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:freeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield an immutable copy of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#freeze",
        "fct-type": "function",
        "title": "freeze"
      },
      "index": {
        "description": "Yield an immutable copy of the mutable vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "freeze",
        "normalized": "MVector(PrimState a)b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a list to a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "[a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "fromList",
        "normalized": "[a]-\u003eVector a",
        "package": "vector",
        "partial": "List",
        "signature": "[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a vector\n\u003c/p\u003e\u003cpre\u003e\n fromListN n xs = \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e [a] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Convert the first elements of list to vector fromListN xs fromList take xs",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "fromListN",
        "normalized": "Int-\u003e[a]-\u003eVector a",
        "package": "vector",
        "partial": "List",
        "signature": "Int-\u003e[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the function to\n each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Construct vector of the given length by applying the function to each index",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the monadic\n action to each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e m a) -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Construct vector of the given length by applying the monadic action to each index",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "generateM",
        "normalized": "Int-\u003e(Int-\u003ea b)-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003em a)-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "head",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:headM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#headM",
        "fct-type": "function",
        "title": "headM"
      },
      "index": {
        "description": "First element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "headM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:ifilter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate which is applied to\n values and their indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#ifilter",
        "fct-type": "function",
        "title": "ifilter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate which is applied to values and their indices",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "ifilter",
        "normalized": "(Int-\u003ea-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold function applied to each element and its index",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:ifoldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator (function applied to each element\n and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#ifoldl%27",
        "fct-type": "function",
        "title": "ifoldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "ifoldl'",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Unboxed.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Right fold function applied to each element and its index",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:ifoldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with strict accumulator (function applied to each\n element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector-Unboxed.html#ifoldr%27",
        "fct-type": "function",
        "title": "ifoldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "ifoldr'",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply a function to every element of a vector and its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of vector and its index",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:indexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad.\n\u003c/p\u003e\u003cp\u003eThe monad allows operations to be strict in the vector when necessary.\n Suppose vector copying is implemented like this:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... write mv i (v ! i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, \u003ccode\u003ev ! i\u003c/code\u003e would not be evaluated which means that \u003ccode\u003emv\u003c/code\u003e\n would unnecessarily retain a reference to \u003ccode\u003ev\u003c/code\u003e in each element written.\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e, copying can be implemented like this instead:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... do\n                   x \u003c- indexM v i\n                   write mv i x\n\u003c/pre\u003e\u003cp\u003eHere, no references to \u003ccode\u003ev\u003c/code\u003e are retained because indexing (but \u003cem\u003enot\u003c/em\u003e the\n elements) is evaluated eagerly.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#indexM",
        "fct-type": "function",
        "title": "indexM"
      },
      "index": {
        "description": "Indexing in monad The monad allows operations to be strict in the vector when necessary Suppose vector copying is implemented like this copy mv write mv For lazy vectors would not be evaluated which means that mv would unnecessarily retain reference to in each element written With indexM copying can be implemented like this instead copy mv do indexM write mv Here no references to are retained because indexing but not the elements is evaluated eagerly",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "indexM",
        "normalized": "Vector a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:indexed",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Pair each element in a vector with its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector (Int, a)",
        "fct-source": "src/Data-Vector-Unboxed.html#indexed",
        "fct-type": "function",
        "title": "indexed"
      },
      "index": {
        "description": "Pair each element in vector with its index",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "indexed",
        "normalized": "Vector a-\u003eVector(Int,a)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "init",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function times to value Zeroth element is original value",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "iterateN",
        "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with a function that also takes the\n elements' indices.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
        "fct-source": "src/Data-Vector-Unboxed.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "min Zip two vectors with function that also takes the elements indices",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:izipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors and their indices with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d",
        "fct-source": "src/Data-Vector-Unboxed.html#izipWith3",
        "fct-type": "function",
        "title": "izipWith3"
      },
      "index": {
        "description": "Zip three vectors and their indices with the given function",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "izipWith3",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:izipWith4",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e",
        "fct-source": "src/Data-Vector-Unboxed.html#izipWith4",
        "fct-type": "function",
        "title": "izipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "izipWith4",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:izipWith5",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f",
        "fct-source": "src/Data-Vector-Unboxed.html#izipWith5",
        "fct-type": "function",
        "title": "izipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "izipWith5",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:izipWith6",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector g",
        "fct-source": "src/Data-Vector-Unboxed.html#izipWith6",
        "fct-type": "function",
        "title": "izipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "izipWith6",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "last",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:lastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#lastM",
        "fct-type": "function",
        "title": "lastM"
      },
      "index": {
        "description": "Last element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "lastM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the length of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Yield the length of the vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "length",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Map a function over a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Vector a -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector-Unboxed.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb(Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eVector a-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:maxIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed.html#maxIndex",
        "fct-type": "function",
        "title": "maxIndex"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "maxIndex",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:maxIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed.html#maxIndexBy",
        "fct-type": "function",
        "title": "maxIndexBy"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "maxIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Yield the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "maximum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:maximumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#maximumBy",
        "fct-type": "function",
        "title": "maximumBy"
      },
      "index": {
        "description": "Yield the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "maximumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:minIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed.html#minIndex",
        "fct-type": "function",
        "title": "minIndex"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "minIndex",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:minIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e Int",
        "fct-source": "src/Data-Vector-Unboxed.html#minIndexBy",
        "fct-type": "function",
        "title": "minIndexBy"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "minIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Yield the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "minimum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:minimumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#minimumBy",
        "fct-type": "function",
        "title": "minimumBy"
      },
      "index": {
        "description": "Yield the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "minimumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:modify",
      "description": {
        "fct-descr": "\u003cp\u003eApply a destructive operation to a vector. The operation will be\n performed in place if it is safe to do so and will modify a copy of the\n vector otherwise.\n\u003c/p\u003e\u003cpre\u003e\n modify (\\v -\u003e write v 0 'x') (\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e 3 'a') = \u003c'x','a','a'\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(forall s.  MVector s a -\u003e ST s ()) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#modify",
        "fct-type": "function",
        "title": "modify"
      },
      "index": {
        "description": "Apply destructive operation to vector The operation will be performed in place if it is safe to do so and will modify copy of the vector otherwise modify write replicate",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "modify",
        "normalized": "(a b MVector c d-\u003eST c())-\u003eVector d-\u003eVector d",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. MVector s a-\u003eST s())-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector does not contain an element (inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Check if the vector does not contain an element inverse of elem",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "notElem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "Elem",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a vector if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether vector if empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "null",
        "normalized": "Vector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector Bool -\u003e Bool",
        "fct-source": "src/Data-Vector-Unboxed.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "Check if any element is True",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "or",
        "normalized": "Vector Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't. The\n relative order of the elements is preserved at the cost of a sometimes\n reduced performance compared to \u003ccode\u003e\u003ca\u003eunstablePartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The relative order of the elements is preserved at the cost of sometimes reduced performance compared to unstablePartition",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "partition",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan\n\u003c/p\u003e\u003cpre\u003e\n postscanl f z = \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003epostscanl (+) 0 \u003c1,2,3,4\u003e = \u003c1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Scan postscanl tail scanl Example postscanl",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "postscanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Scan with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "postscanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:postscanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#postscanr",
        "fct-type": "function",
        "title": "postscanr"
      },
      "index": {
        "description": "Right-to-left scan",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "postscanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:postscanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#postscanr%27",
        "fct-type": "function",
        "title": "postscanr'"
      },
      "index": {
        "description": "Right-to-left scan with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "postscanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanl f z = \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003eprescanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prescan prescanl init scanl Example prescanl",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "prescanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prescan with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "prescanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:prescanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanr f z = \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eprescanl\u003c/a\u003e\u003c/code\u003e (flip f) z . \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#prescanr",
        "fct-type": "function",
        "title": "prescanr"
      },
      "index": {
        "description": "Right-to-left prescan prescanr reverse prescanl flip reverse",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "prescanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:prescanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#prescanr%27",
        "fct-type": "function",
        "title": "prescanr'"
      },
      "index": {
        "description": "Right-to-left prescan with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "prescanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:product",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the produce of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#product",
        "fct-type": "function",
        "title": "product"
      },
      "index": {
        "description": "Compute the produce of the elements",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "product",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Vector of the given length with the same value in each position\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Vector of the given length with the same value in each position",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Execute the monadic action the given number of times and store the\n results in a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute the monadic action the given number of times and store the results in vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Reverse a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "reverse",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan\n\u003c/p\u003e\u003cpre\u003e scanl f z \u003cx1,...,xn\u003e = \u003cy1,...,y(n+1)\u003e\n   where y1 = z\n         yi = f y(i-1) x(i-1)\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003escanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan scanl x1 xn y1 where y1 yi i-1 i-1 Example scanl",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "scanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector\n\u003c/p\u003e\u003cpre\u003e scanl f \u003cx1,...,xn\u003e = \u003cy1,...,yn\u003e\n   where y1 = x1\n         yi = f y(i-1) xi\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty vector scanl x1 xn y1 yn where y1 x1 yi i-1 xi",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "scanl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "scanl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "scanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:scanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector-Unboxed.html#scanr%27",
        "fct-type": "function",
        "title": "scanr'"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "scanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "scanr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:scanr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector with a strict\n accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#scanr1%27",
        "fct-type": "function",
        "title": "scanr1'"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "scanr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Vector with exactly one element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Vector with exactly one element",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "singleton",
        "normalized": "a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying it. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield slice of the vector without copying it The vector must contain at least elements",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "snoc",
        "normalized": "Vector a-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that satisfy\n the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "span",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements paired with the remainder without copying.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e n v\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n v, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n v)\u003c/code\u003e\n but slightly more efficient.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "Yield the first elements paired with the remainder without copying Note that splitAt is equivalent to take drop but slightly more efficient",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "splitAt",
        "normalized": "Int-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the sum of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "Compute the sum of the elements",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "sum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "tail",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield at the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case it is returned unchanged.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "Yield at the first elements without copying The vector may contain less than elements in which case it is returned unchanged",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "take",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the longest prefix of elements satisfying the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Yield the longest prefix of elements satisfying the predicate without copying",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "takeWhile",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:thaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a mutable copy of the immutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed.html#thaw",
        "fct-type": "function",
        "title": "thaw"
      },
      "index": {
        "description": "Yield mutable copy of the immutable vector",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "thaw",
        "normalized": "Vector a-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a vector to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e [a]",
        "fct-source": "src/Data-Vector-Unboxed.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to list",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "toList",
        "normalized": "Vector a-\u003e[a]",
        "package": "vector",
        "partial": "List",
        "signature": "Vector a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector by repeatedly applying the generator function\n to a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the next element and the\n new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\n -\u003e if n == 0 then Nothing else Just (n,n-1)) 10\n  = \u003c10,9,8,7,6,5,4,3,2,1\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Construct vector by repeatedly applying the generator function to seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldr if then Nothing else Just n-1",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with at most \u003ccode\u003en\u003c/code\u003e by repeatedly applying the\n generator function to the a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the\n next element and the new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldrN 3 (\\n -\u003e Just (n,n-1)) 10 = \u003c10,9,8\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Construct vector with at most by repeatedly applying the generator function to the seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldrN Just n-1",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeAccum",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccum\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e [(Int, b)] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeAccum",
        "fct-type": "function",
        "title": "unsafeAccum"
      },
      "index": {
        "description": "Same as accum but without bounds checking",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeAccum",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a",
        "package": "vector",
        "partial": "Accum",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeAccumulate",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e Vector (Int, b) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeAccumulate",
        "fct-type": "function",
        "title": "unsafeAccumulate"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeAccumulate",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector(Int,b)-\u003eVector a",
        "package": "vector",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector(Int,b)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeAccumulate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e Vector Int -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeAccumulate_",
        "fct-type": "function",
        "title": "unsafeAccumulate_"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeAccumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeBackpermute",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ebackpermute\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeBackpermute",
        "fct-type": "function",
        "title": "unsafeBackpermute"
      },
      "index": {
        "description": "Same as backpermute but without bounds checking",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeBackpermute",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a",
        "package": "vector",
        "partial": "Backpermute",
        "signature": "Vector a-\u003eVector Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeCopy",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length This is not checked",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeCopy",
        "normalized": "MVector(PrimState a)b-\u003eVector b-\u003ea()",
        "package": "vector",
        "partial": "Copy",
        "signature": "MVector(PrimState m)a-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeDrop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector\n must contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe convert a mutable vector to an immutable one without\n copying. The mutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeFreeze",
        "fct-type": "function",
        "title": "unsafeFreeze"
      },
      "index": {
        "description": "Unsafe convert mutable vector to an immutable one without copying The mutable vector may not be used after this operation",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeFreeze",
        "normalized": "MVector(PrimState a)b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "Freeze",
        "signature": "MVector(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeHead",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeHead",
        "fct-type": "function",
        "title": "unsafeHead"
      },
      "index": {
        "description": "First element without checking if the vector is empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeHead",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "Head",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeHeadM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeHeadM",
        "fct-type": "function",
        "title": "unsafeHeadM"
      },
      "index": {
        "description": "First element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeHeadM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "Head",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe indexing without bounds checking\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeIndex",
        "fct-type": "function",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Unsafe indexing without bounds checking",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeIndex",
        "normalized": "Vector a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeIndexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad without bounds checks. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeIndexM",
        "fct-type": "function",
        "title": "unsafeIndexM"
      },
      "index": {
        "description": "Indexing in monad without bounds checks See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeIndexM",
        "normalized": "Vector a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeInit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeInit",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "Init",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeLast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeLast",
        "fct-type": "function",
        "title": "unsafeLast"
      },
      "index": {
        "description": "Last element without checking if the vector is empty",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeLast",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "Last",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeLastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeLastM",
        "fct-type": "function",
        "title": "unsafeLastM"
      },
      "index": {
        "description": "Last element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeLastM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "Last",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield slice of the vector without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeTail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeTail",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "Tail",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeTake",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector must\n contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "Yield the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeTake",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely convert an immutable vector to a mutable one without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeThaw",
        "fct-type": "function",
        "title": "unsafeThaw"
      },
      "index": {
        "description": "Unsafely convert an immutable vector to mutable one without copying The immutable vector may not be used after this operation",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeThaw",
        "normalized": "Vector a-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "Thaw",
        "signature": "Vector a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeUpd",
      "description": {
        "fct-descr": "\u003cp\u003eSame as (\u003ccode\u003e\u003ca\u003e//\u003c/a\u003e\u003c/code\u003e) but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e [(Int, a)] -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeUpd",
        "fct-type": "function",
        "title": "unsafeUpd"
      },
      "index": {
        "description": "Same as but without bounds checking",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeUpd",
        "normalized": "Vector a-\u003e[(Int,a)]-\u003eVector a",
        "package": "vector",
        "partial": "Upd",
        "signature": "Vector a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeUpdate",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector (Int, a) -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeUpdate",
        "fct-type": "function",
        "title": "unsafeUpdate"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeUpdate",
        "normalized": "Vector a-\u003eVector(Int,a)-\u003eVector a",
        "package": "vector",
        "partial": "Update",
        "signature": "Vector a-\u003eVector(Int,a)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unsafeUpdate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector-Unboxed.html#unsafeUpdate_",
        "fct-type": "function",
        "title": "unsafeUpdate_"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unsafeUpdate_",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Update",
        "signature": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unstablePartition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't.\n The order of the elements is not preserved but the operation is often\n faster than \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector-Unboxed.html#unstablePartition",
        "fct-type": "function",
        "title": "unstablePartition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The order of the elements is not preserved but the operation is often faster than partition",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unstablePartition",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "Partition",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 2 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b) -\u003e (Vector a, Vector b)",
        "fct-source": "src/Data-Vector-Unboxed.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unzip",
        "normalized": "Vector(a,b)-\u003e(Vector a,Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b)-\u003e(Vector a,Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unzip3",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 3 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b, c) -\u003e (Vector a, Vector b, Vector c)",
        "fct-source": "src/Data-Vector-Unboxed.html#unzip3",
        "fct-type": "function",
        "title": "unzip3"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unzip3",
        "normalized": "Vector(a,b,c)-\u003e(Vector a,Vector b,Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b,c)-\u003e(Vector a,Vector b,Vector c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unzip4",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 4 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b, c, d) -\u003e (Vector a, Vector b, Vector c, Vector d)",
        "fct-source": "src/Data-Vector-Unboxed.html#unzip4",
        "fct-type": "function",
        "title": "unzip4"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unzip4",
        "normalized": "Vector(a,b,c,d)-\u003e(Vector a,Vector b,Vector c,Vector d)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b,c,d)-\u003e(Vector a,Vector b,Vector c,Vector d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unzip5",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 5 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b, c, d, e) -\u003e (Vector a, Vector b, Vector c, Vector d, Vector e)",
        "fct-source": "src/Data-Vector-Unboxed.html#unzip5",
        "fct-type": "function",
        "title": "unzip5"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unzip5",
        "normalized": "Vector(a,b,c,d,e)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b,c,d,e)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:unzip6",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unzip 6 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b, c, d, e, f) -\u003e (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)",
        "fct-source": "src/Data-Vector-Unboxed.html#unzip6",
        "fct-type": "function",
        "title": "unzip6"
      },
      "index": {
        "description": "Unzip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "unzip6",
        "normalized": "Vector(a,b,c,d,e,f)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e,Vector f)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b,c,d,e,f)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e,Vector f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:update",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the vector of index/value pairs,\n replace the vector element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update \u003c5,9,2,7\u003e \u003c(2,1),(0,3),(2,8)\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e Vector (Int, a)-\u003e Vector a",
        "fct-type": "function",
        "title": "update"
      },
      "index": {
        "description": "For each pair from the vector of index value pairs replace the vector element at position by update",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "update",
        "normalized": "Vector a-\u003eVector(Int,a)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector(Int,a)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:update_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003ea\u003c/code\u003e from the value vector, replace the element of the\n initial vector at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update_ \u003c5,9,2,7\u003e  \u003c2,0,2\u003e \u003c1,3,8\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e provides the same functionality and is usually more\n convenient.\n\u003c/p\u003e\u003cpre\u003e\n update_ xs is ys = \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e xs (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is ys)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e Vector Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "update_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the value vector replace the element of the initial vector at position by update The function update provides the same functionality and is usually more convenient update xs is ys update xs zip is ys",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "update_",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 2 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector (a, b)",
        "fct-source": "src/Data-Vector-Unboxed.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zip",
        "normalized": "Vector a-\u003eVector b-\u003eVector(a,b)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zip3",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 3 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector (a, b, c)",
        "fct-source": "src/Data-Vector-Unboxed.html#zip3",
        "fct-type": "function",
        "title": "zip3"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zip3",
        "normalized": "Vector a-\u003eVector b-\u003eVector c-\u003eVector(a,b,c)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector c-\u003eVector(a,b,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zip4",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 4 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector (a, b, c, d)",
        "fct-source": "src/Data-Vector-Unboxed.html#zip4",
        "fct-type": "function",
        "title": "zip4"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zip4",
        "normalized": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector(a,b,c,d)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector(a,b,c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zip5",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 5 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector (a, b, c, d, e)",
        "fct-source": "src/Data-Vector-Unboxed.html#zip5",
        "fct-type": "function",
        "title": "zip5"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zip5",
        "normalized": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector(a,b,c,d,e)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector(a,b,c,d,e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zip6",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Zip 6 vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector (a, b, c, d, e, f)",
        "fct-source": "src/Data-Vector-Unboxed.html#zip6",
        "fct-type": "function",
        "title": "zip6"
      },
      "index": {
        "description": "Zip vectors",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zip6",
        "normalized": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector(a,b,c,d,e,f)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector(a,b,c,d,e,f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
        "fct-source": "src/Data-Vector-Unboxed.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "min Zip two vectors with the given function",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d",
        "fct-source": "src/Data-Vector-Unboxed.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "Zip three vectors with the given function",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zipWith3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e",
        "fct-source": "src/Data-Vector-Unboxed.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zipWith4",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f",
        "fct-source": "src/Data-Vector-Unboxed.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zipWith5",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector g",
        "fct-source": "src/Data-Vector-Unboxed.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zipWith6",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and yield a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Vector a -\u003e Vector b -\u003e m (Vector c)",
        "fct-source": "src/Data-Vector-Unboxed.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and yield vector of results",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eVector a-\u003eVector b-\u003ec(Vector d)",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eVector a-\u003eVector b-\u003em(Vector c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed.html#v:zipWithM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector.Unboxed",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Vector a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector-Unboxed.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and ignore the results",
        "hierarchy": "Data Vector Unboxed",
        "module": "Data.Vector.Unboxed",
        "name": "zipWithM_",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eVector a-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eVector a-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA library for boxed vectors (that is, polymorphic arrays capable of\n holding any Haskell value). The vectors come in two flavours:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e mutable\n\u003c/li\u003e\u003cli\u003e immutable\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eand support a rich interface of both list-like operations, and bulk\n array operations.\n\u003c/p\u003e\u003cp\u003eFor unboxed arrays, use \u003ca\u003eData.Vector.Unboxed\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "module",
        "fct-source": "src/Data-Vector.html",
        "fct-type": "module",
        "title": "Vector"
      },
      "index": {
        "description": "library for boxed vectors that is polymorphic arrays capable of holding any Haskell value The vectors come in two flavours mutable immutable and support rich interface of both list-like operations and bulk array operations For unboxed arrays use Data.Vector.Unboxed",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "Vector",
        "normalized": "",
        "package": "vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#t:MVector",
      "description": {
        "fct-descr": "\u003cp\u003eMutable boxed vectors keyed on the monad they live in (\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ccode\u003eST\u003c/code\u003e s\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector-Mutable.html#MVector",
        "fct-type": "data",
        "title": "MVector"
      },
      "index": {
        "description": "Mutable boxed vectors keyed on the monad they live in IO or ST",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "MVector",
        "normalized": "",
        "package": "vector",
        "partial": "MVector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#t:Vector",
      "description": {
        "fct-descr": "\u003cp\u003eBoxed vectors, supporting efficient slicing.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "data",
        "fct-source": "src/Data-Vector.html#Vector",
        "fct-type": "data",
        "title": "Vector"
      },
      "index": {
        "description": "Boxed vectors supporting efficient slicing",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "Vector",
        "normalized": "",
        "package": "vector",
        "partial": "Vector",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:-33-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector.html#%21",
        "fct-type": "function",
        "title": "(!)"
      },
      "index": {
        "description": "Indexing",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "(!) !",
        "normalized": "Vector a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:-33--63-",
      "description": {
        "fct-descr": "\u003cp\u003eO(1) Safe indexing\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e Maybe a",
        "fct-source": "src/Data-Vector.html#%21%3F",
        "fct-type": "function",
        "title": "(!?)"
      },
      "index": {
        "description": "Safe indexing",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "(!?) !?",
        "normalized": "Vector a-\u003eInt-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:-43--43-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e Concatenate two vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#%2B%2B",
        "fct-type": "function",
        "title": "(++)"
      },
      "index": {
        "description": "Concatenate two vectors",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "(++) ++",
        "normalized": "Vector a-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:-47--47-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the list, replace the vector\n element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003c5,9,2,7\u003e // [(2,1),(0,3),(2,8)] = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e [(Int, a)]-\u003e Vector a",
        "fct-type": "function",
        "title": "(//)"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "(//) //",
        "normalized": "Vector a-\u003e[(Int,a)]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:accum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the list, replace the vector element\n \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accum (+) \u003c5,9,2\u003e [(2,4),(1,6),(0,3),(1,7)] = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e [(Int, b)]-\u003e Vector a",
        "fct-type": "function",
        "title": "accum"
      },
      "index": {
        "description": "For each pair from the list replace the vector element at position by accum",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "accum",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:accumulate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the vector of pairs, replace the vector\n element \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate (+) \u003c5,9,2\u003e \u003c(2,4),(1,6),(0,3),(1,7)\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e Vector (Int, b)-\u003e Vector a",
        "fct-type": "function",
        "title": "accumulate"
      },
      "index": {
        "description": "For each pair from the vector of pairs replace the vector element at position by accumulate",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "accumulate",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector(Int,b)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector(Int,b)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:accumulate_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003eb\u003c/code\u003e from the the value vector,\n replace the element of the initial vector at\n position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate_ (+) \u003c5,9,2\u003e \u003c2,1,0,1\u003e \u003c4,6,3,7\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e provides the same functionality and is usually more\n convenient.\n\u003c/p\u003e\u003cpre\u003e\n accumulate_ f as is bs = \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e f as (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is bs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a)-\u003e Vector a-\u003e Vector Int-\u003e Vector b-\u003e Vector a",
        "fct-type": "function",
        "title": "accumulate_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the the value vector replace the element of the initial vector at position by accumulate The function accumulate provides the same functionality and is usually more convenient accumulate as is bs accumulate as zip is bs",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "accumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:all",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements satisfy the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector.html#all",
        "fct-type": "function",
        "title": "all"
      },
      "index": {
        "description": "Check if all elements satisfy the predicate",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "all",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:and",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements are \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector Bool -\u003e Bool",
        "fct-source": "src/Data-Vector.html#and",
        "fct-type": "function",
        "title": "and"
      },
      "index": {
        "description": "Check if all elements are True",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "and",
        "normalized": "Vector Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:any",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element satisfies the predicate.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector.html#any",
        "fct-type": "function",
        "title": "any"
      },
      "index": {
        "description": "Check if any element satisfies the predicate",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "any",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:backpermute",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the vector obtained by replacing each element \u003ccode\u003ei\u003c/code\u003e of the\n index vector by \u003ccode\u003exs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003ei\u003c/code\u003e. This is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (xs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e) is\u003c/code\u003e but is\n often much more efficient.\n\u003c/p\u003e\u003cpre\u003e backpermute \u003ca,b,c,d\u003e \u003c0,3,2,3,1,0\u003e = \u003ca,d,c,d,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#backpermute",
        "fct-type": "function",
        "title": "backpermute"
      },
      "index": {
        "description": "Yield the vector obtained by replacing each element of the index vector by xs This is equivalent to map xs is but is often much more efficient backpermute",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "backpermute",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that do not\n satisfy the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that do not satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "break",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:concat",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate all vectors in the list\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "[Vector a] -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#concat",
        "fct-type": "function",
        "title": "concat"
      },
      "index": {
        "description": "Concatenate all vectors in the list",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "concat",
        "normalized": "[Vector a]-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "[Vector a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:concatMap",
      "description": {
        "fct-descr": "\u003cp\u003eMap a function over a vector and concatenate the results.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Vector b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#concatMap",
        "fct-type": "function",
        "title": "concatMap"
      },
      "index": {
        "description": "Map function over vector and concatenate the results",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "concatMap",
        "normalized": "(a-\u003eVector b)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "Map",
        "signature": "(a-\u003eVector b)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:cons",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prepend an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#cons",
        "fct-type": "function",
        "title": "cons"
      },
      "index": {
        "description": "Prepend an element",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "cons",
        "normalized": "a-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:constructN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements by repeatedly applying the\n generator function to the already constructed part of the vector.\n\u003c/p\u003e\u003cpre\u003e constructN 3 f = let a = f \u003c\u003e ; b = f \u003ca\u003e ; c = f \u003ca,b\u003e in f \u003ca,b,c\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#constructN",
        "fct-type": "function",
        "title": "constructN"
      },
      "index": {
        "description": "Construct vector with elements by repeatedly applying the generator function to the already constructed part of the vector constructN let in",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "constructN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:constructrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements from right to left by\n repeatedly applying the generator function to the already constructed part\n of the vector.\n\u003c/p\u003e\u003cpre\u003e constructrN 3 f = let a = f \u003c\u003e ; b = f\u003ca\u003e ; c = f \u003cb,a\u003e in f \u003cc,b,a\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Vector a -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#constructrN",
        "fct-type": "function",
        "title": "constructrN"
      },
      "index": {
        "description": "Construct vector with elements from right to left by repeatedly applying the generator function to the already constructed part of the vector constructrN let in",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "constructrN",
        "normalized": "Int-\u003e(Vector a-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Vector a-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:convert",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert different vector types\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "v a -\u003e w a",
        "fct-source": "src/Data-Vector-Generic.html#convert",
        "fct-type": "function",
        "title": "convert"
      },
      "index": {
        "description": "Convert different vector types",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "convert",
        "normalized": "a b-\u003ec b",
        "package": "vector",
        "partial": "",
        "signature": "v a-\u003ew a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:copy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector.html#copy",
        "fct-type": "function",
        "title": "copy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "copy",
        "normalized": "MVector(PrimState a)b-\u003eVector b-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:create",
      "description": {
        "fct-descr": "\u003cp\u003eExecute the monadic action and freeze the resulting vector.\n\u003c/p\u003e\u003cpre\u003e\n create (do { v \u003c- new 2; write v 0 'a'; write v 1 'b'; return v }) = \u003c\u003ccode\u003ea\u003c/code\u003e,\u003ccode\u003eb\u003c/code\u003e\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(forall s.  ST s (MVector s a)) -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#create",
        "fct-type": "function",
        "title": "create"
      },
      "index": {
        "description": "Execute the monadic action and freeze the resulting vector create do new write write return",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "create",
        "normalized": "(a b ST c(MVector c d))-\u003eVector d",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. ST s(MVector s a))-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:drop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case an empty vector is returned.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#drop",
        "fct-type": "function",
        "title": "drop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector may contain less than elements in which case an empty vector is returned",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "drop",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:dropWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop the longest prefix of elements that satisfy the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#dropWhile",
        "fct-type": "function",
        "title": "dropWhile"
      },
      "index": {
        "description": "Drop the longest prefix of elements that satisfy the predicate without copying",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "dropWhile",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:elem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector contains an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector.html#elem",
        "fct-type": "function",
        "title": "elem"
      },
      "index": {
        "description": "Check if the vector contains an element",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "elem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:elemIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first occurence of the given element or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the vector does not contain the element. This is a specialised\n version of \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector.html#elemIndex",
        "fct-type": "function",
        "title": "elemIndex"
      },
      "index": {
        "description": "Yield Just the index of the first occurence of the given element or Nothing if the vector does not contain the element This is specialised version of findIndex",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "elemIndex",
        "normalized": "a-\u003eVector a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "a-\u003eVector a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:elemIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of all occurences of the given element in\n ascending order. This is a specialised version of \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Vector Int",
        "fct-source": "src/Data-Vector.html#elemIndices",
        "fct-type": "function",
        "title": "elemIndices"
      },
      "index": {
        "description": "Yield the indices of all occurences of the given element in ascending order This is specialised version of findIndices",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "elemIndices",
        "normalized": "a-\u003eVector a-\u003eVector Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "a-\u003eVector a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a",
        "fct-source": "src/Data-Vector.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "Empty vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "empty",
        "normalized": "",
        "package": "vector",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:enumFromN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+1\u003c/code\u003e\n etc. This operation is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromN 5 3 = \u003c5,6,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#enumFromN",
        "fct-type": "function",
        "title": "enumFromN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operation is usually more efficient than enumFromTo enumFromN",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "enumFromN",
        "normalized": "a-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From",
        "signature": "a-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:enumFromStepN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc. This operations is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromThenTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromStepN 1 0.1 5 = \u003c1,1.1,1.2,1.3,1.4\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Int -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#enumFromStepN",
        "fct-type": "function",
        "title": "enumFromStepN"
      },
      "index": {
        "description": "Yield vector of the given length containing the values etc This operations is usually more efficient than enumFromThenTo enumFromStepN",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "enumFromStepN",
        "normalized": "a-\u003ea-\u003eInt-\u003eVector a",
        "package": "vector",
        "partial": "From Step",
        "signature": "a-\u003ea-\u003eInt-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:enumFromThenTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e with a specific step \u003ccode\u003ez\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#enumFromThenTo",
        "fct-type": "function",
        "title": "enumFromThenTo"
      },
      "index": {
        "description": "Enumerate values from to with specific step WARNING This operation can be very inefficient If at all possible use enumFromStepN instead",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "enumFromThenTo",
        "normalized": "a-\u003ea-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "From Then To",
        "signature": "a-\u003ea-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:enumFromTo",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#enumFromTo",
        "fct-type": "function",
        "title": "enumFromTo"
      },
      "index": {
        "description": "Enumerate values from to WARNING This operation can be very inefficient If at all possible use enumFromN instead",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "enumFromTo",
        "normalized": "a-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "From To",
        "signature": "a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:filter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#filter",
        "fct-type": "function",
        "title": "filter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "filter",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:filterM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the monadic predicate\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m Bool) -\u003e Vector a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector.html#filterM",
        "fct-type": "function",
        "title": "filterM"
      },
      "index": {
        "description": "Drop elements that do not satisfy the monadic predicate",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "filterM",
        "normalized": "(a-\u003eb Bool)-\u003eVector a-\u003eb(Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em Bool)-\u003eVector a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:find",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Maybe a",
        "fct-source": "src/Data-Vector.html#find",
        "fct-type": "function",
        "title": "find"
      },
      "index": {
        "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "find",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eMaybe a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:findIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Maybe Int",
        "fct-source": "src/Data-Vector.html#findIndex",
        "fct-type": "function",
        "title": "findIndex"
      },
      "index": {
        "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "findIndex",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eMaybe Int",
        "package": "vector",
        "partial": "Index",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eMaybe Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:findIndices",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of elements satisfying the predicate in ascending\n order.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector Int",
        "fct-source": "src/Data-Vector.html#findIndices",
        "fct-type": "function",
        "title": "findIndices"
      },
      "index": {
        "description": "Yield the indices of elements satisfying the predicate in ascending order",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "findIndices",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector Int",
        "package": "vector",
        "partial": "Indices",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:fold1M",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m a",
        "fct-source": "src/Data-Vector.html#fold1M",
        "fct-type": "function",
        "title": "fold1M"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "fold1M",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:fold1M-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m a",
        "fct-source": "src/Data-Vector.html#fold1M%27",
        "fct-type": "function",
        "title": "fold1M'"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "fold1M'",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:fold1M-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector.html#fold1M%27_",
        "fct-type": "function",
        "title": "fold1M'_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors with strict accumulator that discards the result",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "fold1M'_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:fold1M_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e m a) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector.html#fold1M_",
        "fct-type": "function",
        "title": "fold1M_"
      },
      "index": {
        "description": "Monadic fold over non-empty vectors that discards the result",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "fold1M_",
        "normalized": "(a-\u003ea-\u003eb a)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003em a)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m a",
        "fct-source": "src/Data-Vector.html#foldM",
        "fct-type": "function",
        "title": "foldM"
      },
      "index": {
        "description": "Monadic fold",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldM",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldM-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m a",
        "fct-source": "src/Data-Vector.html#foldM%27",
        "fct-type": "function",
        "title": "foldM'"
      },
      "index": {
        "description": "Monadic fold with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldM'",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec a",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldM-39-_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector.html#foldM%27_",
        "fct-type": "function",
        "title": "foldM'_"
      },
      "index": {
        "description": "Monadic fold with strict accumulator that discards the result",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldM'_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "M'",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold that discards the result\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector.html#foldM_",
        "fct-type": "function",
        "title": "foldM_"
      },
      "index": {
        "description": "Monadic fold that discards the result",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldM_",
        "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003eVector b-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector.html#foldl",
        "fct-type": "function",
        "title": "foldl"
      },
      "index": {
        "description": "Left fold",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector.html#foldl%27",
        "fct-type": "function",
        "title": "foldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#foldl1",
        "fct-type": "function",
        "title": "foldl1"
      },
      "index": {
        "description": "Left fold on non-empty vectors",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#foldl1%27",
        "fct-type": "function",
        "title": "foldl1'"
      },
      "index": {
        "description": "Left fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector.html#foldr",
        "fct-type": "function",
        "title": "foldr"
      },
      "index": {
        "description": "Right fold",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector.html#foldr%27",
        "fct-type": "function",
        "title": "foldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#foldr1",
        "fct-type": "function",
        "title": "foldr1"
      },
      "index": {
        "description": "Right fold on non-empty vectors",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:foldr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#foldr1%27",
        "fct-type": "function",
        "title": "foldr1'"
      },
      "index": {
        "description": "Right fold on non-empty vectors with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "foldr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:forM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results. Equvalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (a -\u003e m b) -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector.html#forM",
        "fct-type": "function",
        "title": "forM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results Equvalent to flip mapM",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "forM",
        "normalized": "Vector a-\u003e(a-\u003eb c)-\u003eb(Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e(a-\u003em b)-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:forM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results. Equivalent to \u003ccode\u003eflip \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e (a -\u003e m b) -\u003e m ()",
        "fct-source": "src/Data-Vector.html#forM_",
        "fct-type": "function",
        "title": "forM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results Equivalent to flip mapM",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "forM_",
        "normalized": "Vector a-\u003e(a-\u003eb c)-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003e(a-\u003em b)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:force",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the argument but force it not to retain any extra memory,\n possibly by copying it.\n\u003c/p\u003e\u003cp\u003eThis is especially useful when dealing with slices. For example:\n\u003c/p\u003e\u003cpre\u003e force (slice 0 2 \u003chuge vector\u003e)\n\u003c/pre\u003e\u003cp\u003eHere, the slice retains a reference to the huge vector. Forcing it creates\n a copy of just the elements that belong to the slice and allows the huge\n vector to be garbage collected.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#force",
        "fct-type": "function",
        "title": "force"
      },
      "index": {
        "description": "Yield the argument but force it not to retain any extra memory possibly by copying it This is especially useful when dealing with slices For example force slice huge vector Here the slice retains reference to the huge vector Forcing it creates copy of just the elements that belong to the slice and allows the huge vector to be garbage collected",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "force",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:freeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield an immutable copy of the mutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector.html#freeze",
        "fct-type": "function",
        "title": "freeze"
      },
      "index": {
        "description": "Yield an immutable copy of the mutable vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "freeze",
        "normalized": "MVector(PrimState a)b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "MVector(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a list to a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "[a] -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Convert list to vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "fromList",
        "normalized": "[a]-\u003eVector a",
        "package": "vector",
        "partial": "List",
        "signature": "[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:fromListN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a vector\n\u003c/p\u003e\u003cpre\u003e\n fromListN n xs = \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e [a] -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#fromListN",
        "fct-type": "function",
        "title": "fromListN"
      },
      "index": {
        "description": "Convert the first elements of list to vector fromListN xs fromList take xs",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "fromListN",
        "normalized": "Int-\u003e[a]-\u003eVector a",
        "package": "vector",
        "partial": "List",
        "signature": "Int-\u003e[a]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:generate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the function to\n each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e a) -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#generate",
        "fct-type": "function",
        "title": "generate"
      },
      "index": {
        "description": "Construct vector of the given length by applying the function to each index",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "generate",
        "normalized": "Int-\u003e(Int-\u003ea)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003ea)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:generateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the monadic\n action to each index\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (Int -\u003e m a) -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector.html#generateM",
        "fct-type": "function",
        "title": "generateM"
      },
      "index": {
        "description": "Construct vector of the given length by applying the monadic action to each index",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "generateM",
        "normalized": "Int-\u003e(Int-\u003ea b)-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(Int-\u003em a)-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:head",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#head",
        "fct-type": "function",
        "title": "head"
      },
      "index": {
        "description": "First element",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "head",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:headM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector.html#headM",
        "fct-type": "function",
        "title": "headM"
      },
      "index": {
        "description": "First element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "headM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:ifilter",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate which is applied to\n values and their indices\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#ifilter",
        "fct-type": "function",
        "title": "ifilter"
      },
      "index": {
        "description": "Drop elements that do not satisfy the predicate which is applied to values and their indices",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "ifilter",
        "normalized": "(Int-\u003ea-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:ifoldl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector.html#ifoldl",
        "fct-type": "function",
        "title": "ifoldl"
      },
      "index": {
        "description": "Left fold function applied to each element and its index",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "ifoldl",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:ifoldl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator (function applied to each element\n and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e a",
        "fct-source": "src/Data-Vector.html#ifoldl%27",
        "fct-type": "function",
        "title": "ifoldl'"
      },
      "index": {
        "description": "Left fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "ifoldl'",
        "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:ifoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold (function applied to each element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector.html#ifoldr",
        "fct-type": "function",
        "title": "ifoldr"
      },
      "index": {
        "description": "Right fold function applied to each element and its index",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "ifoldr",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:ifoldr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with strict accumulator (function applied to each\n element and its index)\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
        "fct-source": "src/Data-Vector.html#ifoldr%27",
        "fct-type": "function",
        "title": "ifoldr'"
      },
      "index": {
        "description": "Right fold with strict accumulator function applied to each element and its index",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "ifoldr'",
        "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:imap",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply a function to every element of a vector and its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#imap",
        "fct-type": "function",
        "title": "imap"
      },
      "index": {
        "description": "Apply function to every element of vector and its index",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "imap",
        "normalized": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:indexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad.\n\u003c/p\u003e\u003cp\u003eThe monad allows operations to be strict in the vector when necessary.\n Suppose vector copying is implemented like this:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... write mv i (v ! i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, \u003ccode\u003ev ! i\u003c/code\u003e would not be evaluated which means that \u003ccode\u003emv\u003c/code\u003e\n would unnecessarily retain a reference to \u003ccode\u003ev\u003c/code\u003e in each element written.\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e, copying can be implemented like this instead:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... do\n                   x \u003c- indexM v i\n                   write mv i x\n\u003c/pre\u003e\u003cp\u003eHere, no references to \u003ccode\u003ev\u003c/code\u003e are retained because indexing (but \u003cem\u003enot\u003c/em\u003e the\n elements) is evaluated eagerly.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector.html#indexM",
        "fct-type": "function",
        "title": "indexM"
      },
      "index": {
        "description": "Indexing in monad The monad allows operations to be strict in the vector when necessary Suppose vector copying is implemented like this copy mv write mv For lazy vectors would not be evaluated which means that mv would unnecessarily retain reference to in each element written With indexM copying can be implemented like this instead copy mv do indexM write mv Here no references to are retained because indexing but not the elements is evaluated eagerly",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "indexM",
        "normalized": "Vector a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:indexed",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Pair each element in a vector with its index\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector (Int, a)",
        "fct-source": "src/Data-Vector.html#indexed",
        "fct-type": "function",
        "title": "indexed"
      },
      "index": {
        "description": "Pair each element in vector with its index",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "indexed",
        "normalized": "Vector a-\u003eVector(Int,a)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector(Int,a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:init",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#init",
        "fct-type": "function",
        "title": "init"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "init",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:iterateN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#iterateN",
        "fct-type": "function",
        "title": "iterateN"
      },
      "index": {
        "description": "Apply function times to value Zeroth element is original value",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "iterateN",
        "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:izipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with a function that also takes the\n elements' indices.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
        "fct-source": "src/Data-Vector.html#izipWith",
        "fct-type": "function",
        "title": "izipWith"
      },
      "index": {
        "description": "min Zip two vectors with function that also takes the elements indices",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "izipWith",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:izipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors and their indices with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d",
        "fct-source": "src/Data-Vector.html#izipWith3",
        "fct-type": "function",
        "title": "izipWith3"
      },
      "index": {
        "description": "Zip three vectors and their indices with the given function",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "izipWith3",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:izipWith4",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e",
        "fct-source": "src/Data-Vector.html#izipWith4",
        "fct-type": "function",
        "title": "izipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "izipWith4",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:izipWith5",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f",
        "fct-source": "src/Data-Vector.html#izipWith5",
        "fct-type": "function",
        "title": "izipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "izipWith5",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:izipWith6",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector g",
        "fct-source": "src/Data-Vector.html#izipWith6",
        "fct-type": "function",
        "title": "izipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "izipWith6",
        "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g",
        "package": "vector",
        "partial": "With",
        "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:last",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#last",
        "fct-type": "function",
        "title": "last"
      },
      "index": {
        "description": "Last element",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "last",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:lastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector.html#lastM",
        "fct-type": "function",
        "title": "lastM"
      },
      "index": {
        "description": "Last element of vector in monad See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "lastM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:length",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the length of the vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector.html#length",
        "fct-type": "function",
        "title": "length"
      },
      "index": {
        "description": "Yield the length of the vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "length",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:map",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Map a function over a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b) -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#map",
        "fct-type": "function",
        "title": "map"
      },
      "index": {
        "description": "Map function over vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "map",
        "normalized": "(a-\u003eb)-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb)-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:mapM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of the vector, yielding a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Vector a -\u003e m (Vector b)",
        "fct-source": "src/Data-Vector.html#mapM",
        "fct-type": "function",
        "title": "mapM"
      },
      "index": {
        "description": "Apply the monadic action to all elements of the vector yielding vector of results",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "mapM",
        "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb(Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eVector a-\u003em(Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:mapM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply the monadic action to all elements of a vector and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e m b) -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector.html#mapM_",
        "fct-type": "function",
        "title": "mapM_"
      },
      "index": {
        "description": "Apply the monadic action to all elements of vector and ignore the results",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "mapM_",
        "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb()",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003em b)-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:maxIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector.html#maxIndex",
        "fct-type": "function",
        "title": "maxIndex"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "maxIndex",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:maxIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e Int",
        "fct-source": "src/Data-Vector.html#maxIndexBy",
        "fct-type": "function",
        "title": "maxIndexBy"
      },
      "index": {
        "description": "Yield the index of the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "maxIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:maximum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#maximum",
        "fct-type": "function",
        "title": "maximum"
      },
      "index": {
        "description": "Yield the maximum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "maximum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:maximumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#maximumBy",
        "fct-type": "function",
        "title": "maximumBy"
      },
      "index": {
        "description": "Yield the maximum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "maximumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:minIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int",
        "fct-source": "src/Data-Vector.html#minIndex",
        "fct-type": "function",
        "title": "minIndex"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "minIndex",
        "normalized": "Vector a-\u003eInt",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:minIndexBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e Int",
        "fct-source": "src/Data-Vector.html#minIndexBy",
        "fct-type": "function",
        "title": "minIndexBy"
      },
      "index": {
        "description": "Yield the index of the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "minIndexBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt",
        "package": "vector",
        "partial": "Index By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003eInt"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:minimum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#minimum",
        "fct-type": "function",
        "title": "minimum"
      },
      "index": {
        "description": "Yield the minimum element of the vector The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "minimum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:minimumBy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e Ordering) -\u003e Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#minimumBy",
        "fct-type": "function",
        "title": "minimumBy"
      },
      "index": {
        "description": "Yield the minimum element of the vector according to the given comparison function The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "minimumBy",
        "normalized": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea",
        "package": "vector",
        "partial": "By",
        "signature": "(a-\u003ea-\u003eOrdering)-\u003eVector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:modify",
      "description": {
        "fct-descr": "\u003cp\u003eApply a destructive operation to a vector. The operation will be\n performed in place if it is safe to do so and will modify a copy of the\n vector otherwise.\n\u003c/p\u003e\u003cpre\u003e\n modify (\\v -\u003e write v 0 'x') (\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e 3 'a') = \u003c'x','a','a'\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(forall s.  MVector s a -\u003e ST s ()) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#modify",
        "fct-type": "function",
        "title": "modify"
      },
      "index": {
        "description": "Apply destructive operation to vector The operation will be performed in place if it is safe to do so and will modify copy of the vector otherwise modify write replicate",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "modify",
        "normalized": "(a b MVector c d-\u003eST c())-\u003eVector d-\u003eVector d",
        "package": "vector",
        "partial": "",
        "signature": "(forall s. MVector s a-\u003eST s())-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:notElem",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector does not contain an element (inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector.html#notElem",
        "fct-type": "function",
        "title": "notElem"
      },
      "index": {
        "description": "Check if the vector does not contain an element inverse of elem",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "notElem",
        "normalized": "a-\u003eVector a-\u003eBool",
        "package": "vector",
        "partial": "Elem",
        "signature": "a-\u003eVector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a vector if empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Bool",
        "fct-source": "src/Data-Vector.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Test whether vector if empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "null",
        "normalized": "Vector a-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:or",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector Bool -\u003e Bool",
        "fct-source": "src/Data-Vector.html#or",
        "fct-type": "function",
        "title": "or"
      },
      "index": {
        "description": "Check if any element is True",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "or",
        "normalized": "Vector Bool-\u003eBool",
        "package": "vector",
        "partial": "",
        "signature": "Vector Bool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:partition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't. The\n relative order of the elements is preserved at the cost of a sometimes\n reduced performance compared to \u003ccode\u003e\u003ca\u003eunstablePartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector.html#partition",
        "fct-type": "function",
        "title": "partition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The relative order of the elements is preserved at the cost of sometimes reduced performance compared to unstablePartition",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "partition",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:postscanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan\n\u003c/p\u003e\u003cpre\u003e\n postscanl f z = \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003epostscanl (+) 0 \u003c1,2,3,4\u003e = \u003c1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#postscanl",
        "fct-type": "function",
        "title": "postscanl"
      },
      "index": {
        "description": "Scan postscanl tail scanl Example postscanl",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "postscanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:postscanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#postscanl%27",
        "fct-type": "function",
        "title": "postscanl'"
      },
      "index": {
        "description": "Scan with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "postscanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:postscanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#postscanr",
        "fct-type": "function",
        "title": "postscanr"
      },
      "index": {
        "description": "Right-to-left scan",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "postscanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:postscanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#postscanr%27",
        "fct-type": "function",
        "title": "postscanr'"
      },
      "index": {
        "description": "Right-to-left scan with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "postscanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:prescanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanl f z = \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003eprescanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#prescanl",
        "fct-type": "function",
        "title": "prescanl"
      },
      "index": {
        "description": "Prescan prescanl init scanl Example prescanl",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "prescanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:prescanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#prescanl%27",
        "fct-type": "function",
        "title": "prescanl'"
      },
      "index": {
        "description": "Prescan with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "prescanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:prescanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanr f z = \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eprescanl\u003c/a\u003e\u003c/code\u003e (flip f) z . \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#prescanr",
        "fct-type": "function",
        "title": "prescanr"
      },
      "index": {
        "description": "Right-to-left prescan prescanr reverse prescanl flip reverse",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "prescanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:prescanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#prescanr%27",
        "fct-type": "function",
        "title": "prescanr'"
      },
      "index": {
        "description": "Right-to-left prescan with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "prescanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:product",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the produce of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#product",
        "fct-type": "function",
        "title": "product"
      },
      "index": {
        "description": "Compute the produce of the elements",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "product",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:replicate",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Vector of the given length with the same value in each position\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#replicate",
        "fct-type": "function",
        "title": "replicate"
      },
      "index": {
        "description": "Vector of the given length with the same value in each position",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "replicate",
        "normalized": "Int-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:replicateM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Execute the monadic action the given number of times and store the\n results in a vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e m a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector.html#replicateM",
        "fct-type": "function",
        "title": "replicateM"
      },
      "index": {
        "description": "Execute the monadic action the given number of times and store the results in vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "replicateM",
        "normalized": "Int-\u003ea b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003em a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:reverse",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Reverse a vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#reverse",
        "fct-type": "function",
        "title": "reverse"
      },
      "index": {
        "description": "Reverse vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "reverse",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:scanl",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan\n\u003c/p\u003e\u003cpre\u003e scanl f z \u003cx1,...,xn\u003e = \u003cy1,...,y(n+1)\u003e\n   where y1 = z\n         yi = f y(i-1) x(i-1)\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003escanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#scanl",
        "fct-type": "function",
        "title": "scanl"
      },
      "index": {
        "description": "Haskell-style scan scanl x1 xn y1 where y1 yi i-1 i-1 Example scanl",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "scanl",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:scanl-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#scanl%27",
        "fct-type": "function",
        "title": "scanl'"
      },
      "index": {
        "description": "Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "scanl'",
        "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:scanl1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector\n\u003c/p\u003e\u003cpre\u003e scanl f \u003cx1,...,xn\u003e = \u003cy1,...,yn\u003e\n   where y1 = x1\n         yi = f y(i-1) xi\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#scanl1",
        "fct-type": "function",
        "title": "scanl1"
      },
      "index": {
        "description": "Scan over non-empty vector scanl x1 xn y1 yn where y1 x1 yi i-1 xi",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "scanl1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:scanl1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector with a strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#scanl1%27",
        "fct-type": "function",
        "title": "scanl1'"
      },
      "index": {
        "description": "Scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "scanl1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:scanr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#scanr",
        "fct-type": "function",
        "title": "scanr"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "scanr",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:scanr-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan with strict accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e Vector b",
        "fct-source": "src/Data-Vector.html#scanr%27",
        "fct-type": "function",
        "title": "scanr'"
      },
      "index": {
        "description": "Right-to-left Haskell-style scan with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "scanr'",
        "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eVector b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:scanr1",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#scanr1",
        "fct-type": "function",
        "title": "scanr1"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "scanr1",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:scanr1-39-",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector with a strict\n accumulator\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e a -\u003e a) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#scanr1%27",
        "fct-type": "function",
        "title": "scanr1'"
      },
      "index": {
        "description": "Right-to-left scan over non-empty vector with strict accumulator",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "scanr1'",
        "normalized": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003ea-\u003ea)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:sequence",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate each action and collect the results\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector (m a) -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector.html#sequence",
        "fct-type": "function",
        "title": "sequence"
      },
      "index": {
        "description": "Evaluate each action and collect the results",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "sequence",
        "normalized": "Vector(a b)-\u003ea(Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(m a)-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:sequence_",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluate each action and discard the results\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector (m a) -\u003e m ()",
        "fct-source": "src/Data-Vector.html#sequence_",
        "fct-type": "function",
        "title": "sequence_"
      },
      "index": {
        "description": "Evaluate each action and discard the results",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "sequence_",
        "normalized": "Vector(a b)-\u003ea()",
        "package": "vector",
        "partial": "",
        "signature": "Vector(m a)-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Vector with exactly one element\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "Vector with exactly one element",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "singleton",
        "normalized": "a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:slice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying it. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "slice"
      },
      "index": {
        "description": "Yield slice of the vector without copying it The vector must contain at least elements",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "slice",
        "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eInt-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:snoc",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append an element\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#snoc",
        "fct-type": "function",
        "title": "snoc"
      },
      "index": {
        "description": "Append an element",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "snoc",
        "normalized": "Vector a-\u003ea-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:span",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector into the longest prefix of elements that satisfy\n the predicate and the rest without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector.html#span",
        "fct-type": "function",
        "title": "span"
      },
      "index": {
        "description": "Split the vector into the longest prefix of elements that satisfy the predicate and the rest without copying",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "span",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:splitAt",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements paired with the remainder without copying.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e n v\u003c/code\u003e is equivalent to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n v, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e n v)\u003c/code\u003e\n but slightly more efficient.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector.html#splitAt",
        "fct-type": "function",
        "title": "splitAt"
      },
      "index": {
        "description": "Yield the first elements paired with the remainder without copying Note that splitAt is equivalent to take drop but slightly more efficient",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "splitAt",
        "normalized": "Int-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "At",
        "signature": "Int-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:sum",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the sum of the elements\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#sum",
        "fct-type": "function",
        "title": "sum"
      },
      "index": {
        "description": "Compute the sum of the elements",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "sum",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:tail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#tail",
        "fct-type": "function",
        "title": "tail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "tail",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:take",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield at the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector may\n contain less than \u003ccode\u003en\u003c/code\u003e elements in which case it is returned unchanged.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#take",
        "fct-type": "function",
        "title": "take"
      },
      "index": {
        "description": "Yield at the first elements without copying The vector may contain less than elements in which case it is returned unchanged",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "take",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:takeWhile",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the longest prefix of elements satisfying the predicate\n without copying.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#takeWhile",
        "fct-type": "function",
        "title": "takeWhile"
      },
      "index": {
        "description": "Yield the longest prefix of elements satisfying the predicate without copying",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "takeWhile",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "While",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:thaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a mutable copy of the immutable vector.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector.html#thaw",
        "fct-type": "function",
        "title": "thaw"
      },
      "index": {
        "description": "Yield mutable copy of the immutable vector",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "thaw",
        "normalized": "Vector a-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a vector to a list\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e [a]",
        "fct-source": "src/Data-Vector.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Convert vector to list",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "toList",
        "normalized": "Vector a-\u003e[a]",
        "package": "vector",
        "partial": "List",
        "signature": "Vector a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unfoldr",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector by repeatedly applying the generator function\n to a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the next element and the\n new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\n -\u003e if n == 0 then Nothing else Just (n,n-1)) 10\n  = \u003c10,9,8,7,6,5,4,3,2,1\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unfoldr",
        "fct-type": "function",
        "title": "unfoldr"
      },
      "index": {
        "description": "Construct vector by repeatedly applying the generator function to seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldr if then Nothing else Just n-1",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unfoldr",
        "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unfoldrN",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with at most \u003ccode\u003en\u003c/code\u003e by repeatedly applying the\n generator function to the a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the\n next element and the new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldrN 3 (\\n -\u003e Just (n,n-1)) 10 = \u003c10,9,8\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e (b -\u003e Maybe (a, b)) -\u003e b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unfoldrN",
        "fct-type": "function",
        "title": "unfoldrN"
      },
      "index": {
        "description": "Construct vector with at most by repeatedly applying the generator function to the seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldrN Just n-1",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unfoldrN",
        "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003eVector b",
        "package": "vector",
        "partial": "",
        "signature": "Int-\u003e(b-\u003eMaybe(a,b))-\u003eb-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeAccum",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccum\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e [(Int, b)] -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeAccum",
        "fct-type": "function",
        "title": "unsafeAccum"
      },
      "index": {
        "description": "Same as accum but without bounds checking",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeAccum",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a",
        "package": "vector",
        "partial": "Accum",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003e[(Int,b)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeAccumulate",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e Vector (Int, b) -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeAccumulate",
        "fct-type": "function",
        "title": "unsafeAccumulate"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeAccumulate",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector(Int,b)-\u003eVector a",
        "package": "vector",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector(Int,b)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeAccumulate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e a) -\u003e Vector a -\u003e Vector Int -\u003e Vector b -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeAccumulate_",
        "fct-type": "function",
        "title": "unsafeAccumulate_"
      },
      "index": {
        "description": "Same as accumulate but without bounds checking",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeAccumulate_",
        "normalized": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a",
        "package": "vector",
        "partial": "Accumulate",
        "signature": "(a-\u003eb-\u003ea)-\u003eVector a-\u003eVector Int-\u003eVector b-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeBackpermute",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ebackpermute\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeBackpermute",
        "fct-type": "function",
        "title": "unsafeBackpermute"
      },
      "index": {
        "description": "Same as backpermute but without bounds checking",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeBackpermute",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a",
        "package": "vector",
        "partial": "Backpermute",
        "signature": "Vector a-\u003eVector Int-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeCopy",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length. This is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e Vector a -\u003e m ()",
        "fct-source": "src/Data-Vector.html#unsafeCopy",
        "fct-type": "function",
        "title": "unsafeCopy"
      },
      "index": {
        "description": "Copy an immutable vector into mutable one The two vectors must have the same length This is not checked",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeCopy",
        "normalized": "MVector(PrimState a)b-\u003eVector b-\u003ea()",
        "package": "vector",
        "partial": "Copy",
        "signature": "MVector(PrimState m)a-\u003eVector a-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeDrop",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector\n must contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeDrop",
        "fct-type": "function",
        "title": "unsafeDrop"
      },
      "index": {
        "description": "Yield all but the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeDrop",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Drop",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeFreeze",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe convert a mutable vector to an immutable one without\n copying. The mutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "MVector (PrimState m) a -\u003e m (Vector a)",
        "fct-source": "src/Data-Vector.html#unsafeFreeze",
        "fct-type": "function",
        "title": "unsafeFreeze"
      },
      "index": {
        "description": "Unsafe convert mutable vector to an immutable one without copying The mutable vector may not be used after this operation",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeFreeze",
        "normalized": "MVector(PrimState a)b-\u003ea(Vector b)",
        "package": "vector",
        "partial": "Freeze",
        "signature": "MVector(PrimState m)a-\u003em(Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeHead",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#unsafeHead",
        "fct-type": "function",
        "title": "unsafeHead"
      },
      "index": {
        "description": "First element without checking if the vector is empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeHead",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "Head",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeHeadM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector.html#unsafeHeadM",
        "fct-type": "function",
        "title": "unsafeHeadM"
      },
      "index": {
        "description": "First element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeHeadM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "Head",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeIndex",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe indexing without bounds checking\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e a",
        "fct-source": "src/Data-Vector.html#unsafeIndex",
        "fct-type": "function",
        "title": "unsafeIndex"
      },
      "index": {
        "description": "Unsafe indexing without bounds checking",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeIndex",
        "normalized": "Vector a-\u003eInt-\u003ea",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeIndexM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad without bounds checks. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Int -\u003e m a",
        "fct-source": "src/Data-Vector.html#unsafeIndexM",
        "fct-type": "function",
        "title": "unsafeIndexM"
      },
      "index": {
        "description": "Indexing in monad without bounds checks See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeIndexM",
        "normalized": "Vector a-\u003eInt-\u003eb a",
        "package": "vector",
        "partial": "Index",
        "signature": "Vector a-\u003eInt-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeInit",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the last element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeInit",
        "fct-type": "function",
        "title": "unsafeInit"
      },
      "index": {
        "description": "Yield all but the last element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeInit",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "Init",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeLast",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element without checking if the vector is empty\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e a",
        "fct-source": "src/Data-Vector.html#unsafeLast",
        "fct-type": "function",
        "title": "unsafeLast"
      },
      "index": {
        "description": "Last element without checking if the vector is empty",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeLast",
        "normalized": "Vector a-\u003ea",
        "package": "vector",
        "partial": "Last",
        "signature": "Vector a-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeLastM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m a",
        "fct-source": "src/Data-Vector.html#unsafeLastM",
        "fct-type": "function",
        "title": "unsafeLastM"
      },
      "index": {
        "description": "Last element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeLastM",
        "normalized": "Vector a-\u003eb a",
        "package": "vector",
        "partial": "Last",
        "signature": "Vector a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeSlice",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield a slice of the vector without copying. The vector must\n contain at least \u003ccode\u003ei+n\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int-\u003e Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "unsafeSlice"
      },
      "index": {
        "description": "Yield slice of the vector without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeSlice",
        "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Slice",
        "signature": "Int-\u003eInt-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeTail",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield all but the first element without copying. The vector may not\n be empty but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeTail",
        "fct-type": "function",
        "title": "unsafeTail"
      },
      "index": {
        "description": "Yield all but the first element without copying The vector may not be empty but this is not checked",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeTail",
        "normalized": "Vector a-\u003eVector a",
        "package": "vector",
        "partial": "Tail",
        "signature": "Vector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeTake",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the first \u003ccode\u003en\u003c/code\u003e elements without copying. The vector must\n contain at least \u003ccode\u003en\u003c/code\u003e elements but this is not checked.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeTake",
        "fct-type": "function",
        "title": "unsafeTake"
      },
      "index": {
        "description": "Yield the first elements without copying The vector must contain at least elements but this is not checked",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeTake",
        "normalized": "Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Take",
        "signature": "Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeThaw",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely convert an immutable vector to a mutable one without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e m (MVector (PrimState m) a)",
        "fct-source": "src/Data-Vector.html#unsafeThaw",
        "fct-type": "function",
        "title": "unsafeThaw"
      },
      "index": {
        "description": "Unsafely convert an immutable vector to mutable one without copying The immutable vector may not be used after this operation",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeThaw",
        "normalized": "Vector a-\u003eb(MVector(PrimState b)a)",
        "package": "vector",
        "partial": "Thaw",
        "signature": "Vector a-\u003em(MVector(PrimState m)a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeUpd",
      "description": {
        "fct-descr": "\u003cp\u003eSame as (\u003ccode\u003e\u003ca\u003e//\u003c/a\u003e\u003c/code\u003e) but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e [(Int, a)] -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeUpd",
        "fct-type": "function",
        "title": "unsafeUpd"
      },
      "index": {
        "description": "Same as but without bounds checking",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeUpd",
        "normalized": "Vector a-\u003e[(Int,a)]-\u003eVector a",
        "package": "vector",
        "partial": "Upd",
        "signature": "Vector a-\u003e[(Int,a)]-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeUpdate",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector (Int, a) -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeUpdate",
        "fct-type": "function",
        "title": "unsafeUpdate"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeUpdate",
        "normalized": "Vector a-\u003eVector(Int,a)-\u003eVector a",
        "package": "vector",
        "partial": "Update",
        "signature": "Vector a-\u003eVector(Int,a)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unsafeUpdate_",
      "description": {
        "fct-descr": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector Int -\u003e Vector a -\u003e Vector a",
        "fct-source": "src/Data-Vector.html#unsafeUpdate_",
        "fct-type": "function",
        "title": "unsafeUpdate_"
      },
      "index": {
        "description": "Same as update but without bounds checking",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unsafeUpdate_",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "Update",
        "signature": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unstablePartition",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Split the vector in two parts, the first one containing those\n elements that satisfy the predicate and the second one those that don't.\n The order of the elements is not preserved but the operation is often\n faster than \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e Bool) -\u003e Vector a -\u003e (Vector a, Vector a)",
        "fct-source": "src/Data-Vector.html#unstablePartition",
        "fct-type": "function",
        "title": "unstablePartition"
      },
      "index": {
        "description": "Split the vector in two parts the first one containing those elements that satisfy the predicate and the second one those that don The order of the elements is not preserved but the operation is often faster than partition",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unstablePartition",
        "normalized": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)",
        "package": "vector",
        "partial": "Partition",
        "signature": "(a-\u003eBool)-\u003eVector a-\u003e(Vector a,Vector a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unzip",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Unzip a vector of pairs.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b) -\u003e (Vector a, Vector b)",
        "fct-source": "src/Data-Vector.html#unzip",
        "fct-type": "function",
        "title": "unzip"
      },
      "index": {
        "description": "min Unzip vector of pairs",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unzip",
        "normalized": "Vector(a,b)-\u003e(Vector a,Vector b)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b)-\u003e(Vector a,Vector b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unzip3",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b, c) -\u003e (Vector a, Vector b, Vector c)",
        "fct-source": "src/Data-Vector.html#unzip3",
        "fct-type": "function",
        "title": "unzip3"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unzip3",
        "normalized": "Vector(a,b,c)-\u003e(Vector a,Vector b,Vector c)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b,c)-\u003e(Vector a,Vector b,Vector c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unzip4",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b, c, d) -\u003e (Vector a, Vector b, Vector c, Vector d)",
        "fct-source": "src/Data-Vector.html#unzip4",
        "fct-type": "function",
        "title": "unzip4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unzip4",
        "normalized": "Vector(a,b,c,d)-\u003e(Vector a,Vector b,Vector c,Vector d)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b,c,d)-\u003e(Vector a,Vector b,Vector c,Vector d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unzip5",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b, c, d, e) -\u003e (Vector a, Vector b, Vector c, Vector d, Vector e)",
        "fct-source": "src/Data-Vector.html#unzip5",
        "fct-type": "function",
        "title": "unzip5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unzip5",
        "normalized": "Vector(a,b,c,d,e)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b,c,d,e)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:unzip6",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector (a, b, c, d, e, f) -\u003e (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)",
        "fct-source": "src/Data-Vector.html#unzip6",
        "fct-type": "function",
        "title": "unzip6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "unzip6",
        "normalized": "Vector(a,b,c,d,e,f)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e,Vector f)",
        "package": "vector",
        "partial": "",
        "signature": "Vector(a,b,c,d,e,f)-\u003e(Vector a,Vector b,Vector c,Vector d,Vector e,Vector f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:update",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the vector of index/value pairs,\n replace the vector element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update \u003c5,9,2,7\u003e \u003c(2,1),(0,3),(2,8)\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e Vector (Int, a)-\u003e Vector a",
        "fct-type": "function",
        "title": "update"
      },
      "index": {
        "description": "For each pair from the vector of index value pairs replace the vector element at position by update",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "update",
        "normalized": "Vector a-\u003eVector(Int,a)-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector(Int,a)-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:update_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003ea\u003c/code\u003e from the value vector, replace the element of the\n initial vector at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update_ \u003c5,9,2,7\u003e  \u003c2,0,2\u003e \u003c1,3,8\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e provides the same functionality and is usually more\n convenient.\n\u003c/p\u003e\u003cpre\u003e\n update_ xs is ys = \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e xs (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is ys)\n\u003c/pre\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a-\u003e Vector Int-\u003e Vector a-\u003e Vector a",
        "fct-type": "function",
        "title": "update_"
      },
      "index": {
        "description": "min n1 n2 For each index from the index vector and the corresponding value from the value vector replace the element of the initial vector at position by update The function update provides the same functionality and is usually more convenient update xs is ys update xs zip is ys",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "update_",
        "normalized": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector Int-\u003eVector a-\u003eVector a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zip",
      "description": {
        "fct-descr": "\u003cp\u003eElementwise pairing of array elements. \n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector (a, b)",
        "fct-source": "src/Data-Vector.html#zip",
        "fct-type": "function",
        "title": "zip"
      },
      "index": {
        "description": "Elementwise pairing of array elements",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zip",
        "normalized": "Vector a-\u003eVector b-\u003eVector(a,b)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector(a,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zip3",
      "description": {
        "fct-descr": "\u003cp\u003ezip together three vectors into a vector of triples\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector (a, b, c)",
        "fct-source": "src/Data-Vector.html#zip3",
        "fct-type": "function",
        "title": "zip3"
      },
      "index": {
        "description": "zip together three vectors into vector of triples",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zip3",
        "normalized": "Vector a-\u003eVector b-\u003eVector c-\u003eVector(a,b,c)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector c-\u003eVector(a,b,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zip4",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector (a, b, c, d)",
        "fct-source": "src/Data-Vector.html#zip4",
        "fct-type": "function",
        "title": "zip4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zip4",
        "normalized": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector(a,b,c,d)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector(a,b,c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zip5",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector (a, b, c, d, e)",
        "fct-source": "src/Data-Vector.html#zip5",
        "fct-type": "function",
        "title": "zip5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zip5",
        "normalized": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector(a,b,c,d,e)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector(a,b,c,d,e)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zip6",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector (a, b, c, d, e, f)",
        "fct-source": "src/Data-Vector.html#zip6",
        "fct-type": "function",
        "title": "zip6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zip6",
        "normalized": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector(a,b,c,d,e,f)",
        "package": "vector",
        "partial": "",
        "signature": "Vector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector(a,b,c,d,e,f)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zipWith",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
        "fct-source": "src/Data-Vector.html#zipWith",
        "fct-type": "function",
        "title": "zipWith"
      },
      "index": {
        "description": "min Zip two vectors with the given function",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zipWith",
        "normalized": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zipWith3",
      "description": {
        "fct-descr": "\u003cp\u003eZip three vectors with the given function.\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d",
        "fct-source": "src/Data-Vector.html#zipWith3",
        "fct-type": "function",
        "title": "zipWith3"
      },
      "index": {
        "description": "Zip three vectors with the given function",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zipWith3",
        "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zipWith4",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e",
        "fct-source": "src/Data-Vector.html#zipWith4",
        "fct-type": "function",
        "title": "zipWith4"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zipWith4",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zipWith5",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f",
        "fct-source": "src/Data-Vector.html#zipWith5",
        "fct-type": "function",
        "title": "zipWith5"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zipWith5",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zipWith6",
      "description": {
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e Vector a -\u003e Vector b -\u003e Vector c -\u003e Vector d -\u003e Vector e -\u003e Vector f -\u003e Vector g",
        "fct-source": "src/Data-Vector.html#zipWith6",
        "fct-type": "function",
        "title": "zipWith6"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zipWith6",
        "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eVector a-\u003eVector b-\u003eVector c-\u003eVector d-\u003eVector e-\u003eVector f-\u003eVector g"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zipWithM",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and yield a\n vector of results\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Vector a -\u003e Vector b -\u003e m (Vector c)",
        "fct-source": "src/Data-Vector.html#zipWithM",
        "fct-type": "function",
        "title": "zipWithM"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and yield vector of results",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zipWithM",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eVector a-\u003eVector b-\u003ec(Vector d)",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eVector a-\u003eVector b-\u003em(Vector c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:zipWithM_",
      "description": {
        "fct-descr": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and ignore the\n results\n\u003c/p\u003e",
        "fct-module": "Data.Vector",
        "fct-package": "vector",
        "fct-signature": "(a -\u003e b -\u003e m c) -\u003e Vector a -\u003e Vector b -\u003e m ()",
        "fct-source": "src/Data-Vector.html#zipWithM_",
        "fct-type": "function",
        "title": "zipWithM_"
      },
      "index": {
        "description": "min Zip the two vectors with the monadic action and ignore the results",
        "hierarchy": "Data Vector",
        "module": "Data.Vector",
        "name": "zipWithM_",
        "normalized": "(a-\u003eb-\u003ec d)-\u003eVector a-\u003eVector b-\u003ec()",
        "package": "vector",
        "partial": "With",
        "signature": "(a-\u003eb-\u003em c)-\u003eVector a-\u003eVector b-\u003em()"
      }
    }
  }
]
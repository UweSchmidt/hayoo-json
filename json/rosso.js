[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Control-Monad-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eControl.Monad\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Control.Monad.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Control-Monad-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends Control.Monad",
        "hierarchy": "Control Monad Rosso1",
        "module": "Control.Monad.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Control-Monad-Rosso1.html#v:concatMapM",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic generalisation of \u003ccode\u003e\u003ca\u003econcatMap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "(a -\u003e m [b]) -\u003e [a] -\u003e m [b]",
        "fct-source": "src/Control-Monad-Rosso1.html#concatMapM",
        "fct-type": "function",
        "title": "concatMapM"
      },
      "index": {
        "description": "Monadic generalisation of concatMap",
        "hierarchy": "Control Monad Rosso1",
        "module": "Control.Monad.Rosso1",
        "name": "concatMapM",
        "normalized": "(a-\u003eb[c])-\u003e[a]-\u003eb[c]",
        "package": "rosso",
        "partial": "Map",
        "signature": "(a-\u003em[b])-\u003e[a]-\u003em[b]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Control-Monad-Rosso1.html#v:ifM",
      "description": {
        "fct-descr": "\u003cp\u003eMonadic generalisation of 'if'.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "m Bool -\u003e m a -\u003e m a -\u003e m a",
        "fct-source": "src/Control-Monad-Rosso1.html#ifM",
        "fct-type": "function",
        "title": "ifM"
      },
      "index": {
        "description": "Monadic generalisation of if",
        "hierarchy": "Control Monad Rosso1",
        "module": "Control.Monad.Rosso1",
        "name": "ifM",
        "normalized": "a Bool-\u003ea b-\u003ea b-\u003ea b",
        "package": "rosso",
        "partial": "",
        "signature": "m Bool-\u003em a-\u003em a-\u003em a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Control-Monad-Rosso1.html#v:nop",
      "description": {
        "fct-descr": "\u003cp\u003eSynonym for \u003ccode\u003ereturn ()\u003c/code\u003e\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "m ()",
        "fct-source": "src/Control-Monad-Rosso1.html#nop",
        "fct-type": "function",
        "title": "nop"
      },
      "index": {
        "description": "Synonym for return",
        "hierarchy": "Control Monad Rosso1",
        "module": "Control.Monad.Rosso1",
        "name": "nop",
        "normalized": "a()",
        "package": "rosso",
        "partial": "",
        "signature": "m()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Control-Monad-Rosso1.html#v:whenM",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ewhen\u003c/a\u003e\u003c/code\u003e, but the condition is also monadic.\n\u003c/p\u003e",
        "fct-module": "Control.Monad.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "m Bool -\u003e m () -\u003e m ()",
        "fct-source": "src/Control-Monad-Rosso1.html#whenM",
        "fct-type": "function",
        "title": "whenM"
      },
      "index": {
        "description": "Like when but the condition is also monadic",
        "hierarchy": "Control Monad Rosso1",
        "module": "Control.Monad.Rosso1",
        "name": "whenM",
        "normalized": "a Bool-\u003ea()-\u003ea()",
        "package": "rosso",
        "partial": "",
        "signature": "m Bool-\u003em()-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Bool-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eData.Bool\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Bool.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Data-Bool-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends Data.Bool",
        "hierarchy": "Data Bool Rosso1",
        "module": "Data.Bool.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Bool-Rosso1.html#v:xor",
      "description": {
        "fct-descr": "\u003cp\u003eExclusive OR.\n\u003c/p\u003e",
        "fct-module": "Data.Bool.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "Bool -\u003e Bool -\u003e Bool",
        "fct-source": "src/Data-Bool-Rosso1.html#xor",
        "fct-type": "function",
        "title": "xor"
      },
      "index": {
        "description": "Exclusive OR",
        "hierarchy": "Data Bool Rosso1",
        "module": "Data.Bool.Rosso1",
        "name": "xor",
        "normalized": "Bool-\u003eBool-\u003eBool",
        "package": "rosso",
        "partial": "",
        "signature": "Bool-\u003eBool-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Either-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eData.Either\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Either.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Data-Either-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends Data.Either",
        "hierarchy": "Data Either Rosso1",
        "module": "Data.Either.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Either-Rosso1.html#v:mapLeft",
      "description": {
        "fct-descr": "\u003cp\u003eApplies a function to the left component.\n\u003c/p\u003e",
        "fct-module": "Data.Either.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "(a -\u003e c) -\u003e Either a b -\u003e Either c b",
        "fct-source": "src/Data-Either-Rosso1.html#mapLeft",
        "fct-type": "function",
        "title": "mapLeft"
      },
      "index": {
        "description": "Applies function to the left component",
        "hierarchy": "Data Either Rosso1",
        "module": "Data.Either.Rosso1",
        "name": "mapLeft",
        "normalized": "(a-\u003eb)-\u003eEither a c-\u003eEither b c",
        "package": "rosso",
        "partial": "Left",
        "signature": "(a-\u003ec)-\u003eEither a b-\u003eEither c b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Either-Rosso1.html#v:mapRight",
      "description": {
        "fct-descr": "\u003cp\u003eApplies a function to the right component.\n\u003c/p\u003e",
        "fct-module": "Data.Either.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "(b -\u003e c) -\u003e Either a b -\u003e Either a c",
        "fct-source": "src/Data-Either-Rosso1.html#mapRight",
        "fct-type": "function",
        "title": "mapRight"
      },
      "index": {
        "description": "Applies function to the right component",
        "hierarchy": "Data Either Rosso1",
        "module": "Data.Either.Rosso1",
        "name": "mapRight",
        "normalized": "(a-\u003eb)-\u003eEither c a-\u003eEither c b",
        "package": "rosso",
        "partial": "Right",
        "signature": "(b-\u003ec)-\u003eEither a b-\u003eEither a c"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-List-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eData.List\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.List.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Data-List-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends Data.List",
        "hierarchy": "Data List Rosso1",
        "module": "Data.List.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-List-Rosso1.html#v:alistCollect",
      "description": {
        "fct-descr": "\u003cp\u003eCollects together the list of values corresponding to each unique\n key in an association list. Entries in the output list are arranged\n in ascending order of key. The ordering of values corresponding to\n a given key is preserved from input to output.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ealistCollect [(7, 'a'), (3, 'a'), (5, 'x'), (3, 'a'), (3, 'b')]\n\u003c/code\u003e\u003c/strong\u003e[(3,\"aab\"),(5,\"x\"),(7,\"a\")]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[(k, a)] -\u003e [(k, [a])]",
        "fct-source": "src/Data-List-Rosso1.html#alistCollect",
        "fct-type": "function",
        "title": "alistCollect"
      },
      "index": {
        "description": "Collects together the list of values corresponding to each unique key in an association list Entries in the output list are arranged in ascending order of key The ordering of values corresponding to given key is preserved from input to output alistCollect aab",
        "hierarchy": "Data List Rosso1",
        "module": "Data.List.Rosso1",
        "name": "alistCollect",
        "normalized": "[(a,b)]-\u003e[(a,[b])]",
        "package": "rosso",
        "partial": "Collect",
        "signature": "[(k,a)]-\u003e[(k,[a])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-List-Rosso1.html#v:dropEachElem",
      "description": {
        "fct-descr": "\u003cp\u003eReturns a list of lists, each obtained by dropping a single\n element of the argument.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003edropEachElem \"abcd\"\n\u003c/code\u003e\u003c/strong\u003e[\"bcd\",\"acd\",\"abd\",\"abc\"]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Rosso1.html#dropEachElem",
        "fct-type": "function",
        "title": "dropEachElem"
      },
      "index": {
        "description": "Returns list of lists each obtained by dropping single element of the argument dropEachElem abcd bcd acd abd abc",
        "hierarchy": "Data List Rosso1",
        "module": "Data.List.Rosso1",
        "name": "dropEachElem",
        "normalized": "[a]-\u003e[[a]]",
        "package": "rosso",
        "partial": "Each Elem",
        "signature": "[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-List-Rosso1.html#v:extractEachElem",
      "description": {
        "fct-descr": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003edropEachElem\u003c/a\u003e\u003c/code\u003e, but each output list is paired with the\n element that was dropped.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eextractEachElem \"abcd\"\n\u003c/code\u003e\u003c/strong\u003e[('a',\"bcd\"),('b',\"acd\"),('c',\"abd\"),('d',\"abc\")]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[a] -\u003e [(a, [a])]",
        "fct-source": "src/Data-List-Rosso1.html#extractEachElem",
        "fct-type": "function",
        "title": "extractEachElem"
      },
      "index": {
        "description": "Similar to dropEachElem but each output list is paired with the element that was dropped extractEachElem abcd bcd acd abd abc",
        "hierarchy": "Data List Rosso1",
        "module": "Data.List.Rosso1",
        "name": "extractEachElem",
        "normalized": "[a]-\u003e[(a,[a])]",
        "package": "rosso",
        "partial": "Each Elem",
        "signature": "[a]-\u003e[(a,[a])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-List-Rosso1.html#v:sortAndGroupOn",
      "description": {
        "fct-descr": "\u003cp\u003eSorts, then groups the elements of a list, using a specified key\n function. The sorting process is stable, i.e. elements with equal\n keys remain in the same order.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esortAndGroupOn (`mod` 3) [1..10]\n\u003c/code\u003e\u003c/strong\u003e[[3,6,9],[1,4,7,10],[2,5,8]]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "(a -\u003e b) -\u003e [a] -\u003e [[a]]",
        "fct-source": "src/Data-List-Rosso1.html#sortAndGroupOn",
        "fct-type": "function",
        "title": "sortAndGroupOn"
      },
      "index": {
        "description": "Sorts then groups the elements of list using specified key function The sorting process is stable i.e elements with equal keys remain in the same order sortAndGroupOn mod",
        "hierarchy": "Data List Rosso1",
        "module": "Data.List.Rosso1",
        "name": "sortAndGroupOn",
        "normalized": "(a-\u003eb)-\u003e[a]-\u003e[[a]]",
        "package": "rosso",
        "partial": "And Group On",
        "signature": "(a-\u003eb)-\u003e[a]-\u003e[[a]]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-List-Rosso1.html#v:zipFilter",
      "description": {
        "fct-descr": "\u003cp\u003eFilters a list of values according to a list of corresponding\n boolean flags.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ezipFilter [False, True, False, True, True] [0..]\n\u003c/code\u003e\u003c/strong\u003e[1,3,4]\n\u003c/pre\u003e",
        "fct-module": "Data.List.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[Bool] -\u003e [a] -\u003e [a]",
        "fct-source": "src/Data-List-Rosso1.html#zipFilter",
        "fct-type": "function",
        "title": "zipFilter"
      },
      "index": {
        "description": "Filters list of values according to list of corresponding boolean flags zipFilter False True False True True",
        "hierarchy": "Data List Rosso1",
        "module": "Data.List.Rosso1",
        "name": "zipFilter",
        "normalized": "[Bool]-\u003e[a]-\u003e[a]",
        "package": "rosso",
        "partial": "Filter",
        "signature": "[Bool]-\u003e[a]-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Map-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eData.Map\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Map.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Data-Map-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends Data.Map",
        "hierarchy": "Data Map Rosso1",
        "module": "Data.Map.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Map-Rosso1.html#v:extract",
      "description": {
        "fct-descr": "\u003cp\u003eSimultaneous lookup and delete.\n\u003c/p\u003e",
        "fct-module": "Data.Map.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "k -\u003e Map k a -\u003e (Maybe a, Map k a)",
        "fct-source": "src/Data-Map-Rosso1.html#extract",
        "fct-type": "function",
        "title": "extract"
      },
      "index": {
        "description": "Simultaneous lookup and delete",
        "hierarchy": "Data Map Rosso1",
        "module": "Data.Map.Rosso1",
        "name": "extract",
        "normalized": "a-\u003eMap a b-\u003e(Maybe b,Map a b)",
        "package": "rosso",
        "partial": "",
        "signature": "k-\u003eMap k a-\u003e(Maybe a,Map k a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Map-Rosso1.html#v:insertMany",
      "description": {
        "fct-descr": "\u003cp\u003ePasses down the list from left to right, inserting each entry\n into the map.\n\u003c/p\u003e",
        "fct-module": "Data.Map.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[(k, a)] -\u003e Map k a -\u003e Map k a",
        "fct-source": "src/Data-Map-Rosso1.html#insertMany",
        "fct-type": "function",
        "title": "insertMany"
      },
      "index": {
        "description": "Passes down the list from left to right inserting each entry into the map",
        "hierarchy": "Data Map Rosso1",
        "module": "Data.Map.Rosso1",
        "name": "insertMany",
        "normalized": "[(a,b)]-\u003eMap a b-\u003eMap a b",
        "package": "rosso",
        "partial": "Many",
        "signature": "[(k,a)]-\u003eMap k a-\u003eMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Maybe-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eData.Maybe\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Maybe.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Data-Maybe-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends Data.Maybe",
        "hierarchy": "Data Maybe Rosso1",
        "module": "Data.Maybe.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Maybe-Rosso1.html#v:toMaybe",
      "description": {
        "fct-descr": "\u003cp\u003eDual of \u003ccode\u003e\u003ca\u003efromMaybe\u003c/a\u003e\u003c/code\u003e. Wraps the value in \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e if the predicate\n succeeds, otherwise returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Maybe.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "(a -\u003e Bool) -\u003e a -\u003e Maybe a",
        "fct-source": "src/Data-Maybe-Rosso1.html#toMaybe",
        "fct-type": "function",
        "title": "toMaybe"
      },
      "index": {
        "description": "Dual of fromMaybe Wraps the value in Just if the predicate succeeds otherwise returns Nothing",
        "hierarchy": "Data Maybe Rosso1",
        "module": "Data.Maybe.Rosso1",
        "name": "toMaybe",
        "normalized": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
        "package": "rosso",
        "partial": "Maybe",
        "signature": "(a-\u003eBool)-\u003ea-\u003eMaybe a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eMultiMap\u003c/a\u003e\u003c/code\u003e data structure: similar to a map (\u003ca\u003eData.Map\u003c/a\u003e), but allows\n multiple values with the same key.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Data-MultiMap-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "MultiMap data structure similar to map Data.Map but allows multiple values with the same key",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#t:MultiMap",
      "description": {
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "data",
        "fct-source": "src/Data-MultiMap-Rosso1.html#MultiMap",
        "fct-type": "data",
        "title": "MultiMap"
      },
      "index": {
        "description": "",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "MultiMap",
        "normalized": "",
        "package": "rosso",
        "partial": "Multi Map",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:alter",
      "description": {
        "fct-descr": "\u003cp\u003eModifies the list of values associated with a given key.\n\u003c/p\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "([a] -\u003e [a]) -\u003e k -\u003e MultiMap k a -\u003e MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#alter",
        "fct-type": "function",
        "title": "alter"
      },
      "index": {
        "description": "Modifies the list of values associated with given key",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "alter",
        "normalized": "([a]-\u003e[a])-\u003eb-\u003eMultiMap b a-\u003eMultiMap b a",
        "package": "rosso",
        "partial": "",
        "signature": "([a]-\u003e[a])-\u003ek-\u003eMultiMap k a-\u003eMultiMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:assocs",
      "description": {
        "fct-descr": "\u003cp\u003eReturns all of the key-value pairs in the multimap in ascending order\n of keys.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eassocs $ fromList [(1, \"ab\"), (4, \"cda\")]\n\u003c/code\u003e\u003c/strong\u003e[(1,'a'),(1,'b'),(4,'c'),(4,'d'),(4,'a')]\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a -\u003e [(k, a)]",
        "fct-source": "src/Data-MultiMap-Rosso1.html#assocs",
        "fct-type": "function",
        "title": "assocs"
      },
      "index": {
        "description": "Returns all of the key-value pairs in the multimap in ascending order of keys assocs fromList ab cda",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "assocs",
        "normalized": "MultiMap a b-\u003e[(a,b)]",
        "package": "rosso",
        "partial": "",
        "signature": "MultiMap k a-\u003e[(k,a)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:deleteList",
      "description": {
        "fct-descr": "\u003cp\u003eDeletes all the values associated with the given key.\n\u003c/p\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "k -\u003e MultiMap k a -\u003e MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#deleteList",
        "fct-type": "function",
        "title": "deleteList"
      },
      "index": {
        "description": "Deletes all the values associated with the given key",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "deleteList",
        "normalized": "a-\u003eMultiMap a b-\u003eMultiMap a b",
        "package": "rosso",
        "partial": "List",
        "signature": "k-\u003eMultiMap k a-\u003eMultiMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:descAssocs",
      "description": {
        "fct-descr": "\u003cp\u003eReturns all of the key-value pairs in the multimap in descending order\n of keys. The values are enumerated in the same order as with \u003ccode\u003e\u003ca\u003emaxView\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003edescAssocs (fromList [(1, \"ab\"), (4, \"cda\")])\n\u003c/code\u003e\u003c/strong\u003e[(4,'c'),(4,'d'),(4,'a'),(1,'a'),(1,'b')]\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a -\u003e [(k, a)]",
        "fct-source": "src/Data-MultiMap-Rosso1.html#descAssocs",
        "fct-type": "function",
        "title": "descAssocs"
      },
      "index": {
        "description": "Returns all of the key-value pairs in the multimap in descending order of keys The values are enumerated in the same order as with maxView descAssocs fromList ab cda",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "descAssocs",
        "normalized": "MultiMap a b-\u003e[(a,b)]",
        "package": "rosso",
        "partial": "Assocs",
        "signature": "MultiMap k a-\u003e[(k,a)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:descElems",
      "description": {
        "fct-descr": "\u003cp\u003eReturns all of the values in the multimap in descending order of\n their keys. The values are enumerated in the same order as with \u003ccode\u003e\u003ca\u003emaxView\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003edescElems $ fromList [(1, \"aba\"), (2, \"adf\"), (3, \"z\")]\n\u003c/code\u003e\u003c/strong\u003e\"zadfaba\"\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a -\u003e [a]",
        "fct-source": "src/Data-MultiMap-Rosso1.html#descElems",
        "fct-type": "function",
        "title": "descElems"
      },
      "index": {
        "description": "Returns all of the values in the multimap in descending order of their keys The values are enumerated in the same order as with maxView descElems fromList aba adf zadfaba",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "descElems",
        "normalized": "MultiMap a b-\u003e[b]",
        "package": "rosso",
        "partial": "Elems",
        "signature": "MultiMap k a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:elems",
      "description": {
        "fct-descr": "\u003cp\u003eReturns all of the values in the multimap in ascending order of\n their keys.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eelems $ fromList [(1, \"aba\"), (2, \"adf\"), (3, \"z\")]\n\u003c/code\u003e\u003c/strong\u003e\"abaadfz\"\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a -\u003e [a]",
        "fct-source": "src/Data-MultiMap-Rosso1.html#elems",
        "fct-type": "function",
        "title": "elems"
      },
      "index": {
        "description": "Returns all of the values in the multimap in ascending order of their keys elems fromList aba adf abaadfz",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "elems",
        "normalized": "MultiMap a b-\u003e[b]",
        "package": "rosso",
        "partial": "",
        "signature": "MultiMap k a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:empty",
      "description": {
        "fct-descr": "\u003cp\u003eThe empty multimap.\n\u003c/p\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#empty",
        "fct-type": "function",
        "title": "empty"
      },
      "index": {
        "description": "The empty multimap",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "empty",
        "normalized": "",
        "package": "rosso",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:extractEachListWithKey",
      "description": {
        "fct-descr": "\u003cp\u003eFor each key that maps to a non-empty list of values, returns\n that key and its corresponding values as well as the multimap with\n those values removed. The keys are enumerated in ascending order.\n\u003c/p\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a -\u003e [((k, [a]), MultiMap k a)]",
        "fct-source": "src/Data-MultiMap-Rosso1.html#extractEachListWithKey",
        "fct-type": "function",
        "title": "extractEachListWithKey"
      },
      "index": {
        "description": "For each key that maps to non-empty list of values returns that key and its corresponding values as well as the multimap with those values removed The keys are enumerated in ascending order",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "extractEachListWithKey",
        "normalized": "MultiMap a b-\u003e[((a,[b]),MultiMap a b)]",
        "package": "rosso",
        "partial": "Each List With Key",
        "signature": "MultiMap k a-\u003e[((k,[a]),MultiMap k a)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:extractList",
      "description": {
        "fct-descr": "\u003cp\u003eSimultaneous lookup and deleteList.\n\u003c/p\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "k -\u003e MultiMap k a -\u003e ([a], MultiMap k a)",
        "fct-source": "src/Data-MultiMap-Rosso1.html#extractList",
        "fct-type": "function",
        "title": "extractList"
      },
      "index": {
        "description": "Simultaneous lookup and deleteList",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "extractList",
        "normalized": "a-\u003eMultiMap a b-\u003e([b],MultiMap a b)",
        "package": "rosso",
        "partial": "List",
        "signature": "k-\u003eMultiMap k a-\u003e([a],MultiMap k a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:fromList",
      "description": {
        "fct-descr": "\u003cp\u003eConverts an association list into a multimap. If the association\n list contains duplicate keys, then the corresponding lists of\n values become concatenated.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [(4, \"dca\"), (1, \"aba\"), (2, \"b\"), (1, \"ac\"), (3, \"\")]\n\u003c/code\u003e\u003c/strong\u003efromList [(1,\"abaac\"),(2,\"b\"),(4,\"dca\")]\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[(k, [a])] -\u003e MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#fromList",
        "fct-type": "function",
        "title": "fromList"
      },
      "index": {
        "description": "Converts an association list into multimap If the association list contains duplicate keys then the corresponding lists of values become concatenated fromList dca aba ac fromList abaac dca",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "fromList",
        "normalized": "[(a,[b])]-\u003eMultiMap a b",
        "package": "rosso",
        "partial": "List",
        "signature": "[(k,[a])]-\u003eMultiMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:insert",
      "description": {
        "fct-descr": "\u003cp\u003eInserts a new key-value pair. If other entries already exist\n with the same key, then the new entry is inserted just before them.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003einsert 2 'a' $ fromList [(1, \"efg\"), (2, \"jzw\"), (3, \"abc\")]\n\u003c/code\u003e\u003c/strong\u003efromList [(1,\"efg\"),(2,\"ajzw\"),(3,\"abc\")]\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "k -\u003e a -\u003e MultiMap k a -\u003e MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#insert",
        "fct-type": "function",
        "title": "insert"
      },
      "index": {
        "description": "Inserts new key-value pair If other entries already exist with the same key then the new entry is inserted just before them insert fromList efg jzw abc fromList efg ajzw abc",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "insert",
        "normalized": "a-\u003eb-\u003eMultiMap a b-\u003eMultiMap a b",
        "package": "rosso",
        "partial": "",
        "signature": "k-\u003ea-\u003eMultiMap k a-\u003eMultiMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:insertList",
      "description": {
        "fct-descr": "\u003cp\u003ePrepends a list of values onto the entry with the given key.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003einsertList 7 \"hello\" $ fromList [(5, \"ab\"), (7, \"efg\")]\n\u003c/code\u003e\u003c/strong\u003efromList [(5,\"ab\"),(7,\"helloefg\")]\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "k -\u003e [a] -\u003e MultiMap k a -\u003e MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#insertList",
        "fct-type": "function",
        "title": "insertList"
      },
      "index": {
        "description": "Prepends list of values onto the entry with the given key insertList hello fromList ab efg fromList ab helloefg",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "insertList",
        "normalized": "a-\u003e[b]-\u003eMultiMap a b-\u003eMultiMap a b",
        "package": "rosso",
        "partial": "List",
        "signature": "k-\u003e[a]-\u003eMultiMap k a-\u003eMultiMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:insertMany",
      "description": {
        "fct-descr": "\u003cp\u003ePasses down the list from left to right, inserting each entry into\n the multimap.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003einsertMany [(1, 'a'), (5, 'a'), (1, 'a'), (1, 'b')] empty\n\u003c/code\u003e\u003c/strong\u003efromList [(1,\"baa\"),(5,\"a\")]\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[(k, a)] -\u003e MultiMap k a -\u003e MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#insertMany",
        "fct-type": "function",
        "title": "insertMany"
      },
      "index": {
        "description": "Passes down the list from left to right inserting each entry into the multimap insertMany empty fromList baa",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "insertMany",
        "normalized": "[(a,b)]-\u003eMultiMap a b-\u003eMultiMap a b",
        "package": "rosso",
        "partial": "Many",
        "signature": "[(k,a)]-\u003eMultiMap k a-\u003eMultiMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:insertManyLists",
      "description": {
        "fct-descr": "\u003cp\u003ePasses down the given list from left to right invoking \u003ccode\u003e\u003ca\u003einsertList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[(k, [a])] -\u003e MultiMap k a -\u003e MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#insertManyLists",
        "fct-type": "function",
        "title": "insertManyLists"
      },
      "index": {
        "description": "Passes down the given list from left to right invoking insertList",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "insertManyLists",
        "normalized": "[(a,[b])]-\u003eMultiMap a b-\u003eMultiMap a b",
        "package": "rosso",
        "partial": "Many Lists",
        "signature": "[(k,[a])]-\u003eMultiMap k a-\u003eMultiMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:lookup",
      "description": {
        "fct-descr": "\u003cp\u003eReturns the list of values associated with the given key.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elookup 5 $ fromList [(1, \"abc\"), (5, \"aagf\"), (6, \"c\")]\n\u003c/code\u003e\u003c/strong\u003e\"aagf\"\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "k -\u003e MultiMap k a -\u003e [a]",
        "fct-source": "src/Data-MultiMap-Rosso1.html#lookup",
        "fct-type": "function",
        "title": "lookup"
      },
      "index": {
        "description": "Returns the list of values associated with the given key lookup fromList abc aagf aagf",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "lookup",
        "normalized": "a-\u003eMultiMap a b-\u003e[b]",
        "package": "rosso",
        "partial": "",
        "signature": "k-\u003eMultiMap k a-\u003e[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:maxView",
      "description": {
        "fct-descr": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the multimap is empty, otherwise returns the\n first value associated with the maximal key of the multimap, and\n the multimap stripped of that value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emaxView $ fromList [(1, \"ab\"), (2, \"efg\")]\n\u003c/code\u003e\u003c/strong\u003eJust ('e',fromList [(1,\"ab\"),(2,\"fg\")])\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a -\u003e Maybe (a, MultiMap k a)",
        "fct-source": "src/Data-MultiMap-Rosso1.html#maxView",
        "fct-type": "function",
        "title": "maxView"
      },
      "index": {
        "description": "Returns Nothing if the multimap is empty otherwise returns the first value associated with the maximal key of the multimap and the multimap stripped of that value maxView fromList ab efg Just fromList ab fg",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "maxView",
        "normalized": "MultiMap a b-\u003eMaybe(b,MultiMap a b)",
        "package": "rosso",
        "partial": "View",
        "signature": "MultiMap k a-\u003eMaybe(a,MultiMap k a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eTests if the multimap is empty.\n\u003c/p\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a -\u003e Bool",
        "fct-source": "src/Data-MultiMap-Rosso1.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Tests if the multimap is empty",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "null",
        "normalized": "MultiMap a b-\u003eBool",
        "package": "rosso",
        "partial": "",
        "signature": "MultiMap k a-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:singleton",
      "description": {
        "fct-descr": "\u003cp\u003eA multimap with a single entry.\n\u003c/p\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "k -\u003e a -\u003e MultiMap k a",
        "fct-source": "src/Data-MultiMap-Rosso1.html#singleton",
        "fct-type": "function",
        "title": "singleton"
      },
      "index": {
        "description": "multimap with single entry",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "singleton",
        "normalized": "a-\u003eb-\u003eMultiMap a b",
        "package": "rosso",
        "partial": "",
        "signature": "k-\u003ea-\u003eMultiMap k a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-MultiMap-Rosso1.html#v:toList",
      "description": {
        "fct-descr": "\u003cp\u003eConverts a multimap into an association list, with the keys in\n ascending order.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etoList $ fromList [(4, \"dca\"), (1, \"aba\"), (2, \"b\"), (1, \"ac\"), (3, \"\")]\n\u003c/code\u003e\u003c/strong\u003e[(1,\"abaac\"),(2,\"b\"),(4,\"dca\")]\n\u003c/pre\u003e",
        "fct-module": "Data.MultiMap.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "MultiMap k a -\u003e [(k, [a])]",
        "fct-source": "src/Data-MultiMap-Rosso1.html#toList",
        "fct-type": "function",
        "title": "toList"
      },
      "index": {
        "description": "Converts multimap into an association list with the keys in ascending order toList fromList dca aba ac abaac dca",
        "hierarchy": "Data MultiMap Rosso1",
        "module": "Data.MultiMap.Rosso1",
        "name": "toList",
        "normalized": "MultiMap a b-\u003e[(a,[b])]",
        "package": "rosso",
        "partial": "List",
        "signature": "MultiMap k a-\u003e[(k,[a])]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Set-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eData.Set\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Set.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Data-Set-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends Data.Set",
        "hierarchy": "Data Set Rosso1",
        "module": "Data.Set.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Set-Rosso1.html#v:insertMany",
      "description": {
        "fct-descr": "\u003cp\u003eInserts each element of the list into the set in turn, from left\n to right.\n\u003c/p\u003e",
        "fct-module": "Data.Set.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "[a] -\u003e Set a -\u003e Set a",
        "fct-source": "src/Data-Set-Rosso1.html#insertMany",
        "fct-type": "function",
        "title": "insertMany"
      },
      "index": {
        "description": "Inserts each element of the list into the set in turn from left to right",
        "hierarchy": "Data Set Rosso1",
        "module": "Data.Set.Rosso1",
        "name": "insertMany",
        "normalized": "[a]-\u003eSet a-\u003eSet a",
        "package": "rosso",
        "partial": "Many",
        "signature": "[a]-\u003eSet a-\u003eSet a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Tuple-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eData.Tuple\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Data.Tuple.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/Data-Tuple-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends Data.Tuple",
        "hierarchy": "Data Tuple Rosso1",
        "module": "Data.Tuple.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Tuple-Rosso1.html#v:mapFst",
      "description": {
        "fct-descr": "\u003cp\u003eApplies a function to the first component of a pair.\n\u003c/p\u003e",
        "fct-module": "Data.Tuple.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "(a -\u003e c) -\u003e (a, b) -\u003e (c, b)",
        "fct-source": "src/Data-Tuple-Rosso1.html#mapFst",
        "fct-type": "function",
        "title": "mapFst"
      },
      "index": {
        "description": "Applies function to the first component of pair",
        "hierarchy": "Data Tuple Rosso1",
        "module": "Data.Tuple.Rosso1",
        "name": "mapFst",
        "normalized": "(a-\u003eb)-\u003e(a,c)-\u003e(b,c)",
        "package": "rosso",
        "partial": "Fst",
        "signature": "(a-\u003ec)-\u003e(a,b)-\u003e(c,b)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Tuple-Rosso1.html#v:mapSnd",
      "description": {
        "fct-descr": "\u003cp\u003eApplies a function to the second component of a pair.\n\u003c/p\u003e",
        "fct-module": "Data.Tuple.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "(b -\u003e c) -\u003e (a, b) -\u003e (a, c)",
        "fct-source": "src/Data-Tuple-Rosso1.html#mapSnd",
        "fct-type": "function",
        "title": "mapSnd"
      },
      "index": {
        "description": "Applies function to the second component of pair",
        "hierarchy": "Data Tuple Rosso1",
        "module": "Data.Tuple.Rosso1",
        "name": "mapSnd",
        "normalized": "(a-\u003eb)-\u003e(c,a)-\u003e(c,b)",
        "package": "rosso",
        "partial": "Snd",
        "signature": "(b-\u003ec)-\u003e(a,b)-\u003e(a,c)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/Data-Tuple-Rosso1.html#v:pairApply",
      "description": {
        "fct-descr": "\u003cp\u003eApplies a pair of functions to a pair of values.\n\u003c/p\u003e",
        "fct-module": "Data.Tuple.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "(a -\u003e c) -\u003e (b -\u003e d) -\u003e (a, b) -\u003e (c, d)",
        "fct-source": "src/Data-Tuple-Rosso1.html#pairApply",
        "fct-type": "function",
        "title": "pairApply"
      },
      "index": {
        "description": "Applies pair of functions to pair of values",
        "hierarchy": "Data Tuple Rosso1",
        "module": "Data.Tuple.Rosso1",
        "name": "pairApply",
        "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003e(a,c)-\u003e(b,d)",
        "package": "rosso",
        "partial": "Apply",
        "signature": "(a-\u003ec)-\u003e(b-\u003ed)-\u003e(a,b)-\u003e(c,d)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/System-IO-Rosso1.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtends \u003ca\u003eSystem.IO\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "System.IO.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "module",
        "fct-source": "src/System-IO-Rosso1.html",
        "fct-type": "module",
        "title": "Rosso1"
      },
      "index": {
        "description": "Extends System.IO",
        "hierarchy": "System IO Rosso1",
        "module": "System.IO.Rosso1",
        "name": "Rosso1",
        "normalized": "",
        "package": "rosso",
        "partial": "Rosso",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/rosso/docs/System-IO-Rosso1.html#v:readFileStrict",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ereadFile\u003c/a\u003e\u003c/code\u003e, but reads the entire contents of the file into\n the string, and then closes the file, before the computation\n completes.\n\u003c/p\u003e",
        "fct-module": "System.IO.Rosso1",
        "fct-package": "rosso",
        "fct-signature": "FilePath -\u003e IO String",
        "fct-source": "src/System-IO-Rosso1.html#readFileStrict",
        "fct-type": "function",
        "title": "readFileStrict"
      },
      "index": {
        "description": "Like readFile but reads the entire contents of the file into the string and then closes the file before the computation completes",
        "hierarchy": "System IO Rosso1",
        "module": "System.IO.Rosso1",
        "name": "readFileStrict",
        "normalized": "FilePath-\u003eIO String",
        "package": "rosso",
        "partial": "File Strict",
        "signature": "FilePath-\u003eIO String"
      }
    }
  }
]
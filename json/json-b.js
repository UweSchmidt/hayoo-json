[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSON-Escape.html#",
      "description": {
        "fct-module": "Text.JSON.Escape",
        "fct-package": "json-b",
        "fct-signature": "module",
        "fct-source": "src/Text-JSON-Escape.html",
        "fct-type": "module",
        "title": "Escape"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSON Escape",
        "module": "Text.JSON.Escape",
        "name": "Escape",
        "normalized": "",
        "package": "json-b",
        "partial": "Escape",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSON-Escape.html#t:Escape",
      "description": {
        "fct-descr": "\u003cp\u003eClass of JSON escapable text. The solidus (\u003ccode\u003e/\u003c/code\u003e) is always escaped, as are\n    all ASCII control characters. Non-ASCII control characters and Unicode\n    printable characters above ASCII are left as is.\n\u003c/p\u003e",
        "fct-module": "Text.JSON.Escape",
        "fct-package": "json-b",
        "fct-signature": "class",
        "fct-source": "src/Text-JSON-Escape.html#Escape",
        "fct-type": "class",
        "title": "Escape"
      },
      "index": {
        "description": "Class of JSON escapable text The solidus is always escaped as are all ASCII control characters Non-ASCII control characters and Unicode printable characters above ASCII are left as is",
        "hierarchy": "Text JSON Escape",
        "module": "Text.JSON.Escape",
        "name": "Escape",
        "normalized": "",
        "package": "json-b",
        "partial": "Escape",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSON-Escape.html#v:esc",
      "description": {
        "fct-descr": "\u003cp\u003eEscapes an individual character for embedding in a JSON string.\n\u003c/p\u003e",
        "fct-module": "Text.JSON.Escape",
        "fct-package": "json-b",
        "fct-signature": "Char -\u003e String",
        "fct-source": "src/Text-JSON-Escape.html#esc",
        "fct-type": "function",
        "title": "esc"
      },
      "index": {
        "description": "Escapes an individual character for embedding in JSON string",
        "hierarchy": "Text JSON Escape",
        "module": "Text.JSON.Escape",
        "name": "esc",
        "normalized": "Char-\u003eString",
        "package": "json-b",
        "partial": "",
        "signature": "Char-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSON-Escape.html#v:escape",
      "description": {
        "fct-module": "Text.JSON.Escape",
        "fct-package": "json-b",
        "fct-signature": "t -\u003e t",
        "fct-source": "src/Text-JSON-Escape.html#escape",
        "fct-type": "method",
        "title": "escape"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSON Escape",
        "module": "Text.JSON.Escape",
        "name": "escape",
        "normalized": "a-\u003ea",
        "package": "json-b",
        "partial": "",
        "signature": "t-\u003et"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParse UTF-8 JSON into native Haskell types.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "module",
        "fct-source": "src/Text-JSONb-Decode.html",
        "fct-type": "module",
        "title": "Decode"
      },
      "index": {
        "description": "Parse UTF-8 JSON into native Haskell types",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "Decode",
        "normalized": "",
        "package": "json-b",
        "partial": "Decode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:array",
      "description": {
        "fct-descr": "\u003cp\u003eParse a JSON array.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser JSON",
        "fct-source": "src/Text-JSONb-Decode.html#array",
        "fct-type": "function",
        "title": "array"
      },
      "index": {
        "description": "Parse JSON array",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "array",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:boolean",
      "description": {
        "fct-descr": "\u003cp\u003eParse a JSON Boolean literal.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser JSON",
        "fct-source": "src/Text-JSONb-Decode.html#boolean",
        "fct-type": "function",
        "title": "boolean"
      },
      "index": {
        "description": "Parse JSON Boolean literal",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "boolean",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003eSplit out the first parseable JSON literal from the input, returning\n    the result of the attempt along with the remainder of the input or the\n    whole input if not parseable item was discovered.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "ByteString -\u003e (Either ParseError JSON, ByteString)",
        "fct-source": "src/Text-JSONb-Decode.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split out the first parseable JSON literal from the input returning the result of the attempt along with the remainder of the input or the whole input if not parseable item was discovered",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "break",
        "normalized": "ByteString-\u003e(Either ParseError JSON,ByteString)",
        "package": "json-b",
        "partial": "",
        "signature": "ByteString-\u003e(Either ParseError JSON,ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eInterpret a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e as any JSON literal.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "ByteString -\u003e Either (ParseError, ByteString) JSON",
        "fct-source": "src/Text-JSONb-Decode.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "Interpret ByteString as any JSON literal",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "decode",
        "normalized": "ByteString-\u003eEither(ParseError,ByteString)JSON",
        "package": "json-b",
        "partial": "",
        "signature": "ByteString-\u003eEither(ParseError,ByteString)JSON"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:json",
      "description": {
        "fct-descr": "\u003cp\u003eTries to parse any JSON literal.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser JSON",
        "fct-source": "src/Text-JSONb-Decode.html#json",
        "fct-type": "function",
        "title": "json"
      },
      "index": {
        "description": "Tries to parse any JSON literal",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "json",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:null",
      "description": {
        "fct-descr": "\u003cp\u003eParse a JSON null literal.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser JSON",
        "fct-source": "src/Text-JSONb-Decode.html#null",
        "fct-type": "function",
        "title": "null"
      },
      "index": {
        "description": "Parse JSON null literal",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "null",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:number",
      "description": {
        "fct-descr": "\u003cp\u003eParses a numeric literal to a \u003ccode\u003eRational\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser JSON",
        "fct-source": "src/Text-JSONb-Decode.html#number",
        "fct-type": "function",
        "title": "number"
      },
      "index": {
        "description": "Parses numeric literal to Rational",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "number",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:object",
      "description": {
        "fct-descr": "\u003cp\u003eParse a JSON object (dictionary).\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser JSON",
        "fct-source": "src/Text-JSONb-Decode.html#object",
        "fct-type": "function",
        "title": "object"
      },
      "index": {
        "description": "Parse JSON object dictionary",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "object",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:strictify",
      "description": {
        "fct-descr": "\u003cp\u003eTurn a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e in to a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "ByteString -\u003e ByteString",
        "fct-source": "src/Text-JSONb-Decode.html#strictify",
        "fct-type": "function",
        "title": "strictify"
      },
      "index": {
        "description": "Turn lazy ByteString in to strict ByteString",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "strictify",
        "normalized": "ByteString-\u003eByteString",
        "package": "json-b",
        "partial": "",
        "signature": "ByteString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:string",
      "description": {
        "fct-descr": "\u003cp\u003eParses a string literal, unescaping as it goes.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser JSON",
        "fct-source": "src/Text-JSONb-Decode.html#string",
        "fct-type": "function",
        "title": "string"
      },
      "index": {
        "description": "Parses string literal unescaping as it goes",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "string",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:string_literal",
      "description": {
        "fct-descr": "\u003cp\u003eParse a JSON string literal and unescape it but don't wrap it in a string\n    constructor (we might wrap it as a dict key instead).\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser ByteString",
        "fct-source": "src/Text-JSONb-Decode.html#string_literal",
        "fct-type": "function",
        "title": "string_literal"
      },
      "index": {
        "description": "Parse JSON string literal and unescape it but don wrap it in string constructor we might wrap it as dict key instead",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "string_literal",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Decode.html#v:whitespace",
      "description": {
        "fct-descr": "\u003cp\u003ePer RFC 4627, section 2 \u003ca\u003eJSON Grammar\u003c/a\u003e, only a limited set of whitespace\n    characters actually count as insignificant whitespace. \n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Decode",
        "fct-package": "json-b",
        "fct-signature": "Parser ()",
        "fct-source": "src/Text-JSONb-Decode.html#whitespace",
        "fct-type": "function",
        "title": "whitespace"
      },
      "index": {
        "description": "Per RFC section JSON Grammar only limited set of whitespace characters actually count as insignificant whitespace",
        "hierarchy": "Text JSONb Decode",
        "module": "Text.JSONb.Decode",
        "name": "whitespace",
        "normalized": "Parser()",
        "package": "json-b",
        "partial": "",
        "signature": "Parser()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Encode.html#",
      "description": {
        "fct-module": "Text.JSONb.Encode",
        "fct-package": "json-b",
        "fct-signature": "module",
        "fct-source": "src/Text-JSONb-Encode.html",
        "fct-type": "module",
        "title": "Encode"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Encode",
        "module": "Text.JSONb.Encode",
        "name": "Encode",
        "normalized": "",
        "package": "json-b",
        "partial": "Encode",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Encode.html#t:Style",
      "description": {
        "fct-descr": "\u003cp\u003eStyle of serialization. Compact is the only one that is implemented at\n    present.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Encode",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Encode.html#Style",
        "fct-type": "data",
        "title": "Style"
      },
      "index": {
        "description": "Style of serialization Compact is the only one that is implemented at present",
        "hierarchy": "Text JSONb Encode",
        "module": "Text.JSONb.Encode",
        "name": "Style",
        "normalized": "",
        "package": "json-b",
        "partial": "Style",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Encode.html#v:Compact",
      "description": {
        "fct-module": "Text.JSONb.Encode",
        "fct-package": "json-b",
        "fct-signature": "Compact",
        "fct-source": "src/Text-JSONb-Encode.html#Style",
        "fct-type": "function",
        "title": "Compact"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Encode",
        "module": "Text.JSONb.Encode",
        "name": "Compact",
        "normalized": "",
        "package": "json-b",
        "partial": "Compact",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Encode.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEncode \u003ccode\u003e\u003ca\u003eJSON\u003c/a\u003e\u003c/code\u003e as a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e. All strings are treated as\n    UTF-8; ASCII control characters are escaped and UTF-8 multi-char sequences\n    are simply passed through.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Encode",
        "fct-package": "json-b",
        "fct-signature": "Style -\u003e JSON -\u003e ByteString",
        "fct-source": "src/Text-JSONb-Encode.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Encode JSON as lazy ByteString All strings are treated as UTF-8 ASCII control characters are escaped and UTF-8 multi-char sequences are simply passed through",
        "hierarchy": "Text JSONb Encode",
        "module": "Text.JSONb.Encode",
        "name": "encode",
        "normalized": "Style-\u003eJSON-\u003eByteString",
        "package": "json-b",
        "partial": "",
        "signature": "Style-\u003eJSON-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Encode.html#v:encode-39-",
      "description": {
        "fct-descr": "\u003cp\u003eEncode \u003ccode\u003e\u003ca\u003eJSON\u003c/a\u003e\u003c/code\u003e as a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e. All strings are treated as UTF-8;\n    ASCII control characters are escaped and UTF-8 multi-char sequences are\n    simply passed through.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Encode",
        "fct-package": "json-b",
        "fct-signature": "Style -\u003e JSON -\u003e ByteString",
        "fct-source": "src/Text-JSONb-Encode.html#encode%27",
        "fct-type": "function",
        "title": "encode'"
      },
      "index": {
        "description": "Encode JSON as strict ByteString All strings are treated as UTF-8 ASCII control characters are escaped and UTF-8 multi-char sequences are simply passed through",
        "hierarchy": "Text JSONb Encode",
        "module": "Text.JSONb.Encode",
        "name": "encode'",
        "normalized": "Style-\u003eJSON-\u003eByteString",
        "package": "json-b",
        "partial": "",
        "signature": "Style-\u003eJSON-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Encode.html#v:stringify",
      "description": {
        "fct-descr": "\u003cp\u003eEscape a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e representing a JSON string and wrap it in quote\n    marks.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Encode",
        "fct-package": "json-b",
        "fct-signature": "ByteString -\u003e ByteString",
        "fct-source": "src/Text-JSONb-Encode.html#stringify",
        "fct-type": "function",
        "title": "stringify"
      },
      "index": {
        "description": "Escape ByteString representing JSON string and wrap it in quote marks",
        "hierarchy": "Text JSONb Encode",
        "module": "Text.JSONb.Encode",
        "name": "stringify",
        "normalized": "ByteString-\u003eByteString",
        "package": "json-b",
        "partial": "",
        "signature": "ByteString-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema-Display.html#",
      "description": {
        "fct-module": "Text.JSONb.Schema.Display",
        "fct-package": "json-b",
        "fct-signature": "module",
        "fct-source": "src/Text-JSONb-Schema-Display.html",
        "fct-type": "module",
        "title": "Display"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema Display",
        "module": "Text.JSONb.Schema.Display",
        "name": "Display",
        "normalized": "",
        "package": "json-b",
        "partial": "Display",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema-Display.html#t:Display",
      "description": {
        "fct-module": "Text.JSONb.Schema.Display",
        "fct-package": "json-b",
        "fct-signature": "class",
        "fct-source": "src/Text-JSONb-Schema-Display.html#Display",
        "fct-type": "class",
        "title": "Display"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema Display",
        "module": "Text.JSONb.Schema.Display",
        "name": "Display",
        "normalized": "",
        "package": "json-b",
        "partial": "Display",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema-Display.html#v:bytes",
      "description": {
        "fct-descr": "\u003cp\u003eProvide a formatted \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e for the displayable.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Schema.Display",
        "fct-package": "json-b",
        "fct-signature": "t -\u003e ByteString",
        "fct-source": "src/Text-JSONb-Schema-Display.html#bytes",
        "fct-type": "method",
        "title": "bytes"
      },
      "index": {
        "description": "Provide formatted ByteString for the displayable",
        "hierarchy": "Text JSONb Schema Display",
        "module": "Text.JSONb.Schema.Display",
        "name": "bytes",
        "normalized": "a-\u003eByteString",
        "package": "json-b",
        "partial": "",
        "signature": "t-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "module",
        "fct-source": "src/Text-JSONb-Schema.html",
        "fct-type": "module",
        "title": "Schema"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Schema",
        "normalized": "",
        "package": "json-b",
        "partial": "Schema",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#t:Counter",
      "description": {
        "fct-descr": "\u003cp\u003eA well-ordered semigroup has a minimal element and an associative\n    operation. These are used to provide measures for schema. At present, we\n    allow three measures: whether there is one or more of a schema (measured\n    with '()'), whether there is one or more than one of an item (measured with\n    \u003ccode\u003e\u003ca\u003eOneMany\u003c/a\u003e\u003c/code\u003e) and positive counts of items (measured with \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "class",
        "fct-source": "src/Text-JSONb-Schema.html#Counter",
        "fct-type": "class",
        "title": "Counter"
      },
      "index": {
        "description": "well-ordered semigroup has minimal element and an associative operation These are used to provide measures for schema At present we allow three measures whether there is one or more of schema measured with whether there is one or more than one of an item measured with OneMany and positive counts of items measured with Word",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Counter",
        "normalized": "",
        "package": "json-b",
        "partial": "Counter",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#t:Elements",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Schema.html#Elements",
        "fct-type": "data",
        "title": "Elements"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Elements",
        "normalized": "",
        "package": "json-b",
        "partial": "Elements",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#t:OneMany",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Schema.html#OneMany",
        "fct-type": "data",
        "title": "OneMany"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "OneMany",
        "normalized": "",
        "package": "json-b",
        "partial": "One Many",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#t:Props",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Schema.html#Props",
        "fct-type": "data",
        "title": "Props"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Props",
        "normalized": "",
        "package": "json-b",
        "partial": "Props",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#t:Schema",
      "description": {
        "fct-descr": "\u003cp\u003eThe type of JSON schemas. We treat the atomic types simply whereas objects\n    and arrays are treated specially.\n\u003c/p\u003e\u003cp\u003eObjects are treated as maps of keys to sets of schema types. Say a certain\n    type of object sometimes has a string at a certain key and sometimes has a\n    null at that key; we should merge them and say the schema of that key is a\n    union of string and null.\n\u003c/p\u003e\u003cp\u003eArrays admit measure in the sense of how many elements there are of a\n    certain kind. We support three measures at present: any, one or more and\n    individual counts. We expect the \u003ca\u003eany\u003c/a\u003e measure to prevail practice. Arrays\n    are also ordered; so one can distinguish an array that interleaves strings\n    and ints from one that is all strings and then all ints.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Schema.html#Schema",
        "fct-type": "data",
        "title": "Schema"
      },
      "index": {
        "description": "The type of JSON schemas We treat the atomic types simply whereas objects and arrays are treated specially Objects are treated as maps of keys to sets of schema types Say certain type of object sometimes has string at certain key and sometimes has null at that key we should merge them and say the schema of that key is union of string and null Arrays admit measure in the sense of how many elements there are of certain kind We support three measures at present any one or more and individual counts We expect the any measure to prevail practice Arrays are also ordered so one can distinguish an array that interleaves strings and ints from one that is all strings and then all ints",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Schema",
        "normalized": "",
        "package": "json-b",
        "partial": "Schema",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Arr",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Arr (Elements counter)",
        "fct-source": "src/Text-JSONb-Schema.html#Schema",
        "fct-type": "function",
        "title": "Arr"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Arr",
        "normalized": "",
        "package": "json-b",
        "partial": "Arr",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Bool",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Bool",
        "fct-source": "src/Text-JSONb-Schema.html#Schema",
        "fct-type": "function",
        "title": "Bool"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Bool",
        "normalized": "",
        "package": "json-b",
        "partial": "Bool",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Elements",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Elements [(counter, Schema counter)]",
        "fct-source": "src/Text-JSONb-Schema.html#Elements",
        "fct-type": "function",
        "title": "Elements"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Elements",
        "normalized": "Elements[(a,Schema a)]",
        "package": "json-b",
        "partial": "Elements",
        "signature": "Elements[(counter,Schema counter)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Many",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Many",
        "fct-source": "src/Text-JSONb-Schema.html#OneMany",
        "fct-type": "function",
        "title": "Many"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Many",
        "normalized": "",
        "package": "json-b",
        "partial": "Many",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Null",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Null",
        "fct-source": "src/Text-JSONb-Schema.html#Schema",
        "fct-type": "function",
        "title": "Null"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Null",
        "normalized": "",
        "package": "json-b",
        "partial": "Null",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Num",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Num",
        "fct-source": "src/Text-JSONb-Schema.html#Schema",
        "fct-type": "function",
        "title": "Num"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Num",
        "normalized": "",
        "package": "json-b",
        "partial": "Num",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Obj",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Obj (Props counter)",
        "fct-source": "src/Text-JSONb-Schema.html#Schema",
        "fct-type": "function",
        "title": "Obj"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Obj",
        "normalized": "",
        "package": "json-b",
        "partial": "Obj",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:One",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "One",
        "fct-source": "src/Text-JSONb-Schema.html#OneMany",
        "fct-type": "function",
        "title": "One"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "One",
        "normalized": "",
        "package": "json-b",
        "partial": "One",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Props",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Props (Trie (Set (Schema counter)))",
        "fct-source": "src/Text-JSONb-Schema.html#Props",
        "fct-type": "function",
        "title": "Props"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Props",
        "normalized": "",
        "package": "json-b",
        "partial": "Props",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:Str",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Str",
        "fct-source": "src/Text-JSONb-Schema.html#Schema",
        "fct-type": "function",
        "title": "Str"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "Str",
        "normalized": "",
        "package": "json-b",
        "partial": "Str",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:bottom",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "t",
        "fct-source": "src/Text-JSONb-Schema.html#bottom",
        "fct-type": "method",
        "title": "bottom"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "bottom",
        "normalized": "",
        "package": "json-b",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:collate",
      "description": {
        "fct-descr": "\u003cp\u003eCollate a list of counted schemas. Alike counted schemas that are adjacent\n    are replaced by a counted schema with an incremented counter. This\n    operation is mutually recursive with \u003ccode\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/code\u003e, in order to merge comaptible\n    object definitions before collating.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "(counter, Schema counter') -\u003e [(counter, Schema counter')] -\u003e [(counter, Schema counter')]",
        "fct-source": "src/Text-JSONb-Schema.html#collate",
        "fct-type": "function",
        "title": "collate"
      },
      "index": {
        "description": "Collate list of counted schemas Alike counted schemas that are adjacent are replaced by counted schema with an incremented counter This operation is mutually recursive with merge in order to merge comaptible object definitions before collating",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "collate",
        "normalized": "(a,Schema b)-\u003e[(a,Schema b)]-\u003e[(a,Schema b)]",
        "package": "json-b",
        "partial": "",
        "signature": "(counter,Schema counter')-\u003e[(counter,Schema counter')]-\u003e[(counter,Schema counter')]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:match",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Props counter -\u003e Props counter -\u003e Bool",
        "fct-source": "src/Text-JSONb-Schema.html#match",
        "fct-type": "function",
        "title": "match"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "match",
        "normalized": "Props a-\u003eProps a-\u003eBool",
        "package": "json-b",
        "partial": "",
        "signature": "Props counter-\u003eProps counter-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:merge",
      "description": {
        "fct-descr": "\u003cp\u003eMerge two property sets. This operation is mutually recursive with our\n    \u003ccode\u003e\u003ca\u003ecollate\u003c/a\u003e\u003c/code\u003e and relies on polymorphic recusion in \u003ccode\u003e\u003ca\u003ecollate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Props counter -\u003e Props counter -\u003e Props counter",
        "fct-source": "src/Text-JSONb-Schema.html#merge",
        "fct-type": "function",
        "title": "merge"
      },
      "index": {
        "description": "Merge two property sets This operation is mutually recursive with our collate and relies on polymorphic recusion in collate",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "merge",
        "normalized": "Props a-\u003eProps a-\u003eProps a",
        "package": "json-b",
        "partial": "",
        "signature": "Props counter-\u003eProps counter-\u003eProps counter"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:plus",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "t -\u003e t -\u003e t",
        "fct-source": "src/Text-JSONb-Schema.html#plus",
        "fct-type": "method",
        "title": "plus"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "plus",
        "normalized": "a-\u003ea-\u003ea",
        "package": "json-b",
        "partial": "",
        "signature": "t-\u003et-\u003et"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:props",
      "description": {
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "Trie JSON -\u003e Props counter",
        "fct-source": "src/Text-JSONb-Schema.html#props",
        "fct-type": "function",
        "title": "props"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "props",
        "normalized": "Trie JSON-\u003eProps a",
        "package": "json-b",
        "partial": "",
        "signature": "Trie JSON-\u003eProps counter"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:schema",
      "description": {
        "fct-descr": "\u003cp\u003eDetermine a schema for one JSON data item.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "JSON -\u003e Schema counter",
        "fct-source": "src/Text-JSONb-Schema.html#schema",
        "fct-type": "function",
        "title": "schema"
      },
      "index": {
        "description": "Determine schema for one JSON data item",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "schema",
        "normalized": "JSON-\u003eSchema a",
        "package": "json-b",
        "partial": "",
        "signature": "JSON-\u003eSchema counter"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Schema.html#v:schemas",
      "description": {
        "fct-descr": "\u003cp\u003eDevelop a schema for a list of JSON data, collating schemas according to\n    the measure, a well-ordered semigroup. \n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Schema",
        "fct-package": "json-b",
        "fct-signature": "[JSON] -\u003e [(counter, Schema counter)]",
        "fct-source": "src/Text-JSONb-Schema.html#schemas",
        "fct-type": "function",
        "title": "schemas"
      },
      "index": {
        "description": "Develop schema for list of JSON data collating schemas according to the measure well-ordered semigroup",
        "hierarchy": "Text JSONb Schema",
        "module": "Text.JSONb.Schema",
        "name": "schemas",
        "normalized": "[JSON]-\u003e[(a,Schema a)]",
        "package": "json-b",
        "partial": "",
        "signature": "[JSON]-\u003e[(counter,Schema counter)]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Simple.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eJSON datatype definition.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.JSONb.Simple",
        "fct-package": "json-b",
        "fct-signature": "module",
        "fct-source": "src/Text-JSONb-Simple.html",
        "fct-type": "module",
        "title": "Simple"
      },
      "index": {
        "description": "JSON datatype definition",
        "hierarchy": "Text JSONb Simple",
        "module": "Text.JSONb.Simple",
        "name": "Simple",
        "normalized": "",
        "package": "json-b",
        "partial": "Simple",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Simple.html#t:JSON",
      "description": {
        "fct-descr": "\u003cp\u003eA monomorphic JSON datatype, backed with \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e, strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n    and \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTrie\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb.Simple",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "data",
        "title": "JSON"
      },
      "index": {
        "description": "monomorphic JSON datatype backed with Rational strict ByteString and ByteString Trie",
        "hierarchy": "Text JSONb Simple",
        "module": "Text.JSONb.Simple",
        "name": "JSON",
        "normalized": "",
        "package": "json-b",
        "partial": "JSON",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Simple.html#v:Array",
      "description": {
        "fct-module": "Text.JSONb.Simple",
        "fct-package": "json-b",
        "fct-signature": "Array [JSON]",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Array"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Simple",
        "module": "Text.JSONb.Simple",
        "name": "Array",
        "normalized": "Array[JSON]",
        "package": "json-b",
        "partial": "Array",
        "signature": "Array[JSON]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Simple.html#v:Boolean",
      "description": {
        "fct-module": "Text.JSONb.Simple",
        "fct-package": "json-b",
        "fct-signature": "Boolean Bool",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Boolean"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Simple",
        "module": "Text.JSONb.Simple",
        "name": "Boolean",
        "normalized": "",
        "package": "json-b",
        "partial": "Boolean",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Simple.html#v:Null",
      "description": {
        "fct-module": "Text.JSONb.Simple",
        "fct-package": "json-b",
        "fct-signature": "Null",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Null"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Simple",
        "module": "Text.JSONb.Simple",
        "name": "Null",
        "normalized": "",
        "package": "json-b",
        "partial": "Null",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Simple.html#v:Number",
      "description": {
        "fct-module": "Text.JSONb.Simple",
        "fct-package": "json-b",
        "fct-signature": "Number Rational",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Number"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Simple",
        "module": "Text.JSONb.Simple",
        "name": "Number",
        "normalized": "",
        "package": "json-b",
        "partial": "Number",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Simple.html#v:Object",
      "description": {
        "fct-module": "Text.JSONb.Simple",
        "fct-package": "json-b",
        "fct-signature": "Object (Trie JSON)",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Object"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Simple",
        "module": "Text.JSONb.Simple",
        "name": "Object",
        "normalized": "",
        "package": "json-b",
        "partial": "Object",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb-Simple.html#v:String",
      "description": {
        "fct-module": "Text.JSONb.Simple",
        "fct-package": "json-b",
        "fct-signature": "String ByteString",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "String"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb Simple",
        "module": "Text.JSONb.Simple",
        "name": "String",
        "normalized": "",
        "package": "json-b",
        "partial": "String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eByteString parser for a simple, monomorphic JSON datatype.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "module",
        "fct-source": "src/Text-JSONb.html",
        "fct-type": "module",
        "title": "JSONb"
      },
      "index": {
        "description": "ByteString parser for simple monomorphic JSON datatype",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "JSONb",
        "normalized": "",
        "package": "json-b",
        "partial": "JSONb",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#t:Display",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "class",
        "fct-source": "src/Text-JSONb-Schema-Display.html#Display",
        "fct-type": "class",
        "title": "Display"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Display",
        "normalized": "",
        "package": "json-b",
        "partial": "Display",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#t:Escape",
      "description": {
        "fct-descr": "\u003cp\u003eClass of JSON escapable text. The solidus (\u003ccode\u003e/\u003c/code\u003e) is always escaped, as are\n    all ASCII control characters. Non-ASCII control characters and Unicode\n    printable characters above ASCII are left as is.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "class",
        "fct-source": "src/Text-JSON-Escape.html#Escape",
        "fct-type": "class",
        "title": "Escape"
      },
      "index": {
        "description": "Class of JSON escapable text The solidus is always escaped as are all ASCII control characters Non-ASCII control characters and Unicode printable characters above ASCII are left as is",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Escape",
        "normalized": "",
        "package": "json-b",
        "partial": "Escape",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#t:JSON",
      "description": {
        "fct-descr": "\u003cp\u003eA monomorphic JSON datatype, backed with \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e, strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n    and \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTrie\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "data",
        "title": "JSON"
      },
      "index": {
        "description": "monomorphic JSON datatype backed with Rational strict ByteString and ByteString Trie",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "JSON",
        "normalized": "",
        "package": "json-b",
        "partial": "JSON",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#t:OneMany",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Schema.html#OneMany",
        "fct-type": "data",
        "title": "OneMany"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "OneMany",
        "normalized": "",
        "package": "json-b",
        "partial": "One Many",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#t:Schema",
      "description": {
        "fct-descr": "\u003cp\u003eThe type of JSON schemas. We treat the atomic types simply whereas objects\n    and arrays are treated specially.\n\u003c/p\u003e\u003cp\u003eObjects are treated as maps of keys to sets of schema types. Say a certain\n    type of object sometimes has a string at a certain key and sometimes has a\n    null at that key; we should merge them and say the schema of that key is a\n    union of string and null.\n\u003c/p\u003e\u003cp\u003eArrays admit measure in the sense of how many elements there are of a\n    certain kind. We support three measures at present: any, one or more and\n    individual counts. We expect the \u003ca\u003eany\u003c/a\u003e measure to prevail practice. Arrays\n    are also ordered; so one can distinguish an array that interleaves strings\n    and ints from one that is all strings and then all ints.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Schema.html#Schema",
        "fct-type": "data",
        "title": "Schema"
      },
      "index": {
        "description": "The type of JSON schemas We treat the atomic types simply whereas objects and arrays are treated specially Objects are treated as maps of keys to sets of schema types Say certain type of object sometimes has string at certain key and sometimes has null at that key we should merge them and say the schema of that key is union of string and null Arrays admit measure in the sense of how many elements there are of certain kind We support three measures at present any one or more and individual counts We expect the any measure to prevail practice Arrays are also ordered so one can distinguish an array that interleaves strings and ints from one that is all strings and then all ints",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Schema",
        "normalized": "",
        "package": "json-b",
        "partial": "Schema",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#t:Style",
      "description": {
        "fct-descr": "\u003cp\u003eStyle of serialization. Compact is the only one that is implemented at\n    present.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "data",
        "fct-source": "src/Text-JSONb-Encode.html#Style",
        "fct-type": "data",
        "title": "Style"
      },
      "index": {
        "description": "Style of serialization Compact is the only one that is implemented at present",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Style",
        "normalized": "",
        "package": "json-b",
        "partial": "Style",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:Array",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Array [JSON]",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Array"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Array",
        "normalized": "Array[JSON]",
        "package": "json-b",
        "partial": "Array",
        "signature": "Array[JSON]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:Boolean",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Boolean Bool",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Boolean"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Boolean",
        "normalized": "",
        "package": "json-b",
        "partial": "Boolean",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:Compact",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Compact",
        "fct-source": "src/Text-JSONb-Encode.html#Style",
        "fct-type": "function",
        "title": "Compact"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Compact",
        "normalized": "",
        "package": "json-b",
        "partial": "Compact",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:Many",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Many",
        "fct-source": "src/Text-JSONb-Schema.html#OneMany",
        "fct-type": "function",
        "title": "Many"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Many",
        "normalized": "",
        "package": "json-b",
        "partial": "Many",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:Null",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Null",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Null"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Null",
        "normalized": "",
        "package": "json-b",
        "partial": "Null",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:Number",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Number Rational",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Number"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Number",
        "normalized": "",
        "package": "json-b",
        "partial": "Number",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:Object",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Object (Trie JSON)",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "Object"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "Object",
        "normalized": "",
        "package": "json-b",
        "partial": "Object",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:One",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "One",
        "fct-source": "src/Text-JSONb-Schema.html#OneMany",
        "fct-type": "function",
        "title": "One"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "One",
        "normalized": "",
        "package": "json-b",
        "partial": "One",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:String",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "String ByteString",
        "fct-source": "src/Text-JSONb-Simple.html#JSON",
        "fct-type": "function",
        "title": "String"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "String",
        "normalized": "",
        "package": "json-b",
        "partial": "String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:break",
      "description": {
        "fct-descr": "\u003cp\u003eSplit out the first parseable JSON literal from the input, returning\n    the result of the attempt along with the remainder of the input or the\n    whole input if not parseable item was discovered.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "ByteString -\u003e (Either ParseError JSON, ByteString)",
        "fct-source": "src/Text-JSONb-Decode.html#break",
        "fct-type": "function",
        "title": "break"
      },
      "index": {
        "description": "Split out the first parseable JSON literal from the input returning the result of the attempt along with the remainder of the input or the whole input if not parseable item was discovered",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "break",
        "normalized": "ByteString-\u003e(Either ParseError JSON,ByteString)",
        "package": "json-b",
        "partial": "",
        "signature": "ByteString-\u003e(Either ParseError JSON,ByteString)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:bytes",
      "description": {
        "fct-descr": "\u003cp\u003eProvide a formatted \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e for the displayable.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "t -\u003e ByteString",
        "fct-source": "src/Text-JSONb-Schema-Display.html#bytes",
        "fct-type": "method",
        "title": "bytes"
      },
      "index": {
        "description": "Provide formatted ByteString for the displayable",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "bytes",
        "normalized": "a-\u003eByteString",
        "package": "json-b",
        "partial": "",
        "signature": "t-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:decode",
      "description": {
        "fct-descr": "\u003cp\u003eInterpret a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e as any JSON literal.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "ByteString -\u003e Either (ParseError, ByteString) JSON",
        "fct-source": "src/Text-JSONb-Decode.html#decode",
        "fct-type": "function",
        "title": "decode"
      },
      "index": {
        "description": "Interpret ByteString as any JSON literal",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "decode",
        "normalized": "ByteString-\u003eEither(ParseError,ByteString)JSON",
        "package": "json-b",
        "partial": "",
        "signature": "ByteString-\u003eEither(ParseError,ByteString)JSON"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:encode",
      "description": {
        "fct-descr": "\u003cp\u003eEncode \u003ccode\u003e\u003ca\u003eJSON\u003c/a\u003e\u003c/code\u003e as a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e. All strings are treated as\n    UTF-8; ASCII control characters are escaped and UTF-8 multi-char sequences\n    are simply passed through.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Style -\u003e JSON -\u003e ByteString",
        "fct-source": "src/Text-JSONb-Encode.html#encode",
        "fct-type": "function",
        "title": "encode"
      },
      "index": {
        "description": "Encode JSON as lazy ByteString All strings are treated as UTF-8 ASCII control characters are escaped and UTF-8 multi-char sequences are simply passed through",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "encode",
        "normalized": "Style-\u003eJSON-\u003eByteString",
        "package": "json-b",
        "partial": "",
        "signature": "Style-\u003eJSON-\u003eByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:escape",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "t -\u003e t",
        "fct-source": "src/Text-JSON-Escape.html#escape",
        "fct-type": "method",
        "title": "escape"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "escape",
        "normalized": "a-\u003ea",
        "package": "json-b",
        "partial": "",
        "signature": "t-\u003et"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:escaped",
      "description": {
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "Char -\u003e Bool",
        "fct-source": "src/Text-JSON-Escape.html#escaped",
        "fct-type": "function",
        "title": "escaped"
      },
      "index": {
        "description": "",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "escaped",
        "normalized": "Char-\u003eBool",
        "package": "json-b",
        "partial": "",
        "signature": "Char-\u003eBool"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:schema",
      "description": {
        "fct-descr": "\u003cp\u003eDetermine a schema for one JSON data item.\n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "JSON -\u003e Schema counter",
        "fct-source": "src/Text-JSONb-Schema.html#schema",
        "fct-type": "function",
        "title": "schema"
      },
      "index": {
        "description": "Determine schema for one JSON data item",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "schema",
        "normalized": "JSON-\u003eSchema a",
        "package": "json-b",
        "partial": "",
        "signature": "JSON-\u003eSchema counter"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/json-b/docs/Text-JSONb.html#v:schemas",
      "description": {
        "fct-descr": "\u003cp\u003eDevelop a schema for a list of JSON data, collating schemas according to\n    the measure, a well-ordered semigroup. \n\u003c/p\u003e",
        "fct-module": "Text.JSONb",
        "fct-package": "json-b",
        "fct-signature": "[JSON] -\u003e [(counter, Schema counter)]",
        "fct-source": "src/Text-JSONb-Schema.html#schemas",
        "fct-type": "function",
        "title": "schemas"
      },
      "index": {
        "description": "Develop schema for list of JSON data collating schemas according to the measure well-ordered semigroup",
        "hierarchy": "Text JSONb",
        "module": "Text.JSONb",
        "name": "schemas",
        "normalized": "[JSON]-\u003e[(a,Schema a)]",
        "package": "json-b",
        "partial": "",
        "signature": "[JSON]-\u003e[(counter,Schema counter)]"
      }
    }
  }
]
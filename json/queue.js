[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue-Classes.html",
        "fct-type": "module",
        "title": "Classes"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "Classes",
        "normalized": "",
        "package": "queue",
        "partial": "Classes",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#t:DefaultFifo",
      "description": {
        "fct-descr": "\u003cp\u003eA type class carrying an altered set of functional dependencies used to\n  constrain queues when the type of the queue never escapes far enough for\n  a more deliberate choice to be made.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#DefaultFifo",
        "fct-type": "class",
        "title": "DefaultFifo"
      },
      "index": {
        "description": "type class carrying an altered set of functional dependencies used to constrain queues when the type of the queue never escapes far enough for more deliberate choice to be made",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "DefaultFifo",
        "normalized": "",
        "package": "queue",
        "partial": "Default Fifo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#t:Dequeue",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#Dequeue",
        "fct-type": "class",
        "title": "Dequeue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "Dequeue",
        "normalized": "",
        "package": "queue",
        "partial": "Dequeue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#t:DequeueWhere",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#DequeueWhere",
        "fct-type": "class",
        "title": "DequeueWhere"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "DequeueWhere",
        "normalized": "",
        "package": "queue",
        "partial": "Dequeue Where",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#t:Enqueue",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#Enqueue",
        "fct-type": "class",
        "title": "Enqueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "Enqueue",
        "normalized": "",
        "package": "queue",
        "partial": "Enqueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#t:NewFifo",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a new FIFO queue.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#NewFifo",
        "fct-type": "class",
        "title": "NewFifo"
      },
      "index": {
        "description": "Construct new FIFO queue",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "NewFifo",
        "normalized": "",
        "package": "queue",
        "partial": "New Fifo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#t:PeekQueue",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#PeekQueue",
        "fct-type": "class",
        "title": "PeekQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "PeekQueue",
        "normalized": "",
        "package": "queue",
        "partial": "Peek Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#t:QueueSize",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#QueueSize",
        "fct-type": "class",
        "title": "QueueSize"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "QueueSize",
        "normalized": "",
        "package": "queue",
        "partial": "Queue Size",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:dequeue",
      "description": {
        "fct-descr": "\u003cp\u003ePull an item out of a queue.  Should not block.  No ordering\n  constraints are implied other than that any item that went into\n  the queue \u003ca\u003ereally ought to\u003c/a\u003e come out before \u003ccode\u003e\u003ca\u003edequeue\u003c/a\u003e\u003c/code\u003e returns\n  \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "q -\u003e m (Maybe a)",
        "fct-source": "src/Data-Queue-Classes.html#dequeue",
        "fct-type": "method",
        "title": "dequeue"
      },
      "index": {
        "description": "Pull an item out of queue Should not block No ordering constraints are implied other than that any item that went into the queue really ought to come out before dequeue returns Nothing",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "dequeue",
        "normalized": "a-\u003eb(Maybe c)",
        "package": "queue",
        "partial": "",
        "signature": "q-\u003em(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:dequeueBatch",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "q -\u003e m [a]",
        "fct-source": "src/Data-Queue-Classes.html#dequeueBatch",
        "fct-type": "method",
        "title": "dequeueBatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "dequeueBatch",
        "normalized": "a-\u003eb[c]",
        "package": "queue",
        "partial": "Batch",
        "signature": "q-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:dequeueWhere",
      "description": {
        "fct-descr": "\u003cp\u003ePull an item matching the given predicate out of a queue.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "q -\u003e (a -\u003e Bool) -\u003e m (Maybe a)",
        "fct-source": "src/Data-Queue-Classes.html#dequeueWhere",
        "fct-type": "method",
        "title": "dequeueWhere"
      },
      "index": {
        "description": "Pull an item matching the given predicate out of queue",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "dequeueWhere",
        "normalized": "a-\u003e(b-\u003eBool)-\u003ec(Maybe b)",
        "package": "queue",
        "partial": "Where",
        "signature": "q-\u003e(a-\u003eBool)-\u003em(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:enqueue",
      "description": {
        "fct-descr": "\u003cp\u003ePut an item into a queue.  May block while trying to do so.\n  No constraint is placed on the behavior of the queue except that\n  every item put in \u003ca\u003ereally ought to\u003c/a\u003e come out sometime before\n  \u003ccode\u003e\u003ca\u003edequeue\u003c/a\u003e\u003c/code\u003e returns a \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "q -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Queue-Classes.html#enqueue",
        "fct-type": "method",
        "title": "enqueue"
      },
      "index": {
        "description": "Put an item into queue May block while trying to do so No constraint is placed on the behavior of the queue except that every item put in really ought to come out sometime before dequeue returns Nothing",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "enqueue",
        "normalized": "a-\u003eb-\u003ec()",
        "package": "queue",
        "partial": "",
        "signature": "q-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:enqueueBatch",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "q -\u003e [a] -\u003e m ()",
        "fct-source": "src/Data-Queue-Classes.html#enqueueBatch",
        "fct-type": "method",
        "title": "enqueueBatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "enqueueBatch",
        "normalized": "a-\u003e[b]-\u003ec()",
        "package": "queue",
        "partial": "Batch",
        "signature": "q-\u003e[a]-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:newFifo",
      "description": {
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "m q",
        "fct-source": "src/Data-Queue-Classes.html#newFifo",
        "fct-type": "method",
        "title": "newFifo"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "newFifo",
        "normalized": "",
        "package": "queue",
        "partial": "Fifo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:peekQueue",
      "description": {
        "fct-descr": "\u003cp\u003ereturn the whole contents of the queue (if possible) without \n  altering the queue's contents.  Obviously in cases where this\n  can't be done lazily this can be a very expensive operation.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "q -\u003e m [a]",
        "fct-source": "src/Data-Queue-Classes.html#peekQueue",
        "fct-type": "method",
        "title": "peekQueue"
      },
      "index": {
        "description": "return the whole contents of the queue if possible without altering the queue contents Obviously in cases where this can be done lazily this can be very expensive operation",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "peekQueue",
        "normalized": "a-\u003eb[c]",
        "package": "queue",
        "partial": "Queue",
        "signature": "q-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:peekQueueTaking",
      "description": {
        "fct-descr": "\u003cp\u003epeek a specified number of items off the queue.  The default\n  implementation is hideously wasteful in cases where peekQueue is\n  not able to get the contents lazily.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "Int -\u003e q -\u003e m [a]",
        "fct-source": "src/Data-Queue-Classes.html#peekQueueTaking",
        "fct-type": "method",
        "title": "peekQueueTaking"
      },
      "index": {
        "description": "peek specified number of items off the queue The default implementation is hideously wasteful in cases where peekQueue is not able to get the contents lazily",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "peekQueueTaking",
        "normalized": "Int-\u003ea-\u003eb[c]",
        "package": "queue",
        "partial": "Queue Taking",
        "signature": "Int-\u003eq-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Classes.html#v:queueSize",
      "description": {
        "fct-descr": "\u003cp\u003ereturn the number of elements in the queue\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Classes",
        "fct-package": "queue",
        "fct-signature": "q -\u003e m Int",
        "fct-source": "src/Data-Queue-Classes.html#queueSize",
        "fct-type": "method",
        "title": "queueSize"
      },
      "index": {
        "description": "return the number of elements in the queue",
        "hierarchy": "Data Queue Classes",
        "module": "Data.Queue.Classes",
        "name": "queueSize",
        "normalized": "a-\u003eb Int",
        "package": "queue",
        "partial": "Size",
        "signature": "q-\u003em Int"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Instances.html#",
      "description": {
        "fct-module": "Data.Queue.Instances",
        "fct-package": "queue",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue-Instances.html",
        "fct-type": "module",
        "title": "Instances"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue Instances",
        "module": "Data.Queue.Instances",
        "name": "Instances",
        "normalized": "",
        "package": "queue",
        "partial": "Instances",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Instances.html#t:Chan",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e is an abstract type representing an unbounded FIFO channel.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Instances",
        "fct-package": "queue",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "Chan"
      },
      "index": {
        "description": "Chan is an abstract type representing an unbounded FIFO channel",
        "hierarchy": "Data Queue Instances",
        "module": "Data.Queue.Instances",
        "name": "Chan",
        "normalized": "",
        "package": "queue",
        "partial": "Chan",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Instances.html#t:MVar",
      "description": {
        "fct-descr": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e (pronounced \"em-var\") is a synchronising variable, used\nfor communication between concurrent threads.  It can be thought of\nas a a box, which may be empty or full.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Instances",
        "fct-package": "queue",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "MVar"
      },
      "index": {
        "description": "An MVar pronounced em-var is synchronising variable used for communication between concurrent threads It can be thought of as box which may be empty or full",
        "hierarchy": "Data Queue Instances",
        "module": "Data.Queue.Instances",
        "name": "MVar",
        "normalized": "",
        "package": "queue",
        "partial": "MVar",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Instances.html#t:STM",
      "description": {
        "fct-descr": "\u003cp\u003eA monad supporting atomic memory transactions.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Instances",
        "fct-package": "queue",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "STM"
      },
      "index": {
        "description": "monad supporting atomic memory transactions",
        "hierarchy": "Data Queue Instances",
        "module": "Data.Queue.Instances",
        "name": "STM",
        "normalized": "",
        "package": "queue",
        "partial": "STM",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Instances.html#t:TChan",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTChan\u003c/a\u003e\u003c/code\u003e is an abstract type representing an unbounded FIFO channel.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Instances",
        "fct-package": "queue",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "TChan"
      },
      "index": {
        "description": "TChan is an abstract type representing an unbounded FIFO channel",
        "hierarchy": "Data Queue Instances",
        "module": "Data.Queue.Instances",
        "name": "TChan",
        "normalized": "",
        "package": "queue",
        "partial": "TChan",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Instances.html#t:TMVar",
      "description": {
        "fct-descr": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTMVar\u003c/a\u003e\u003c/code\u003e is a synchronising variable, used\nfor communication between concurrent threads.  It can be thought of\nas a box, which may be empty or full.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Instances",
        "fct-package": "queue",
        "fct-signature": "data",
        "fct-type": "data",
        "title": "TMVar"
      },
      "index": {
        "description": "TMVar is synchronising variable used for communication between concurrent threads It can be thought of as box which may be empty or full",
        "hierarchy": "Data Queue Instances",
        "module": "Data.Queue.Instances",
        "name": "TMVar",
        "normalized": "",
        "package": "queue",
        "partial": "TMVar",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue-Instances.html#v:atomically",
      "description": {
        "fct-descr": "\u003cp\u003ePerform a series of STM actions atomically.\n\u003c/p\u003e\u003cp\u003eYou cannot use \u003ccode\u003e\u003ca\u003eatomically\u003c/a\u003e\u003c/code\u003e inside an \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eunsafeInterleaveIO\u003c/a\u003e\u003c/code\u003e.\n Any attempt to do so will result in a runtime error.  (Reason: allowing\n this would effectively allow a transaction inside a transaction, depending\n on exactly when the thunk is evaluated.)\n\u003c/p\u003e\u003cp\u003eHowever, see \u003ccode\u003e\u003ca\u003enewTVarIO\u003c/a\u003e\u003c/code\u003e, which can be called inside \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e,\n and which allows top-level TVars to be allocated.\n\u003c/p\u003e",
        "fct-module": "Data.Queue.Instances",
        "fct-package": "queue",
        "fct-signature": "STM a -\u003e IO a",
        "fct-type": "function",
        "title": "atomically"
      },
      "index": {
        "description": "Perform series of STM actions atomically You cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO Any attempt to do so will result in runtime error Reason allowing this would effectively allow transaction inside transaction depending on exactly when the thunk is evaluated However see newTVarIO which can be called inside unsafePerformIO and which allows top-level TVars to be allocated",
        "hierarchy": "Data Queue Instances",
        "module": "Data.Queue.Instances",
        "name": "atomically",
        "normalized": "STM a-\u003eIO a",
        "package": "queue",
        "partial": "",
        "signature": "STM a-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "module",
        "fct-source": "src/Data-Queue.html",
        "fct-type": "module",
        "title": "Queue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "Queue",
        "normalized": "",
        "package": "queue",
        "partial": "Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:DefaultFifo",
      "description": {
        "fct-descr": "\u003cp\u003eA type class carrying an altered set of functional dependencies used to\n  constrain queues when the type of the queue never escapes far enough for\n  a more deliberate choice to be made.\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#DefaultFifo",
        "fct-type": "class",
        "title": "DefaultFifo"
      },
      "index": {
        "description": "type class carrying an altered set of functional dependencies used to constrain queues when the type of the queue never escapes far enough for more deliberate choice to be made",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "DefaultFifo",
        "normalized": "",
        "package": "queue",
        "partial": "Default Fifo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:Dequeue",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#Dequeue",
        "fct-type": "class",
        "title": "Dequeue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "Dequeue",
        "normalized": "",
        "package": "queue",
        "partial": "Dequeue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:DequeueWhere",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#DequeueWhere",
        "fct-type": "class",
        "title": "DequeueWhere"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "DequeueWhere",
        "normalized": "",
        "package": "queue",
        "partial": "Dequeue Where",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:Enqueue",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#Enqueue",
        "fct-type": "class",
        "title": "Enqueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "Enqueue",
        "normalized": "",
        "package": "queue",
        "partial": "Enqueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:NewFifo",
      "description": {
        "fct-descr": "\u003cp\u003eConstruct a new FIFO queue.\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#NewFifo",
        "fct-type": "class",
        "title": "NewFifo"
      },
      "index": {
        "description": "Construct new FIFO queue",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "NewFifo",
        "normalized": "",
        "package": "queue",
        "partial": "New Fifo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:PeekQueue",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#PeekQueue",
        "fct-type": "class",
        "title": "PeekQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "PeekQueue",
        "normalized": "",
        "package": "queue",
        "partial": "Peek Queue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:QueueSize",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "class",
        "fct-source": "src/Data-Queue-Classes.html#QueueSize",
        "fct-type": "class",
        "title": "QueueSize"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "QueueSize",
        "normalized": "",
        "package": "queue",
        "partial": "Queue Size",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:RQueue",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQueue\u003c/a\u003e\u003c/code\u003e : read-only newtype wrapper for arbitrary queues\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "data",
        "fct-source": "src/Data-Queue.html#RQueue",
        "fct-type": "data",
        "title": "RQueue"
      },
      "index": {
        "description": "RQueue read-only newtype wrapper for arbitrary queues",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "RQueue",
        "normalized": "",
        "package": "queue",
        "partial": "RQueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#t:WQueue",
      "description": {
        "fct-descr": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eWQueue\u003c/a\u003e\u003c/code\u003e : write-only newtype wrapper for arbitrary queues\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "data",
        "fct-source": "src/Data-Queue.html#WQueue",
        "fct-type": "data",
        "title": "WQueue"
      },
      "index": {
        "description": "WQueue write-only newtype wrapper for arbitrary queues",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "WQueue",
        "normalized": "",
        "package": "queue",
        "partial": "WQueue",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:dequeue",
      "description": {
        "fct-descr": "\u003cp\u003ePull an item out of a queue.  Should not block.  No ordering\n  constraints are implied other than that any item that went into\n  the queue \u003ca\u003ereally ought to\u003c/a\u003e come out before \u003ccode\u003e\u003ca\u003edequeue\u003c/a\u003e\u003c/code\u003e returns\n  \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e m (Maybe a)",
        "fct-source": "src/Data-Queue-Classes.html#dequeue",
        "fct-type": "method",
        "title": "dequeue"
      },
      "index": {
        "description": "Pull an item out of queue Should not block No ordering constraints are implied other than that any item that went into the queue really ought to come out before dequeue returns Nothing",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "dequeue",
        "normalized": "a-\u003eb(Maybe c)",
        "package": "queue",
        "partial": "",
        "signature": "q-\u003em(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:dequeueBatch",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e m [a]",
        "fct-source": "src/Data-Queue-Classes.html#dequeueBatch",
        "fct-type": "method",
        "title": "dequeueBatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "dequeueBatch",
        "normalized": "a-\u003eb[c]",
        "package": "queue",
        "partial": "Batch",
        "signature": "q-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:dequeueWhere",
      "description": {
        "fct-descr": "\u003cp\u003ePull an item matching the given predicate out of a queue.\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e (a -\u003e Bool) -\u003e m (Maybe a)",
        "fct-source": "src/Data-Queue-Classes.html#dequeueWhere",
        "fct-type": "method",
        "title": "dequeueWhere"
      },
      "index": {
        "description": "Pull an item matching the given predicate out of queue",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "dequeueWhere",
        "normalized": "a-\u003e(b-\u003eBool)-\u003ec(Maybe b)",
        "package": "queue",
        "partial": "Where",
        "signature": "q-\u003e(a-\u003eBool)-\u003em(Maybe a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:enqueue",
      "description": {
        "fct-descr": "\u003cp\u003ePut an item into a queue.  May block while trying to do so.\n  No constraint is placed on the behavior of the queue except that\n  every item put in \u003ca\u003ereally ought to\u003c/a\u003e come out sometime before\n  \u003ccode\u003e\u003ca\u003edequeue\u003c/a\u003e\u003c/code\u003e returns a \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e a -\u003e m ()",
        "fct-source": "src/Data-Queue-Classes.html#enqueue",
        "fct-type": "method",
        "title": "enqueue"
      },
      "index": {
        "description": "Put an item into queue May block while trying to do so No constraint is placed on the behavior of the queue except that every item put in really ought to come out sometime before dequeue returns Nothing",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "enqueue",
        "normalized": "a-\u003eb-\u003ec()",
        "package": "queue",
        "partial": "",
        "signature": "q-\u003ea-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:enqueueBatch",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e [a] -\u003e m ()",
        "fct-source": "src/Data-Queue-Classes.html#enqueueBatch",
        "fct-type": "method",
        "title": "enqueueBatch"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "enqueueBatch",
        "normalized": "a-\u003e[b]-\u003ec()",
        "package": "queue",
        "partial": "Batch",
        "signature": "q-\u003e[a]-\u003em()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:mkRQueue",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e RQueue q",
        "fct-source": "src/Data-Queue.html#mkRQueue",
        "fct-type": "function",
        "title": "mkRQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "mkRQueue",
        "normalized": "a-\u003eRQueue a",
        "package": "queue",
        "partial": "RQueue",
        "signature": "q-\u003eRQueue q"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:mkWQueue",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e WQueue q",
        "fct-source": "src/Data-Queue.html#mkWQueue",
        "fct-type": "function",
        "title": "mkWQueue"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "mkWQueue",
        "normalized": "a-\u003eWQueue a",
        "package": "queue",
        "partial": "WQueue",
        "signature": "q-\u003eWQueue q"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:newFifo",
      "description": {
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "m q",
        "fct-source": "src/Data-Queue-Classes.html#newFifo",
        "fct-type": "method",
        "title": "newFifo"
      },
      "index": {
        "description": "",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "newFifo",
        "normalized": "",
        "package": "queue",
        "partial": "Fifo",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:peekQueue",
      "description": {
        "fct-descr": "\u003cp\u003ereturn the whole contents of the queue (if possible) without \n  altering the queue's contents.  Obviously in cases where this\n  can't be done lazily this can be a very expensive operation.\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e m [a]",
        "fct-source": "src/Data-Queue-Classes.html#peekQueue",
        "fct-type": "method",
        "title": "peekQueue"
      },
      "index": {
        "description": "return the whole contents of the queue if possible without altering the queue contents Obviously in cases where this can be done lazily this can be very expensive operation",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "peekQueue",
        "normalized": "a-\u003eb[c]",
        "package": "queue",
        "partial": "Queue",
        "signature": "q-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:peekQueueTaking",
      "description": {
        "fct-descr": "\u003cp\u003epeek a specified number of items off the queue.  The default\n  implementation is hideously wasteful in cases where peekQueue is\n  not able to get the contents lazily.\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "Int -\u003e q -\u003e m [a]",
        "fct-source": "src/Data-Queue-Classes.html#peekQueueTaking",
        "fct-type": "method",
        "title": "peekQueueTaking"
      },
      "index": {
        "description": "peek specified number of items off the queue The default implementation is hideously wasteful in cases where peekQueue is not able to get the contents lazily",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "peekQueueTaking",
        "normalized": "Int-\u003ea-\u003eb[c]",
        "package": "queue",
        "partial": "Queue Taking",
        "signature": "Int-\u003eq-\u003em[a]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/queue/docs/Data-Queue.html#v:queueSize",
      "description": {
        "fct-descr": "\u003cp\u003ereturn the number of elements in the queue\n\u003c/p\u003e",
        "fct-module": "Data.Queue",
        "fct-package": "queue",
        "fct-signature": "q -\u003e m Int",
        "fct-source": "src/Data-Queue-Classes.html#queueSize",
        "fct-type": "method",
        "title": "queueSize"
      },
      "index": {
        "description": "return the number of elements in the queue",
        "hierarchy": "Data Queue",
        "module": "Data.Queue",
        "name": "queueSize",
        "normalized": "a-\u003eb Int",
        "package": "queue",
        "partial": "Size",
        "signature": "q-\u003em Int"
      }
    }
  }
]